# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessControlRuleSetGrantRuleArgs',
    'AccessControlRuleSetGrantRuleArgsDict',
    'AlertConditionArgs',
    'AlertConditionArgsDict',
    'AlertConditionOperandArgs',
    'AlertConditionOperandArgsDict',
    'AlertConditionOperandColumnArgs',
    'AlertConditionOperandColumnArgsDict',
    'AlertConditionThresholdArgs',
    'AlertConditionThresholdArgsDict',
    'AlertConditionThresholdValueArgs',
    'AlertConditionThresholdValueArgsDict',
    'ArtifactAllowlistArtifactMatcherArgs',
    'ArtifactAllowlistArtifactMatcherArgsDict',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceArgs',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceArgsDict',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgs',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgsDict',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgsDict',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgsDict',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgsDict',
    'BudgetAlertConfigurationArgs',
    'BudgetAlertConfigurationArgsDict',
    'BudgetAlertConfigurationActionConfigurationArgs',
    'BudgetAlertConfigurationActionConfigurationArgsDict',
    'BudgetFilterArgs',
    'BudgetFilterArgsDict',
    'BudgetFilterTagArgs',
    'BudgetFilterTagArgsDict',
    'BudgetFilterTagValueArgs',
    'BudgetFilterTagValueArgsDict',
    'BudgetFilterWorkspaceIdArgs',
    'BudgetFilterWorkspaceIdArgsDict',
    'ClusterAutoscaleArgs',
    'ClusterAutoscaleArgsDict',
    'ClusterAwsAttributesArgs',
    'ClusterAwsAttributesArgsDict',
    'ClusterAzureAttributesArgs',
    'ClusterAzureAttributesArgsDict',
    'ClusterAzureAttributesLogAnalyticsInfoArgs',
    'ClusterAzureAttributesLogAnalyticsInfoArgsDict',
    'ClusterClusterLogConfArgs',
    'ClusterClusterLogConfArgsDict',
    'ClusterClusterLogConfDbfsArgs',
    'ClusterClusterLogConfDbfsArgsDict',
    'ClusterClusterLogConfS3Args',
    'ClusterClusterLogConfS3ArgsDict',
    'ClusterClusterMountInfoArgs',
    'ClusterClusterMountInfoArgsDict',
    'ClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'ClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'ClusterDockerImageArgs',
    'ClusterDockerImageArgsDict',
    'ClusterDockerImageBasicAuthArgs',
    'ClusterDockerImageBasicAuthArgsDict',
    'ClusterGcpAttributesArgs',
    'ClusterGcpAttributesArgsDict',
    'ClusterInitScriptArgs',
    'ClusterInitScriptArgsDict',
    'ClusterInitScriptAbfssArgs',
    'ClusterInitScriptAbfssArgsDict',
    'ClusterInitScriptDbfsArgs',
    'ClusterInitScriptDbfsArgsDict',
    'ClusterInitScriptFileArgs',
    'ClusterInitScriptFileArgsDict',
    'ClusterInitScriptGcsArgs',
    'ClusterInitScriptGcsArgsDict',
    'ClusterInitScriptS3Args',
    'ClusterInitScriptS3ArgsDict',
    'ClusterInitScriptVolumesArgs',
    'ClusterInitScriptVolumesArgsDict',
    'ClusterInitScriptWorkspaceArgs',
    'ClusterInitScriptWorkspaceArgsDict',
    'ClusterLibraryArgs',
    'ClusterLibraryArgsDict',
    'ClusterLibraryCranArgs',
    'ClusterLibraryCranArgsDict',
    'ClusterLibraryMavenArgs',
    'ClusterLibraryMavenArgsDict',
    'ClusterLibraryPypiArgs',
    'ClusterLibraryPypiArgsDict',
    'ClusterPolicyLibraryArgs',
    'ClusterPolicyLibraryArgsDict',
    'ClusterPolicyLibraryCranArgs',
    'ClusterPolicyLibraryCranArgsDict',
    'ClusterPolicyLibraryMavenArgs',
    'ClusterPolicyLibraryMavenArgsDict',
    'ClusterPolicyLibraryPypiArgs',
    'ClusterPolicyLibraryPypiArgsDict',
    'ClusterWorkloadTypeArgs',
    'ClusterWorkloadTypeArgsDict',
    'ClusterWorkloadTypeClientsArgs',
    'ClusterWorkloadTypeClientsArgsDict',
    'ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspaceArgs',
    'ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspaceArgsDict',
    'CustomAppIntegrationTokenAccessPolicyArgs',
    'CustomAppIntegrationTokenAccessPolicyArgsDict',
    'DefaultNamespaceSettingNamespaceArgs',
    'DefaultNamespaceSettingNamespaceArgsDict',
    'EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspaceArgs',
    'EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspaceArgsDict',
    'ExternalLocationEncryptionDetailsArgs',
    'ExternalLocationEncryptionDetailsArgsDict',
    'ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs',
    'ExternalLocationEncryptionDetailsSseEncryptionDetailsArgsDict',
    'GrantsGrantArgs',
    'GrantsGrantArgsDict',
    'InstancePoolAwsAttributesArgs',
    'InstancePoolAwsAttributesArgsDict',
    'InstancePoolAzureAttributesArgs',
    'InstancePoolAzureAttributesArgsDict',
    'InstancePoolDiskSpecArgs',
    'InstancePoolDiskSpecArgsDict',
    'InstancePoolDiskSpecDiskTypeArgs',
    'InstancePoolDiskSpecDiskTypeArgsDict',
    'InstancePoolGcpAttributesArgs',
    'InstancePoolGcpAttributesArgsDict',
    'InstancePoolInstancePoolFleetAttributesArgs',
    'InstancePoolInstancePoolFleetAttributesArgsDict',
    'InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs',
    'InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgsDict',
    'InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs',
    'InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgsDict',
    'InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs',
    'InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgsDict',
    'InstancePoolPreloadedDockerImageArgs',
    'InstancePoolPreloadedDockerImageArgsDict',
    'InstancePoolPreloadedDockerImageBasicAuthArgs',
    'InstancePoolPreloadedDockerImageBasicAuthArgsDict',
    'JobContinuousArgs',
    'JobContinuousArgsDict',
    'JobDbtTaskArgs',
    'JobDbtTaskArgsDict',
    'JobDeploymentArgs',
    'JobDeploymentArgsDict',
    'JobEmailNotificationsArgs',
    'JobEmailNotificationsArgsDict',
    'JobEnvironmentArgs',
    'JobEnvironmentArgsDict',
    'JobEnvironmentSpecArgs',
    'JobEnvironmentSpecArgsDict',
    'JobGitSourceArgs',
    'JobGitSourceArgsDict',
    'JobGitSourceGitSnapshotArgs',
    'JobGitSourceGitSnapshotArgsDict',
    'JobGitSourceJobSourceArgs',
    'JobGitSourceJobSourceArgsDict',
    'JobHealthArgs',
    'JobHealthArgsDict',
    'JobHealthRuleArgs',
    'JobHealthRuleArgsDict',
    'JobJobClusterArgs',
    'JobJobClusterArgsDict',
    'JobJobClusterNewClusterArgs',
    'JobJobClusterNewClusterArgsDict',
    'JobJobClusterNewClusterAutoscaleArgs',
    'JobJobClusterNewClusterAutoscaleArgsDict',
    'JobJobClusterNewClusterAwsAttributesArgs',
    'JobJobClusterNewClusterAwsAttributesArgsDict',
    'JobJobClusterNewClusterAzureAttributesArgs',
    'JobJobClusterNewClusterAzureAttributesArgsDict',
    'JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgs',
    'JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgsDict',
    'JobJobClusterNewClusterClusterLogConfArgs',
    'JobJobClusterNewClusterClusterLogConfArgsDict',
    'JobJobClusterNewClusterClusterLogConfDbfsArgs',
    'JobJobClusterNewClusterClusterLogConfDbfsArgsDict',
    'JobJobClusterNewClusterClusterLogConfS3Args',
    'JobJobClusterNewClusterClusterLogConfS3ArgsDict',
    'JobJobClusterNewClusterClusterMountInfoArgs',
    'JobJobClusterNewClusterClusterMountInfoArgsDict',
    'JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'JobJobClusterNewClusterDockerImageArgs',
    'JobJobClusterNewClusterDockerImageArgsDict',
    'JobJobClusterNewClusterDockerImageBasicAuthArgs',
    'JobJobClusterNewClusterDockerImageBasicAuthArgsDict',
    'JobJobClusterNewClusterGcpAttributesArgs',
    'JobJobClusterNewClusterGcpAttributesArgsDict',
    'JobJobClusterNewClusterInitScriptArgs',
    'JobJobClusterNewClusterInitScriptArgsDict',
    'JobJobClusterNewClusterInitScriptAbfssArgs',
    'JobJobClusterNewClusterInitScriptAbfssArgsDict',
    'JobJobClusterNewClusterInitScriptDbfsArgs',
    'JobJobClusterNewClusterInitScriptDbfsArgsDict',
    'JobJobClusterNewClusterInitScriptFileArgs',
    'JobJobClusterNewClusterInitScriptFileArgsDict',
    'JobJobClusterNewClusterInitScriptGcsArgs',
    'JobJobClusterNewClusterInitScriptGcsArgsDict',
    'JobJobClusterNewClusterInitScriptS3Args',
    'JobJobClusterNewClusterInitScriptS3ArgsDict',
    'JobJobClusterNewClusterInitScriptVolumesArgs',
    'JobJobClusterNewClusterInitScriptVolumesArgsDict',
    'JobJobClusterNewClusterInitScriptWorkspaceArgs',
    'JobJobClusterNewClusterInitScriptWorkspaceArgsDict',
    'JobJobClusterNewClusterLibraryArgs',
    'JobJobClusterNewClusterLibraryArgsDict',
    'JobJobClusterNewClusterLibraryCranArgs',
    'JobJobClusterNewClusterLibraryCranArgsDict',
    'JobJobClusterNewClusterLibraryMavenArgs',
    'JobJobClusterNewClusterLibraryMavenArgsDict',
    'JobJobClusterNewClusterLibraryPypiArgs',
    'JobJobClusterNewClusterLibraryPypiArgsDict',
    'JobJobClusterNewClusterWorkloadTypeArgs',
    'JobJobClusterNewClusterWorkloadTypeArgsDict',
    'JobJobClusterNewClusterWorkloadTypeClientsArgs',
    'JobJobClusterNewClusterWorkloadTypeClientsArgsDict',
    'JobLibraryArgs',
    'JobLibraryArgsDict',
    'JobLibraryCranArgs',
    'JobLibraryCranArgsDict',
    'JobLibraryMavenArgs',
    'JobLibraryMavenArgsDict',
    'JobLibraryPypiArgs',
    'JobLibraryPypiArgsDict',
    'JobNewClusterArgs',
    'JobNewClusterArgsDict',
    'JobNewClusterAutoscaleArgs',
    'JobNewClusterAutoscaleArgsDict',
    'JobNewClusterAwsAttributesArgs',
    'JobNewClusterAwsAttributesArgsDict',
    'JobNewClusterAzureAttributesArgs',
    'JobNewClusterAzureAttributesArgsDict',
    'JobNewClusterAzureAttributesLogAnalyticsInfoArgs',
    'JobNewClusterAzureAttributesLogAnalyticsInfoArgsDict',
    'JobNewClusterClusterLogConfArgs',
    'JobNewClusterClusterLogConfArgsDict',
    'JobNewClusterClusterLogConfDbfsArgs',
    'JobNewClusterClusterLogConfDbfsArgsDict',
    'JobNewClusterClusterLogConfS3Args',
    'JobNewClusterClusterLogConfS3ArgsDict',
    'JobNewClusterClusterMountInfoArgs',
    'JobNewClusterClusterMountInfoArgsDict',
    'JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'JobNewClusterDockerImageArgs',
    'JobNewClusterDockerImageArgsDict',
    'JobNewClusterDockerImageBasicAuthArgs',
    'JobNewClusterDockerImageBasicAuthArgsDict',
    'JobNewClusterGcpAttributesArgs',
    'JobNewClusterGcpAttributesArgsDict',
    'JobNewClusterInitScriptArgs',
    'JobNewClusterInitScriptArgsDict',
    'JobNewClusterInitScriptAbfssArgs',
    'JobNewClusterInitScriptAbfssArgsDict',
    'JobNewClusterInitScriptDbfsArgs',
    'JobNewClusterInitScriptDbfsArgsDict',
    'JobNewClusterInitScriptFileArgs',
    'JobNewClusterInitScriptFileArgsDict',
    'JobNewClusterInitScriptGcsArgs',
    'JobNewClusterInitScriptGcsArgsDict',
    'JobNewClusterInitScriptS3Args',
    'JobNewClusterInitScriptS3ArgsDict',
    'JobNewClusterInitScriptVolumesArgs',
    'JobNewClusterInitScriptVolumesArgsDict',
    'JobNewClusterInitScriptWorkspaceArgs',
    'JobNewClusterInitScriptWorkspaceArgsDict',
    'JobNewClusterLibraryArgs',
    'JobNewClusterLibraryArgsDict',
    'JobNewClusterLibraryCranArgs',
    'JobNewClusterLibraryCranArgsDict',
    'JobNewClusterLibraryMavenArgs',
    'JobNewClusterLibraryMavenArgsDict',
    'JobNewClusterLibraryPypiArgs',
    'JobNewClusterLibraryPypiArgsDict',
    'JobNewClusterWorkloadTypeArgs',
    'JobNewClusterWorkloadTypeArgsDict',
    'JobNewClusterWorkloadTypeClientsArgs',
    'JobNewClusterWorkloadTypeClientsArgsDict',
    'JobNotebookTaskArgs',
    'JobNotebookTaskArgsDict',
    'JobNotificationSettingsArgs',
    'JobNotificationSettingsArgsDict',
    'JobParameterArgs',
    'JobParameterArgsDict',
    'JobPipelineTaskArgs',
    'JobPipelineTaskArgsDict',
    'JobPythonWheelTaskArgs',
    'JobPythonWheelTaskArgsDict',
    'JobQueueArgs',
    'JobQueueArgsDict',
    'JobRunAsArgs',
    'JobRunAsArgsDict',
    'JobRunJobTaskArgs',
    'JobRunJobTaskArgsDict',
    'JobScheduleArgs',
    'JobScheduleArgsDict',
    'JobSparkJarTaskArgs',
    'JobSparkJarTaskArgsDict',
    'JobSparkPythonTaskArgs',
    'JobSparkPythonTaskArgsDict',
    'JobSparkSubmitTaskArgs',
    'JobSparkSubmitTaskArgsDict',
    'JobTaskArgs',
    'JobTaskArgsDict',
    'JobTaskConditionTaskArgs',
    'JobTaskConditionTaskArgsDict',
    'JobTaskDbtTaskArgs',
    'JobTaskDbtTaskArgsDict',
    'JobTaskDependsOnArgs',
    'JobTaskDependsOnArgsDict',
    'JobTaskEmailNotificationsArgs',
    'JobTaskEmailNotificationsArgsDict',
    'JobTaskForEachTaskArgs',
    'JobTaskForEachTaskArgsDict',
    'JobTaskForEachTaskTaskArgs',
    'JobTaskForEachTaskTaskArgsDict',
    'JobTaskForEachTaskTaskConditionTaskArgs',
    'JobTaskForEachTaskTaskConditionTaskArgsDict',
    'JobTaskForEachTaskTaskDbtTaskArgs',
    'JobTaskForEachTaskTaskDbtTaskArgsDict',
    'JobTaskForEachTaskTaskDependsOnArgs',
    'JobTaskForEachTaskTaskDependsOnArgsDict',
    'JobTaskForEachTaskTaskEmailNotificationsArgs',
    'JobTaskForEachTaskTaskEmailNotificationsArgsDict',
    'JobTaskForEachTaskTaskHealthArgs',
    'JobTaskForEachTaskTaskHealthArgsDict',
    'JobTaskForEachTaskTaskHealthRuleArgs',
    'JobTaskForEachTaskTaskHealthRuleArgsDict',
    'JobTaskForEachTaskTaskLibraryArgs',
    'JobTaskForEachTaskTaskLibraryArgsDict',
    'JobTaskForEachTaskTaskLibraryCranArgs',
    'JobTaskForEachTaskTaskLibraryCranArgsDict',
    'JobTaskForEachTaskTaskLibraryMavenArgs',
    'JobTaskForEachTaskTaskLibraryMavenArgsDict',
    'JobTaskForEachTaskTaskLibraryPypiArgs',
    'JobTaskForEachTaskTaskLibraryPypiArgsDict',
    'JobTaskForEachTaskTaskNewClusterArgs',
    'JobTaskForEachTaskTaskNewClusterArgsDict',
    'JobTaskForEachTaskTaskNewClusterAutoscaleArgs',
    'JobTaskForEachTaskTaskNewClusterAutoscaleArgsDict',
    'JobTaskForEachTaskTaskNewClusterAwsAttributesArgs',
    'JobTaskForEachTaskTaskNewClusterAwsAttributesArgsDict',
    'JobTaskForEachTaskTaskNewClusterAzureAttributesArgs',
    'JobTaskForEachTaskTaskNewClusterAzureAttributesArgsDict',
    'JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgs',
    'JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfArgs',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfArgsDict',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfS3Args',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict',
    'JobTaskForEachTaskTaskNewClusterClusterMountInfoArgs',
    'JobTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict',
    'JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'JobTaskForEachTaskTaskNewClusterDockerImageArgs',
    'JobTaskForEachTaskTaskNewClusterDockerImageArgsDict',
    'JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs',
    'JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict',
    'JobTaskForEachTaskTaskNewClusterGcpAttributesArgs',
    'JobTaskForEachTaskTaskNewClusterGcpAttributesArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptFileArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptFileArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptGcsArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptS3Args',
    'JobTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict',
    'JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs',
    'JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict',
    'JobTaskForEachTaskTaskNewClusterLibraryArgs',
    'JobTaskForEachTaskTaskNewClusterLibraryArgsDict',
    'JobTaskForEachTaskTaskNewClusterLibraryCranArgs',
    'JobTaskForEachTaskTaskNewClusterLibraryCranArgsDict',
    'JobTaskForEachTaskTaskNewClusterLibraryMavenArgs',
    'JobTaskForEachTaskTaskNewClusterLibraryMavenArgsDict',
    'JobTaskForEachTaskTaskNewClusterLibraryPypiArgs',
    'JobTaskForEachTaskTaskNewClusterLibraryPypiArgsDict',
    'JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs',
    'JobTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict',
    'JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs',
    'JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict',
    'JobTaskForEachTaskTaskNotebookTaskArgs',
    'JobTaskForEachTaskTaskNotebookTaskArgsDict',
    'JobTaskForEachTaskTaskNotificationSettingsArgs',
    'JobTaskForEachTaskTaskNotificationSettingsArgsDict',
    'JobTaskForEachTaskTaskPipelineTaskArgs',
    'JobTaskForEachTaskTaskPipelineTaskArgsDict',
    'JobTaskForEachTaskTaskPythonWheelTaskArgs',
    'JobTaskForEachTaskTaskPythonWheelTaskArgsDict',
    'JobTaskForEachTaskTaskRunJobTaskArgs',
    'JobTaskForEachTaskTaskRunJobTaskArgsDict',
    'JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgs',
    'JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgsDict',
    'JobTaskForEachTaskTaskSparkJarTaskArgs',
    'JobTaskForEachTaskTaskSparkJarTaskArgsDict',
    'JobTaskForEachTaskTaskSparkPythonTaskArgs',
    'JobTaskForEachTaskTaskSparkPythonTaskArgsDict',
    'JobTaskForEachTaskTaskSparkSubmitTaskArgs',
    'JobTaskForEachTaskTaskSparkSubmitTaskArgsDict',
    'JobTaskForEachTaskTaskSqlTaskArgs',
    'JobTaskForEachTaskTaskSqlTaskArgsDict',
    'JobTaskForEachTaskTaskSqlTaskAlertArgs',
    'JobTaskForEachTaskTaskSqlTaskAlertArgsDict',
    'JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs',
    'JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict',
    'JobTaskForEachTaskTaskSqlTaskDashboardArgs',
    'JobTaskForEachTaskTaskSqlTaskDashboardArgsDict',
    'JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs',
    'JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict',
    'JobTaskForEachTaskTaskSqlTaskFileArgs',
    'JobTaskForEachTaskTaskSqlTaskFileArgsDict',
    'JobTaskForEachTaskTaskSqlTaskQueryArgs',
    'JobTaskForEachTaskTaskSqlTaskQueryArgsDict',
    'JobTaskForEachTaskTaskWebhookNotificationsArgs',
    'JobTaskForEachTaskTaskWebhookNotificationsArgsDict',
    'JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict',
    'JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs',
    'JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict',
    'JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs',
    'JobTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict',
    'JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs',
    'JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict',
    'JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs',
    'JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict',
    'JobTaskHealthArgs',
    'JobTaskHealthArgsDict',
    'JobTaskHealthRuleArgs',
    'JobTaskHealthRuleArgsDict',
    'JobTaskLibraryArgs',
    'JobTaskLibraryArgsDict',
    'JobTaskLibraryCranArgs',
    'JobTaskLibraryCranArgsDict',
    'JobTaskLibraryMavenArgs',
    'JobTaskLibraryMavenArgsDict',
    'JobTaskLibraryPypiArgs',
    'JobTaskLibraryPypiArgsDict',
    'JobTaskNewClusterArgs',
    'JobTaskNewClusterArgsDict',
    'JobTaskNewClusterAutoscaleArgs',
    'JobTaskNewClusterAutoscaleArgsDict',
    'JobTaskNewClusterAwsAttributesArgs',
    'JobTaskNewClusterAwsAttributesArgsDict',
    'JobTaskNewClusterAzureAttributesArgs',
    'JobTaskNewClusterAzureAttributesArgsDict',
    'JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgs',
    'JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict',
    'JobTaskNewClusterClusterLogConfArgs',
    'JobTaskNewClusterClusterLogConfArgsDict',
    'JobTaskNewClusterClusterLogConfDbfsArgs',
    'JobTaskNewClusterClusterLogConfDbfsArgsDict',
    'JobTaskNewClusterClusterLogConfS3Args',
    'JobTaskNewClusterClusterLogConfS3ArgsDict',
    'JobTaskNewClusterClusterMountInfoArgs',
    'JobTaskNewClusterClusterMountInfoArgsDict',
    'JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'JobTaskNewClusterDockerImageArgs',
    'JobTaskNewClusterDockerImageArgsDict',
    'JobTaskNewClusterDockerImageBasicAuthArgs',
    'JobTaskNewClusterDockerImageBasicAuthArgsDict',
    'JobTaskNewClusterGcpAttributesArgs',
    'JobTaskNewClusterGcpAttributesArgsDict',
    'JobTaskNewClusterInitScriptArgs',
    'JobTaskNewClusterInitScriptArgsDict',
    'JobTaskNewClusterInitScriptAbfssArgs',
    'JobTaskNewClusterInitScriptAbfssArgsDict',
    'JobTaskNewClusterInitScriptDbfsArgs',
    'JobTaskNewClusterInitScriptDbfsArgsDict',
    'JobTaskNewClusterInitScriptFileArgs',
    'JobTaskNewClusterInitScriptFileArgsDict',
    'JobTaskNewClusterInitScriptGcsArgs',
    'JobTaskNewClusterInitScriptGcsArgsDict',
    'JobTaskNewClusterInitScriptS3Args',
    'JobTaskNewClusterInitScriptS3ArgsDict',
    'JobTaskNewClusterInitScriptVolumesArgs',
    'JobTaskNewClusterInitScriptVolumesArgsDict',
    'JobTaskNewClusterInitScriptWorkspaceArgs',
    'JobTaskNewClusterInitScriptWorkspaceArgsDict',
    'JobTaskNewClusterLibraryArgs',
    'JobTaskNewClusterLibraryArgsDict',
    'JobTaskNewClusterLibraryCranArgs',
    'JobTaskNewClusterLibraryCranArgsDict',
    'JobTaskNewClusterLibraryMavenArgs',
    'JobTaskNewClusterLibraryMavenArgsDict',
    'JobTaskNewClusterLibraryPypiArgs',
    'JobTaskNewClusterLibraryPypiArgsDict',
    'JobTaskNewClusterWorkloadTypeArgs',
    'JobTaskNewClusterWorkloadTypeArgsDict',
    'JobTaskNewClusterWorkloadTypeClientsArgs',
    'JobTaskNewClusterWorkloadTypeClientsArgsDict',
    'JobTaskNotebookTaskArgs',
    'JobTaskNotebookTaskArgsDict',
    'JobTaskNotificationSettingsArgs',
    'JobTaskNotificationSettingsArgsDict',
    'JobTaskPipelineTaskArgs',
    'JobTaskPipelineTaskArgsDict',
    'JobTaskPythonWheelTaskArgs',
    'JobTaskPythonWheelTaskArgsDict',
    'JobTaskRunJobTaskArgs',
    'JobTaskRunJobTaskArgsDict',
    'JobTaskRunJobTaskPipelineParamsArgs',
    'JobTaskRunJobTaskPipelineParamsArgsDict',
    'JobTaskSparkJarTaskArgs',
    'JobTaskSparkJarTaskArgsDict',
    'JobTaskSparkPythonTaskArgs',
    'JobTaskSparkPythonTaskArgsDict',
    'JobTaskSparkSubmitTaskArgs',
    'JobTaskSparkSubmitTaskArgsDict',
    'JobTaskSqlTaskArgs',
    'JobTaskSqlTaskArgsDict',
    'JobTaskSqlTaskAlertArgs',
    'JobTaskSqlTaskAlertArgsDict',
    'JobTaskSqlTaskAlertSubscriptionArgs',
    'JobTaskSqlTaskAlertSubscriptionArgsDict',
    'JobTaskSqlTaskDashboardArgs',
    'JobTaskSqlTaskDashboardArgsDict',
    'JobTaskSqlTaskDashboardSubscriptionArgs',
    'JobTaskSqlTaskDashboardSubscriptionArgsDict',
    'JobTaskSqlTaskFileArgs',
    'JobTaskSqlTaskFileArgsDict',
    'JobTaskSqlTaskQueryArgs',
    'JobTaskSqlTaskQueryArgsDict',
    'JobTaskWebhookNotificationsArgs',
    'JobTaskWebhookNotificationsArgsDict',
    'JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict',
    'JobTaskWebhookNotificationsOnFailureArgs',
    'JobTaskWebhookNotificationsOnFailureArgsDict',
    'JobTaskWebhookNotificationsOnStartArgs',
    'JobTaskWebhookNotificationsOnStartArgsDict',
    'JobTaskWebhookNotificationsOnStreamingBacklogExceededArgs',
    'JobTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict',
    'JobTaskWebhookNotificationsOnSuccessArgs',
    'JobTaskWebhookNotificationsOnSuccessArgsDict',
    'JobTriggerArgs',
    'JobTriggerArgsDict',
    'JobTriggerFileArrivalArgs',
    'JobTriggerFileArrivalArgsDict',
    'JobTriggerPeriodicArgs',
    'JobTriggerPeriodicArgsDict',
    'JobTriggerTableArgs',
    'JobTriggerTableArgsDict',
    'JobTriggerTableUpdateArgs',
    'JobTriggerTableUpdateArgsDict',
    'JobWebhookNotificationsArgs',
    'JobWebhookNotificationsArgsDict',
    'JobWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'JobWebhookNotificationsOnDurationWarningThresholdExceededArgsDict',
    'JobWebhookNotificationsOnFailureArgs',
    'JobWebhookNotificationsOnFailureArgsDict',
    'JobWebhookNotificationsOnStartArgs',
    'JobWebhookNotificationsOnStartArgsDict',
    'JobWebhookNotificationsOnStreamingBacklogExceededArgs',
    'JobWebhookNotificationsOnStreamingBacklogExceededArgsDict',
    'JobWebhookNotificationsOnSuccessArgs',
    'JobWebhookNotificationsOnSuccessArgsDict',
    'LakehouseMonitorCustomMetricArgs',
    'LakehouseMonitorCustomMetricArgsDict',
    'LakehouseMonitorDataClassificationConfigArgs',
    'LakehouseMonitorDataClassificationConfigArgsDict',
    'LakehouseMonitorInferenceLogArgs',
    'LakehouseMonitorInferenceLogArgsDict',
    'LakehouseMonitorNotificationsArgs',
    'LakehouseMonitorNotificationsArgsDict',
    'LakehouseMonitorNotificationsOnFailureArgs',
    'LakehouseMonitorNotificationsOnFailureArgsDict',
    'LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs',
    'LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgsDict',
    'LakehouseMonitorScheduleArgs',
    'LakehouseMonitorScheduleArgsDict',
    'LakehouseMonitorSnapshotArgs',
    'LakehouseMonitorSnapshotArgsDict',
    'LakehouseMonitorTimeSeriesArgs',
    'LakehouseMonitorTimeSeriesArgsDict',
    'LibraryCranArgs',
    'LibraryCranArgsDict',
    'LibraryMavenArgs',
    'LibraryMavenArgsDict',
    'LibraryPypiArgs',
    'LibraryPypiArgsDict',
    'MetastoreDataAccessAwsIamRoleArgs',
    'MetastoreDataAccessAwsIamRoleArgsDict',
    'MetastoreDataAccessAzureManagedIdentityArgs',
    'MetastoreDataAccessAzureManagedIdentityArgsDict',
    'MetastoreDataAccessAzureServicePrincipalArgs',
    'MetastoreDataAccessAzureServicePrincipalArgsDict',
    'MetastoreDataAccessCloudflareApiTokenArgs',
    'MetastoreDataAccessCloudflareApiTokenArgsDict',
    'MetastoreDataAccessDatabricksGcpServiceAccountArgs',
    'MetastoreDataAccessDatabricksGcpServiceAccountArgsDict',
    'MetastoreDataAccessGcpServiceAccountKeyArgs',
    'MetastoreDataAccessGcpServiceAccountKeyArgsDict',
    'MlflowModelTagArgs',
    'MlflowModelTagArgsDict',
    'MlflowWebhookHttpUrlSpecArgs',
    'MlflowWebhookHttpUrlSpecArgsDict',
    'MlflowWebhookJobSpecArgs',
    'MlflowWebhookJobSpecArgsDict',
    'ModelServingAiGatewayArgs',
    'ModelServingAiGatewayArgsDict',
    'ModelServingAiGatewayGuardrailsArgs',
    'ModelServingAiGatewayGuardrailsArgsDict',
    'ModelServingAiGatewayGuardrailsInputArgs',
    'ModelServingAiGatewayGuardrailsInputArgsDict',
    'ModelServingAiGatewayGuardrailsInputPiiArgs',
    'ModelServingAiGatewayGuardrailsInputPiiArgsDict',
    'ModelServingAiGatewayGuardrailsOutputArgs',
    'ModelServingAiGatewayGuardrailsOutputArgsDict',
    'ModelServingAiGatewayGuardrailsOutputPiiArgs',
    'ModelServingAiGatewayGuardrailsOutputPiiArgsDict',
    'ModelServingAiGatewayInferenceTableConfigArgs',
    'ModelServingAiGatewayInferenceTableConfigArgsDict',
    'ModelServingAiGatewayRateLimitArgs',
    'ModelServingAiGatewayRateLimitArgsDict',
    'ModelServingAiGatewayUsageTrackingConfigArgs',
    'ModelServingAiGatewayUsageTrackingConfigArgsDict',
    'ModelServingConfigArgs',
    'ModelServingConfigArgsDict',
    'ModelServingConfigAutoCaptureConfigArgs',
    'ModelServingConfigAutoCaptureConfigArgsDict',
    'ModelServingConfigServedEntityArgs',
    'ModelServingConfigServedEntityArgsDict',
    'ModelServingConfigServedEntityExternalModelArgs',
    'ModelServingConfigServedEntityExternalModelArgsDict',
    'ModelServingConfigServedEntityExternalModelAi21labsConfigArgs',
    'ModelServingConfigServedEntityExternalModelAi21labsConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs',
    'ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelAnthropicConfigArgs',
    'ModelServingConfigServedEntityExternalModelAnthropicConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelCohereConfigArgs',
    'ModelServingConfigServedEntityExternalModelCohereConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs',
    'ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs',
    'ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelOpenaiConfigArgs',
    'ModelServingConfigServedEntityExternalModelOpenaiConfigArgsDict',
    'ModelServingConfigServedEntityExternalModelPalmConfigArgs',
    'ModelServingConfigServedEntityExternalModelPalmConfigArgsDict',
    'ModelServingConfigServedModelArgs',
    'ModelServingConfigServedModelArgsDict',
    'ModelServingConfigTrafficConfigArgs',
    'ModelServingConfigTrafficConfigArgsDict',
    'ModelServingConfigTrafficConfigRouteArgs',
    'ModelServingConfigTrafficConfigRouteArgsDict',
    'ModelServingRateLimitArgs',
    'ModelServingRateLimitArgsDict',
    'ModelServingTagArgs',
    'ModelServingTagArgsDict',
    'MountAbfsArgs',
    'MountAbfsArgsDict',
    'MountAdlArgs',
    'MountAdlArgsDict',
    'MountGsArgs',
    'MountGsArgsDict',
    'MountS3Args',
    'MountS3ArgsDict',
    'MountWasbArgs',
    'MountWasbArgsDict',
    'MwsCustomerManagedKeysAwsKeyInfoArgs',
    'MwsCustomerManagedKeysAwsKeyInfoArgsDict',
    'MwsCustomerManagedKeysGcpKeyInfoArgs',
    'MwsCustomerManagedKeysGcpKeyInfoArgsDict',
    'MwsNetworkConnectivityConfigEgressConfigArgs',
    'MwsNetworkConnectivityConfigEgressConfigArgsDict',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgsDict',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgsDict',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgsDict',
    'MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs',
    'MwsNetworkConnectivityConfigEgressConfigTargetRulesArgsDict',
    'MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs',
    'MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgsDict',
    'MwsNetworksErrorMessageArgs',
    'MwsNetworksErrorMessageArgsDict',
    'MwsNetworksGcpNetworkInfoArgs',
    'MwsNetworksGcpNetworkInfoArgsDict',
    'MwsNetworksVpcEndpointsArgs',
    'MwsNetworksVpcEndpointsArgsDict',
    'MwsVpcEndpointGcpVpcEndpointInfoArgs',
    'MwsVpcEndpointGcpVpcEndpointInfoArgsDict',
    'MwsWorkspacesCloudResourceContainerArgs',
    'MwsWorkspacesCloudResourceContainerArgsDict',
    'MwsWorkspacesCloudResourceContainerGcpArgs',
    'MwsWorkspacesCloudResourceContainerGcpArgsDict',
    'MwsWorkspacesExternalCustomerInfoArgs',
    'MwsWorkspacesExternalCustomerInfoArgsDict',
    'MwsWorkspacesGcpManagedNetworkConfigArgs',
    'MwsWorkspacesGcpManagedNetworkConfigArgsDict',
    'MwsWorkspacesGkeConfigArgs',
    'MwsWorkspacesGkeConfigArgsDict',
    'MwsWorkspacesTokenArgs',
    'MwsWorkspacesTokenArgsDict',
    'NotificationDestinationConfigArgs',
    'NotificationDestinationConfigArgsDict',
    'NotificationDestinationConfigEmailArgs',
    'NotificationDestinationConfigEmailArgsDict',
    'NotificationDestinationConfigGenericWebhookArgs',
    'NotificationDestinationConfigGenericWebhookArgsDict',
    'NotificationDestinationConfigMicrosoftTeamsArgs',
    'NotificationDestinationConfigMicrosoftTeamsArgsDict',
    'NotificationDestinationConfigPagerdutyArgs',
    'NotificationDestinationConfigPagerdutyArgsDict',
    'NotificationDestinationConfigSlackArgs',
    'NotificationDestinationConfigSlackArgsDict',
    'OnlineTableSpecArgs',
    'OnlineTableSpecArgsDict',
    'OnlineTableSpecRunContinuouslyArgs',
    'OnlineTableSpecRunContinuouslyArgsDict',
    'OnlineTableSpecRunTriggeredArgs',
    'OnlineTableSpecRunTriggeredArgsDict',
    'OnlineTableStatusArgs',
    'OnlineTableStatusArgsDict',
    'OnlineTableStatusContinuousUpdateStatusArgs',
    'OnlineTableStatusContinuousUpdateStatusArgsDict',
    'OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs',
    'OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgsDict',
    'OnlineTableStatusFailedStatusArgs',
    'OnlineTableStatusFailedStatusArgsDict',
    'OnlineTableStatusProvisioningStatusArgs',
    'OnlineTableStatusProvisioningStatusArgsDict',
    'OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgs',
    'OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgsDict',
    'OnlineTableStatusTriggeredUpdateStatusArgs',
    'OnlineTableStatusTriggeredUpdateStatusArgsDict',
    'OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs',
    'OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgsDict',
    'PermissionsAccessControlArgs',
    'PermissionsAccessControlArgsDict',
    'PipelineClusterArgs',
    'PipelineClusterArgsDict',
    'PipelineClusterAutoscaleArgs',
    'PipelineClusterAutoscaleArgsDict',
    'PipelineClusterAwsAttributesArgs',
    'PipelineClusterAwsAttributesArgsDict',
    'PipelineClusterAzureAttributesArgs',
    'PipelineClusterAzureAttributesArgsDict',
    'PipelineClusterAzureAttributesLogAnalyticsInfoArgs',
    'PipelineClusterAzureAttributesLogAnalyticsInfoArgsDict',
    'PipelineClusterClusterLogConfArgs',
    'PipelineClusterClusterLogConfArgsDict',
    'PipelineClusterClusterLogConfDbfsArgs',
    'PipelineClusterClusterLogConfDbfsArgsDict',
    'PipelineClusterClusterLogConfS3Args',
    'PipelineClusterClusterLogConfS3ArgsDict',
    'PipelineClusterGcpAttributesArgs',
    'PipelineClusterGcpAttributesArgsDict',
    'PipelineClusterInitScriptArgs',
    'PipelineClusterInitScriptArgsDict',
    'PipelineClusterInitScriptAbfssArgs',
    'PipelineClusterInitScriptAbfssArgsDict',
    'PipelineClusterInitScriptDbfsArgs',
    'PipelineClusterInitScriptDbfsArgsDict',
    'PipelineClusterInitScriptFileArgs',
    'PipelineClusterInitScriptFileArgsDict',
    'PipelineClusterInitScriptGcsArgs',
    'PipelineClusterInitScriptGcsArgsDict',
    'PipelineClusterInitScriptS3Args',
    'PipelineClusterInitScriptS3ArgsDict',
    'PipelineClusterInitScriptVolumesArgs',
    'PipelineClusterInitScriptVolumesArgsDict',
    'PipelineClusterInitScriptWorkspaceArgs',
    'PipelineClusterInitScriptWorkspaceArgsDict',
    'PipelineDeploymentArgs',
    'PipelineDeploymentArgsDict',
    'PipelineFiltersArgs',
    'PipelineFiltersArgsDict',
    'PipelineGatewayDefinitionArgs',
    'PipelineGatewayDefinitionArgsDict',
    'PipelineIngestionDefinitionArgs',
    'PipelineIngestionDefinitionArgsDict',
    'PipelineIngestionDefinitionObjectArgs',
    'PipelineIngestionDefinitionObjectArgsDict',
    'PipelineIngestionDefinitionObjectReportArgs',
    'PipelineIngestionDefinitionObjectReportArgsDict',
    'PipelineIngestionDefinitionObjectReportTableConfigurationArgs',
    'PipelineIngestionDefinitionObjectReportTableConfigurationArgsDict',
    'PipelineIngestionDefinitionObjectSchemaArgs',
    'PipelineIngestionDefinitionObjectSchemaArgsDict',
    'PipelineIngestionDefinitionObjectSchemaTableConfigurationArgs',
    'PipelineIngestionDefinitionObjectSchemaTableConfigurationArgsDict',
    'PipelineIngestionDefinitionObjectTableArgs',
    'PipelineIngestionDefinitionObjectTableArgsDict',
    'PipelineIngestionDefinitionObjectTableTableConfigurationArgs',
    'PipelineIngestionDefinitionObjectTableTableConfigurationArgsDict',
    'PipelineIngestionDefinitionTableConfigurationArgs',
    'PipelineIngestionDefinitionTableConfigurationArgsDict',
    'PipelineLatestUpdateArgs',
    'PipelineLatestUpdateArgsDict',
    'PipelineLibraryArgs',
    'PipelineLibraryArgsDict',
    'PipelineLibraryFileArgs',
    'PipelineLibraryFileArgsDict',
    'PipelineLibraryMavenArgs',
    'PipelineLibraryMavenArgsDict',
    'PipelineLibraryNotebookArgs',
    'PipelineLibraryNotebookArgsDict',
    'PipelineNotificationArgs',
    'PipelineNotificationArgsDict',
    'PipelineRestartWindowArgs',
    'PipelineRestartWindowArgsDict',
    'PipelineTriggerArgs',
    'PipelineTriggerArgsDict',
    'PipelineTriggerCronArgs',
    'PipelineTriggerCronArgsDict',
    'PipelineTriggerManualArgs',
    'PipelineTriggerManualArgsDict',
    'QualityMonitorCustomMetricArgs',
    'QualityMonitorCustomMetricArgsDict',
    'QualityMonitorDataClassificationConfigArgs',
    'QualityMonitorDataClassificationConfigArgsDict',
    'QualityMonitorInferenceLogArgs',
    'QualityMonitorInferenceLogArgsDict',
    'QualityMonitorNotificationsArgs',
    'QualityMonitorNotificationsArgsDict',
    'QualityMonitorNotificationsOnFailureArgs',
    'QualityMonitorNotificationsOnFailureArgsDict',
    'QualityMonitorNotificationsOnNewClassificationTagDetectedArgs',
    'QualityMonitorNotificationsOnNewClassificationTagDetectedArgsDict',
    'QualityMonitorScheduleArgs',
    'QualityMonitorScheduleArgsDict',
    'QualityMonitorSnapshotArgs',
    'QualityMonitorSnapshotArgsDict',
    'QualityMonitorTimeSeriesArgs',
    'QualityMonitorTimeSeriesArgsDict',
    'QueryParameterArgs',
    'QueryParameterArgsDict',
    'QueryParameterDateRangeValueArgs',
    'QueryParameterDateRangeValueArgsDict',
    'QueryParameterDateRangeValueDateRangeValueArgs',
    'QueryParameterDateRangeValueDateRangeValueArgsDict',
    'QueryParameterDateValueArgs',
    'QueryParameterDateValueArgsDict',
    'QueryParameterEnumValueArgs',
    'QueryParameterEnumValueArgsDict',
    'QueryParameterEnumValueMultiValuesOptionsArgs',
    'QueryParameterEnumValueMultiValuesOptionsArgsDict',
    'QueryParameterNumericValueArgs',
    'QueryParameterNumericValueArgsDict',
    'QueryParameterQueryBackedValueArgs',
    'QueryParameterQueryBackedValueArgsDict',
    'QueryParameterQueryBackedValueMultiValuesOptionsArgs',
    'QueryParameterQueryBackedValueMultiValuesOptionsArgsDict',
    'QueryParameterTextValueArgs',
    'QueryParameterTextValueArgsDict',
    'RecipientIpAccessListArgs',
    'RecipientIpAccessListArgsDict',
    'RecipientPropertiesKvpairsArgs',
    'RecipientPropertiesKvpairsArgsDict',
    'RecipientTokenArgs',
    'RecipientTokenArgsDict',
    'RepoSparseCheckoutArgs',
    'RepoSparseCheckoutArgsDict',
    'RestrictWorkspaceAdminsSettingRestrictWorkspaceAdminsArgs',
    'RestrictWorkspaceAdminsSettingRestrictWorkspaceAdminsArgsDict',
    'SecretScopeKeyvaultMetadataArgs',
    'SecretScopeKeyvaultMetadataArgsDict',
    'ShareObjectArgs',
    'ShareObjectArgsDict',
    'ShareObjectPartitionArgs',
    'ShareObjectPartitionArgsDict',
    'ShareObjectPartitionValueArgs',
    'ShareObjectPartitionValueArgsDict',
    'SqlAlertOptionsArgs',
    'SqlAlertOptionsArgsDict',
    'SqlEndpointChannelArgs',
    'SqlEndpointChannelArgsDict',
    'SqlEndpointHealthArgs',
    'SqlEndpointHealthArgsDict',
    'SqlEndpointHealthFailureReasonArgs',
    'SqlEndpointHealthFailureReasonArgsDict',
    'SqlEndpointOdbcParamsArgs',
    'SqlEndpointOdbcParamsArgsDict',
    'SqlEndpointTagsArgs',
    'SqlEndpointTagsArgsDict',
    'SqlEndpointTagsCustomTagArgs',
    'SqlEndpointTagsCustomTagArgsDict',
    'SqlPermissionsPrivilegeAssignmentArgs',
    'SqlPermissionsPrivilegeAssignmentArgsDict',
    'SqlQueryParameterArgs',
    'SqlQueryParameterArgsDict',
    'SqlQueryParameterDateArgs',
    'SqlQueryParameterDateArgsDict',
    'SqlQueryParameterDateRangeArgs',
    'SqlQueryParameterDateRangeArgsDict',
    'SqlQueryParameterDateRangeRangeArgs',
    'SqlQueryParameterDateRangeRangeArgsDict',
    'SqlQueryParameterDatetimeArgs',
    'SqlQueryParameterDatetimeArgsDict',
    'SqlQueryParameterDatetimeRangeArgs',
    'SqlQueryParameterDatetimeRangeArgsDict',
    'SqlQueryParameterDatetimeRangeRangeArgs',
    'SqlQueryParameterDatetimeRangeRangeArgsDict',
    'SqlQueryParameterDatetimesecArgs',
    'SqlQueryParameterDatetimesecArgsDict',
    'SqlQueryParameterDatetimesecRangeArgs',
    'SqlQueryParameterDatetimesecRangeArgsDict',
    'SqlQueryParameterDatetimesecRangeRangeArgs',
    'SqlQueryParameterDatetimesecRangeRangeArgsDict',
    'SqlQueryParameterEnumArgs',
    'SqlQueryParameterEnumArgsDict',
    'SqlQueryParameterEnumMultipleArgs',
    'SqlQueryParameterEnumMultipleArgsDict',
    'SqlQueryParameterNumberArgs',
    'SqlQueryParameterNumberArgsDict',
    'SqlQueryParameterQueryArgs',
    'SqlQueryParameterQueryArgsDict',
    'SqlQueryParameterQueryMultipleArgs',
    'SqlQueryParameterQueryMultipleArgsDict',
    'SqlQueryParameterTextArgs',
    'SqlQueryParameterTextArgsDict',
    'SqlQueryScheduleArgs',
    'SqlQueryScheduleArgsDict',
    'SqlQueryScheduleContinuousArgs',
    'SqlQueryScheduleContinuousArgsDict',
    'SqlQueryScheduleDailyArgs',
    'SqlQueryScheduleDailyArgsDict',
    'SqlQueryScheduleWeeklyArgs',
    'SqlQueryScheduleWeeklyArgsDict',
    'SqlTableColumnArgs',
    'SqlTableColumnArgsDict',
    'SqlWidgetParameterArgs',
    'SqlWidgetParameterArgsDict',
    'SqlWidgetPositionArgs',
    'SqlWidgetPositionArgsDict',
    'StorageCredentialAwsIamRoleArgs',
    'StorageCredentialAwsIamRoleArgsDict',
    'StorageCredentialAzureManagedIdentityArgs',
    'StorageCredentialAzureManagedIdentityArgsDict',
    'StorageCredentialAzureServicePrincipalArgs',
    'StorageCredentialAzureServicePrincipalArgsDict',
    'StorageCredentialCloudflareApiTokenArgs',
    'StorageCredentialCloudflareApiTokenArgsDict',
    'StorageCredentialDatabricksGcpServiceAccountArgs',
    'StorageCredentialDatabricksGcpServiceAccountArgsDict',
    'StorageCredentialGcpServiceAccountKeyArgs',
    'StorageCredentialGcpServiceAccountKeyArgsDict',
    'TableColumnArgs',
    'TableColumnArgsDict',
    'VectorSearchEndpointEndpointStatusArgs',
    'VectorSearchEndpointEndpointStatusArgsDict',
    'VectorSearchIndexDeltaSyncIndexSpecArgs',
    'VectorSearchIndexDeltaSyncIndexSpecArgsDict',
    'VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs',
    'VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgsDict',
    'VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgs',
    'VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgsDict',
    'VectorSearchIndexDirectAccessIndexSpecArgs',
    'VectorSearchIndexDirectAccessIndexSpecArgsDict',
    'VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs',
    'VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgsDict',
    'VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgs',
    'VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgsDict',
    'VectorSearchIndexStatusArgs',
    'VectorSearchIndexStatusArgsDict',
    'GetCatalogCatalogInfoArgs',
    'GetCatalogCatalogInfoArgsDict',
    'GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs',
    'GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgsDict',
    'GetCatalogCatalogInfoProvisioningInfoArgs',
    'GetCatalogCatalogInfoProvisioningInfoArgsDict',
    'GetClusterClusterInfoArgs',
    'GetClusterClusterInfoArgsDict',
    'GetClusterClusterInfoAutoscaleArgs',
    'GetClusterClusterInfoAutoscaleArgsDict',
    'GetClusterClusterInfoAwsAttributesArgs',
    'GetClusterClusterInfoAwsAttributesArgsDict',
    'GetClusterClusterInfoAzureAttributesArgs',
    'GetClusterClusterInfoAzureAttributesArgsDict',
    'GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgs',
    'GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgsDict',
    'GetClusterClusterInfoClusterLogConfArgs',
    'GetClusterClusterInfoClusterLogConfArgsDict',
    'GetClusterClusterInfoClusterLogConfDbfsArgs',
    'GetClusterClusterInfoClusterLogConfDbfsArgsDict',
    'GetClusterClusterInfoClusterLogConfS3Args',
    'GetClusterClusterInfoClusterLogConfS3ArgsDict',
    'GetClusterClusterInfoClusterLogStatusArgs',
    'GetClusterClusterInfoClusterLogStatusArgsDict',
    'GetClusterClusterInfoDockerImageArgs',
    'GetClusterClusterInfoDockerImageArgsDict',
    'GetClusterClusterInfoDockerImageBasicAuthArgs',
    'GetClusterClusterInfoDockerImageBasicAuthArgsDict',
    'GetClusterClusterInfoDriverArgs',
    'GetClusterClusterInfoDriverArgsDict',
    'GetClusterClusterInfoDriverNodeAwsAttributesArgs',
    'GetClusterClusterInfoDriverNodeAwsAttributesArgsDict',
    'GetClusterClusterInfoExecutorArgs',
    'GetClusterClusterInfoExecutorArgsDict',
    'GetClusterClusterInfoExecutorNodeAwsAttributesArgs',
    'GetClusterClusterInfoExecutorNodeAwsAttributesArgsDict',
    'GetClusterClusterInfoGcpAttributesArgs',
    'GetClusterClusterInfoGcpAttributesArgsDict',
    'GetClusterClusterInfoInitScriptArgs',
    'GetClusterClusterInfoInitScriptArgsDict',
    'GetClusterClusterInfoInitScriptAbfssArgs',
    'GetClusterClusterInfoInitScriptAbfssArgsDict',
    'GetClusterClusterInfoInitScriptDbfsArgs',
    'GetClusterClusterInfoInitScriptDbfsArgsDict',
    'GetClusterClusterInfoInitScriptFileArgs',
    'GetClusterClusterInfoInitScriptFileArgsDict',
    'GetClusterClusterInfoInitScriptGcsArgs',
    'GetClusterClusterInfoInitScriptGcsArgsDict',
    'GetClusterClusterInfoInitScriptS3Args',
    'GetClusterClusterInfoInitScriptS3ArgsDict',
    'GetClusterClusterInfoInitScriptVolumesArgs',
    'GetClusterClusterInfoInitScriptVolumesArgsDict',
    'GetClusterClusterInfoInitScriptWorkspaceArgs',
    'GetClusterClusterInfoInitScriptWorkspaceArgsDict',
    'GetClusterClusterInfoSpecArgs',
    'GetClusterClusterInfoSpecArgsDict',
    'GetClusterClusterInfoSpecAutoscaleArgs',
    'GetClusterClusterInfoSpecAutoscaleArgsDict',
    'GetClusterClusterInfoSpecAwsAttributesArgs',
    'GetClusterClusterInfoSpecAwsAttributesArgsDict',
    'GetClusterClusterInfoSpecAzureAttributesArgs',
    'GetClusterClusterInfoSpecAzureAttributesArgsDict',
    'GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgs',
    'GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgsDict',
    'GetClusterClusterInfoSpecClusterLogConfArgs',
    'GetClusterClusterInfoSpecClusterLogConfArgsDict',
    'GetClusterClusterInfoSpecClusterLogConfDbfsArgs',
    'GetClusterClusterInfoSpecClusterLogConfDbfsArgsDict',
    'GetClusterClusterInfoSpecClusterLogConfS3Args',
    'GetClusterClusterInfoSpecClusterLogConfS3ArgsDict',
    'GetClusterClusterInfoSpecClusterMountInfoArgs',
    'GetClusterClusterInfoSpecClusterMountInfoArgsDict',
    'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgs',
    'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgsDict',
    'GetClusterClusterInfoSpecDockerImageArgs',
    'GetClusterClusterInfoSpecDockerImageArgsDict',
    'GetClusterClusterInfoSpecDockerImageBasicAuthArgs',
    'GetClusterClusterInfoSpecDockerImageBasicAuthArgsDict',
    'GetClusterClusterInfoSpecGcpAttributesArgs',
    'GetClusterClusterInfoSpecGcpAttributesArgsDict',
    'GetClusterClusterInfoSpecInitScriptArgs',
    'GetClusterClusterInfoSpecInitScriptArgsDict',
    'GetClusterClusterInfoSpecInitScriptAbfssArgs',
    'GetClusterClusterInfoSpecInitScriptAbfssArgsDict',
    'GetClusterClusterInfoSpecInitScriptDbfsArgs',
    'GetClusterClusterInfoSpecInitScriptDbfsArgsDict',
    'GetClusterClusterInfoSpecInitScriptFileArgs',
    'GetClusterClusterInfoSpecInitScriptFileArgsDict',
    'GetClusterClusterInfoSpecInitScriptGcsArgs',
    'GetClusterClusterInfoSpecInitScriptGcsArgsDict',
    'GetClusterClusterInfoSpecInitScriptS3Args',
    'GetClusterClusterInfoSpecInitScriptS3ArgsDict',
    'GetClusterClusterInfoSpecInitScriptVolumesArgs',
    'GetClusterClusterInfoSpecInitScriptVolumesArgsDict',
    'GetClusterClusterInfoSpecInitScriptWorkspaceArgs',
    'GetClusterClusterInfoSpecInitScriptWorkspaceArgsDict',
    'GetClusterClusterInfoSpecLibraryArgs',
    'GetClusterClusterInfoSpecLibraryArgsDict',
    'GetClusterClusterInfoSpecLibraryCranArgs',
    'GetClusterClusterInfoSpecLibraryCranArgsDict',
    'GetClusterClusterInfoSpecLibraryMavenArgs',
    'GetClusterClusterInfoSpecLibraryMavenArgsDict',
    'GetClusterClusterInfoSpecLibraryPypiArgs',
    'GetClusterClusterInfoSpecLibraryPypiArgsDict',
    'GetClusterClusterInfoSpecWorkloadTypeArgs',
    'GetClusterClusterInfoSpecWorkloadTypeArgsDict',
    'GetClusterClusterInfoSpecWorkloadTypeClientsArgs',
    'GetClusterClusterInfoSpecWorkloadTypeClientsArgsDict',
    'GetClusterClusterInfoTerminationReasonArgs',
    'GetClusterClusterInfoTerminationReasonArgsDict',
    'GetClusterClusterInfoWorkloadTypeArgs',
    'GetClusterClusterInfoWorkloadTypeArgsDict',
    'GetClusterClusterInfoWorkloadTypeClientsArgs',
    'GetClusterClusterInfoWorkloadTypeClientsArgsDict',
    'GetClustersFilterByArgs',
    'GetClustersFilterByArgsDict',
    'GetCurrentMetastoreMetastoreInfoArgs',
    'GetCurrentMetastoreMetastoreInfoArgsDict',
    'GetExternalLocationExternalLocationInfoArgs',
    'GetExternalLocationExternalLocationInfoArgsDict',
    'GetExternalLocationExternalLocationInfoEncryptionDetailsArgs',
    'GetExternalLocationExternalLocationInfoEncryptionDetailsArgsDict',
    'GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgs',
    'GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgsDict',
    'GetFunctionsFunctionArgs',
    'GetFunctionsFunctionArgsDict',
    'GetFunctionsFunctionInputParamsArgs',
    'GetFunctionsFunctionInputParamsArgsDict',
    'GetFunctionsFunctionInputParamsParameterArgs',
    'GetFunctionsFunctionInputParamsParameterArgsDict',
    'GetFunctionsFunctionReturnParamsArgs',
    'GetFunctionsFunctionReturnParamsArgsDict',
    'GetFunctionsFunctionReturnParamsParameterArgs',
    'GetFunctionsFunctionReturnParamsParameterArgsDict',
    'GetFunctionsFunctionRoutineDependenciesArgs',
    'GetFunctionsFunctionRoutineDependenciesArgsDict',
    'GetFunctionsFunctionRoutineDependenciesDependencyArgs',
    'GetFunctionsFunctionRoutineDependenciesDependencyArgsDict',
    'GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgs',
    'GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgsDict',
    'GetFunctionsFunctionRoutineDependenciesDependencyTableArgs',
    'GetFunctionsFunctionRoutineDependenciesDependencyTableArgsDict',
    'GetInstancePoolPoolInfoArgs',
    'GetInstancePoolPoolInfoArgsDict',
    'GetInstancePoolPoolInfoAwsAttributesArgs',
    'GetInstancePoolPoolInfoAwsAttributesArgsDict',
    'GetInstancePoolPoolInfoAzureAttributesArgs',
    'GetInstancePoolPoolInfoAzureAttributesArgsDict',
    'GetInstancePoolPoolInfoDiskSpecArgs',
    'GetInstancePoolPoolInfoDiskSpecArgsDict',
    'GetInstancePoolPoolInfoDiskSpecDiskTypeArgs',
    'GetInstancePoolPoolInfoDiskSpecDiskTypeArgsDict',
    'GetInstancePoolPoolInfoGcpAttributesArgs',
    'GetInstancePoolPoolInfoGcpAttributesArgsDict',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeArgsDict',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgsDict',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgsDict',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgsDict',
    'GetInstancePoolPoolInfoPreloadedDockerImageArgs',
    'GetInstancePoolPoolInfoPreloadedDockerImageArgsDict',
    'GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs',
    'GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgsDict',
    'GetInstancePoolPoolInfoStatsArgs',
    'GetInstancePoolPoolInfoStatsArgsDict',
    'GetInstanceProfilesInstanceProfileArgs',
    'GetInstanceProfilesInstanceProfileArgsDict',
    'GetJobJobSettingsArgs',
    'GetJobJobSettingsArgsDict',
    'GetJobJobSettingsSettingsArgs',
    'GetJobJobSettingsSettingsArgsDict',
    'GetJobJobSettingsSettingsContinuousArgs',
    'GetJobJobSettingsSettingsContinuousArgsDict',
    'GetJobJobSettingsSettingsDbtTaskArgs',
    'GetJobJobSettingsSettingsDbtTaskArgsDict',
    'GetJobJobSettingsSettingsDeploymentArgs',
    'GetJobJobSettingsSettingsDeploymentArgsDict',
    'GetJobJobSettingsSettingsEmailNotificationsArgs',
    'GetJobJobSettingsSettingsEmailNotificationsArgsDict',
    'GetJobJobSettingsSettingsEnvironmentArgs',
    'GetJobJobSettingsSettingsEnvironmentArgsDict',
    'GetJobJobSettingsSettingsEnvironmentSpecArgs',
    'GetJobJobSettingsSettingsEnvironmentSpecArgsDict',
    'GetJobJobSettingsSettingsGitSourceArgs',
    'GetJobJobSettingsSettingsGitSourceArgsDict',
    'GetJobJobSettingsSettingsGitSourceJobSourceArgs',
    'GetJobJobSettingsSettingsGitSourceJobSourceArgsDict',
    'GetJobJobSettingsSettingsHealthArgs',
    'GetJobJobSettingsSettingsHealthArgsDict',
    'GetJobJobSettingsSettingsHealthRuleArgs',
    'GetJobJobSettingsSettingsHealthRuleArgsDict',
    'GetJobJobSettingsSettingsJobClusterArgs',
    'GetJobJobSettingsSettingsJobClusterArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3ArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3ArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgsDict',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgsDict',
    'GetJobJobSettingsSettingsLibraryArgs',
    'GetJobJobSettingsSettingsLibraryArgsDict',
    'GetJobJobSettingsSettingsLibraryCranArgs',
    'GetJobJobSettingsSettingsLibraryCranArgsDict',
    'GetJobJobSettingsSettingsLibraryMavenArgs',
    'GetJobJobSettingsSettingsLibraryMavenArgsDict',
    'GetJobJobSettingsSettingsLibraryPypiArgs',
    'GetJobJobSettingsSettingsLibraryPypiArgsDict',
    'GetJobJobSettingsSettingsNewClusterArgs',
    'GetJobJobSettingsSettingsNewClusterArgsDict',
    'GetJobJobSettingsSettingsNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsNewClusterAutoscaleArgsDict',
    'GetJobJobSettingsSettingsNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsNewClusterAwsAttributesArgsDict',
    'GetJobJobSettingsSettingsNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsNewClusterAzureAttributesArgsDict',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfArgsDict',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgsDict',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfS3ArgsDict',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoArgsDict',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'GetJobJobSettingsSettingsNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsNewClusterDockerImageArgsDict',
    'GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgsDict',
    'GetJobJobSettingsSettingsNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsNewClusterGcpAttributesArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptFileArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptGcsArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsNewClusterInitScriptS3ArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgsDict',
    'GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgsDict',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeArgsDict',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgsDict',
    'GetJobJobSettingsSettingsNotebookTaskArgs',
    'GetJobJobSettingsSettingsNotebookTaskArgsDict',
    'GetJobJobSettingsSettingsNotificationSettingsArgs',
    'GetJobJobSettingsSettingsNotificationSettingsArgsDict',
    'GetJobJobSettingsSettingsParameterArgs',
    'GetJobJobSettingsSettingsParameterArgsDict',
    'GetJobJobSettingsSettingsPipelineTaskArgs',
    'GetJobJobSettingsSettingsPipelineTaskArgsDict',
    'GetJobJobSettingsSettingsPythonWheelTaskArgs',
    'GetJobJobSettingsSettingsPythonWheelTaskArgsDict',
    'GetJobJobSettingsSettingsQueueArgs',
    'GetJobJobSettingsSettingsQueueArgsDict',
    'GetJobJobSettingsSettingsRunAsArgs',
    'GetJobJobSettingsSettingsRunAsArgsDict',
    'GetJobJobSettingsSettingsRunJobTaskArgs',
    'GetJobJobSettingsSettingsRunJobTaskArgsDict',
    'GetJobJobSettingsSettingsScheduleArgs',
    'GetJobJobSettingsSettingsScheduleArgsDict',
    'GetJobJobSettingsSettingsSparkJarTaskArgs',
    'GetJobJobSettingsSettingsSparkJarTaskArgsDict',
    'GetJobJobSettingsSettingsSparkPythonTaskArgs',
    'GetJobJobSettingsSettingsSparkPythonTaskArgsDict',
    'GetJobJobSettingsSettingsSparkSubmitTaskArgs',
    'GetJobJobSettingsSettingsSparkSubmitTaskArgsDict',
    'GetJobJobSettingsSettingsTaskArgs',
    'GetJobJobSettingsSettingsTaskArgsDict',
    'GetJobJobSettingsSettingsTaskConditionTaskArgs',
    'GetJobJobSettingsSettingsTaskConditionTaskArgsDict',
    'GetJobJobSettingsSettingsTaskDbtTaskArgs',
    'GetJobJobSettingsSettingsTaskDbtTaskArgsDict',
    'GetJobJobSettingsSettingsTaskDependsOnArgs',
    'GetJobJobSettingsSettingsTaskDependsOnArgsDict',
    'GetJobJobSettingsSettingsTaskEmailNotificationsArgs',
    'GetJobJobSettingsSettingsTaskEmailNotificationsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict',
    'GetJobJobSettingsSettingsTaskHealthArgs',
    'GetJobJobSettingsSettingsTaskHealthArgsDict',
    'GetJobJobSettingsSettingsTaskHealthRuleArgs',
    'GetJobJobSettingsSettingsTaskHealthRuleArgsDict',
    'GetJobJobSettingsSettingsTaskLibraryArgs',
    'GetJobJobSettingsSettingsTaskLibraryArgsDict',
    'GetJobJobSettingsSettingsTaskLibraryCranArgs',
    'GetJobJobSettingsSettingsTaskLibraryCranArgsDict',
    'GetJobJobSettingsSettingsTaskLibraryMavenArgs',
    'GetJobJobSettingsSettingsTaskLibraryMavenArgsDict',
    'GetJobJobSettingsSettingsTaskLibraryPypiArgs',
    'GetJobJobSettingsSettingsTaskLibraryPypiArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterArgs',
    'GetJobJobSettingsSettingsTaskNewClusterArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3ArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptS3ArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgsDict',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgsDict',
    'GetJobJobSettingsSettingsTaskNotebookTaskArgs',
    'GetJobJobSettingsSettingsTaskNotebookTaskArgsDict',
    'GetJobJobSettingsSettingsTaskNotificationSettingsArgs',
    'GetJobJobSettingsSettingsTaskNotificationSettingsArgsDict',
    'GetJobJobSettingsSettingsTaskPipelineTaskArgs',
    'GetJobJobSettingsSettingsTaskPipelineTaskArgsDict',
    'GetJobJobSettingsSettingsTaskPythonWheelTaskArgs',
    'GetJobJobSettingsSettingsTaskPythonWheelTaskArgsDict',
    'GetJobJobSettingsSettingsTaskRunJobTaskArgs',
    'GetJobJobSettingsSettingsTaskRunJobTaskArgsDict',
    'GetJobJobSettingsSettingsTaskSparkJarTaskArgs',
    'GetJobJobSettingsSettingsTaskSparkJarTaskArgsDict',
    'GetJobJobSettingsSettingsTaskSparkPythonTaskArgs',
    'GetJobJobSettingsSettingsTaskSparkPythonTaskArgsDict',
    'GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs',
    'GetJobJobSettingsSettingsTaskSparkSubmitTaskArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskFileArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskFileArgsDict',
    'GetJobJobSettingsSettingsTaskSqlTaskQueryArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskQueryArgsDict',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsArgs',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsArgsDict',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgs',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgsDict',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgs',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgsDict',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgs',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgs',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgsDict',
    'GetJobJobSettingsSettingsTriggerArgs',
    'GetJobJobSettingsSettingsTriggerArgsDict',
    'GetJobJobSettingsSettingsTriggerFileArrivalArgs',
    'GetJobJobSettingsSettingsTriggerFileArrivalArgsDict',
    'GetJobJobSettingsSettingsTriggerPeriodicArgs',
    'GetJobJobSettingsSettingsTriggerPeriodicArgsDict',
    'GetJobJobSettingsSettingsTriggerTableUpdateArgs',
    'GetJobJobSettingsSettingsTriggerTableUpdateArgsDict',
    'GetJobJobSettingsSettingsWebhookNotificationsArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsArgsDict',
    'GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgsDict',
    'GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgsDict',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStartArgsDict',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgsDict',
    'GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgsDict',
    'GetMetastoreMetastoreInfoArgs',
    'GetMetastoreMetastoreInfoArgsDict',
    'GetMlflowExperimentTagArgs',
    'GetMlflowExperimentTagArgsDict',
    'GetMlflowModelLatestVersionArgs',
    'GetMlflowModelLatestVersionArgsDict',
    'GetMlflowModelLatestVersionTagArgs',
    'GetMlflowModelLatestVersionTagArgsDict',
    'GetMlflowModelTagArgs',
    'GetMlflowModelTagArgsDict',
    'GetNotificationDestinationsNotificationDestinationArgs',
    'GetNotificationDestinationsNotificationDestinationArgsDict',
    'GetRegisteredModelModelInfoArgs',
    'GetRegisteredModelModelInfoArgsDict',
    'GetRegisteredModelModelInfoAliasArgs',
    'GetRegisteredModelModelInfoAliasArgsDict',
    'GetSchemaSchemaInfoArgs',
    'GetSchemaSchemaInfoArgsDict',
    'GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs',
    'GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgsDict',
    'GetShareObjectArgs',
    'GetShareObjectArgsDict',
    'GetShareObjectPartitionArgs',
    'GetShareObjectPartitionArgsDict',
    'GetShareObjectPartitionValueArgs',
    'GetShareObjectPartitionValueArgsDict',
    'GetSqlWarehouseChannelArgs',
    'GetSqlWarehouseChannelArgsDict',
    'GetSqlWarehouseHealthArgs',
    'GetSqlWarehouseHealthArgsDict',
    'GetSqlWarehouseHealthFailureReasonArgs',
    'GetSqlWarehouseHealthFailureReasonArgsDict',
    'GetSqlWarehouseOdbcParamsArgs',
    'GetSqlWarehouseOdbcParamsArgsDict',
    'GetSqlWarehouseTagsArgs',
    'GetSqlWarehouseTagsArgsDict',
    'GetSqlWarehouseTagsCustomTagArgs',
    'GetSqlWarehouseTagsCustomTagArgsDict',
    'GetStorageCredentialStorageCredentialInfoArgs',
    'GetStorageCredentialStorageCredentialInfoArgsDict',
    'GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs',
    'GetStorageCredentialStorageCredentialInfoAwsIamRoleArgsDict',
    'GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs',
    'GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgsDict',
    'GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs',
    'GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgsDict',
    'GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgs',
    'GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgsDict',
    'GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs',
    'GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgsDict',
    'GetTableTableInfoArgs',
    'GetTableTableInfoArgsDict',
    'GetTableTableInfoColumnArgs',
    'GetTableTableInfoColumnArgsDict',
    'GetTableTableInfoColumnMaskArgs',
    'GetTableTableInfoColumnMaskArgsDict',
    'GetTableTableInfoDeltaRuntimePropertiesKvpairsArgs',
    'GetTableTableInfoDeltaRuntimePropertiesKvpairsArgsDict',
    'GetTableTableInfoEffectivePredictiveOptimizationFlagArgs',
    'GetTableTableInfoEffectivePredictiveOptimizationFlagArgsDict',
    'GetTableTableInfoEncryptionDetailsArgs',
    'GetTableTableInfoEncryptionDetailsArgsDict',
    'GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgs',
    'GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgsDict',
    'GetTableTableInfoRowFilterArgs',
    'GetTableTableInfoRowFilterArgsDict',
    'GetTableTableInfoTableConstraintArgs',
    'GetTableTableInfoTableConstraintArgsDict',
    'GetTableTableInfoTableConstraintForeignKeyConstraintArgs',
    'GetTableTableInfoTableConstraintForeignKeyConstraintArgsDict',
    'GetTableTableInfoTableConstraintNamedTableConstraintArgs',
    'GetTableTableInfoTableConstraintNamedTableConstraintArgsDict',
    'GetTableTableInfoTableConstraintPrimaryKeyConstraintArgs',
    'GetTableTableInfoTableConstraintPrimaryKeyConstraintArgsDict',
    'GetTableTableInfoViewDependenciesArgs',
    'GetTableTableInfoViewDependenciesArgsDict',
    'GetTableTableInfoViewDependenciesDependencyArgs',
    'GetTableTableInfoViewDependenciesDependencyArgsDict',
    'GetTableTableInfoViewDependenciesDependencyFunctionArgs',
    'GetTableTableInfoViewDependenciesDependencyFunctionArgsDict',
    'GetTableTableInfoViewDependenciesDependencyTableArgs',
    'GetTableTableInfoViewDependenciesDependencyTableArgsDict',
    'GetVolumeVolumeInfoArgs',
    'GetVolumeVolumeInfoArgsDict',
    'GetVolumeVolumeInfoEncryptionDetailsArgs',
    'GetVolumeVolumeInfoEncryptionDetailsArgsDict',
    'GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgs',
    'GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgsDict',
]

MYPY = False

if not MYPY:
    class AccessControlRuleSetGrantRuleArgsDict(TypedDict):
        role: pulumi.Input[str]
        """
        Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page) or [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role).
        * `roles/servicePrincipal.manager` - Manager of a service principal.
        * `roles/servicePrincipal.user` - User of a service principal.
        * `roles/group.manager` - Manager of a group.
        * `roles/marketplace.admin` - Admin of marketplace.
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        a list of principals who are granted a role. The following format is supported:
        * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
        * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
        * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
elif False:
    AccessControlRuleSetGrantRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlRuleSetGrantRuleArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[str],
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] role: Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page) or [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role).
               * `roles/servicePrincipal.manager` - Manager of a service principal.
               * `roles/servicePrincipal.user` - User of a service principal.
               * `roles/group.manager` - Manager of a group.
               * `roles/marketplace.admin` - Admin of marketplace.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] principals: a list of principals who are granted a role. The following format is supported:
               * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
               * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
               * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
        pulumi.set(__self__, "role", role)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page) or [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role).
        * `roles/servicePrincipal.manager` - Manager of a service principal.
        * `roles/servicePrincipal.user` - User of a service principal.
        * `roles/group.manager` - Manager of a group.
        * `roles/marketplace.admin` - Admin of marketplace.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        a list of principals who are granted a role. The following format is supported:
        * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
        * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
        * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "principals", value)


if not MYPY:
    class AlertConditionArgsDict(TypedDict):
        op: pulumi.Input[str]
        """
        Operator used for comparison in alert evaluation. (Enum: `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `EQUAL`, `NOT_EQUAL`, `IS_NULL`)
        """
        operand: pulumi.Input['AlertConditionOperandArgsDict']
        """
        Name of the column from the query result to use for comparison in alert evaluation:
        """
        empty_result_state: NotRequired[pulumi.Input[str]]
        """
        Alert state if the result is empty (`UNKNOWN`, `OK`, `TRIGGERED`)
        """
        threshold: NotRequired[pulumi.Input['AlertConditionThresholdArgsDict']]
        """
        Threshold value used for comparison in alert evaluation:
        """
elif False:
    AlertConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConditionArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[str],
                 operand: pulumi.Input['AlertConditionOperandArgs'],
                 empty_result_state: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input['AlertConditionThresholdArgs']] = None):
        """
        :param pulumi.Input[str] op: Operator used for comparison in alert evaluation. (Enum: `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `EQUAL`, `NOT_EQUAL`, `IS_NULL`)
        :param pulumi.Input['AlertConditionOperandArgs'] operand: Name of the column from the query result to use for comparison in alert evaluation:
        :param pulumi.Input[str] empty_result_state: Alert state if the result is empty (`UNKNOWN`, `OK`, `TRIGGERED`)
        :param pulumi.Input['AlertConditionThresholdArgs'] threshold: Threshold value used for comparison in alert evaluation:
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "operand", operand)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        Operator used for comparison in alert evaluation. (Enum: `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `EQUAL`, `NOT_EQUAL`, `IS_NULL`)
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def operand(self) -> pulumi.Input['AlertConditionOperandArgs']:
        """
        Name of the column from the query result to use for comparison in alert evaluation:
        """
        return pulumi.get(self, "operand")

    @operand.setter
    def operand(self, value: pulumi.Input['AlertConditionOperandArgs']):
        pulumi.set(self, "operand", value)

    @property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[pulumi.Input[str]]:
        """
        Alert state if the result is empty (`UNKNOWN`, `OK`, `TRIGGERED`)
        """
        return pulumi.get(self, "empty_result_state")

    @empty_result_state.setter
    def empty_result_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "empty_result_state", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['AlertConditionThresholdArgs']]:
        """
        Threshold value used for comparison in alert evaluation:
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['AlertConditionThresholdArgs']]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class AlertConditionOperandArgsDict(TypedDict):
        column: pulumi.Input['AlertConditionOperandColumnArgsDict']
        """
        Block describing the column from the query result to use for comparison in alert evaluation:
        """
elif False:
    AlertConditionOperandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConditionOperandArgs:
    def __init__(__self__, *,
                 column: pulumi.Input['AlertConditionOperandColumnArgs']):
        """
        :param pulumi.Input['AlertConditionOperandColumnArgs'] column: Block describing the column from the query result to use for comparison in alert evaluation:
        """
        pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input['AlertConditionOperandColumnArgs']:
        """
        Block describing the column from the query result to use for comparison in alert evaluation:
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input['AlertConditionOperandColumnArgs']):
        pulumi.set(self, "column", value)


if not MYPY:
    class AlertConditionOperandColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the column.
        """
elif False:
    AlertConditionOperandColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConditionOperandColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the column.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AlertConditionThresholdArgsDict(TypedDict):
        value: pulumi.Input['AlertConditionThresholdValueArgsDict']
        """
        actual value used in comparison (one of the attributes is required):
        """
elif False:
    AlertConditionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConditionThresholdArgs:
    def __init__(__self__, *,
                 value: pulumi.Input['AlertConditionThresholdValueArgs']):
        """
        :param pulumi.Input['AlertConditionThresholdValueArgs'] value: actual value used in comparison (one of the attributes is required):
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['AlertConditionThresholdValueArgs']:
        """
        actual value used in comparison (one of the attributes is required):
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['AlertConditionThresholdValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertConditionThresholdValueArgsDict(TypedDict):
        bool_value: NotRequired[pulumi.Input[bool]]
        """
        boolean value (`true` or `false`) to compare against boolean results.
        """
        double_value: NotRequired[pulumi.Input[float]]
        """
        double value to compare against integer and double results.
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        string value to compare against string results.
        """
elif False:
    AlertConditionThresholdValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertConditionThresholdValueArgs:
    def __init__(__self__, *,
                 bool_value: Optional[pulumi.Input[bool]] = None,
                 double_value: Optional[pulumi.Input[float]] = None,
                 string_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] bool_value: boolean value (`true` or `false`) to compare against boolean results.
        :param pulumi.Input[float] double_value: double value to compare against integer and double results.
        :param pulumi.Input[str] string_value: string value to compare against string results.
        """
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[pulumi.Input[bool]]:
        """
        boolean value (`true` or `false`) to compare against boolean results.
        """
        return pulumi.get(self, "bool_value")

    @bool_value.setter
    def bool_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bool_value", value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input[float]]:
        """
        double value to compare against integer and double results.
        """
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        string value to compare against string results.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class ArtifactAllowlistArtifactMatcherArgsDict(TypedDict):
        artifact: pulumi.Input[str]
        """
        The artifact path or maven coordinate.
        """
        match_type: pulumi.Input[str]
        """
        The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
elif False:
    ArtifactAllowlistArtifactMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactAllowlistArtifactMatcherArgs:
    def __init__(__self__, *,
                 artifact: pulumi.Input[str],
                 match_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] artifact: The artifact path or maven coordinate.
        :param pulumi.Input[str] match_type: The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
        pulumi.set(__self__, "artifact", artifact)
        pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter
    def artifact(self) -> pulumi.Input[str]:
        """
        The artifact path or maven coordinate.
        """
        return pulumi.get(self, "artifact")

    @artifact.setter
    def artifact(self, value: pulumi.Input[str]):
        pulumi.set(self, "artifact", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        can_toggle: NotRequired[pulumi.Input[bool]]
        enablement_details: NotRequired[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgsDict']]
        maintenance_window: NotRequired[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgsDict']]
        restart_even_if_no_updates_available: NotRequired[pulumi.Input[bool]]
elif False:
    AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 can_toggle: Optional[pulumi.Input[bool]] = None,
                 enablement_details: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgs']] = None,
                 maintenance_window: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs']] = None,
                 restart_even_if_no_updates_available: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "can_toggle")

    @can_toggle.setter
    def can_toggle(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_toggle", value)

    @property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgs']]:
        return pulumi.get(self, "enablement_details")

    @enablement_details.setter
    def enablement_details(self, value: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgs']]):
        pulumi.set(self, "enablement_details", value)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs']]:
        return pulumi.get(self, "maintenance_window")

    @maintenance_window.setter
    def maintenance_window(self, value: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs']]):
        pulumi.set(self, "maintenance_window", value)

    @property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "restart_even_if_no_updates_available")

    @restart_even_if_no_updates_available.setter
    def restart_even_if_no_updates_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restart_even_if_no_updates_available", value)


if not MYPY:
    class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgsDict(TypedDict):
        forced_for_compliance_mode: NotRequired[pulumi.Input[bool]]
        unavailable_for_disabled_entitlement: NotRequired[pulumi.Input[bool]]
        unavailable_for_non_enterprise_tier: NotRequired[pulumi.Input[bool]]
elif False:
    AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetailsArgs:
    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[pulumi.Input[bool]] = None,
                 unavailable_for_disabled_entitlement: Optional[pulumi.Input[bool]] = None,
                 unavailable_for_non_enterprise_tier: Optional[pulumi.Input[bool]] = None):
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "forced_for_compliance_mode")

    @forced_for_compliance_mode.setter
    def forced_for_compliance_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "forced_for_compliance_mode", value)

    @property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @unavailable_for_disabled_entitlement.setter
    def unavailable_for_disabled_entitlement(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unavailable_for_disabled_entitlement", value)

    @property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")

    @unavailable_for_non_enterprise_tier.setter
    def unavailable_for_non_enterprise_tier(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unavailable_for_non_enterprise_tier", value)


if not MYPY:
    class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgsDict(TypedDict):
        week_day_based_schedule: NotRequired[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgsDict']]
elif False:
    AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs:
    def __init__(__self__, *,
                 week_day_based_schedule: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs']] = None):
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs']]:
        return pulumi.get(self, "week_day_based_schedule")

    @week_day_based_schedule.setter
    def week_day_based_schedule(self, value: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs']]):
        pulumi.set(self, "week_day_based_schedule", value)


if not MYPY:
    class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgsDict(TypedDict):
        day_of_week: pulumi.Input[str]
        frequency: pulumi.Input[str]
        window_start_time: NotRequired[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgsDict']]
elif False:
    AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 frequency: pulumi.Input[str],
                 window_start_time: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs']] = None):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[str]:
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs']]:
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: Optional[pulumi.Input['AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs']]):
        pulumi.set(self, "window_start_time", value)


if not MYPY:
    class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgsDict(TypedDict):
        hours: pulumi.Input[int]
        minutes: pulumi.Input[int]
elif False:
    AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[int],
                 minutes: pulumi.Input[int]):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[int]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[int]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[int]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class BudgetAlertConfigurationArgsDict(TypedDict):
        action_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BudgetAlertConfigurationActionConfigurationArgsDict']]]]
        """
        List of action configurations to take when the budget alert is triggered. Consists of the following fields:
        """
        alert_configuration_id: NotRequired[pulumi.Input[str]]
        quantity_threshold: NotRequired[pulumi.Input[str]]
        """
        The threshold for the budget alert to determine if it is in a triggered state. The number is evaluated based on `quantity_type`.
        """
        quantity_type: NotRequired[pulumi.Input[str]]
        """
        The way to calculate cost for this budget alert. This is what quantity_threshold is measured in. (Enum: `LIST_PRICE_DOLLARS_USD`)
        """
        time_period: NotRequired[pulumi.Input[str]]
        """
        The time window of usage data for the budget. (Enum: `MONTH`)
        """
        trigger_type: NotRequired[pulumi.Input[str]]
        """
        The evaluation method to determine when this budget alert is in a triggered state. (Enum: `CUMULATIVE_SPENDING_EXCEEDED`)
        """
elif False:
    BudgetAlertConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAlertConfigurationArgs:
    def __init__(__self__, *,
                 action_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetAlertConfigurationActionConfigurationArgs']]]] = None,
                 alert_configuration_id: Optional[pulumi.Input[str]] = None,
                 quantity_threshold: Optional[pulumi.Input[str]] = None,
                 quantity_type: Optional[pulumi.Input[str]] = None,
                 time_period: Optional[pulumi.Input[str]] = None,
                 trigger_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BudgetAlertConfigurationActionConfigurationArgs']]] action_configurations: List of action configurations to take when the budget alert is triggered. Consists of the following fields:
        :param pulumi.Input[str] quantity_threshold: The threshold for the budget alert to determine if it is in a triggered state. The number is evaluated based on `quantity_type`.
        :param pulumi.Input[str] quantity_type: The way to calculate cost for this budget alert. This is what quantity_threshold is measured in. (Enum: `LIST_PRICE_DOLLARS_USD`)
        :param pulumi.Input[str] time_period: The time window of usage data for the budget. (Enum: `MONTH`)
        :param pulumi.Input[str] trigger_type: The evaluation method to determine when this budget alert is in a triggered state. (Enum: `CUMULATIVE_SPENDING_EXCEEDED`)
        """
        if action_configurations is not None:
            pulumi.set(__self__, "action_configurations", action_configurations)
        if alert_configuration_id is not None:
            pulumi.set(__self__, "alert_configuration_id", alert_configuration_id)
        if quantity_threshold is not None:
            pulumi.set(__self__, "quantity_threshold", quantity_threshold)
        if quantity_type is not None:
            pulumi.set(__self__, "quantity_type", quantity_type)
        if time_period is not None:
            pulumi.set(__self__, "time_period", time_period)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter(name="actionConfigurations")
    def action_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetAlertConfigurationActionConfigurationArgs']]]]:
        """
        List of action configurations to take when the budget alert is triggered. Consists of the following fields:
        """
        return pulumi.get(self, "action_configurations")

    @action_configurations.setter
    def action_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetAlertConfigurationActionConfigurationArgs']]]]):
        pulumi.set(self, "action_configurations", value)

    @property
    @pulumi.getter(name="alertConfigurationId")
    def alert_configuration_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "alert_configuration_id")

    @alert_configuration_id.setter
    def alert_configuration_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_configuration_id", value)

    @property
    @pulumi.getter(name="quantityThreshold")
    def quantity_threshold(self) -> Optional[pulumi.Input[str]]:
        """
        The threshold for the budget alert to determine if it is in a triggered state. The number is evaluated based on `quantity_type`.
        """
        return pulumi.get(self, "quantity_threshold")

    @quantity_threshold.setter
    def quantity_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quantity_threshold", value)

    @property
    @pulumi.getter(name="quantityType")
    def quantity_type(self) -> Optional[pulumi.Input[str]]:
        """
        The way to calculate cost for this budget alert. This is what quantity_threshold is measured in. (Enum: `LIST_PRICE_DOLLARS_USD`)
        """
        return pulumi.get(self, "quantity_type")

    @quantity_type.setter
    def quantity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quantity_type", value)

    @property
    @pulumi.getter(name="timePeriod")
    def time_period(self) -> Optional[pulumi.Input[str]]:
        """
        The time window of usage data for the budget. (Enum: `MONTH`)
        """
        return pulumi.get(self, "time_period")

    @time_period.setter
    def time_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_period", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input[str]]:
        """
        The evaluation method to determine when this budget alert is in a triggered state. (Enum: `CUMULATIVE_SPENDING_EXCEEDED`)
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_type", value)


if not MYPY:
    class BudgetAlertConfigurationActionConfigurationArgsDict(TypedDict):
        action_configuration_id: NotRequired[pulumi.Input[str]]
        action_type: NotRequired[pulumi.Input[str]]
        """
        The type of action to take when the budget alert is triggered. (Enum: `EMAIL_NOTIFICATION`)
        """
        target: NotRequired[pulumi.Input[str]]
        """
        The target of the action. For `EMAIL_NOTIFICATION`, this is the email address to send the notification to.
        """
elif False:
    BudgetAlertConfigurationActionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAlertConfigurationActionConfigurationArgs:
    def __init__(__self__, *,
                 action_configuration_id: Optional[pulumi.Input[str]] = None,
                 action_type: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_type: The type of action to take when the budget alert is triggered. (Enum: `EMAIL_NOTIFICATION`)
        :param pulumi.Input[str] target: The target of the action. For `EMAIL_NOTIFICATION`, this is the email address to send the notification to.
        """
        if action_configuration_id is not None:
            pulumi.set(__self__, "action_configuration_id", action_configuration_id)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="actionConfigurationId")
    def action_configuration_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action_configuration_id")

    @action_configuration_id.setter
    def action_configuration_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_configuration_id", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to take when the budget alert is triggered. (Enum: `EMAIL_NOTIFICATION`)
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The target of the action. For `EMAIL_NOTIFICATION`, this is the email address to send the notification to.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class BudgetFilterArgsDict(TypedDict):
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['BudgetFilterTagArgsDict']]]]
        """
        List of tags to filter by. Consists of the following fields:
        """
        workspace_id: NotRequired[pulumi.Input['BudgetFilterWorkspaceIdArgsDict']]
        """
        Filter by workspace ID (if empty, include usage all usage for this account). Consists of the following fields:
        """
elif False:
    BudgetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetFilterArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetFilterTagArgs']]]] = None,
                 workspace_id: Optional[pulumi.Input['BudgetFilterWorkspaceIdArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BudgetFilterTagArgs']]] tags: List of tags to filter by. Consists of the following fields:
        :param pulumi.Input['BudgetFilterWorkspaceIdArgs'] workspace_id: Filter by workspace ID (if empty, include usage all usage for this account). Consists of the following fields:
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BudgetFilterTagArgs']]]]:
        """
        List of tags to filter by. Consists of the following fields:
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BudgetFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[pulumi.Input['BudgetFilterWorkspaceIdArgs']]:
        """
        Filter by workspace ID (if empty, include usage all usage for this account). Consists of the following fields:
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: Optional[pulumi.Input['BudgetFilterWorkspaceIdArgs']]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class BudgetFilterTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The key of the tag.
        """
        value: NotRequired[pulumi.Input['BudgetFilterTagValueArgsDict']]
        """
        Consists of the following fields:
        """
elif False:
    BudgetFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetFilterTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input['BudgetFilterTagValueArgs']] = None):
        """
        :param pulumi.Input[str] key: The key of the tag.
        :param pulumi.Input['BudgetFilterTagValueArgs'] value: Consists of the following fields:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['BudgetFilterTagValueArgs']]:
        """
        Consists of the following fields:
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['BudgetFilterTagValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BudgetFilterTagValueArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        The operator to use for the filter. (Enum: `IN`)
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The values to filter by.
        """
elif False:
    BudgetFilterTagValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetFilterTagValueArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for the filter. (Enum: `IN`)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The values to filter by.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for the filter. (Enum: `IN`)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The values to filter by.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class BudgetFilterWorkspaceIdArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        The operator to use for the filter. (Enum: `IN`)
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The values to filter by.
        """
elif False:
    BudgetFilterWorkspaceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetFilterWorkspaceIdArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for the filter. (Enum: `IN`)
        :param pulumi.Input[Sequence[pulumi.Input[int]]] values: The values to filter by.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to use for the filter. (Enum: `IN`)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The values to filter by.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[pulumi.Input[int]]
        """
        The maximum number of workers to which the cluster can scale up when overloaded. max_workers must be strictly greater than min_workers.

        When using a [Single Node cluster](https://docs.databricks.com/clusters/single-node.html), `num_workers` needs to be `0`. It can be set to `0` explicitly, or simply not specified, as it defaults to `0`.  When `num_workers` is `0`, provider checks for presence of the required Spark configurations:

        * `spark.master` must have prefix `local`, like `local[*]`
        * `spark.databricks.cluster.profile` must have value `singleNode`

        and also `custom_tag` entry:

        * `"ResourceClass" = "SingleNode"`

        The following example demonstrates how to create an single node cluster:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        smallest = databricks.get_node_type(local_disk=True)
        latest_lts = databricks.get_spark_version(long_term_support=True)
        single_node = databricks.Cluster("single_node",
            cluster_name="Single Node",
            spark_version=latest_lts.id,
            node_type_id=smallest.id,
            autotermination_minutes=20,
            spark_conf={
                "spark.databricks.cluster.profile": "singleNode",
                "spark.master": "local[*]",
            },
            custom_tags={
                "ResourceClass": "SingleNode",
            })
        ```
        """
        min_workers: NotRequired[pulumi.Input[int]]
        """
        The minimum number of workers to which the cluster can scale down when underutilized. It is also the initial number of workers the cluster will have after creation.
        """
elif False:
    ClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_workers: The maximum number of workers to which the cluster can scale up when overloaded. max_workers must be strictly greater than min_workers.
               
               When using a [Single Node cluster](https://docs.databricks.com/clusters/single-node.html), `num_workers` needs to be `0`. It can be set to `0` explicitly, or simply not specified, as it defaults to `0`.  When `num_workers` is `0`, provider checks for presence of the required Spark configurations:
               
               * `spark.master` must have prefix `local`, like `local[*]`
               * `spark.databricks.cluster.profile` must have value `singleNode`
               
               and also `custom_tag` entry:
               
               * `"ResourceClass" = "SingleNode"`
               
               The following example demonstrates how to create an single node cluster:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               smallest = databricks.get_node_type(local_disk=True)
               latest_lts = databricks.get_spark_version(long_term_support=True)
               single_node = databricks.Cluster("single_node",
                   cluster_name="Single Node",
                   spark_version=latest_lts.id,
                   node_type_id=smallest.id,
                   autotermination_minutes=20,
                   spark_conf={
                       "spark.databricks.cluster.profile": "singleNode",
                       "spark.master": "local[*]",
                   },
                   custom_tags={
                       "ResourceClass": "SingleNode",
                   })
               ```
        :param pulumi.Input[int] min_workers: The minimum number of workers to which the cluster can scale down when underutilized. It is also the initial number of workers the cluster will have after creation.
        """
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of workers to which the cluster can scale up when overloaded. max_workers must be strictly greater than min_workers.

        When using a [Single Node cluster](https://docs.databricks.com/clusters/single-node.html), `num_workers` needs to be `0`. It can be set to `0` explicitly, or simply not specified, as it defaults to `0`.  When `num_workers` is `0`, provider checks for presence of the required Spark configurations:

        * `spark.master` must have prefix `local`, like `local[*]`
        * `spark.databricks.cluster.profile` must have value `singleNode`

        and also `custom_tag` entry:

        * `"ResourceClass" = "SingleNode"`

        The following example demonstrates how to create an single node cluster:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        smallest = databricks.get_node_type(local_disk=True)
        latest_lts = databricks.get_spark_version(long_term_support=True)
        single_node = databricks.Cluster("single_node",
            cluster_name="Single Node",
            spark_version=latest_lts.id,
            node_type_id=smallest.id,
            autotermination_minutes=20,
            spark_conf={
                "spark.databricks.cluster.profile": "singleNode",
                "spark.master": "local[*]",
            },
            custom_tags={
                "ResourceClass": "SingleNode",
            })
        ```
        """
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of workers to which the cluster can scale down when underutilized. It is also the initial number of workers the cluster will have after creation.
        """
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class ClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        """
        Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT`, `SPOT_WITH_FALLBACK` and `ON_DEMAND`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster. Backend default value is `SPOT_WITH_FALLBACK` and could change in the future
        """
        ebs_volume_count: NotRequired[pulumi.Input[int]]
        """
        The number of volumes launched for each instance. You can choose up to 10 volumes. This feature is only enabled for supported node types. Legacy node types cannot specify custom EBS volumes. For node types with no instance store, at least one EBS volume needs to be specified; otherwise, cluster creation will fail. These EBS volumes will be mounted at /ebs0, /ebs1, and etc. Instance store volumes will be mounted at /local_disk0, /local_disk1, and etc. If EBS volumes are attached, Databricks will configure Spark to use only the EBS volumes for scratch storage because heterogeneously sized scratch devices can lead to inefficient disk utilization. If no EBS volumes are attached, Databricks will configure Spark to use instance store volumes. If EBS volumes are specified, then the Spark configuration spark.local.dir will be overridden.
        """
        ebs_volume_iops: NotRequired[pulumi.Input[int]]
        ebs_volume_size: NotRequired[pulumi.Input[int]]
        """
        The size of each EBS volume (in GiB) launched for each instance. For general purpose SSD, this value must be within the range 100 - 4096. For throughput optimized HDD, this value must be within the range 500 - 4096. Custom EBS volumes cannot be specified for the legacy node types (memory-optimized and compute-optimized).
        """
        ebs_volume_throughput: NotRequired[pulumi.Input[int]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        """
        The type of EBS volumes that will be launched with this cluster. Valid values are `GENERAL_PURPOSE_SSD` or `THROUGHPUT_OPTIMIZED_HDD`. Use this option only if you're not picking *Delta Optimized `i3.*`* node types.
        """
        first_on_demand: NotRequired[pulumi.Input[int]]
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster. Backend default value is `1` and could change in the future
        """
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        """
        Nodes for this cluster will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        """
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        """
        The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the cluster needs a new `i3.xlarge` spot instance, then the max price is half of the price of on-demand `i3.xlarge` instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand `i3.xlarge` instances. If not specified, the default value is `100`. When spot instances are requested for this cluster, only spot instances whose max price percentage matches this field will be considered. For safety, we enforce this field to be no more than `10000`.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-west-2a`. The provided availability zone must be in the same region as the Databricks deployment. For example, `us-west-2a` is not a valid zone ID if the Databricks deployment resides in the `us-east-1` region. Enable automatic availability zone selection ("Auto-AZ"), by setting the value `auto`. Databricks selects the AZ based on available IPs in the workspace subnets and retries in other availability zones if AWS returns insufficient capacity errors.
        """
elif False:
    ClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_throughput: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability: Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT`, `SPOT_WITH_FALLBACK` and `ON_DEMAND`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster. Backend default value is `SPOT_WITH_FALLBACK` and could change in the future
        :param pulumi.Input[int] ebs_volume_count: The number of volumes launched for each instance. You can choose up to 10 volumes. This feature is only enabled for supported node types. Legacy node types cannot specify custom EBS volumes. For node types with no instance store, at least one EBS volume needs to be specified; otherwise, cluster creation will fail. These EBS volumes will be mounted at /ebs0, /ebs1, and etc. Instance store volumes will be mounted at /local_disk0, /local_disk1, and etc. If EBS volumes are attached, Databricks will configure Spark to use only the EBS volumes for scratch storage because heterogeneously sized scratch devices can lead to inefficient disk utilization. If no EBS volumes are attached, Databricks will configure Spark to use instance store volumes. If EBS volumes are specified, then the Spark configuration spark.local.dir will be overridden.
        :param pulumi.Input[int] ebs_volume_size: The size of each EBS volume (in GiB) launched for each instance. For general purpose SSD, this value must be within the range 100 - 4096. For throughput optimized HDD, this value must be within the range 500 - 4096. Custom EBS volumes cannot be specified for the legacy node types (memory-optimized and compute-optimized).
        :param pulumi.Input[str] ebs_volume_type: The type of EBS volumes that will be launched with this cluster. Valid values are `GENERAL_PURPOSE_SSD` or `THROUGHPUT_OPTIMIZED_HDD`. Use this option only if you're not picking *Delta Optimized `i3.*`* node types.
        :param pulumi.Input[int] first_on_demand: The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster. Backend default value is `1` and could change in the future
        :param pulumi.Input[str] instance_profile_arn: Nodes for this cluster will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        :param pulumi.Input[int] spot_bid_price_percent: The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the cluster needs a new `i3.xlarge` spot instance, then the max price is half of the price of on-demand `i3.xlarge` instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand `i3.xlarge` instances. If not specified, the default value is `100`. When spot instances are requested for this cluster, only spot instances whose max price percentage matches this field will be considered. For safety, we enforce this field to be no more than `10000`.
        :param pulumi.Input[str] zone_id: Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-west-2a`. The provided availability zone must be in the same region as the Databricks deployment. For example, `us-west-2a` is not a valid zone ID if the Databricks deployment resides in the `us-east-1` region. Enable automatic availability zone selection ("Auto-AZ"), by setting the value `auto`. Databricks selects the AZ based on available IPs in the workspace subnets and retries in other availability zones if AWS returns insufficient capacity errors.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT`, `SPOT_WITH_FALLBACK` and `ON_DEMAND`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster. Backend default value is `SPOT_WITH_FALLBACK` and could change in the future
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of volumes launched for each instance. You can choose up to 10 volumes. This feature is only enabled for supported node types. Legacy node types cannot specify custom EBS volumes. For node types with no instance store, at least one EBS volume needs to be specified; otherwise, cluster creation will fail. These EBS volumes will be mounted at /ebs0, /ebs1, and etc. Instance store volumes will be mounted at /local_disk0, /local_disk1, and etc. If EBS volumes are attached, Databricks will configure Spark to use only the EBS volumes for scratch storage because heterogeneously sized scratch devices can lead to inefficient disk utilization. If no EBS volumes are attached, Databricks will configure Spark to use instance store volumes. If EBS volumes are specified, then the Spark configuration spark.local.dir will be overridden.
        """
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of each EBS volume (in GiB) launched for each instance. For general purpose SSD, this value must be within the range 100 - 4096. For throughput optimized HDD, this value must be within the range 500 - 4096. Custom EBS volumes cannot be specified for the legacy node types (memory-optimized and compute-optimized).
        """
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of EBS volumes that will be launched with this cluster. Valid values are `GENERAL_PURPOSE_SSD` or `THROUGHPUT_OPTIMIZED_HDD`. Use this option only if you're not picking *Delta Optimized `i3.*`* node types.
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster. Backend default value is `1` and could change in the future
        """
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Nodes for this cluster will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        """
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        """
        The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the cluster needs a new `i3.xlarge` spot instance, then the max price is half of the price of on-demand `i3.xlarge` instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand `i3.xlarge` instances. If not specified, the default value is `100`. When spot instances are requested for this cluster, only spot instances whose max price percentage matches this field will be considered. For safety, we enforce this field to be no more than `10000`.
        """
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-west-2a`. The provided availability zone must be in the same region as the Databricks deployment. For example, `us-west-2a` is not a valid zone ID if the Databricks deployment resides in the `us-east-1` region. Enable automatic availability zone selection ("Auto-AZ"), by setting the value `auto`. Databricks selects the AZ based on available IPs in the workspace subnets and retries in other availability zones if AWS returns insufficient capacity errors.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class ClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        """
        Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT_AZURE`, `SPOT_WITH_FALLBACK_AZURE`, and `ON_DEMAND_AZURE`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster.
        """
        first_on_demand: NotRequired[pulumi.Input[int]]
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        """
        log_analytics_info: NotRequired[pulumi.Input['ClusterAzureAttributesLogAnalyticsInfoArgsDict']]
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
        """
        The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
elif False:
    ClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 log_analytics_info: Optional[pulumi.Input['ClusterAzureAttributesLogAnalyticsInfoArgs']] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability: Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT_AZURE`, `SPOT_WITH_FALLBACK_AZURE`, and `ON_DEMAND_AZURE`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster.
        :param pulumi.Input[int] first_on_demand: The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        :param pulumi.Input[float] spot_bid_max_price: The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT_AZURE`, `SPOT_WITH_FALLBACK_AZURE`, and `ON_DEMAND_AZURE`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        """
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional[pulumi.Input['ClusterAzureAttributesLogAnalyticsInfoArgs']]:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional[pulumi.Input['ClusterAzureAttributesLogAnalyticsInfoArgs']]):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        """
        The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class ClusterAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[pulumi.Input[str]]
        log_analytics_workspace_id: NotRequired[pulumi.Input[str]]
elif False:
    ClusterAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_id: Optional[pulumi.Input[str]] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class ClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired[pulumi.Input['ClusterClusterLogConfDbfsArgsDict']]
        s3: NotRequired[pulumi.Input['ClusterClusterLogConfS3ArgsDict']]
elif False:
    ClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterClusterLogConfS3Args']] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class ClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        canned_acl: NotRequired[pulumi.Input[str]]
        """
        Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        """
        enable_encryption: NotRequired[pulumi.Input[bool]]
        """
        Enable server-side encryption, false by default.
        """
        encryption_type: NotRequired[pulumi.Input[str]]
        """
        The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
elif False:
    ClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        :param pulumi.Input[str] canned_acl: Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        :param pulumi.Input[bool] enable_encryption: Enable server-side encryption, false by default.
        :param pulumi.Input[str] encryption_type: The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        :param pulumi.Input[str] endpoint: S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        :param pulumi.Input[str] kms_key: KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        :param pulumi.Input[str] region: S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable server-side encryption, false by default.
        """
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: pulumi.Input[str]
        """
        path inside the Spark container.

        For example, you can mount Azure Data Lake Storage container using the following code:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        storage_account = "ewfw3ggwegwg"
        storage_container = "test"
        with_nfs = databricks.Cluster("with_nfs", cluster_mount_infos=[{
            "network_filesystem_info": {
                "server_address": f"{storage_account}.blob.core.windows.net",
                "mount_options": "sec=sys,vers=3,nolock,proto=tcp",
            },
            "remote_mount_dir_path": f"{storage_account}/{storage_container}",
            "local_mount_dir_path": "/mnt/nfs-test",
        }])
        ```
        """
        network_filesystem_info: pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgsDict']
        """
        block specifying connection. It consists of:
        """
        remote_mount_dir_path: NotRequired[pulumi.Input[str]]
        """
        string specifying path to mount on the remote service.
        """
elif False:
    ClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] local_mount_dir_path: path inside the Spark container.
               
               For example, you can mount Azure Data Lake Storage container using the following code:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               storage_account = "ewfw3ggwegwg"
               storage_container = "test"
               with_nfs = databricks.Cluster("with_nfs", cluster_mount_infos=[{
                   "network_filesystem_info": {
                       "server_address": f"{storage_account}.blob.core.windows.net",
                       "mount_options": "sec=sys,vers=3,nolock,proto=tcp",
                   },
                   "remote_mount_dir_path": f"{storage_account}/{storage_container}",
                   "local_mount_dir_path": "/mnt/nfs-test",
               }])
               ```
        :param pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs'] network_filesystem_info: block specifying connection. It consists of:
        :param pulumi.Input[str] remote_mount_dir_path: string specifying path to mount on the remote service.
        """
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        """
        path inside the Spark container.

        For example, you can mount Azure Data Lake Storage container using the following code:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        storage_account = "ewfw3ggwegwg"
        storage_container = "test"
        with_nfs = databricks.Cluster("with_nfs", cluster_mount_infos=[{
            "network_filesystem_info": {
                "server_address": f"{storage_account}.blob.core.windows.net",
                "mount_options": "sec=sys,vers=3,nolock,proto=tcp",
            },
            "remote_mount_dir_path": f"{storage_account}/{storage_container}",
            "local_mount_dir_path": "/mnt/nfs-test",
        }])
        ```
        """
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        """
        block specifying connection. It consists of:
        """
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying path to mount on the remote service.
        """
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class ClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: pulumi.Input[str]
        """
        host name.
        """
        mount_options: NotRequired[pulumi.Input[str]]
        """
        string that will be passed as options passed to the `mount` command.
        """
elif False:
    ClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] server_address: host name.
        :param pulumi.Input[str] mount_options: string that will be passed as options passed to the `mount` command.
        """
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        """
        host name.
        """
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        """
        string that will be passed as options passed to the `mount` command.
        """
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class ClusterDockerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL for the Docker image
        """
        basic_auth: NotRequired[pulumi.Input['ClusterDockerImageBasicAuthArgsDict']]
        """
        `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch. However, other authenticated and authorized API users of this workspace can access the username and password.

        Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:

        ```python
        import pulumi
        import pulumi_databricks as databricks
        import pulumi_docker as docker

        this = docker.index.RegistryImage("this",
            build=[{}],
            name=f{this_azurerm_container_registry.login_server}/sample:latest)
        this_cluster = databricks.Cluster("this", docker_image={
            "url": this["name"],
            "basic_auth": {
                "username": this_azurerm_container_registry["adminUsername"],
                "password": this_azurerm_container_registry["adminPassword"],
            },
        })
        ```
        """
elif False:
    ClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL for the Docker image
        :param pulumi.Input['ClusterDockerImageBasicAuthArgs'] basic_auth: `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch. However, other authenticated and authorized API users of this workspace can access the username and password.
               
               Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               import pulumi_docker as docker
               
               this = docker.index.RegistryImage("this",
                   build=[{}],
                   name=f{this_azurerm_container_registry.login_server}/sample:latest)
               this_cluster = databricks.Cluster("this", docker_image={
                   "url": this["name"],
                   "basic_auth": {
                       "username": this_azurerm_container_registry["adminUsername"],
                       "password": this_azurerm_container_registry["adminPassword"],
                   },
               })
               ```
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL for the Docker image
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']]:
        """
        `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch. However, other authenticated and authorized API users of this workspace can access the username and password.

        Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:

        ```python
        import pulumi
        import pulumi_databricks as databricks
        import pulumi_docker as docker

        this = docker.index.RegistryImage("this",
            build=[{}],
            name=f{this_azurerm_container_registry.login_server}/sample:latest)
        this_cluster = databricks.Cluster("this", docker_image={
            "url": this["name"],
            "basic_auth": {
                "username": this_azurerm_container_registry["adminUsername"],
                "password": this_azurerm_container_registry["adminPassword"],
            },
        })
        ```
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class ClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    ClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        boot_disk_size: NotRequired[pulumi.Input[int]]
        """
        Boot disk size in GB
        """
        google_service_account: NotRequired[pulumi.Input[str]]
        """
        Google Service Account email address that the cluster uses to authenticate with Google Identity. This field is used for authentication with the GCS and BigQuery data sources.
        """
        local_ssd_count: NotRequired[pulumi.Input[int]]
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        use_preemptible_executors: NotRequired[pulumi.Input[bool]]
        """
        if we should use preemptible executors ([GCP documentation](https://cloud.google.com/compute/docs/instances/preemptible)). *Warning: this field is deprecated in favor of `availability`, and will be removed soon.*
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the availability zone in which the cluster resides. This can be one of the following:
        * `HA` (default): High availability, spread nodes across availability zones for a Databricks deployment region.
        * `AUTO`: Databricks picks an availability zone to schedule the cluster on.
        * name of a GCP availability zone: pick one of the available zones from the [list of available availability zones](https://cloud.google.com/compute/docs/regions-zones#available).
        """
elif False:
    ClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param pulumi.Input[int] boot_disk_size: Boot disk size in GB
        :param pulumi.Input[str] google_service_account: Google Service Account email address that the cluster uses to authenticate with Google Identity. This field is used for authentication with the GCS and BigQuery data sources.
        :param pulumi.Input[int] local_ssd_count: Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        :param pulumi.Input[bool] use_preemptible_executors: if we should use preemptible executors ([GCP documentation](https://cloud.google.com/compute/docs/instances/preemptible)). *Warning: this field is deprecated in favor of `availability`, and will be removed soon.*
        :param pulumi.Input[str] zone_id: Identifier for the availability zone in which the cluster resides. This can be one of the following:
               * `HA` (default): High availability, spread nodes across availability zones for a Databricks deployment region.
               * `AUTO`: Databricks picks an availability zone to schedule the cluster on.
               * name of a GCP availability zone: pick one of the available zones from the [list of available availability zones](https://cloud.google.com/compute/docs/regions-zones#available).
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Boot disk size in GB
        """
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        """
        Google Service Account email address that the cluster uses to authenticate with Google Identity. This field is used for authentication with the GCS and BigQuery data sources.
        """
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        """
        if we should use preemptible executors ([GCP documentation](https://cloud.google.com/compute/docs/instances/preemptible)). *Warning: this field is deprecated in favor of `availability`, and will be removed soon.*
        """
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the availability zone in which the cluster resides. This can be one of the following:
        * `HA` (default): High availability, spread nodes across availability zones for a Databricks deployment region.
        * `AUTO`: Databricks picks an availability zone to schedule the cluster on.
        * name of a GCP availability zone: pick one of the available zones from the [list of available availability zones](https://cloud.google.com/compute/docs/regions-zones#available).
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class ClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired[pulumi.Input['ClusterInitScriptAbfssArgsDict']]
        dbfs: NotRequired[pulumi.Input['ClusterInitScriptDbfsArgsDict']]
        file: NotRequired[pulumi.Input['ClusterInitScriptFileArgsDict']]
        gcs: NotRequired[pulumi.Input['ClusterInitScriptGcsArgsDict']]
        s3: NotRequired[pulumi.Input['ClusterInitScriptS3ArgsDict']]
        volumes: NotRequired[pulumi.Input['ClusterInitScriptVolumesArgsDict']]
        workspace: NotRequired[pulumi.Input['ClusterInitScriptWorkspaceArgsDict']]
elif False:
    ClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['ClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['ClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['ClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['ClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['ClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['ClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['ClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional[pulumi.Input['ClusterInitScriptDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['ClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['ClusterInitScriptFileArgs']]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['ClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['ClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['ClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['ClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['ClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class ClusterInitScriptAbfssArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterInitScriptDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterInitScriptFileArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterInitScriptGcsArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterInitScriptS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        canned_acl: NotRequired[pulumi.Input[str]]
        """
        Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        """
        enable_encryption: NotRequired[pulumi.Input[bool]]
        """
        Enable server-side encryption, false by default.
        """
        encryption_type: NotRequired[pulumi.Input[str]]
        """
        The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
elif False:
    ClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        :param pulumi.Input[str] canned_acl: Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        :param pulumi.Input[bool] enable_encryption: Enable server-side encryption, false by default.
        :param pulumi.Input[str] encryption_type: The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        :param pulumi.Input[str] endpoint: S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        :param pulumi.Input[str] kms_key: KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        :param pulumi.Input[str] region: S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable server-side encryption, false by default.
        """
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ClusterInitScriptVolumesArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
elif False:
    ClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class ClusterLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['ClusterLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['ClusterLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['ClusterLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    ClusterLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['ClusterLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['ClusterLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['ClusterLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['ClusterLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['ClusterLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['ClusterLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['ClusterLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['ClusterLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['ClusterLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class ClusterLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    ClusterLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class ClusterLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    ClusterLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class ClusterLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    ClusterLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class ClusterPolicyLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['ClusterPolicyLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['ClusterPolicyLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['ClusterPolicyLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    ClusterPolicyLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPolicyLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['ClusterPolicyLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['ClusterPolicyLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['ClusterPolicyLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['ClusterPolicyLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['ClusterPolicyLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['ClusterPolicyLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['ClusterPolicyLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['ClusterPolicyLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['ClusterPolicyLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class ClusterPolicyLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    ClusterPolicyLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPolicyLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class ClusterPolicyLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    ClusterPolicyLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPolicyLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class ClusterPolicyLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    ClusterPolicyLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPolicyLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class ClusterWorkloadTypeArgsDict(TypedDict):
        clients: pulumi.Input['ClusterWorkloadTypeClientsArgsDict']
elif False:
    ClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['ClusterWorkloadTypeClientsArgs']):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['ClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['ClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


if not MYPY:
    class ClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[pulumi.Input[bool]]
        """
        boolean flag defining if it's possible to run Databricks Jobs on this cluster. Default: `true`.

        ```python
        import pulumi
        import pulumi_databricks as databricks

        with_nfs = databricks.Cluster("with_nfs", workload_type={
            "clients": {
                "jobs": False,
                "notebooks": True,
            },
        })
        ```
        """
        notebooks: NotRequired[pulumi.Input[bool]]
        """
        boolean flag defining if it's possible to run notebooks on this cluster. Default: `true`.
        """
elif False:
    ClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] jobs: boolean flag defining if it's possible to run Databricks Jobs on this cluster. Default: `true`.
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               with_nfs = databricks.Cluster("with_nfs", workload_type={
                   "clients": {
                       "jobs": False,
                       "notebooks": True,
                   },
               })
               ```
        :param pulumi.Input[bool] notebooks: boolean flag defining if it's possible to run notebooks on this cluster. Default: `true`.
        """
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        """
        boolean flag defining if it's possible to run Databricks Jobs on this cluster. Default: `true`.

        ```python
        import pulumi
        import pulumi_databricks as databricks

        with_nfs = databricks.Cluster("with_nfs", workload_type={
            "clients": {
                "jobs": False,
                "notebooks": True,
            },
        })
        ```
        """
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        """
        boolean flag defining if it's possible to run notebooks on this cluster. Default: `true`.
        """
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspaceArgsDict(TypedDict):
        compliance_standards: pulumi.Input[Sequence[pulumi.Input[str]]]
        is_enabled: pulumi.Input[bool]
elif False:
    ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspaceArgs:
    def __init__(__self__, *,
                 compliance_standards: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "compliance_standards", compliance_standards)
        pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="complianceStandards")
    def compliance_standards(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "compliance_standards")

    @compliance_standards.setter
    def compliance_standards(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "compliance_standards", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class CustomAppIntegrationTokenAccessPolicyArgsDict(TypedDict):
        access_token_ttl_in_minutes: NotRequired[pulumi.Input[int]]
        """
        access token time to live (TTL) in minutes.
        """
        refresh_token_ttl_in_minutes: NotRequired[pulumi.Input[int]]
        """
        refresh token TTL in minutes. The TTL of refresh token cannot be lower than TTL of access token.
        """
elif False:
    CustomAppIntegrationTokenAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomAppIntegrationTokenAccessPolicyArgs:
    def __init__(__self__, *,
                 access_token_ttl_in_minutes: Optional[pulumi.Input[int]] = None,
                 refresh_token_ttl_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] access_token_ttl_in_minutes: access token time to live (TTL) in minutes.
        :param pulumi.Input[int] refresh_token_ttl_in_minutes: refresh token TTL in minutes. The TTL of refresh token cannot be lower than TTL of access token.
        """
        if access_token_ttl_in_minutes is not None:
            pulumi.set(__self__, "access_token_ttl_in_minutes", access_token_ttl_in_minutes)
        if refresh_token_ttl_in_minutes is not None:
            pulumi.set(__self__, "refresh_token_ttl_in_minutes", refresh_token_ttl_in_minutes)

    @property
    @pulumi.getter(name="accessTokenTtlInMinutes")
    def access_token_ttl_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        access token time to live (TTL) in minutes.
        """
        return pulumi.get(self, "access_token_ttl_in_minutes")

    @access_token_ttl_in_minutes.setter
    def access_token_ttl_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "access_token_ttl_in_minutes", value)

    @property
    @pulumi.getter(name="refreshTokenTtlInMinutes")
    def refresh_token_ttl_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        refresh token TTL in minutes. The TTL of refresh token cannot be lower than TTL of access token.
        """
        return pulumi.get(self, "refresh_token_ttl_in_minutes")

    @refresh_token_ttl_in_minutes.setter
    def refresh_token_ttl_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_token_ttl_in_minutes", value)


if not MYPY:
    class DefaultNamespaceSettingNamespaceArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        The value for the setting.
        """
elif False:
    DefaultNamespaceSettingNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefaultNamespaceSettingNamespaceArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The value for the setting.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value for the setting.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspaceArgsDict(TypedDict):
        is_enabled: pulumi.Input[bool]
elif False:
    EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspaceArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class ExternalLocationEncryptionDetailsArgsDict(TypedDict):
        sse_encryption_details: NotRequired[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgsDict']]
elif False:
    ExternalLocationEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalLocationEncryptionDetailsArgs:
    def __init__(__self__, *,
                 sse_encryption_details: Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']] = None):
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']]:
        return pulumi.get(self, "sse_encryption_details")

    @sse_encryption_details.setter
    def sse_encryption_details(self, value: Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']]):
        pulumi.set(self, "sse_encryption_details", value)


if not MYPY:
    class ExternalLocationEncryptionDetailsSseEncryptionDetailsArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[str]]
        aws_kms_key_arn: NotRequired[pulumi.Input[str]]
elif False:
    ExternalLocationEncryptionDetailsSseEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 aws_kms_key_arn: Optional[pulumi.Input[str]] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aws_kms_key_arn")

    @aws_kms_key_arn.setter
    def aws_kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_kms_key_arn", value)


if not MYPY:
    class GrantsGrantArgsDict(TypedDict):
        principal: pulumi.Input[str]
        privileges: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    GrantsGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrantsGrantArgs:
    def __init__(__self__, *,
                 principal: pulumi.Input[str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "privileges", privileges)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "privileges", value)


if not MYPY:
    class InstancePoolAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        """
        (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        """
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        """
        (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
elif False:
    InstancePoolAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability: (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        :param pulumi.Input[int] spot_bid_price_percent: (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        :param pulumi.Input[str] zone_id: (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        """
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class InstancePoolAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        """
        Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        """
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
        """
        The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
elif False:
    InstancePoolAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability: Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        :param pulumi.Input[float] spot_bid_max_price: The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        """
        The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class InstancePoolDiskSpecArgsDict(TypedDict):
        disk_count: NotRequired[pulumi.Input[int]]
        """
        (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        """
        disk_size: NotRequired[pulumi.Input[int]]
        """
        (Integer) The size of each disk (in GiB) to attach.
        """
        disk_type: NotRequired[pulumi.Input['InstancePoolDiskSpecDiskTypeArgsDict']]
elif False:
    InstancePoolDiskSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolDiskSpecArgs:
    def __init__(__self__, *,
                 disk_count: Optional[pulumi.Input[int]] = None,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type: Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']] = None):
        """
        :param pulumi.Input[int] disk_count: (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        :param pulumi.Input[int] disk_size: (Integer) The size of each disk (in GiB) to attach.
        """
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        """
        return pulumi.get(self, "disk_count")

    @disk_count.setter
    def disk_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_count", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) The size of each disk (in GiB) to attach.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']]):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class InstancePoolDiskSpecDiskTypeArgsDict(TypedDict):
        azure_disk_volume_type: NotRequired[pulumi.Input[str]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
elif False:
    InstancePoolDiskSpecDiskTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolDiskSpecDiskTypeArgs:
    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[pulumi.Input[str]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None):
        if azure_disk_volume_type is not None:
            pulumi.set(__self__, "azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)

    @property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "azure_disk_volume_type")

    @azure_disk_volume_type.setter
    def azure_disk_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_disk_volume_type", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)


if not MYPY:
    class InstancePoolGcpAttributesArgsDict(TypedDict):
        gcp_availability: NotRequired[pulumi.Input[str]]
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        local_ssd_count: NotRequired[pulumi.Input[int]]
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        zone_id: NotRequired[pulumi.Input[str]]
        """
        Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-central1-a`. The provided availability zone must be in the same region as the Databricks workspace.
        """
elif False:
    InstancePoolGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolGcpAttributesArgs:
    def __init__(__self__, *,
                 gcp_availability: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gcp_availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param pulumi.Input[int] local_ssd_count: Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        :param pulumi.Input[str] zone_id: Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-central1-a`. The provided availability zone must be in the same region as the Databricks workspace.
        """
        if gcp_availability is not None:
            pulumi.set(__self__, "gcp_availability", gcp_availability)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="gcpAvailability")
    def gcp_availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "gcp_availability")

    @gcp_availability.setter
    def gcp_availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gcp_availability", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-central1-a`. The provided availability zone must be in the same region as the Databricks workspace.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class InstancePoolInstancePoolFleetAttributesArgsDict(TypedDict):
        launch_template_overrides: pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgsDict']]]
        fleet_on_demand_option: NotRequired[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgsDict']]
        fleet_spot_option: NotRequired[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgsDict']]
elif False:
    InstancePoolInstancePoolFleetAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesArgs:
    def __init__(__self__, *,
                 launch_template_overrides: pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]],
                 fleet_on_demand_option: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']] = None,
                 fleet_spot_option: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']] = None):
        pulumi.set(__self__, "launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            pulumi.set(__self__, "fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            pulumi.set(__self__, "fleet_spot_option", fleet_spot_option)

    @property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]]:
        return pulumi.get(self, "launch_template_overrides")

    @launch_template_overrides.setter
    def launch_template_overrides(self, value: pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]]):
        pulumi.set(self, "launch_template_overrides", value)

    @property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']]:
        return pulumi.get(self, "fleet_on_demand_option")

    @fleet_on_demand_option.setter
    def fleet_on_demand_option(self, value: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']]):
        pulumi.set(self, "fleet_on_demand_option", value)

    @property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']]:
        return pulumi.get(self, "fleet_spot_option")

    @fleet_spot_option.setter
    def fleet_spot_option(self, value: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']]):
        pulumi.set(self, "fleet_spot_option", value)


if not MYPY:
    class InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[str]
        instance_pools_to_use_count: NotRequired[pulumi.Input[int]]
elif False:
    InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[str],
                 instance_pools_to_use_count: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)


if not MYPY:
    class InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgsDict(TypedDict):
        allocation_strategy: pulumi.Input[str]
        instance_pools_to_use_count: NotRequired[pulumi.Input[int]]
elif False:
    InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[str],
                 instance_pools_to_use_count: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)


if not MYPY:
    class InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgsDict(TypedDict):
        availability_zone: pulumi.Input[str]
        instance_type: pulumi.Input[str]
elif False:
    InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[str],
                 instance_type: pulumi.Input[str]):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)


if not MYPY:
    class InstancePoolPreloadedDockerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL for the Docker image
        """
        basic_auth: NotRequired[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgsDict']]
        """
        `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch. However, other authenticated and authorized API users of this workspace can access the username and password.

        Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:

        ```python
        import pulumi
        import pulumi_databricks as databricks
        import pulumi_docker as docker

        this = docker.index.RegistryImage("this",
            build=[{}],
            name=f{this_azurerm_container_registry.login_server}/sample:latest)
        this_instance_pool = databricks.InstancePool("this", preloaded_docker_images=[{
            "url": this["name"],
            "basic_auth": {
                "username": this_azurerm_container_registry["adminUsername"],
                "password": this_azurerm_container_registry["adminPassword"],
            },
        }])
        ```
        """
elif False:
    InstancePoolPreloadedDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolPreloadedDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL for the Docker image
        :param pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs'] basic_auth: `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch. However, other authenticated and authorized API users of this workspace can access the username and password.
               
               Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               import pulumi_docker as docker
               
               this = docker.index.RegistryImage("this",
                   build=[{}],
                   name=f{this_azurerm_container_registry.login_server}/sample:latest)
               this_instance_pool = databricks.InstancePool("this", preloaded_docker_images=[{
                   "url": this["name"],
                   "basic_auth": {
                       "username": this_azurerm_container_registry["adminUsername"],
                       "password": this_azurerm_container_registry["adminPassword"],
                   },
               }])
               ```
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL for the Docker image
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']]:
        """
        `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch. However, other authenticated and authorized API users of this workspace can access the username and password.

        Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:

        ```python
        import pulumi
        import pulumi_databricks as databricks
        import pulumi_docker as docker

        this = docker.index.RegistryImage("this",
            build=[{}],
            name=f{this_azurerm_container_registry.login_server}/sample:latest)
        this_instance_pool = databricks.InstancePool("this", preloaded_docker_images=[{
            "url": this["name"],
            "basic_auth": {
                "username": this_azurerm_container_registry["adminUsername"],
                "password": this_azurerm_container_registry["adminPassword"],
            },
        }])
        ```
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class InstancePoolPreloadedDockerImageBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    InstancePoolPreloadedDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePoolPreloadedDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class JobContinuousArgsDict(TypedDict):
        pause_status: NotRequired[pulumi.Input[str]]
        """
        Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
elif False:
    JobContinuousArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobContinuousArgs:
    def __init__(__self__, *,
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pause_status: Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


if not MYPY:
    class JobDbtTaskArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        catalog: NotRequired[pulumi.Input[str]]
        """
        The name of the catalog to use inside Unity Catalog.
        """
        profiles_directory: NotRequired[pulumi.Input[str]]
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        project_directory: NotRequired[pulumi.Input[str]]
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        schema: NotRequired[pulumi.Input[str]]
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        warehouse_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
elif False:
    JobDbtTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobDbtTaskArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 catalog: Optional[pulumi.Input[str]] = None,
                 profiles_directory: Optional[pulumi.Input[str]] = None,
                 project_directory: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param pulumi.Input[str] catalog: The name of the catalog to use inside Unity Catalog.
        :param pulumi.Input[str] profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param pulumi.Input[str] project_directory: The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
               * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
               * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        :param pulumi.Input[str] schema: The name of the schema dbt should run in. Defaults to `default`.
        :param pulumi.Input[str] source: The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        :param pulumi.Input[str] warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class JobDeploymentArgsDict(TypedDict):
        kind: pulumi.Input[str]
        metadata_file_path: NotRequired[pulumi.Input[str]]
elif False:
    JobDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobDeploymentArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 metadata_file_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "kind", kind)
        if metadata_file_path is not None:
            pulumi.set(__self__, "metadata_file_path", metadata_file_path)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata_file_path")

    @metadata_file_path.setter
    def metadata_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_file_path", value)


if not MYPY:
    class JobEmailNotificationsArgsDict(TypedDict):
        no_alert_for_skipped_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        on_duration_warning_threshold_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        The following parameter is only available for the job level configuration.
        """
        on_failures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run fails.
        """
        on_starts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run starts.
        """
        on_streaming_backlog_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        on_successes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run completes successfully.
        """
elif False:
    JobEmailNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobEmailNotificationsArgs:
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_streaming_backlog_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               The following parameter is only available for the job level configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_failures: (List) list of emails to notify when the run fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_starts: (List) list of emails to notify when the run starts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        The following parameter is only available for the job level configuration.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class JobEnvironmentArgsDict(TypedDict):
        environment_key: pulumi.Input[str]
        """
        an unique identifier of the Environment.  It will be referenced from `environment_key` attribute of corresponding task.
        """
        spec: NotRequired[pulumi.Input['JobEnvironmentSpecArgsDict']]
        """
        block describing the Environment. Consists of following attributes:
        """
elif False:
    JobEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobEnvironmentArgs:
    def __init__(__self__, *,
                 environment_key: pulumi.Input[str],
                 spec: Optional[pulumi.Input['JobEnvironmentSpecArgs']] = None):
        """
        :param pulumi.Input[str] environment_key: an unique identifier of the Environment.  It will be referenced from `environment_key` attribute of corresponding task.
        :param pulumi.Input['JobEnvironmentSpecArgs'] spec: block describing the Environment. Consists of following attributes:
        """
        pulumi.set(__self__, "environment_key", environment_key)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> pulumi.Input[str]:
        """
        an unique identifier of the Environment.  It will be referenced from `environment_key` attribute of corresponding task.
        """
        return pulumi.get(self, "environment_key")

    @environment_key.setter
    def environment_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment_key", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['JobEnvironmentSpecArgs']]:
        """
        block describing the Environment. Consists of following attributes:
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['JobEnvironmentSpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class JobEnvironmentSpecArgsDict(TypedDict):
        client: pulumi.Input[str]
        """
        client version used by the environment.
        """
        dependencies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See [API docs](https://docs.databricks.com/api/workspace/jobs/create#environments-spec-dependencies) for more information.
        """
elif False:
    JobEnvironmentSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobEnvironmentSpecArgs:
    def __init__(__self__, *,
                 client: pulumi.Input[str],
                 dependencies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client: client version used by the environment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dependencies: List of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See [API docs](https://docs.databricks.com/api/workspace/jobs/create#environments-spec-dependencies) for more information.
        """
        pulumi.set(__self__, "client", client)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @property
    @pulumi.getter
    def client(self) -> pulumi.Input[str]:
        """
        client version used by the environment.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: pulumi.Input[str]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See [API docs](https://docs.databricks.com/api/workspace/jobs/create#environments-spec-dependencies) for more information.
        """
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dependencies", value)


if not MYPY:
    class JobGitSourceArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL of the Git repository to use.
        """
        branch: NotRequired[pulumi.Input[str]]
        """
        name of the Git branch to use. Conflicts with `tag` and `commit`.
        """
        commit: NotRequired[pulumi.Input[str]]
        """
        hash of Git commit to use. Conflicts with `branch` and `tag`.
        """
        git_snapshot: NotRequired[pulumi.Input['JobGitSourceGitSnapshotArgsDict']]
        job_source: NotRequired[pulumi.Input['JobGitSourceJobSourceArgsDict']]
        provider: NotRequired[pulumi.Input[str]]
        """
        case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        """
        tag: NotRequired[pulumi.Input[str]]
        """
        name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
elif False:
    JobGitSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobGitSourceArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 branch: Optional[pulumi.Input[str]] = None,
                 commit: Optional[pulumi.Input[str]] = None,
                 git_snapshot: Optional[pulumi.Input['JobGitSourceGitSnapshotArgs']] = None,
                 job_source: Optional[pulumi.Input['JobGitSourceJobSourceArgs']] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: URL of the Git repository to use.
        :param pulumi.Input[str] branch: name of the Git branch to use. Conflicts with `tag` and `commit`.
        :param pulumi.Input[str] commit: hash of Git commit to use. Conflicts with `branch` and `tag`.
        :param pulumi.Input[str] provider: case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        :param pulumi.Input[str] tag: name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        pulumi.set(__self__, "url", url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if git_snapshot is not None:
            pulumi.set(__self__, "git_snapshot", git_snapshot)
        if job_source is not None:
            pulumi.set(__self__, "job_source", job_source)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the Git repository to use.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        name of the Git branch to use. Conflicts with `tag` and `commit`.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def commit(self) -> Optional[pulumi.Input[str]]:
        """
        hash of Git commit to use. Conflicts with `branch` and `tag`.
        """
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter(name="gitSnapshot")
    def git_snapshot(self) -> Optional[pulumi.Input['JobGitSourceGitSnapshotArgs']]:
        return pulumi.get(self, "git_snapshot")

    @git_snapshot.setter
    def git_snapshot(self, value: Optional[pulumi.Input['JobGitSourceGitSnapshotArgs']]):
        pulumi.set(self, "git_snapshot", value)

    @property
    @pulumi.getter(name="jobSource")
    def job_source(self) -> Optional[pulumi.Input['JobGitSourceJobSourceArgs']]:
        return pulumi.get(self, "job_source")

    @job_source.setter
    def job_source(self, value: Optional[pulumi.Input['JobGitSourceJobSourceArgs']]):
        pulumi.set(self, "job_source", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class JobGitSourceGitSnapshotArgsDict(TypedDict):
        used_commit: NotRequired[pulumi.Input[str]]
elif False:
    JobGitSourceGitSnapshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobGitSourceGitSnapshotArgs:
    def __init__(__self__, *,
                 used_commit: Optional[pulumi.Input[str]] = None):
        if used_commit is not None:
            pulumi.set(__self__, "used_commit", used_commit)

    @property
    @pulumi.getter(name="usedCommit")
    def used_commit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "used_commit")

    @used_commit.setter
    def used_commit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "used_commit", value)


if not MYPY:
    class JobGitSourceJobSourceArgsDict(TypedDict):
        import_from_git_branch: pulumi.Input[str]
        job_config_path: pulumi.Input[str]
        dirty_state: NotRequired[pulumi.Input[str]]
elif False:
    JobGitSourceJobSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobGitSourceJobSourceArgs:
    def __init__(__self__, *,
                 import_from_git_branch: pulumi.Input[str],
                 job_config_path: pulumi.Input[str],
                 dirty_state: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "import_from_git_branch", import_from_git_branch)
        pulumi.set(__self__, "job_config_path", job_config_path)
        if dirty_state is not None:
            pulumi.set(__self__, "dirty_state", dirty_state)

    @property
    @pulumi.getter(name="importFromGitBranch")
    def import_from_git_branch(self) -> pulumi.Input[str]:
        return pulumi.get(self, "import_from_git_branch")

    @import_from_git_branch.setter
    def import_from_git_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "import_from_git_branch", value)

    @property
    @pulumi.getter(name="jobConfigPath")
    def job_config_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "job_config_path")

    @job_config_path.setter
    def job_config_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_config_path", value)

    @property
    @pulumi.getter(name="dirtyState")
    def dirty_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dirty_state")

    @dirty_state.setter
    def dirty_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dirty_state", value)


if not MYPY:
    class JobHealthArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgsDict']]]
        """
        list of rules that are represented as objects with the following attributes:
        """
elif False:
    JobHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobHealthArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]] rules: list of rules that are represented as objects with the following attributes:
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class JobHealthRuleArgsDict(TypedDict):
        metric: pulumi.Input[str]
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        op: pulumi.Input[str]
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        value: pulumi.Input[int]
        """
        integer value used to compare to the given metric.
        """
elif False:
    JobHealthRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobHealthRuleArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 op: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] metric: string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        :param pulumi.Input[str] op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param pulumi.Input[int] value: integer value used to compare to the given metric.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class JobJobClusterArgsDict(TypedDict):
        job_cluster_key: pulumi.Input[str]
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        new_cluster: pulumi.Input['JobJobClusterNewClusterArgsDict']
        """
        Block with almost the same set of parameters as for Cluster resource, except following (check the [REST API documentation for full list of supported parameters](https://docs.databricks.com/api/workspace/jobs/create#job_clusters-new_cluster)):
        """
elif False:
    JobJobClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterArgs:
    def __init__(__self__, *,
                 job_cluster_key: pulumi.Input[str],
                 new_cluster: pulumi.Input['JobJobClusterNewClusterArgs']):
        """
        :param pulumi.Input[str] job_cluster_key: Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        :param pulumi.Input['JobJobClusterNewClusterArgs'] new_cluster: Block with almost the same set of parameters as for Cluster resource, except following (check the [REST API documentation for full list of supported parameters](https://docs.databricks.com/api/workspace/jobs/create#job_clusters-new_cluster)):
        """
        pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        pulumi.set(__self__, "new_cluster", new_cluster)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> pulumi.Input[str]:
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> pulumi.Input['JobJobClusterNewClusterArgs']:
        """
        Block with almost the same set of parameters as for Cluster resource, except following (check the [REST API documentation for full list of supported parameters](https://docs.databricks.com/api/workspace/jobs/create#job_clusters-new_cluster)):
        """
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: pulumi.Input['JobJobClusterNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)


if not MYPY:
    class JobJobClusterNewClusterArgsDict(TypedDict):
        spark_version: pulumi.Input[str]
        apply_policy_default_values: NotRequired[pulumi.Input[bool]]
        autoscale: NotRequired[pulumi.Input['JobJobClusterNewClusterAutoscaleArgsDict']]
        aws_attributes: NotRequired[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgsDict']]
        azure_attributes: NotRequired[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgsDict']]
        cluster_id: NotRequired[pulumi.Input[str]]
        cluster_log_conf: NotRequired[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgsDict']]
        cluster_mount_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgsDict']]]]
        cluster_name: NotRequired[pulumi.Input[str]]
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        data_security_mode: NotRequired[pulumi.Input[str]]
        docker_image: NotRequired[pulumi.Input['JobJobClusterNewClusterDockerImageArgsDict']]
        driver_instance_pool_id: NotRequired[pulumi.Input[str]]
        driver_node_type_id: NotRequired[pulumi.Input[str]]
        enable_elastic_disk: NotRequired[pulumi.Input[bool]]
        enable_local_disk_encryption: NotRequired[pulumi.Input[bool]]
        gcp_attributes: NotRequired[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgsDict']]
        idempotency_token: NotRequired[pulumi.Input[str]]
        init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgsDict']]]]
        instance_pool_id: NotRequired[pulumi.Input[str]]
        libraries: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterLibraryArgsDict']]]]
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        node_type_id: NotRequired[pulumi.Input[str]]
        num_workers: NotRequired[pulumi.Input[int]]
        policy_id: NotRequired[pulumi.Input[str]]
        runtime_engine: NotRequired[pulumi.Input[str]]
        single_user_name: NotRequired[pulumi.Input[str]]
        spark_conf: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        spark_env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        ssh_public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        workload_type: NotRequired[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgsDict']]
        """
        isn't supported
        """
elif False:
    JobJobClusterNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']] = None,
                 aws_attributes: Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterLibraryArgs']]]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterLibraryArgs']]] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs'] workload_type: isn't supported
        """
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterLibraryArgs']]]]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']]:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class JobJobClusterNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[pulumi.Input[int]]
        min_workers: NotRequired[pulumi.Input[int]]
elif False:
    JobJobClusterNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class JobJobClusterNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        ebs_volume_count: NotRequired[pulumi.Input[int]]
        ebs_volume_iops: NotRequired[pulumi.Input[int]]
        ebs_volume_size: NotRequired[pulumi.Input[int]]
        ebs_volume_throughput: NotRequired[pulumi.Input[int]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_throughput: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobJobClusterNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        log_analytics_info: NotRequired[pulumi.Input['JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgsDict']]
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
elif False:
    JobJobClusterNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 log_analytics_info: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgs']] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgs']]:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgs']]):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[pulumi.Input[str]]
        log_analytics_workspace_id: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_id: Optional[pulumi.Input[str]] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class JobJobClusterNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgsDict']]
        s3: NotRequired[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3ArgsDict']]
elif False:
    JobJobClusterNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class JobJobClusterNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobJobClusterNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: pulumi.Input[str]
        network_filesystem_info: pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict']
        remote_mount_dir_path: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: pulumi.Input[str]
        mount_options: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class JobJobClusterNewClusterDockerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL of the job on the given workspace
        """
        basic_auth: NotRequired[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgsDict']]
elif False:
    JobJobClusterNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class JobJobClusterNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class JobJobClusterNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        boot_disk_size: NotRequired[pulumi.Input[int]]
        google_service_account: NotRequired[pulumi.Input[str]]
        local_ssd_count: NotRequired[pulumi.Input[int]]
        use_preemptible_executors: NotRequired[pulumi.Input[bool]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgsDict']]
        dbfs: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgsDict']]
        file: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgsDict']]
        """
        block consisting of single string fields:
        """
        gcs: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgsDict']]
        s3: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptS3ArgsDict']]
        volumes: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgsDict']]
        workspace: NotRequired[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgsDict']]
elif False:
    JobJobClusterNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs'] file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptFileArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobJobClusterNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobJobClusterNewClusterLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobJobClusterNewClusterLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobJobClusterNewClusterLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobJobClusterNewClusterLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobJobClusterNewClusterLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobJobClusterNewClusterLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobJobClusterNewClusterLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobJobClusterNewClusterLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobJobClusterNewClusterLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobJobClusterNewClusterLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobJobClusterNewClusterLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobJobClusterNewClusterLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobJobClusterNewClusterLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobJobClusterNewClusterLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobJobClusterNewClusterLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobJobClusterNewClusterLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobJobClusterNewClusterLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobJobClusterNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgsDict']
elif False:
    JobJobClusterNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


if not MYPY:
    class JobJobClusterNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[pulumi.Input[bool]]
        notebooks: NotRequired[pulumi.Input[bool]]
elif False:
    JobJobClusterNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobJobClusterNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class JobLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobNewClusterArgsDict(TypedDict):
        spark_version: pulumi.Input[str]
        apply_policy_default_values: NotRequired[pulumi.Input[bool]]
        autoscale: NotRequired[pulumi.Input['JobNewClusterAutoscaleArgsDict']]
        aws_attributes: NotRequired[pulumi.Input['JobNewClusterAwsAttributesArgsDict']]
        azure_attributes: NotRequired[pulumi.Input['JobNewClusterAzureAttributesArgsDict']]
        cluster_id: NotRequired[pulumi.Input[str]]
        cluster_log_conf: NotRequired[pulumi.Input['JobNewClusterClusterLogConfArgsDict']]
        cluster_mount_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgsDict']]]]
        cluster_name: NotRequired[pulumi.Input[str]]
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        data_security_mode: NotRequired[pulumi.Input[str]]
        docker_image: NotRequired[pulumi.Input['JobNewClusterDockerImageArgsDict']]
        driver_instance_pool_id: NotRequired[pulumi.Input[str]]
        driver_node_type_id: NotRequired[pulumi.Input[str]]
        enable_elastic_disk: NotRequired[pulumi.Input[bool]]
        enable_local_disk_encryption: NotRequired[pulumi.Input[bool]]
        gcp_attributes: NotRequired[pulumi.Input['JobNewClusterGcpAttributesArgsDict']]
        idempotency_token: NotRequired[pulumi.Input[str]]
        init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgsDict']]]]
        instance_pool_id: NotRequired[pulumi.Input[str]]
        libraries: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobNewClusterLibraryArgsDict']]]]
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        node_type_id: NotRequired[pulumi.Input[str]]
        num_workers: NotRequired[pulumi.Input[int]]
        policy_id: NotRequired[pulumi.Input[str]]
        runtime_engine: NotRequired[pulumi.Input[str]]
        single_user_name: NotRequired[pulumi.Input[str]]
        spark_conf: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        spark_env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        ssh_public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        workload_type: NotRequired[pulumi.Input['JobNewClusterWorkloadTypeArgsDict']]
        """
        isn't supported
        """
elif False:
    JobNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobNewClusterAutoscaleArgs']] = None,
                 aws_attributes: Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterLibraryArgs']]]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobNewClusterLibraryArgs']]] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param pulumi.Input['JobNewClusterWorkloadTypeArgs'] workload_type: isn't supported
        """
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterLibraryArgs']]]]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']]:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class JobNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[pulumi.Input[int]]
        min_workers: NotRequired[pulumi.Input[int]]
elif False:
    JobNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class JobNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        ebs_volume_count: NotRequired[pulumi.Input[int]]
        ebs_volume_iops: NotRequired[pulumi.Input[int]]
        ebs_volume_size: NotRequired[pulumi.Input[int]]
        ebs_volume_throughput: NotRequired[pulumi.Input[int]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_throughput: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        log_analytics_info: NotRequired[pulumi.Input['JobNewClusterAzureAttributesLogAnalyticsInfoArgsDict']]
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
elif False:
    JobNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 log_analytics_info: Optional[pulumi.Input['JobNewClusterAzureAttributesLogAnalyticsInfoArgs']] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional[pulumi.Input['JobNewClusterAzureAttributesLogAnalyticsInfoArgs']]:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional[pulumi.Input['JobNewClusterAzureAttributesLogAnalyticsInfoArgs']]):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class JobNewClusterAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[pulumi.Input[str]]
        log_analytics_workspace_id: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_id: Optional[pulumi.Input[str]] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class JobNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired[pulumi.Input['JobNewClusterClusterLogConfDbfsArgsDict']]
        s3: NotRequired[pulumi.Input['JobNewClusterClusterLogConfS3ArgsDict']]
elif False:
    JobNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class JobNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: pulumi.Input[str]
        network_filesystem_info: pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict']
        remote_mount_dir_path: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class JobNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: pulumi.Input[str]
        mount_options: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class JobNewClusterDockerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL of the job on the given workspace
        """
        basic_auth: NotRequired[pulumi.Input['JobNewClusterDockerImageBasicAuthArgsDict']]
elif False:
    JobNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class JobNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    JobNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class JobNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        boot_disk_size: NotRequired[pulumi.Input[int]]
        google_service_account: NotRequired[pulumi.Input[str]]
        local_ssd_count: NotRequired[pulumi.Input[int]]
        use_preemptible_executors: NotRequired[pulumi.Input[bool]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired[pulumi.Input['JobNewClusterInitScriptAbfssArgsDict']]
        dbfs: NotRequired[pulumi.Input['JobNewClusterInitScriptDbfsArgsDict']]
        file: NotRequired[pulumi.Input['JobNewClusterInitScriptFileArgsDict']]
        """
        block consisting of single string fields:
        """
        gcs: NotRequired[pulumi.Input['JobNewClusterInitScriptGcsArgsDict']]
        s3: NotRequired[pulumi.Input['JobNewClusterInitScriptS3ArgsDict']]
        volumes: NotRequired[pulumi.Input['JobNewClusterInitScriptVolumesArgsDict']]
        workspace: NotRequired[pulumi.Input['JobNewClusterInitScriptWorkspaceArgsDict']]
elif False:
    JobNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobNewClusterInitScriptFileArgs'] file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class JobNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterInitScriptFileArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobNewClusterLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobNewClusterLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobNewClusterLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobNewClusterLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobNewClusterLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobNewClusterLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobNewClusterLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobNewClusterLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobNewClusterLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobNewClusterLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobNewClusterLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobNewClusterLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobNewClusterLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobNewClusterLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobNewClusterLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobNewClusterLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobNewClusterLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: pulumi.Input['JobNewClusterWorkloadTypeClientsArgsDict']
elif False:
    JobNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


if not MYPY:
    class JobNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[pulumi.Input[bool]]
        notebooks: NotRequired[pulumi.Input[bool]]
elif False:
    JobNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class JobNotebookTaskArgsDict(TypedDict):
        notebook_path: pulumi.Input[str]
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        base_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        warehouse_id: NotRequired[pulumi.Input[str]]
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
elif False:
    JobNotebookTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: pulumi.Input[str],
                 base_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param pulumi.Input[str] source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        :param pulumi.Input[str] warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> pulumi.Input[str]:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class JobNotificationSettingsArgsDict(TypedDict):
        no_alert_for_canceled_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        no_alert_for_skipped_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for skipped runs.
        """
elif False:
    JobNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobNotificationSettingsArgs:
    def __init__(__self__, *,
                 no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
               
               The following parameter is only available on task level.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


if not MYPY:
    class JobParameterArgsDict(TypedDict):
        default: pulumi.Input[str]
        """
        Default value of the parameter.

        *You can use this block only together with `task` blocks, not with the legacy tasks specification!*
        """
        name: pulumi.Input[str]
        """
        The name of the defined parameter. May only contain alphanumeric characters, `_`, `-`, and `.`.
        """
elif False:
    JobParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobParameterArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] default: Default value of the parameter.
               
               *You can use this block only together with `task` blocks, not with the legacy tasks specification!*
        :param pulumi.Input[str] name: The name of the defined parameter. May only contain alphanumeric characters, `_`, `-`, and `.`.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> pulumi.Input[str]:
        """
        Default value of the parameter.

        *You can use this block only together with `task` blocks, not with the legacy tasks specification!*
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[str]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the defined parameter. May only contain alphanumeric characters, `_`, `-`, and `.`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class JobPipelineTaskArgsDict(TypedDict):
        pipeline_id: pulumi.Input[str]
        """
        The pipeline's unique ID.
        """
        full_refresh: NotRequired[pulumi.Input[bool]]
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
elif False:
    JobPipelineTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: pulumi.Input[str],
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline's unique ID.
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> pulumi.Input[str]:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class JobPythonWheelTaskArgsDict(TypedDict):
        entry_point: NotRequired[pulumi.Input[str]]
        """
        Python function as entry point for the task
        """
        named_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Named parameters for the task
        """
        package_name: NotRequired[pulumi.Input[str]]
        """
        Name of Python package
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameters for the task
        """
elif False:
    JobPythonWheelTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 named_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 package_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entry_point: Python function as entry point for the task
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] named_parameters: Named parameters for the task
        :param pulumi.Input[str] package_name: Name of Python package
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobQueueArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        If true, enable queueing for the job.
        """
elif False:
    JobQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueueArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: If true, enable queueing for the job.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        If true, enable queueing for the job.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class JobRunAsArgsDict(TypedDict):
        service_principal_name: NotRequired[pulumi.Input[str]]
        """
        The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.

        Example:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        this = databricks.Job("this", run_as={
            "service_principal_name": "8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
        })
        ```
        """
        user_name: NotRequired[pulumi.Input[str]]
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
elif False:
    JobRunAsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunAsArgs:
    def __init__(__self__, *,
                 service_principal_name: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_principal_name: The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               this = databricks.Job("this", run_as={
                   "service_principal_name": "8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
               })
               ```
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.

        Example:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        this = databricks.Job("this", run_as={
            "service_principal_name": "8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
        })
        ```
        """
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class JobRunJobTaskArgsDict(TypedDict):
        job_id: pulumi.Input[int]
        """
        (String) ID of the job
        """
        job_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) Job parameters for the task
        """
elif False:
    JobRunJobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: pulumi.Input[int],
                 job_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] job_id: (String) ID of the job
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] job_parameters: (Map) Job parameters for the task
        """
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[int]:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "job_parameters", value)


if not MYPY:
    class JobScheduleArgsDict(TypedDict):
        quartz_cron_expression: pulumi.Input[str]
        """
        A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        """
        timezone_id: pulumi.Input[str]
        """
        A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        """
        pause_status: NotRequired[pulumi.Input[str]]
        """
        Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
elif False:
    JobScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobScheduleArgs:
    def __init__(__self__, *,
                 quartz_cron_expression: pulumi.Input[str],
                 timezone_id: pulumi.Input[str],
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] quartz_cron_expression: A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        :param pulumi.Input[str] timezone_id: A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        :param pulumi.Input[str] pause_status: Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> pulumi.Input[str]:
        """
        A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @quartz_cron_expression.setter
    def quartz_cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "quartz_cron_expression", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> pulumi.Input[str]:
        """
        A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        """
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone_id", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


if not MYPY:
    class JobSparkJarTaskArgsDict(TypedDict):
        jar_uri: NotRequired[pulumi.Input[str]]
        main_class_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Parameters passed to the main method.
        """
elif False:
    JobSparkJarTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[pulumi.Input[str]] = None,
                 main_class_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Parameters passed to the main method.
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobSparkPythonTaskArgsDict(TypedDict):
        python_file: pulumi.Input[str]
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Command line parameters passed to the Python file.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
elif False:
    JobSparkPythonTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] python_file: The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command line parameters passed to the Python file.
        :param pulumi.Input[str] source: Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> pulumi.Input[str]:
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class JobSparkSubmitTaskArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Command-line parameters passed to spark submit.
        """
elif False:
    JobSparkSubmitTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command-line parameters passed to spark submit.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskArgsDict(TypedDict):
        task_key: pulumi.Input[str]
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        condition_task: NotRequired[pulumi.Input['JobTaskConditionTaskArgsDict']]
        dbt_task: NotRequired[pulumi.Input['JobTaskDbtTaskArgsDict']]
        depends_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgsDict']]]]
        """
        block specifying dependency(-ies) for a given task.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description for this task.
        """
        disable_auto_optimization: NotRequired[pulumi.Input[bool]]
        """
        A flag to disable auto optimization in serverless tasks.
        """
        email_notifications: NotRequired[pulumi.Input['JobTaskEmailNotificationsArgsDict']]
        """
        An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        """
        environment_key: NotRequired[pulumi.Input[str]]
        """
        identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        """
        existing_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        """
        for_each_task: NotRequired[pulumi.Input['JobTaskForEachTaskArgsDict']]
        health: NotRequired[pulumi.Input['JobTaskHealthArgsDict']]
        """
        block described below that specifies health conditions for a given task.
        """
        job_cluster_key: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Job cluster specified in the `job_cluster` block.
        """
        libraries: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgsDict']]]]
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        """
        max_retries: NotRequired[pulumi.Input[int]]
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        min_retry_interval_millis: NotRequired[pulumi.Input[int]]
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        new_cluster: NotRequired[pulumi.Input['JobTaskNewClusterArgsDict']]
        """
        Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        """
        notebook_task: NotRequired[pulumi.Input['JobTaskNotebookTaskArgsDict']]
        notification_settings: NotRequired[pulumi.Input['JobTaskNotificationSettingsArgsDict']]
        """
        An optional block controlling the notification settings on the job level documented below.
        """
        pipeline_task: NotRequired[pulumi.Input['JobTaskPipelineTaskArgsDict']]
        python_wheel_task: NotRequired[pulumi.Input['JobTaskPythonWheelTaskArgsDict']]
        retry_on_timeout: NotRequired[pulumi.Input[bool]]
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        run_if: NotRequired[pulumi.Input[str]]
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        """
        run_job_task: NotRequired[pulumi.Input['JobTaskRunJobTaskArgsDict']]
        spark_jar_task: NotRequired[pulumi.Input['JobTaskSparkJarTaskArgsDict']]
        spark_python_task: NotRequired[pulumi.Input['JobTaskSparkPythonTaskArgsDict']]
        spark_submit_task: NotRequired[pulumi.Input['JobTaskSparkSubmitTaskArgsDict']]
        sql_task: NotRequired[pulumi.Input['JobTaskSqlTaskArgsDict']]
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        webhook_notifications: NotRequired[pulumi.Input['JobTaskWebhookNotificationsArgsDict']]
        """
        (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.

        > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
elif False:
    JobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskArgs:
    def __init__(__self__, *,
                 task_key: pulumi.Input[str],
                 condition_task: Optional[pulumi.Input['JobTaskConditionTaskArgs']] = None,
                 dbt_task: Optional[pulumi.Input['JobTaskDbtTaskArgs']] = None,
                 depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_auto_optimization: Optional[pulumi.Input[bool]] = None,
                 email_notifications: Optional[pulumi.Input['JobTaskEmailNotificationsArgs']] = None,
                 environment_key: Optional[pulumi.Input[str]] = None,
                 existing_cluster_id: Optional[pulumi.Input[str]] = None,
                 for_each_task: Optional[pulumi.Input['JobTaskForEachTaskArgs']] = None,
                 health: Optional[pulumi.Input['JobTaskHealthArgs']] = None,
                 job_cluster_key: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 min_retry_interval_millis: Optional[pulumi.Input[int]] = None,
                 new_cluster: Optional[pulumi.Input['JobTaskNewClusterArgs']] = None,
                 notebook_task: Optional[pulumi.Input['JobTaskNotebookTaskArgs']] = None,
                 notification_settings: Optional[pulumi.Input['JobTaskNotificationSettingsArgs']] = None,
                 pipeline_task: Optional[pulumi.Input['JobTaskPipelineTaskArgs']] = None,
                 python_wheel_task: Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']] = None,
                 retry_on_timeout: Optional[pulumi.Input[bool]] = None,
                 run_if: Optional[pulumi.Input[str]] = None,
                 run_job_task: Optional[pulumi.Input['JobTaskRunJobTaskArgs']] = None,
                 spark_jar_task: Optional[pulumi.Input['JobTaskSparkJarTaskArgs']] = None,
                 spark_python_task: Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']] = None,
                 spark_submit_task: Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']] = None,
                 sql_task: Optional[pulumi.Input['JobTaskSqlTaskArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 webhook_notifications: Optional[pulumi.Input['JobTaskWebhookNotificationsArgs']] = None):
        """
        :param pulumi.Input[str] task_key: string specifying an unique key for a given task.
               * `*_task` - (Required) one of the specific task blocks described below:
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]] depends_ons: block specifying dependency(-ies) for a given task.
        :param pulumi.Input[str] description: description for this task.
        :param pulumi.Input[bool] disable_auto_optimization: A flag to disable auto optimization in serverless tasks.
        :param pulumi.Input['JobTaskEmailNotificationsArgs'] email_notifications: An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        :param pulumi.Input[str] environment_key: identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        :param pulumi.Input[str] existing_cluster_id: Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        :param pulumi.Input['JobTaskHealthArgs'] health: block described below that specifies health conditions for a given task.
        :param pulumi.Input[str] job_cluster_key: Identifier of the Job cluster specified in the `job_cluster` block.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]] libraries: (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        :param pulumi.Input[int] max_retries: (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        :param pulumi.Input[int] min_retry_interval_millis: (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        :param pulumi.Input['JobTaskNewClusterArgs'] new_cluster: Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        :param pulumi.Input['JobTaskNotificationSettingsArgs'] notification_settings: An optional block controlling the notification settings on the job level documented below.
        :param pulumi.Input[bool] retry_on_timeout: (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        :param pulumi.Input[str] run_if: An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        :param pulumi.Input[int] timeout_seconds: (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        :param pulumi.Input['JobTaskWebhookNotificationsArgs'] webhook_notifications: (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
               
               > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        pulumi.set(__self__, "task_key", task_key)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_auto_optimization is not None:
            pulumi.set(__self__, "disable_auto_optimization", disable_auto_optimization)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if for_each_task is not None:
            pulumi.set(__self__, "for_each_task", for_each_task)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> pulumi.Input[str]:
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional[pulumi.Input['JobTaskConditionTaskArgs']]:
        return pulumi.get(self, "condition_task")

    @condition_task.setter
    def condition_task(self, value: Optional[pulumi.Input['JobTaskConditionTaskArgs']]):
        pulumi.set(self, "condition_task", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional[pulumi.Input['JobTaskDbtTaskArgs']]:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional[pulumi.Input['JobTaskDbtTaskArgs']]):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]]:
        """
        block specifying dependency(-ies) for a given task.
        """
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description for this task.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoOptimization")
    def disable_auto_optimization(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to disable auto optimization in serverless tasks.
        """
        return pulumi.get(self, "disable_auto_optimization")

    @disable_auto_optimization.setter
    def disable_auto_optimization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_auto_optimization", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional[pulumi.Input['JobTaskEmailNotificationsArgs']]:
        """
        An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        """
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional[pulumi.Input['JobTaskEmailNotificationsArgs']]):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[pulumi.Input[str]]:
        """
        identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        """
        return pulumi.get(self, "environment_key")

    @environment_key.setter
    def environment_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_key", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        """
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter(name="forEachTask")
    def for_each_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskArgs']]:
        return pulumi.get(self, "for_each_task")

    @for_each_task.setter
    def for_each_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskArgs']]):
        pulumi.set(self, "for_each_task", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input['JobTaskHealthArgs']]:
        """
        block described below that specifies health conditions for a given task.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input['JobTaskHealthArgs']]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Job cluster specified in the `job_cluster` block.
        """
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]]:
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional[pulumi.Input['JobTaskNewClusterArgs']]:
        """
        Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        """
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional[pulumi.Input['JobTaskNewClusterArgs']]):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional[pulumi.Input['JobTaskNotebookTaskArgs']]:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional[pulumi.Input['JobTaskNotebookTaskArgs']]):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['JobTaskNotificationSettingsArgs']]:
        """
        An optional block controlling the notification settings on the job level documented below.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['JobTaskNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional[pulumi.Input['JobTaskPipelineTaskArgs']]:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional[pulumi.Input['JobTaskPipelineTaskArgs']]):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']]:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']]):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[pulumi.Input[str]]:
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        """
        return pulumi.get(self, "run_if")

    @run_if.setter
    def run_if(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_if", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional[pulumi.Input['JobTaskRunJobTaskArgs']]:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional[pulumi.Input['JobTaskRunJobTaskArgs']]):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional[pulumi.Input['JobTaskSparkJarTaskArgs']]:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional[pulumi.Input['JobTaskSparkJarTaskArgs']]):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']]:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']]):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']]:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']]):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional[pulumi.Input['JobTaskSqlTaskArgs']]:
        return pulumi.get(self, "sql_task")

    @sql_task.setter
    def sql_task(self, value: Optional[pulumi.Input['JobTaskSqlTaskArgs']]):
        pulumi.set(self, "sql_task", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional[pulumi.Input['JobTaskWebhookNotificationsArgs']]:
        """
        (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.

        > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        return pulumi.get(self, "webhook_notifications")

    @webhook_notifications.setter
    def webhook_notifications(self, value: Optional[pulumi.Input['JobTaskWebhookNotificationsArgs']]):
        pulumi.set(self, "webhook_notifications", value)


if not MYPY:
    class JobTaskConditionTaskArgsDict(TypedDict):
        left: pulumi.Input[str]
        """
        The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        """
        op: pulumi.Input[str]
        """
        The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).

        This task does not require a cluster to execute and does not support retries or notifications.
        """
        right: pulumi.Input[str]
        """
        The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
elif False:
    JobTaskConditionTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskConditionTaskArgs:
    def __init__(__self__, *,
                 left: pulumi.Input[str],
                 op: pulumi.Input[str],
                 right: pulumi.Input[str]):
        """
        :param pulumi.Input[str] left: The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        :param pulumi.Input[str] op: The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
               
               This task does not require a cluster to execute and does not support retries or notifications.
        :param pulumi.Input[str] right: The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @property
    @pulumi.getter
    def left(self) -> pulumi.Input[str]:
        """
        The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        """
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: pulumi.Input[str]):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).

        This task does not require a cluster to execute and does not support retries or notifications.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def right(self) -> pulumi.Input[str]:
        """
        The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        return pulumi.get(self, "right")

    @right.setter
    def right(self, value: pulumi.Input[str]):
        pulumi.set(self, "right", value)


if not MYPY:
    class JobTaskDbtTaskArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        catalog: NotRequired[pulumi.Input[str]]
        """
        The name of the catalog to use inside Unity Catalog.
        """
        profiles_directory: NotRequired[pulumi.Input[str]]
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        project_directory: NotRequired[pulumi.Input[str]]
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        schema: NotRequired[pulumi.Input[str]]
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        warehouse_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
elif False:
    JobTaskDbtTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskDbtTaskArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 catalog: Optional[pulumi.Input[str]] = None,
                 profiles_directory: Optional[pulumi.Input[str]] = None,
                 project_directory: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param pulumi.Input[str] catalog: The name of the catalog to use inside Unity Catalog.
        :param pulumi.Input[str] profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param pulumi.Input[str] project_directory: The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
               * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
               * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        :param pulumi.Input[str] schema: The name of the schema dbt should run in. Defaults to `default`.
        :param pulumi.Input[str] source: The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        :param pulumi.Input[str] warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class JobTaskDependsOnArgsDict(TypedDict):
        task_key: pulumi.Input[str]
        """
        The name of the task this task depends on.
        """
        outcome: NotRequired[pulumi.Input[str]]
        """
        Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.

        > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
elif False:
    JobTaskDependsOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskDependsOnArgs:
    def __init__(__self__, *,
                 task_key: pulumi.Input[str],
                 outcome: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] task_key: The name of the task this task depends on.
        :param pulumi.Input[str] outcome: Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.
               
               > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> pulumi.Input[str]:
        """
        The name of the task this task depends on.
        """
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter
    def outcome(self) -> Optional[pulumi.Input[str]]:
        """
        Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.

        > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        return pulumi.get(self, "outcome")

    @outcome.setter
    def outcome(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outcome", value)


if not MYPY:
    class JobTaskEmailNotificationsArgsDict(TypedDict):
        no_alert_for_skipped_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        on_duration_warning_threshold_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        The following parameter is only available for the job level configuration.
        """
        on_failures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run fails.
        """
        on_starts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run starts.
        """
        on_streaming_backlog_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        on_successes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run completes successfully.
        """
elif False:
    JobTaskEmailNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskEmailNotificationsArgs:
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_streaming_backlog_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               The following parameter is only available for the job level configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_failures: (List) list of emails to notify when the run fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_starts: (List) list of emails to notify when the run starts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        The following parameter is only available for the job level configuration.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class JobTaskForEachTaskArgsDict(TypedDict):
        inputs: pulumi.Input[str]
        """
        (String) Array for task to iterate on. This can be a JSON string or a reference to an array parameter.
        """
        task: pulumi.Input['JobTaskForEachTaskTaskArgsDict']
        """
        Task to run against the `inputs` list.
        """
        concurrency: NotRequired[pulumi.Input[int]]
        """
        Controls the number of active iteration task runs. Default is 20, maximum allowed is 100.
        """
elif False:
    JobTaskForEachTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskArgs:
    def __init__(__self__, *,
                 inputs: pulumi.Input[str],
                 task: pulumi.Input['JobTaskForEachTaskTaskArgs'],
                 concurrency: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] inputs: (String) Array for task to iterate on. This can be a JSON string or a reference to an array parameter.
        :param pulumi.Input['JobTaskForEachTaskTaskArgs'] task: Task to run against the `inputs` list.
        :param pulumi.Input[int] concurrency: Controls the number of active iteration task runs. Default is 20, maximum allowed is 100.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "task", task)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)

    @property
    @pulumi.getter
    def inputs(self) -> pulumi.Input[str]:
        """
        (String) Array for task to iterate on. This can be a JSON string or a reference to an array parameter.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: pulumi.Input[str]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter
    def task(self) -> pulumi.Input['JobTaskForEachTaskTaskArgs']:
        """
        Task to run against the `inputs` list.
        """
        return pulumi.get(self, "task")

    @task.setter
    def task(self, value: pulumi.Input['JobTaskForEachTaskTaskArgs']):
        pulumi.set(self, "task", value)

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Controls the number of active iteration task runs. Default is 20, maximum allowed is 100.
        """
        return pulumi.get(self, "concurrency")

    @concurrency.setter
    def concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "concurrency", value)


if not MYPY:
    class JobTaskForEachTaskTaskArgsDict(TypedDict):
        task_key: pulumi.Input[str]
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        condition_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskConditionTaskArgsDict']]
        dbt_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskDbtTaskArgsDict']]
        depends_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskDependsOnArgsDict']]]]
        """
        block specifying dependency(-ies) for a given task.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description for this task.
        """
        disable_auto_optimization: NotRequired[pulumi.Input[bool]]
        """
        A flag to disable auto optimization in serverless tasks.
        """
        email_notifications: NotRequired[pulumi.Input['JobTaskForEachTaskTaskEmailNotificationsArgsDict']]
        """
        An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        """
        environment_key: NotRequired[pulumi.Input[str]]
        """
        identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        """
        existing_cluster_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        """
        health: NotRequired[pulumi.Input['JobTaskForEachTaskTaskHealthArgsDict']]
        """
        block described below that specifies health conditions for a given task.
        """
        job_cluster_key: NotRequired[pulumi.Input[str]]
        """
        Identifier of the Job cluster specified in the `job_cluster` block.
        """
        libraries: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskLibraryArgsDict']]]]
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        """
        max_retries: NotRequired[pulumi.Input[int]]
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        min_retry_interval_millis: NotRequired[pulumi.Input[int]]
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        new_cluster: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterArgsDict']]
        """
        Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        """
        notebook_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNotebookTaskArgsDict']]
        notification_settings: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNotificationSettingsArgsDict']]
        """
        An optional block controlling the notification settings on the job level documented below.
        """
        pipeline_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskPipelineTaskArgsDict']]
        python_wheel_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskPythonWheelTaskArgsDict']]
        retry_on_timeout: NotRequired[pulumi.Input[bool]]
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        run_if: NotRequired[pulumi.Input[str]]
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        """
        run_job_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskArgsDict']]
        spark_jar_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSparkJarTaskArgsDict']]
        spark_python_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSparkPythonTaskArgsDict']]
        spark_submit_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSparkSubmitTaskArgsDict']]
        sql_task: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSqlTaskArgsDict']]
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        webhook_notifications: NotRequired[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsArgsDict']]
        """
        (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.

        > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
elif False:
    JobTaskForEachTaskTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskArgs:
    def __init__(__self__, *,
                 task_key: pulumi.Input[str],
                 condition_task: Optional[pulumi.Input['JobTaskForEachTaskTaskConditionTaskArgs']] = None,
                 dbt_task: Optional[pulumi.Input['JobTaskForEachTaskTaskDbtTaskArgs']] = None,
                 depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskDependsOnArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disable_auto_optimization: Optional[pulumi.Input[bool]] = None,
                 email_notifications: Optional[pulumi.Input['JobTaskForEachTaskTaskEmailNotificationsArgs']] = None,
                 environment_key: Optional[pulumi.Input[str]] = None,
                 existing_cluster_id: Optional[pulumi.Input[str]] = None,
                 health: Optional[pulumi.Input['JobTaskForEachTaskTaskHealthArgs']] = None,
                 job_cluster_key: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskLibraryArgs']]]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 min_retry_interval_millis: Optional[pulumi.Input[int]] = None,
                 new_cluster: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterArgs']] = None,
                 notebook_task: Optional[pulumi.Input['JobTaskForEachTaskTaskNotebookTaskArgs']] = None,
                 notification_settings: Optional[pulumi.Input['JobTaskForEachTaskTaskNotificationSettingsArgs']] = None,
                 pipeline_task: Optional[pulumi.Input['JobTaskForEachTaskTaskPipelineTaskArgs']] = None,
                 python_wheel_task: Optional[pulumi.Input['JobTaskForEachTaskTaskPythonWheelTaskArgs']] = None,
                 retry_on_timeout: Optional[pulumi.Input[bool]] = None,
                 run_if: Optional[pulumi.Input[str]] = None,
                 run_job_task: Optional[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskArgs']] = None,
                 spark_jar_task: Optional[pulumi.Input['JobTaskForEachTaskTaskSparkJarTaskArgs']] = None,
                 spark_python_task: Optional[pulumi.Input['JobTaskForEachTaskTaskSparkPythonTaskArgs']] = None,
                 spark_submit_task: Optional[pulumi.Input['JobTaskForEachTaskTaskSparkSubmitTaskArgs']] = None,
                 sql_task: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 webhook_notifications: Optional[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsArgs']] = None):
        """
        :param pulumi.Input[str] task_key: string specifying an unique key for a given task.
               * `*_task` - (Required) one of the specific task blocks described below:
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskDependsOnArgs']]] depends_ons: block specifying dependency(-ies) for a given task.
        :param pulumi.Input[str] description: description for this task.
        :param pulumi.Input[bool] disable_auto_optimization: A flag to disable auto optimization in serverless tasks.
        :param pulumi.Input['JobTaskForEachTaskTaskEmailNotificationsArgs'] email_notifications: An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        :param pulumi.Input[str] environment_key: identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        :param pulumi.Input[str] existing_cluster_id: Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        :param pulumi.Input['JobTaskForEachTaskTaskHealthArgs'] health: block described below that specifies health conditions for a given task.
        :param pulumi.Input[str] job_cluster_key: Identifier of the Job cluster specified in the `job_cluster` block.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskLibraryArgs']]] libraries: (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        :param pulumi.Input[int] max_retries: (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        :param pulumi.Input[int] min_retry_interval_millis: (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        :param pulumi.Input['JobTaskForEachTaskTaskNewClusterArgs'] new_cluster: Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        :param pulumi.Input['JobTaskForEachTaskTaskNotificationSettingsArgs'] notification_settings: An optional block controlling the notification settings on the job level documented below.
        :param pulumi.Input[bool] retry_on_timeout: (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        :param pulumi.Input[str] run_if: An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        :param pulumi.Input[int] timeout_seconds: (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        :param pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsArgs'] webhook_notifications: (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
               
               > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        pulumi.set(__self__, "task_key", task_key)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_auto_optimization is not None:
            pulumi.set(__self__, "disable_auto_optimization", disable_auto_optimization)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> pulumi.Input[str]:
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskConditionTaskArgs']]:
        return pulumi.get(self, "condition_task")

    @condition_task.setter
    def condition_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskConditionTaskArgs']]):
        pulumi.set(self, "condition_task", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskDbtTaskArgs']]:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskDbtTaskArgs']]):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskDependsOnArgs']]]]:
        """
        block specifying dependency(-ies) for a given task.
        """
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskDependsOnArgs']]]]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description for this task.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="disableAutoOptimization")
    def disable_auto_optimization(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to disable auto optimization in serverless tasks.
        """
        return pulumi.get(self, "disable_auto_optimization")

    @disable_auto_optimization.setter
    def disable_auto_optimization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_auto_optimization", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskEmailNotificationsArgs']]:
        """
        An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        """
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskEmailNotificationsArgs']]):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[pulumi.Input[str]]:
        """
        identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        """
        return pulumi.get(self, "environment_key")

    @environment_key.setter
    def environment_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_key", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        """
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskHealthArgs']]:
        """
        block described below that specifies health conditions for a given task.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskHealthArgs']]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the Job cluster specified in the `job_cluster` block.
        """
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskLibraryArgs']]]]:
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterArgs']]:
        """
        Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        """
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterArgs']]):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNotebookTaskArgs']]:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNotebookTaskArgs']]):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNotificationSettingsArgs']]:
        """
        An optional block controlling the notification settings on the job level documented below.
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskPipelineTaskArgs']]:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskPipelineTaskArgs']]):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskPythonWheelTaskArgs']]:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskPythonWheelTaskArgs']]):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[pulumi.Input[str]]:
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        """
        return pulumi.get(self, "run_if")

    @run_if.setter
    def run_if(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_if", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskArgs']]:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskArgs']]):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSparkJarTaskArgs']]:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSparkJarTaskArgs']]):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSparkPythonTaskArgs']]:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSparkPythonTaskArgs']]):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSparkSubmitTaskArgs']]:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSparkSubmitTaskArgs']]):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskArgs']]:
        return pulumi.get(self, "sql_task")

    @sql_task.setter
    def sql_task(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskArgs']]):
        pulumi.set(self, "sql_task", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsArgs']]:
        """
        (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.

        > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        return pulumi.get(self, "webhook_notifications")

    @webhook_notifications.setter
    def webhook_notifications(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsArgs']]):
        pulumi.set(self, "webhook_notifications", value)


if not MYPY:
    class JobTaskForEachTaskTaskConditionTaskArgsDict(TypedDict):
        left: pulumi.Input[str]
        """
        The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        """
        op: pulumi.Input[str]
        """
        The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).

        This task does not require a cluster to execute and does not support retries or notifications.
        """
        right: pulumi.Input[str]
        """
        The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
elif False:
    JobTaskForEachTaskTaskConditionTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskConditionTaskArgs:
    def __init__(__self__, *,
                 left: pulumi.Input[str],
                 op: pulumi.Input[str],
                 right: pulumi.Input[str]):
        """
        :param pulumi.Input[str] left: The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        :param pulumi.Input[str] op: The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
               
               This task does not require a cluster to execute and does not support retries or notifications.
        :param pulumi.Input[str] right: The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @property
    @pulumi.getter
    def left(self) -> pulumi.Input[str]:
        """
        The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        """
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: pulumi.Input[str]):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).

        This task does not require a cluster to execute and does not support retries or notifications.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def right(self) -> pulumi.Input[str]:
        """
        The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        return pulumi.get(self, "right")

    @right.setter
    def right(self, value: pulumi.Input[str]):
        pulumi.set(self, "right", value)


if not MYPY:
    class JobTaskForEachTaskTaskDbtTaskArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        catalog: NotRequired[pulumi.Input[str]]
        """
        The name of the catalog to use inside Unity Catalog.
        """
        profiles_directory: NotRequired[pulumi.Input[str]]
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        project_directory: NotRequired[pulumi.Input[str]]
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        schema: NotRequired[pulumi.Input[str]]
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        warehouse_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
elif False:
    JobTaskForEachTaskTaskDbtTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskDbtTaskArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 catalog: Optional[pulumi.Input[str]] = None,
                 profiles_directory: Optional[pulumi.Input[str]] = None,
                 project_directory: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param pulumi.Input[str] catalog: The name of the catalog to use inside Unity Catalog.
        :param pulumi.Input[str] profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param pulumi.Input[str] project_directory: The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
               * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
               * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        :param pulumi.Input[str] schema: The name of the schema dbt should run in. Defaults to `default`.
        :param pulumi.Input[str] source: The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        :param pulumi.Input[str] warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class JobTaskForEachTaskTaskDependsOnArgsDict(TypedDict):
        task_key: pulumi.Input[str]
        """
        The name of the task this task depends on.
        """
        outcome: NotRequired[pulumi.Input[str]]
        """
        Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.

        > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
elif False:
    JobTaskForEachTaskTaskDependsOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskDependsOnArgs:
    def __init__(__self__, *,
                 task_key: pulumi.Input[str],
                 outcome: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] task_key: The name of the task this task depends on.
        :param pulumi.Input[str] outcome: Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.
               
               > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> pulumi.Input[str]:
        """
        The name of the task this task depends on.
        """
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter
    def outcome(self) -> Optional[pulumi.Input[str]]:
        """
        Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.

        > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        return pulumi.get(self, "outcome")

    @outcome.setter
    def outcome(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outcome", value)


if not MYPY:
    class JobTaskForEachTaskTaskEmailNotificationsArgsDict(TypedDict):
        no_alert_for_skipped_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        on_duration_warning_threshold_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        The following parameter is only available for the job level configuration.
        """
        on_failures: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run fails.
        """
        on_starts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run starts.
        """
        on_streaming_backlog_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        on_successes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) list of emails to notify when the run completes successfully.
        """
elif False:
    JobTaskForEachTaskTaskEmailNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskEmailNotificationsArgs:
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_streaming_backlog_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               The following parameter is only available for the job level configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_failures: (List) list of emails to notify when the run fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_starts: (List) list of emails to notify when the run starts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        The following parameter is only available for the job level configuration.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class JobTaskForEachTaskTaskHealthArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskHealthRuleArgsDict']]]
        """
        list of rules that are represented as objects with the following attributes:
        """
elif False:
    JobTaskForEachTaskTaskHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskHealthArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskHealthRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskHealthRuleArgs']]] rules: list of rules that are represented as objects with the following attributes:
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskHealthRuleArgs']]]:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskHealthRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class JobTaskForEachTaskTaskHealthRuleArgsDict(TypedDict):
        metric: pulumi.Input[str]
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        op: pulumi.Input[str]
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        value: pulumi.Input[int]
        """
        integer value used to compare to the given metric.
        """
elif False:
    JobTaskForEachTaskTaskHealthRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskHealthRuleArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 op: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] metric: string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        :param pulumi.Input[str] op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param pulumi.Input[int] value: integer value used to compare to the given metric.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class JobTaskForEachTaskTaskLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobTaskForEachTaskTaskLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobTaskForEachTaskTaskLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobTaskForEachTaskTaskLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobTaskForEachTaskTaskLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskForEachTaskTaskLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskForEachTaskTaskLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterArgsDict(TypedDict):
        spark_version: pulumi.Input[str]
        apply_policy_default_values: NotRequired[pulumi.Input[bool]]
        autoscale: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterAutoscaleArgsDict']]
        aws_attributes: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterAwsAttributesArgsDict']]
        azure_attributes: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesArgsDict']]
        cluster_id: NotRequired[pulumi.Input[str]]
        cluster_log_conf: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfArgsDict']]
        cluster_mount_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict']]]]
        cluster_name: NotRequired[pulumi.Input[str]]
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        data_security_mode: NotRequired[pulumi.Input[str]]
        docker_image: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageArgsDict']]
        driver_instance_pool_id: NotRequired[pulumi.Input[str]]
        driver_node_type_id: NotRequired[pulumi.Input[str]]
        enable_elastic_disk: NotRequired[pulumi.Input[bool]]
        enable_local_disk_encryption: NotRequired[pulumi.Input[bool]]
        gcp_attributes: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterGcpAttributesArgsDict']]
        idempotency_token: NotRequired[pulumi.Input[str]]
        init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptArgsDict']]]]
        instance_pool_id: NotRequired[pulumi.Input[str]]
        libraries: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryArgsDict']]]]
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        node_type_id: NotRequired[pulumi.Input[str]]
        num_workers: NotRequired[pulumi.Input[int]]
        policy_id: NotRequired[pulumi.Input[str]]
        runtime_engine: NotRequired[pulumi.Input[str]]
        single_user_name: NotRequired[pulumi.Input[str]]
        spark_conf: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        spark_env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        ssh_public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        workload_type: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict']]
        """
        isn't supported
        """
elif False:
    JobTaskForEachTaskTaskNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAutoscaleArgs']] = None,
                 aws_attributes: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryArgs']]]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryArgs']]] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs'] workload_type: isn't supported
        """
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryArgs']]]]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs']]:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[pulumi.Input[int]]
        min_workers: NotRequired[pulumi.Input[int]]
elif False:
    JobTaskForEachTaskTaskNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        ebs_volume_count: NotRequired[pulumi.Input[int]]
        ebs_volume_iops: NotRequired[pulumi.Input[int]]
        ebs_volume_size: NotRequired[pulumi.Input[int]]
        ebs_volume_throughput: NotRequired[pulumi.Input[int]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_throughput: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        log_analytics_info: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict']]
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
elif False:
    JobTaskForEachTaskTaskNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 log_analytics_info: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgs']] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgs']]:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgs']]):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[pulumi.Input[str]]
        log_analytics_workspace_id: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_id: Optional[pulumi.Input[str]] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict']]
        s3: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict']]
elif False:
    JobTaskForEachTaskTaskNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfS3Args']] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: pulumi.Input[str]
        network_filesystem_info: pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict']
        remote_mount_dir_path: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: pulumi.Input[str]
        mount_options: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterDockerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL of the job on the given workspace
        """
        basic_auth: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict']]
elif False:
    JobTaskForEachTaskTaskNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        boot_disk_size: NotRequired[pulumi.Input[int]]
        google_service_account: NotRequired[pulumi.Input[str]]
        local_ssd_count: NotRequired[pulumi.Input[int]]
        use_preemptible_executors: NotRequired[pulumi.Input[bool]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict']]
        dbfs: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict']]
        file: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptFileArgsDict']]
        """
        block consisting of single string fields:
        """
        gcs: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict']]
        s3: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict']]
        volumes: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict']]
        workspace: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict']]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptFileArgs'] file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptFileArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskNewClusterLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskForEachTaskTaskNewClusterLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict']
elif False:
    JobTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


if not MYPY:
    class JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[pulumi.Input[bool]]
        notebooks: NotRequired[pulumi.Input[bool]]
elif False:
    JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class JobTaskForEachTaskTaskNotebookTaskArgsDict(TypedDict):
        notebook_path: pulumi.Input[str]
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        base_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        warehouse_id: NotRequired[pulumi.Input[str]]
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
elif False:
    JobTaskForEachTaskTaskNotebookTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: pulumi.Input[str],
                 base_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param pulumi.Input[str] source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        :param pulumi.Input[str] warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> pulumi.Input[str]:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class JobTaskForEachTaskTaskNotificationSettingsArgsDict(TypedDict):
        alert_on_last_attempt: NotRequired[pulumi.Input[bool]]
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        no_alert_for_canceled_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        no_alert_for_skipped_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for skipped runs.
        """
elif False:
    JobTaskForEachTaskTaskNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskNotificationSettingsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param pulumi.Input[bool] no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
               
               The following parameter is only available on task level.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


if not MYPY:
    class JobTaskForEachTaskTaskPipelineTaskArgsDict(TypedDict):
        pipeline_id: pulumi.Input[str]
        """
        The pipeline's unique ID.
        """
        full_refresh: NotRequired[pulumi.Input[bool]]
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
elif False:
    JobTaskForEachTaskTaskPipelineTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: pulumi.Input[str],
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline's unique ID.
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> pulumi.Input[str]:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class JobTaskForEachTaskTaskPythonWheelTaskArgsDict(TypedDict):
        entry_point: NotRequired[pulumi.Input[str]]
        """
        Python function as entry point for the task
        """
        named_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Named parameters for the task
        """
        package_name: NotRequired[pulumi.Input[str]]
        """
        Name of Python package
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameters for the task
        """
elif False:
    JobTaskForEachTaskTaskPythonWheelTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 named_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 package_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entry_point: Python function as entry point for the task
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] named_parameters: Named parameters for the task
        :param pulumi.Input[str] package_name: Name of Python package
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskForEachTaskTaskRunJobTaskArgsDict(TypedDict):
        job_id: pulumi.Input[int]
        """
        (String) ID of the job
        """
        dbt_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        jar_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        job_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) Job parameters for the task
        """
        notebook_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        pipeline_params: NotRequired[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgsDict']]
        python_named_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        python_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        spark_submit_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        sql_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    JobTaskForEachTaskTaskRunJobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: pulumi.Input[int],
                 dbt_commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jar_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 job_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 notebook_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pipeline_params: Optional[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgs']] = None,
                 python_named_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 python_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 spark_submit_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sql_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] job_id: (String) ID of the job
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] job_parameters: (Map) Job parameters for the task
        """
        pulumi.set(__self__, "job_id", job_id)
        if dbt_commands is not None:
            pulumi.set(__self__, "dbt_commands", dbt_commands)
        if jar_params is not None:
            pulumi.set(__self__, "jar_params", jar_params)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)
        if notebook_params is not None:
            pulumi.set(__self__, "notebook_params", notebook_params)
        if pipeline_params is not None:
            pulumi.set(__self__, "pipeline_params", pipeline_params)
        if python_named_params is not None:
            pulumi.set(__self__, "python_named_params", python_named_params)
        if python_params is not None:
            pulumi.set(__self__, "python_params", python_params)
        if spark_submit_params is not None:
            pulumi.set(__self__, "spark_submit_params", spark_submit_params)
        if sql_params is not None:
            pulumi.set(__self__, "sql_params", sql_params)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[int]:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="dbtCommands")
    def dbt_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dbt_commands")

    @dbt_commands.setter
    def dbt_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dbt_commands", value)

    @property
    @pulumi.getter(name="jarParams")
    def jar_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "jar_params")

    @jar_params.setter
    def jar_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jar_params", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "job_parameters", value)

    @property
    @pulumi.getter(name="notebookParams")
    def notebook_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "notebook_params")

    @notebook_params.setter
    def notebook_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "notebook_params", value)

    @property
    @pulumi.getter(name="pipelineParams")
    def pipeline_params(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgs']]:
        return pulumi.get(self, "pipeline_params")

    @pipeline_params.setter
    def pipeline_params(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgs']]):
        pulumi.set(self, "pipeline_params", value)

    @property
    @pulumi.getter(name="pythonNamedParams")
    def python_named_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "python_named_params")

    @python_named_params.setter
    def python_named_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "python_named_params", value)

    @property
    @pulumi.getter(name="pythonParams")
    def python_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "python_params")

    @python_params.setter
    def python_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "python_params", value)

    @property
    @pulumi.getter(name="sparkSubmitParams")
    def spark_submit_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_submit_params")

    @spark_submit_params.setter
    def spark_submit_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "spark_submit_params", value)

    @property
    @pulumi.getter(name="sqlParams")
    def sql_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "sql_params")

    @sql_params.setter
    def sql_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "sql_params", value)


if not MYPY:
    class JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgsDict(TypedDict):
        full_refresh: NotRequired[pulumi.Input[bool]]
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
elif False:
    JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskRunJobTaskPipelineParamsArgs:
    def __init__(__self__, *,
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class JobTaskForEachTaskTaskSparkJarTaskArgsDict(TypedDict):
        jar_uri: NotRequired[pulumi.Input[str]]
        main_class_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Parameters passed to the main method.
        """
elif False:
    JobTaskForEachTaskTaskSparkJarTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[pulumi.Input[str]] = None,
                 main_class_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Parameters passed to the main method.
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskForEachTaskTaskSparkPythonTaskArgsDict(TypedDict):
        python_file: pulumi.Input[str]
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Command line parameters passed to the Python file.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
elif False:
    JobTaskForEachTaskTaskSparkPythonTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] python_file: The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command line parameters passed to the Python file.
        :param pulumi.Input[str] source: Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> pulumi.Input[str]:
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class JobTaskForEachTaskTaskSparkSubmitTaskArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Command-line parameters passed to spark submit.
        """
elif False:
    JobTaskForEachTaskTaskSparkSubmitTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command-line parameters passed to spark submit.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskArgsDict(TypedDict):
        warehouse_id: pulumi.Input[str]
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        alert: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertArgsDict']]
        """
        block consisting of following fields:
        """
        dashboard: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardArgsDict']]
        """
        block consisting of following fields:
        """
        file: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSqlTaskFileArgsDict']]
        """
        block consisting of single string fields:
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        query: NotRequired[pulumi.Input['JobTaskForEachTaskTaskSqlTaskQueryArgsDict']]
        """
        block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
elif False:
    JobTaskForEachTaskTaskSqlTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskArgs:
    def __init__(__self__, *,
                 warehouse_id: pulumi.Input[str],
                 alert: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertArgs']] = None,
                 dashboard: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardArgs']] = None,
                 file: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskFileArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 query: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskQueryArgs']] = None):
        """
        :param pulumi.Input[str] warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        :param pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertArgs'] alert: block consisting of following fields:
        :param pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardArgs'] dashboard: block consisting of following fields:
        :param pulumi.Input['JobTaskForEachTaskTaskSqlTaskFileArgs'] file: block consisting of single string fields:
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        :param pulumi.Input['JobTaskForEachTaskTaskSqlTaskQueryArgs'] query: block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> pulumi.Input[str]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "warehouse_id", value)

    @property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertArgs']]:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertArgs']]):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardArgs']]:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardArgs']]):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskFileArgs']]:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskQueryArgs']]:
        """
        block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['JobTaskForEachTaskTaskSqlTaskQueryArgs']]):
        pulumi.set(self, "query", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskAlertArgsDict(TypedDict):
        alert_id: pulumi.Input[str]
        """
        (String) identifier of the Databricks Alert (databricks_alert).
        """
        pause_subscriptions: NotRequired[pulumi.Input[bool]]
        """
        flag that specifies if subscriptions are paused or not.
        """
        subscriptions: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict']]]]
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
elif False:
    JobTaskForEachTaskTaskSqlTaskAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskAlertArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 pause_subscriptions: Optional[pulumi.Input[bool]] = None,
                 subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']]]] = None):
        """
        :param pulumi.Input[str] alert_id: (String) identifier of the Databricks Alert (databricks_alert).
        :param pulumi.Input[bool] pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']]] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        (String) identifier of the Databricks Alert (databricks_alert).
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[pulumi.Input[bool]]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']]]]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']]]]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[pulumi.Input[str]]
        user_name: NotRequired[pulumi.Input[str]]
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
elif False:
    JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskDashboardArgsDict(TypedDict):
        dashboard_id: pulumi.Input[str]
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        custom_subject: NotRequired[pulumi.Input[str]]
        """
        string specifying a custom subject of email sent.
        """
        pause_subscriptions: NotRequired[pulumi.Input[bool]]
        """
        flag that specifies if subscriptions are paused or not.
        """
        subscriptions: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict']]]]
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
elif False:
    JobTaskForEachTaskTaskSqlTaskDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: pulumi.Input[str],
                 custom_subject: Optional[pulumi.Input[str]] = None,
                 pause_subscriptions: Optional[pulumi.Input[bool]] = None,
                 subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']]]] = None):
        """
        :param pulumi.Input[str] dashboard_id: (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        :param pulumi.Input[str] custom_subject: string specifying a custom subject of email sent.
        :param pulumi.Input[bool] pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']]] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying a custom subject of email sent.
        """
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[pulumi.Input[bool]]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']]]]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']]]]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[pulumi.Input[str]]
        user_name: NotRequired[pulumi.Input[str]]
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
elif False:
    JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskFileArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sql_aggregation_job",
            name="Example SQL Job",
            tasks=[
                {
                    "task_key": "run_agg_query",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "query": {
                            "query_id": agg_query["id"],
                        },
                    },
                },
                {
                    "task_key": "run_dashboard",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "dashboard": {
                            "dashboard_id": dash["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
                {
                    "task_key": "run_alert",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "alert": {
                            "alert_id": alert["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
            ])
        ```
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
elif False:
    JobTaskForEachTaskTaskSqlTaskFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sql_aggregation_job",
                   name="Example SQL Job",
                   tasks=[
                       {
                           "task_key": "run_agg_query",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "query": {
                                   "query_id": agg_query["id"],
                               },
                           },
                       },
                       {
                           "task_key": "run_dashboard",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "dashboard": {
                                   "dashboard_id": dash["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                       {
                           "task_key": "run_alert",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "alert": {
                                   "alert_id": alert["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                   ])
               ```
        :param pulumi.Input[str] source: The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sql_aggregation_job",
            name="Example SQL Job",
            tasks=[
                {
                    "task_key": "run_agg_query",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "query": {
                            "query_id": agg_query["id"],
                        },
                    },
                },
                {
                    "task_key": "run_dashboard",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "dashboard": {
                            "dashboard_id": dash["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
                {
                    "task_key": "run_alert",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "alert": {
                            "alert_id": alert["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
            ])
        ```
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class JobTaskForEachTaskTaskSqlTaskQueryArgsDict(TypedDict):
        query_id: pulumi.Input[str]
elif False:
    JobTaskForEachTaskTaskSqlTaskQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskSqlTaskQueryArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str]):
        pulumi.set(__self__, "query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)


if not MYPY:
    class JobTaskForEachTaskTaskWebhookNotificationsArgsDict(TypedDict):
        on_duration_warning_threshold_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict']]]]
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        on_failures: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict']]]]
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        on_starts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict']]]]
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        on_streaming_backlog_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict']]]]
        on_successes: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict']]]]
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
elif False:
    JobTaskForEachTaskTaskWebhookNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs']]]] = None,
                 on_streaming_backlog_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']]] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs']]] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']]] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']]]]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs']]]]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs']]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']]]]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']]]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskHealthArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgsDict']]]
        """
        list of rules that are represented as objects with the following attributes:
        """
elif False:
    JobTaskHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskHealthArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]] rules: list of rules that are represented as objects with the following attributes:
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class JobTaskHealthRuleArgsDict(TypedDict):
        metric: pulumi.Input[str]
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        op: pulumi.Input[str]
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        value: pulumi.Input[int]
        """
        integer value used to compare to the given metric.
        """
elif False:
    JobTaskHealthRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskHealthRuleArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 op: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] metric: string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        :param pulumi.Input[str] op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param pulumi.Input[int] value: integer value used to compare to the given metric.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class JobTaskLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobTaskLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobTaskLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobTaskLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobTaskLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobTaskLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobTaskLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobTaskLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobTaskLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobTaskLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobTaskLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobTaskLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobTaskLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobTaskLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskNewClusterArgsDict(TypedDict):
        spark_version: pulumi.Input[str]
        apply_policy_default_values: NotRequired[pulumi.Input[bool]]
        autoscale: NotRequired[pulumi.Input['JobTaskNewClusterAutoscaleArgsDict']]
        aws_attributes: NotRequired[pulumi.Input['JobTaskNewClusterAwsAttributesArgsDict']]
        azure_attributes: NotRequired[pulumi.Input['JobTaskNewClusterAzureAttributesArgsDict']]
        cluster_id: NotRequired[pulumi.Input[str]]
        cluster_log_conf: NotRequired[pulumi.Input['JobTaskNewClusterClusterLogConfArgsDict']]
        cluster_mount_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgsDict']]]]
        cluster_name: NotRequired[pulumi.Input[str]]
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        data_security_mode: NotRequired[pulumi.Input[str]]
        docker_image: NotRequired[pulumi.Input['JobTaskNewClusterDockerImageArgsDict']]
        driver_instance_pool_id: NotRequired[pulumi.Input[str]]
        driver_node_type_id: NotRequired[pulumi.Input[str]]
        enable_elastic_disk: NotRequired[pulumi.Input[bool]]
        enable_local_disk_encryption: NotRequired[pulumi.Input[bool]]
        gcp_attributes: NotRequired[pulumi.Input['JobTaskNewClusterGcpAttributesArgsDict']]
        idempotency_token: NotRequired[pulumi.Input[str]]
        init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgsDict']]]]
        instance_pool_id: NotRequired[pulumi.Input[str]]
        libraries: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterLibraryArgsDict']]]]
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        node_type_id: NotRequired[pulumi.Input[str]]
        num_workers: NotRequired[pulumi.Input[int]]
        policy_id: NotRequired[pulumi.Input[str]]
        runtime_engine: NotRequired[pulumi.Input[str]]
        single_user_name: NotRequired[pulumi.Input[str]]
        spark_conf: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        spark_env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        ssh_public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        workload_type: NotRequired[pulumi.Input['JobTaskNewClusterWorkloadTypeArgsDict']]
        """
        isn't supported
        """
elif False:
    JobTaskNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']] = None,
                 aws_attributes: Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterLibraryArgs']]]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterLibraryArgs']]] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param pulumi.Input['JobTaskNewClusterWorkloadTypeArgs'] workload_type: isn't supported
        """
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterLibraryArgs']]]]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']]:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class JobTaskNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[pulumi.Input[int]]
        min_workers: NotRequired[pulumi.Input[int]]
elif False:
    JobTaskNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class JobTaskNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        ebs_volume_count: NotRequired[pulumi.Input[int]]
        ebs_volume_iops: NotRequired[pulumi.Input[int]]
        ebs_volume_size: NotRequired[pulumi.Input[int]]
        ebs_volume_throughput: NotRequired[pulumi.Input[int]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_throughput: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobTaskNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        log_analytics_info: NotRequired[pulumi.Input['JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict']]
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
elif False:
    JobTaskNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 log_analytics_info: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgs']] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional[pulumi.Input['JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgs']]:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgs']]):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[pulumi.Input[str]]
        log_analytics_workspace_id: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_id: Optional[pulumi.Input[str]] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class JobTaskNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgsDict']]
        s3: NotRequired[pulumi.Input['JobTaskNewClusterClusterLogConfS3ArgsDict']]
elif False:
    JobTaskNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class JobTaskNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobTaskNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: pulumi.Input[str]
        network_filesystem_info: pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict']
        remote_mount_dir_path: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: pulumi.Input[str]
        mount_options: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class JobTaskNewClusterDockerImageArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL of the job on the given workspace
        """
        basic_auth: NotRequired[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgsDict']]
elif False:
    JobTaskNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class JobTaskNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    JobTaskNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class JobTaskNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        boot_disk_size: NotRequired[pulumi.Input[int]]
        google_service_account: NotRequired[pulumi.Input[str]]
        local_ssd_count: NotRequired[pulumi.Input[int]]
        use_preemptible_executors: NotRequired[pulumi.Input[bool]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class JobTaskNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgsDict']]
        dbfs: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgsDict']]
        file: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptFileArgsDict']]
        """
        block consisting of single string fields:
        """
        gcs: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptGcsArgsDict']]
        s3: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptS3ArgsDict']]
        volumes: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgsDict']]
        workspace: NotRequired[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgsDict']]
elif False:
    JobTaskNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobTaskNewClusterInitScriptFileArgs'] file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class JobTaskNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterInitScriptFileArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class JobTaskNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    JobTaskNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class JobTaskNewClusterLibraryArgsDict(TypedDict):
        cran: NotRequired[pulumi.Input['JobTaskNewClusterLibraryCranArgsDict']]
        egg: NotRequired[pulumi.Input[str]]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['JobTaskNewClusterLibraryMavenArgsDict']]
        pypi: NotRequired[pulumi.Input['JobTaskNewClusterLibraryPypiArgsDict']]
        requirements: NotRequired[pulumi.Input[str]]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobTaskNewClusterLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobTaskNewClusterLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobTaskNewClusterLibraryPypiArgs']] = None,
                 requirements: Optional[pulumi.Input[str]] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobTaskNewClusterLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobTaskNewClusterLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobTaskNewClusterLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobTaskNewClusterLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobTaskNewClusterLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobTaskNewClusterLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class JobTaskNewClusterLibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskNewClusterLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskNewClusterLibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    JobTaskNewClusterLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class JobTaskNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgsDict']
elif False:
    JobTaskNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


if not MYPY:
    class JobTaskNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[pulumi.Input[bool]]
        notebooks: NotRequired[pulumi.Input[bool]]
elif False:
    JobTaskNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class JobTaskNotebookTaskArgsDict(TypedDict):
        notebook_path: pulumi.Input[str]
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        base_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        warehouse_id: NotRequired[pulumi.Input[str]]
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
elif False:
    JobTaskNotebookTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: pulumi.Input[str],
                 base_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param pulumi.Input[str] source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        :param pulumi.Input[str] warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> pulumi.Input[str]:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class JobTaskNotificationSettingsArgsDict(TypedDict):
        alert_on_last_attempt: NotRequired[pulumi.Input[bool]]
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        no_alert_for_canceled_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        no_alert_for_skipped_runs: NotRequired[pulumi.Input[bool]]
        """
        (Bool) don't send alert for skipped runs.
        """
elif False:
    JobTaskNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskNotificationSettingsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param pulumi.Input[bool] no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
               
               The following parameter is only available on task level.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


if not MYPY:
    class JobTaskPipelineTaskArgsDict(TypedDict):
        pipeline_id: pulumi.Input[str]
        """
        The pipeline's unique ID.
        """
        full_refresh: NotRequired[pulumi.Input[bool]]
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
elif False:
    JobTaskPipelineTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: pulumi.Input[str],
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline's unique ID.
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> pulumi.Input[str]:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class JobTaskPythonWheelTaskArgsDict(TypedDict):
        entry_point: NotRequired[pulumi.Input[str]]
        """
        Python function as entry point for the task
        """
        named_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Named parameters for the task
        """
        package_name: NotRequired[pulumi.Input[str]]
        """
        Name of Python package
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Parameters for the task
        """
elif False:
    JobTaskPythonWheelTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 named_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 package_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entry_point: Python function as entry point for the task
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] named_parameters: Named parameters for the task
        :param pulumi.Input[str] package_name: Name of Python package
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskRunJobTaskArgsDict(TypedDict):
        job_id: pulumi.Input[int]
        """
        (String) ID of the job
        """
        dbt_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        jar_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        job_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) Job parameters for the task
        """
        notebook_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        pipeline_params: NotRequired[pulumi.Input['JobTaskRunJobTaskPipelineParamsArgsDict']]
        python_named_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        python_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        spark_submit_params: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        sql_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    JobTaskRunJobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: pulumi.Input[int],
                 dbt_commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jar_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 job_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 notebook_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pipeline_params: Optional[pulumi.Input['JobTaskRunJobTaskPipelineParamsArgs']] = None,
                 python_named_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 python_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 spark_submit_params: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sql_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] job_id: (String) ID of the job
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] job_parameters: (Map) Job parameters for the task
        """
        pulumi.set(__self__, "job_id", job_id)
        if dbt_commands is not None:
            pulumi.set(__self__, "dbt_commands", dbt_commands)
        if jar_params is not None:
            pulumi.set(__self__, "jar_params", jar_params)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)
        if notebook_params is not None:
            pulumi.set(__self__, "notebook_params", notebook_params)
        if pipeline_params is not None:
            pulumi.set(__self__, "pipeline_params", pipeline_params)
        if python_named_params is not None:
            pulumi.set(__self__, "python_named_params", python_named_params)
        if python_params is not None:
            pulumi.set(__self__, "python_params", python_params)
        if spark_submit_params is not None:
            pulumi.set(__self__, "spark_submit_params", spark_submit_params)
        if sql_params is not None:
            pulumi.set(__self__, "sql_params", sql_params)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[int]:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="dbtCommands")
    def dbt_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "dbt_commands")

    @dbt_commands.setter
    def dbt_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dbt_commands", value)

    @property
    @pulumi.getter(name="jarParams")
    def jar_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "jar_params")

    @jar_params.setter
    def jar_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jar_params", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "job_parameters", value)

    @property
    @pulumi.getter(name="notebookParams")
    def notebook_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "notebook_params")

    @notebook_params.setter
    def notebook_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "notebook_params", value)

    @property
    @pulumi.getter(name="pipelineParams")
    def pipeline_params(self) -> Optional[pulumi.Input['JobTaskRunJobTaskPipelineParamsArgs']]:
        return pulumi.get(self, "pipeline_params")

    @pipeline_params.setter
    def pipeline_params(self, value: Optional[pulumi.Input['JobTaskRunJobTaskPipelineParamsArgs']]):
        pulumi.set(self, "pipeline_params", value)

    @property
    @pulumi.getter(name="pythonNamedParams")
    def python_named_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "python_named_params")

    @python_named_params.setter
    def python_named_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "python_named_params", value)

    @property
    @pulumi.getter(name="pythonParams")
    def python_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "python_params")

    @python_params.setter
    def python_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "python_params", value)

    @property
    @pulumi.getter(name="sparkSubmitParams")
    def spark_submit_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_submit_params")

    @spark_submit_params.setter
    def spark_submit_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "spark_submit_params", value)

    @property
    @pulumi.getter(name="sqlParams")
    def sql_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "sql_params")

    @sql_params.setter
    def sql_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "sql_params", value)


if not MYPY:
    class JobTaskRunJobTaskPipelineParamsArgsDict(TypedDict):
        full_refresh: NotRequired[pulumi.Input[bool]]
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
elif False:
    JobTaskRunJobTaskPipelineParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskRunJobTaskPipelineParamsArgs:
    def __init__(__self__, *,
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class JobTaskSparkJarTaskArgsDict(TypedDict):
        jar_uri: NotRequired[pulumi.Input[str]]
        main_class_name: NotRequired[pulumi.Input[str]]
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Parameters passed to the main method.
        """
elif False:
    JobTaskSparkJarTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[pulumi.Input[str]] = None,
                 main_class_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Parameters passed to the main method.
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskSparkPythonTaskArgsDict(TypedDict):
        python_file: pulumi.Input[str]
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Command line parameters passed to the Python file.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
elif False:
    JobTaskSparkPythonTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] python_file: The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command line parameters passed to the Python file.
        :param pulumi.Input[str] source: Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> pulumi.Input[str]:
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class JobTaskSparkSubmitTaskArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (List) Command-line parameters passed to spark submit.
        """
elif False:
    JobTaskSparkSubmitTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command-line parameters passed to spark submit.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class JobTaskSqlTaskArgsDict(TypedDict):
        warehouse_id: pulumi.Input[str]
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        alert: NotRequired[pulumi.Input['JobTaskSqlTaskAlertArgsDict']]
        """
        block consisting of following fields:
        """
        dashboard: NotRequired[pulumi.Input['JobTaskSqlTaskDashboardArgsDict']]
        """
        block consisting of following fields:
        """
        file: NotRequired[pulumi.Input['JobTaskSqlTaskFileArgsDict']]
        """
        block consisting of single string fields:
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        query: NotRequired[pulumi.Input['JobTaskSqlTaskQueryArgsDict']]
        """
        block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
elif False:
    JobTaskSqlTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskArgs:
    def __init__(__self__, *,
                 warehouse_id: pulumi.Input[str],
                 alert: Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']] = None,
                 dashboard: Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']] = None,
                 file: Optional[pulumi.Input['JobTaskSqlTaskFileArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 query: Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']] = None):
        """
        :param pulumi.Input[str] warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        :param pulumi.Input['JobTaskSqlTaskAlertArgs'] alert: block consisting of following fields:
        :param pulumi.Input['JobTaskSqlTaskDashboardArgs'] dashboard: block consisting of following fields:
        :param pulumi.Input['JobTaskSqlTaskFileArgs'] file: block consisting of single string fields:
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        :param pulumi.Input['JobTaskSqlTaskQueryArgs'] query: block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> pulumi.Input[str]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "warehouse_id", value)

    @property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']]:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']]):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']]:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']]):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobTaskSqlTaskFileArgs']]:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobTaskSqlTaskFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']]:
        """
        block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']]):
        pulumi.set(self, "query", value)


if not MYPY:
    class JobTaskSqlTaskAlertArgsDict(TypedDict):
        alert_id: pulumi.Input[str]
        """
        (String) identifier of the Databricks Alert (databricks_alert).
        """
        pause_subscriptions: NotRequired[pulumi.Input[bool]]
        """
        flag that specifies if subscriptions are paused or not.
        """
        subscriptions: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgsDict']]]]
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
elif False:
    JobTaskSqlTaskAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskAlertArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 pause_subscriptions: Optional[pulumi.Input[bool]] = None,
                 subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]]] = None):
        """
        :param pulumi.Input[str] alert_id: (String) identifier of the Databricks Alert (databricks_alert).
        :param pulumi.Input[bool] pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        (String) identifier of the Databricks Alert (databricks_alert).
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[pulumi.Input[bool]]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]]]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]]]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class JobTaskSqlTaskAlertSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[pulumi.Input[str]]
        user_name: NotRequired[pulumi.Input[str]]
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
elif False:
    JobTaskSqlTaskAlertSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskAlertSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class JobTaskSqlTaskDashboardArgsDict(TypedDict):
        dashboard_id: pulumi.Input[str]
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        custom_subject: NotRequired[pulumi.Input[str]]
        """
        string specifying a custom subject of email sent.
        """
        pause_subscriptions: NotRequired[pulumi.Input[bool]]
        """
        flag that specifies if subscriptions are paused or not.
        """
        subscriptions: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgsDict']]]]
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
elif False:
    JobTaskSqlTaskDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: pulumi.Input[str],
                 custom_subject: Optional[pulumi.Input[str]] = None,
                 pause_subscriptions: Optional[pulumi.Input[bool]] = None,
                 subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]] = None):
        """
        :param pulumi.Input[str] dashboard_id: (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        :param pulumi.Input[str] custom_subject: string specifying a custom subject of email sent.
        :param pulumi.Input[bool] pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying a custom subject of email sent.
        """
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[pulumi.Input[bool]]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class JobTaskSqlTaskDashboardSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[pulumi.Input[str]]
        user_name: NotRequired[pulumi.Input[str]]
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
elif False:
    JobTaskSqlTaskDashboardSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskDashboardSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class JobTaskSqlTaskFileArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sql_aggregation_job",
            name="Example SQL Job",
            tasks=[
                {
                    "task_key": "run_agg_query",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "query": {
                            "query_id": agg_query["id"],
                        },
                    },
                },
                {
                    "task_key": "run_dashboard",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "dashboard": {
                            "dashboard_id": dash["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
                {
                    "task_key": "run_alert",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "alert": {
                            "alert_id": alert["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
            ])
        ```
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
elif False:
    JobTaskSqlTaskFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sql_aggregation_job",
                   name="Example SQL Job",
                   tasks=[
                       {
                           "task_key": "run_agg_query",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "query": {
                                   "query_id": agg_query["id"],
                               },
                           },
                       },
                       {
                           "task_key": "run_dashboard",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "dashboard": {
                                   "dashboard_id": dash["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                       {
                           "task_key": "run_alert",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "alert": {
                                   "alert_id": alert["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                   ])
               ```
        :param pulumi.Input[str] source: The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sql_aggregation_job",
            name="Example SQL Job",
            tasks=[
                {
                    "task_key": "run_agg_query",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "query": {
                            "query_id": agg_query["id"],
                        },
                    },
                },
                {
                    "task_key": "run_dashboard",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "dashboard": {
                            "dashboard_id": dash["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
                {
                    "task_key": "run_alert",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "alert": {
                            "alert_id": alert["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
            ])
        ```
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class JobTaskSqlTaskQueryArgsDict(TypedDict):
        query_id: pulumi.Input[str]
elif False:
    JobTaskSqlTaskQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskSqlTaskQueryArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str]):
        pulumi.set(__self__, "query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)


if not MYPY:
    class JobTaskWebhookNotificationsArgsDict(TypedDict):
        on_duration_warning_threshold_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict']]]]
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        on_failures: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnFailureArgsDict']]]]
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        on_starts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStartArgsDict']]]]
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        on_streaming_backlog_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict']]]]
        on_successes: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnSuccessArgsDict']]]]
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
elif False:
    JobTaskWebhookNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnFailureArgs']]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStartArgs']]]] = None,
                 on_streaming_backlog_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnSuccessArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnFailureArgs']]] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStartArgs']]] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnSuccessArgs']]] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnFailureArgs']]]]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnFailureArgs']]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStartArgs']]]]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStartArgs']]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnSuccessArgs']]]]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskWebhookNotificationsOnSuccessArgs']]]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskWebhookNotificationsOnFailureArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskWebhookNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskWebhookNotificationsOnStartArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskWebhookNotificationsOnStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskWebhookNotificationsOnStreamingBacklogExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTaskWebhookNotificationsOnSuccessArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobTaskWebhookNotificationsOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTaskWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobTriggerArgsDict(TypedDict):
        file_arrival: NotRequired[pulumi.Input['JobTriggerFileArrivalArgsDict']]
        """
        configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        """
        pause_status: NotRequired[pulumi.Input[str]]
        """
        Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        periodic: NotRequired[pulumi.Input['JobTriggerPeriodicArgsDict']]
        """
        configuration block to define a trigger for Periodic Triggers consisting of the following attributes:
        """
        table: NotRequired[pulumi.Input['JobTriggerTableArgsDict']]
        table_update: NotRequired[pulumi.Input['JobTriggerTableUpdateArgsDict']]
elif False:
    JobTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTriggerArgs:
    def __init__(__self__, *,
                 file_arrival: Optional[pulumi.Input['JobTriggerFileArrivalArgs']] = None,
                 pause_status: Optional[pulumi.Input[str]] = None,
                 periodic: Optional[pulumi.Input['JobTriggerPeriodicArgs']] = None,
                 table: Optional[pulumi.Input['JobTriggerTableArgs']] = None,
                 table_update: Optional[pulumi.Input['JobTriggerTableUpdateArgs']] = None):
        """
        :param pulumi.Input['JobTriggerFileArrivalArgs'] file_arrival: configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        :param pulumi.Input[str] pause_status: Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        :param pulumi.Input['JobTriggerPeriodicArgs'] periodic: configuration block to define a trigger for Periodic Triggers consisting of the following attributes:
        """
        if file_arrival is not None:
            pulumi.set(__self__, "file_arrival", file_arrival)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)
        if periodic is not None:
            pulumi.set(__self__, "periodic", periodic)
        if table is not None:
            pulumi.set(__self__, "table", table)
        if table_update is not None:
            pulumi.set(__self__, "table_update", table_update)

    @property
    @pulumi.getter(name="fileArrival")
    def file_arrival(self) -> Optional[pulumi.Input['JobTriggerFileArrivalArgs']]:
        """
        configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        """
        return pulumi.get(self, "file_arrival")

    @file_arrival.setter
    def file_arrival(self, value: Optional[pulumi.Input['JobTriggerFileArrivalArgs']]):
        pulumi.set(self, "file_arrival", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)

    @property
    @pulumi.getter
    def periodic(self) -> Optional[pulumi.Input['JobTriggerPeriodicArgs']]:
        """
        configuration block to define a trigger for Periodic Triggers consisting of the following attributes:
        """
        return pulumi.get(self, "periodic")

    @periodic.setter
    def periodic(self, value: Optional[pulumi.Input['JobTriggerPeriodicArgs']]):
        pulumi.set(self, "periodic", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input['JobTriggerTableArgs']]:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input['JobTriggerTableArgs']]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="tableUpdate")
    def table_update(self) -> Optional[pulumi.Input['JobTriggerTableUpdateArgs']]:
        return pulumi.get(self, "table_update")

    @table_update.setter
    def table_update(self, value: Optional[pulumi.Input['JobTriggerTableUpdateArgs']]):
        pulumi.set(self, "table_update", value)


if not MYPY:
    class JobTriggerFileArrivalArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL to be monitored for file arrivals. The path must point to the root or a subpath of the external location. Please note that the URL must have a trailing slash character (`/`).
        """
        min_time_between_triggers_seconds: NotRequired[pulumi.Input[int]]
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        wait_after_last_change_seconds: NotRequired[pulumi.Input[int]]
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
elif False:
    JobTriggerFileArrivalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTriggerFileArrivalArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 min_time_between_triggers_seconds: Optional[pulumi.Input[int]] = None,
                 wait_after_last_change_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] url: URL to be monitored for file arrivals. The path must point to the root or a subpath of the external location. Please note that the URL must have a trailing slash character (`/`).
        :param pulumi.Input[int] min_time_between_triggers_seconds: If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        :param pulumi.Input[int] wait_after_last_change_seconds: If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        pulumi.set(__self__, "url", url)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL to be monitored for file arrivals. The path must point to the root or a subpath of the external location. Please note that the URL must have a trailing slash character (`/`).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


if not MYPY:
    class JobTriggerPeriodicArgsDict(TypedDict):
        interval: pulumi.Input[int]
        """
        Specifies the interval at which the job should run. This value is required.
        """
        unit: pulumi.Input[str]
        """
        Options are {"DAYS", "HOURS", "WEEKS"}.
        """
elif False:
    JobTriggerPeriodicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTriggerPeriodicArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[int],
                 unit: pulumi.Input[str]):
        """
        :param pulumi.Input[int] interval: Specifies the interval at which the job should run. This value is required.
        :param pulumi.Input[str] unit: Options are {"DAYS", "HOURS", "WEEKS"}.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        Specifies the interval at which the job should run. This value is required.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        Options are {"DAYS", "HOURS", "WEEKS"}.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class JobTriggerTableArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[str]]
        min_time_between_triggers_seconds: NotRequired[pulumi.Input[int]]
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        table_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        wait_after_last_change_seconds: NotRequired[pulumi.Input[int]]
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
elif False:
    JobTriggerTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTriggerTableArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 min_time_between_triggers_seconds: Optional[pulumi.Input[int]] = None,
                 table_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 wait_after_last_change_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] min_time_between_triggers_seconds: If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        :param pulumi.Input[int] wait_after_last_change_seconds: If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if table_names is not None:
            pulumi.set(__self__, "table_names", table_names)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "table_names", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


if not MYPY:
    class JobTriggerTableUpdateArgsDict(TypedDict):
        table_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        condition: NotRequired[pulumi.Input[str]]
        min_time_between_triggers_seconds: NotRequired[pulumi.Input[int]]
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        wait_after_last_change_seconds: NotRequired[pulumi.Input[int]]
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
elif False:
    JobTriggerTableUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTriggerTableUpdateArgs:
    def __init__(__self__, *,
                 table_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 condition: Optional[pulumi.Input[str]] = None,
                 min_time_between_triggers_seconds: Optional[pulumi.Input[int]] = None,
                 wait_after_last_change_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] min_time_between_triggers_seconds: If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        :param pulumi.Input[int] wait_after_last_change_seconds: If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        pulumi.set(__self__, "table_names", table_names)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "table_names", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


if not MYPY:
    class JobWebhookNotificationsArgsDict(TypedDict):
        on_duration_warning_threshold_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgsDict']]]]
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        on_failures: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgsDict']]]]
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        on_starts: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgsDict']]]]
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        on_streaming_backlog_exceededs: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStreamingBacklogExceededArgsDict']]]]
        on_successes: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgsDict']]]]
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
elif False:
    JobWebhookNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]] = None,
                 on_streaming_backlog_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStreamingBacklogExceededArgs']]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStreamingBacklogExceededArgs']]]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStreamingBacklogExceededArgs']]]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class JobWebhookNotificationsOnDurationWarningThresholdExceededArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobWebhookNotificationsOnDurationWarningThresholdExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobWebhookNotificationsOnFailureArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobWebhookNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobWebhookNotificationsOnStartArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobWebhookNotificationsOnStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobWebhookNotificationsOnStreamingBacklogExceededArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobWebhookNotificationsOnStreamingBacklogExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobWebhookNotificationsOnStreamingBacklogExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class JobWebhookNotificationsOnSuccessArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the job
        """
elif False:
    JobWebhookNotificationsOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LakehouseMonitorCustomMetricArgsDict(TypedDict):
        definition: pulumi.Input[str]
        """
        [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        input_columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Columns on the monitored table to apply the custom metrics to.
        """
        name: pulumi.Input[str]
        """
        Name of the custom metric.
        """
        output_data_type: pulumi.Input[str]
        """
        The output type of the custom metric.
        """
        type: pulumi.Input[str]
        """
        The type of the custom metric.
        """
elif False:
    LakehouseMonitorCustomMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorCustomMetricArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 input_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 output_data_type: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] definition: [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_columns: Columns on the monitored table to apply the custom metrics to.
        :param pulumi.Input[str] name: Name of the custom metric.
        :param pulumi.Input[str] output_data_type: The output type of the custom metric.
        :param pulumi.Input[str] type: The type of the custom metric.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Columns on the monitored table to apply the custom metrics to.
        """
        return pulumi.get(self, "input_columns")

    @input_columns.setter
    def input_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "input_columns", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom metric.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> pulumi.Input[str]:
        """
        The output type of the custom metric.
        """
        return pulumi.get(self, "output_data_type")

    @output_data_type.setter
    def output_data_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_data_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the custom metric.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LakehouseMonitorDataClassificationConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    LakehouseMonitorDataClassificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorDataClassificationConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LakehouseMonitorInferenceLogArgsDict(TypedDict):
        granularities: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        model_id_col: pulumi.Input[str]
        """
        Column of the model id or version
        """
        prediction_col: pulumi.Input[str]
        """
        Column of the model prediction
        """
        problem_type: pulumi.Input[str]
        """
        Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        """
        timestamp_col: pulumi.Input[str]
        """
        Column of the timestamp of predictions
        """
        label_col: NotRequired[pulumi.Input[str]]
        """
        Column of the model label
        """
        prediction_proba_col: NotRequired[pulumi.Input[str]]
        """
        Column of the model prediction probabilities
        """
elif False:
    LakehouseMonitorInferenceLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorInferenceLogArgs:
    def __init__(__self__, *,
                 granularities: pulumi.Input[Sequence[pulumi.Input[str]]],
                 model_id_col: pulumi.Input[str],
                 prediction_col: pulumi.Input[str],
                 problem_type: pulumi.Input[str],
                 timestamp_col: pulumi.Input[str],
                 label_col: Optional[pulumi.Input[str]] = None,
                 prediction_proba_col: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param pulumi.Input[str] model_id_col: Column of the model id or version
        :param pulumi.Input[str] prediction_col: Column of the model prediction
        :param pulumi.Input[str] problem_type: Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        :param pulumi.Input[str] timestamp_col: Column of the timestamp of predictions
        :param pulumi.Input[str] label_col: Column of the model label
        :param pulumi.Input[str] prediction_proba_col: Column of the model prediction probabilities
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_col", model_id_col)
        pulumi.set(__self__, "prediction_col", prediction_col)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_col", timestamp_col)
        if label_col is not None:
            pulumi.set(__self__, "label_col", label_col)
        if prediction_proba_col is not None:
            pulumi.set(__self__, "prediction_proba_col", prediction_proba_col)

    @property
    @pulumi.getter
    def granularities(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @granularities.setter
    def granularities(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "granularities", value)

    @property
    @pulumi.getter(name="modelIdCol")
    def model_id_col(self) -> pulumi.Input[str]:
        """
        Column of the model id or version
        """
        return pulumi.get(self, "model_id_col")

    @model_id_col.setter
    def model_id_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_id_col", value)

    @property
    @pulumi.getter(name="predictionCol")
    def prediction_col(self) -> pulumi.Input[str]:
        """
        Column of the model prediction
        """
        return pulumi.get(self, "prediction_col")

    @prediction_col.setter
    def prediction_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "prediction_col", value)

    @property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> pulumi.Input[str]:
        """
        Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @problem_type.setter
    def problem_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "problem_type", value)

    @property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> pulumi.Input[str]:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")

    @timestamp_col.setter
    def timestamp_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "timestamp_col", value)

    @property
    @pulumi.getter(name="labelCol")
    def label_col(self) -> Optional[pulumi.Input[str]]:
        """
        Column of the model label
        """
        return pulumi.get(self, "label_col")

    @label_col.setter
    def label_col(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label_col", value)

    @property
    @pulumi.getter(name="predictionProbaCol")
    def prediction_proba_col(self) -> Optional[pulumi.Input[str]]:
        """
        Column of the model prediction probabilities
        """
        return pulumi.get(self, "prediction_proba_col")

    @prediction_proba_col.setter
    def prediction_proba_col(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prediction_proba_col", value)


if not MYPY:
    class LakehouseMonitorNotificationsArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['LakehouseMonitorNotificationsOnFailureArgsDict']]
        """
        who to send notifications to on monitor failure.
        """
        on_new_classification_tag_detected: NotRequired[pulumi.Input['LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgsDict']]
        """
        Who to send notifications to when new data classification tags are detected.
        """
elif False:
    LakehouseMonitorNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorNotificationsArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['LakehouseMonitorNotificationsOnFailureArgs']] = None,
                 on_new_classification_tag_detected: Optional[pulumi.Input['LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs']] = None):
        """
        :param pulumi.Input['LakehouseMonitorNotificationsOnFailureArgs'] on_failure: who to send notifications to on monitor failure.
        :param pulumi.Input['LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs'] on_new_classification_tag_detected: Who to send notifications to when new data classification tags are detected.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_new_classification_tag_detected is not None:
            pulumi.set(__self__, "on_new_classification_tag_detected", on_new_classification_tag_detected)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['LakehouseMonitorNotificationsOnFailureArgs']]:
        """
        who to send notifications to on monitor failure.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['LakehouseMonitorNotificationsOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onNewClassificationTagDetected")
    def on_new_classification_tag_detected(self) -> Optional[pulumi.Input['LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs']]:
        """
        Who to send notifications to when new data classification tags are detected.
        """
        return pulumi.get(self, "on_new_classification_tag_detected")

    @on_new_classification_tag_detected.setter
    def on_new_classification_tag_detected(self, value: Optional[pulumi.Input['LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs']]):
        pulumi.set(self, "on_new_classification_tag_detected", value)


if not MYPY:
    class LakehouseMonitorNotificationsOnFailureArgsDict(TypedDict):
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    LakehouseMonitorNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)


if not MYPY:
    class LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgsDict(TypedDict):
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs:
    def __init__(__self__, *,
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)


if not MYPY:
    class LakehouseMonitorScheduleArgsDict(TypedDict):
        quartz_cron_expression: pulumi.Input[str]
        """
        string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        """
        timezone_id: pulumi.Input[str]
        """
        string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        pause_status: NotRequired[pulumi.Input[str]]
        """
        optional string field that indicates whether a schedule is paused (`PAUSED`) or not (`UNPAUSED`).
        """
elif False:
    LakehouseMonitorScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorScheduleArgs:
    def __init__(__self__, *,
                 quartz_cron_expression: pulumi.Input[str],
                 timezone_id: pulumi.Input[str],
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] quartz_cron_expression: string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        :param pulumi.Input[str] timezone_id: string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        :param pulumi.Input[str] pause_status: optional string field that indicates whether a schedule is paused (`PAUSED`) or not (`UNPAUSED`).
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> pulumi.Input[str]:
        """
        string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @quartz_cron_expression.setter
    def quartz_cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "quartz_cron_expression", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> pulumi.Input[str]:
        """
        string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone_id", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        optional string field that indicates whether a schedule is paused (`PAUSED`) or not (`UNPAUSED`).
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


if not MYPY:
    class LakehouseMonitorSnapshotArgsDict(TypedDict):
        pass
elif False:
    LakehouseMonitorSnapshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorSnapshotArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class LakehouseMonitorTimeSeriesArgsDict(TypedDict):
        granularities: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        timestamp_col: pulumi.Input[str]
        """
        Column of the timestamp of predictions
        """
elif False:
    LakehouseMonitorTimeSeriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LakehouseMonitorTimeSeriesArgs:
    def __init__(__self__, *,
                 granularities: pulumi.Input[Sequence[pulumi.Input[str]]],
                 timestamp_col: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param pulumi.Input[str] timestamp_col: Column of the timestamp of predictions
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_col", timestamp_col)

    @property
    @pulumi.getter
    def granularities(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @granularities.setter
    def granularities(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "granularities", value)

    @property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> pulumi.Input[str]:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")

    @timestamp_col.setter
    def timestamp_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "timestamp_col", value)


if not MYPY:
    class LibraryCranArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    LibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class LibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    LibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class LibraryPypiArgsDict(TypedDict):
        package: pulumi.Input[str]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    LibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class MetastoreDataAccessAwsIamRoleArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        external_id: NotRequired[pulumi.Input[str]]
        unity_catalog_iam_arn: NotRequired[pulumi.Input[str]]
elif False:
    MetastoreDataAccessAwsIamRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetastoreDataAccessAwsIamRoleArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 external_id: Optional[pulumi.Input[str]] = None,
                 unity_catalog_iam_arn: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unity_catalog_iam_arn")

    @unity_catalog_iam_arn.setter
    def unity_catalog_iam_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unity_catalog_iam_arn", value)


if not MYPY:
    class MetastoreDataAccessAzureManagedIdentityArgsDict(TypedDict):
        access_connector_id: pulumi.Input[str]
        credential_id: NotRequired[pulumi.Input[str]]
        managed_identity_id: NotRequired[pulumi.Input[str]]
elif False:
    MetastoreDataAccessAzureManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetastoreDataAccessAzureManagedIdentityArgs:
    def __init__(__self__, *,
                 access_connector_id: pulumi.Input[str],
                 credential_id: Optional[pulumi.Input[str]] = None,
                 managed_identity_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "access_connector_id")

    @access_connector_id.setter
    def access_connector_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_connector_id", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "managed_identity_id")

    @managed_identity_id.setter
    def managed_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_identity_id", value)


if not MYPY:
    class MetastoreDataAccessAzureServicePrincipalArgsDict(TypedDict):
        application_id: pulumi.Input[str]
        client_secret: pulumi.Input[str]
        directory_id: pulumi.Input[str]
elif False:
    MetastoreDataAccessAzureServicePrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetastoreDataAccessAzureServicePrincipalArgs:
    def __init__(__self__, *,
                 application_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 directory_id: pulumi.Input[str]):
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "directory_id", value)


if not MYPY:
    class MetastoreDataAccessCloudflareApiTokenArgsDict(TypedDict):
        access_key_id: pulumi.Input[str]
        account_id: pulumi.Input[str]
        secret_access_key: pulumi.Input[str]
elif False:
    MetastoreDataAccessCloudflareApiTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetastoreDataAccessCloudflareApiTokenArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[str],
                 account_id: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str]):
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class MetastoreDataAccessDatabricksGcpServiceAccountArgsDict(TypedDict):
        credential_id: NotRequired[pulumi.Input[str]]
        email: NotRequired[pulumi.Input[str]]
elif False:
    MetastoreDataAccessDatabricksGcpServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetastoreDataAccessDatabricksGcpServiceAccountArgs:
    def __init__(__self__, *,
                 credential_id: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None):
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


if not MYPY:
    class MetastoreDataAccessGcpServiceAccountKeyArgsDict(TypedDict):
        email: pulumi.Input[str]
        private_key: pulumi.Input[str]
        private_key_id: pulumi.Input[str]
elif False:
    MetastoreDataAccessGcpServiceAccountKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetastoreDataAccessGcpServiceAccountKeyArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 private_key_id: pulumi.Input[str]):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_id", value)


if not MYPY:
    class MlflowModelTagArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    MlflowModelTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlflowModelTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MlflowWebhookHttpUrlSpecArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        """
        authorization: NotRequired[pulumi.Input[str]]
        """
        Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        """
        enable_ssl_verification: NotRequired[pulumi.Input[bool]]
        """
        Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
elif False:
    MlflowWebhookHttpUrlSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlflowWebhookHttpUrlSpecArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization: Optional[pulumi.Input[str]] = None,
                 enable_ssl_verification: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        :param pulumi.Input[str] authorization: Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        :param pulumi.Input[bool] enable_ssl_verification: Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        :param pulumi.Input[str] secret: Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
        pulumi.set(__self__, "url", url)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if enable_ssl_verification is not None:
            pulumi.set(__self__, "enable_ssl_verification", enable_ssl_verification)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="enableSslVerification")
    def enable_ssl_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        """
        return pulumi.get(self, "enable_ssl_verification")

    @enable_ssl_verification.setter
    def enable_ssl_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ssl_verification", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class MlflowWebhookJobSpecArgsDict(TypedDict):
        access_token: pulumi.Input[str]
        """
        The personal access token used to authorize webhook's job runs.
        """
        job_id: pulumi.Input[str]
        """
        ID of the Databricks job that the webhook runs.
        """
        workspace_url: NotRequired[pulumi.Input[str]]
        """
        URL of the workspace containing the job that this webhook runs. If not specified, the job’s workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
elif False:
    MlflowWebhookJobSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MlflowWebhookJobSpecArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 job_id: pulumi.Input[str],
                 workspace_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The personal access token used to authorize webhook's job runs.
        :param pulumi.Input[str] job_id: ID of the Databricks job that the webhook runs.
        :param pulumi.Input[str] workspace_url: URL of the workspace containing the job that this webhook runs. If not specified, the job’s workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "job_id", job_id)
        if workspace_url is not None:
            pulumi.set(__self__, "workspace_url", workspace_url)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The personal access token used to authorize webhook's job runs.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[str]:
        """
        ID of the Databricks job that the webhook runs.
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="workspaceUrl")
    def workspace_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the workspace containing the job that this webhook runs. If not specified, the job’s workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        return pulumi.get(self, "workspace_url")

    @workspace_url.setter
    def workspace_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_url", value)


if not MYPY:
    class ModelServingAiGatewayArgsDict(TypedDict):
        guardrails: NotRequired[pulumi.Input['ModelServingAiGatewayGuardrailsArgsDict']]
        """
        Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        """
        inference_table_config: NotRequired[pulumi.Input['ModelServingAiGatewayInferenceTableConfigArgsDict']]
        """
        Block describing the configuration of usage tracking. Consists of the following attributes:
        """
        rate_limits: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelServingAiGatewayRateLimitArgsDict']]]]
        """
        Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        """
        usage_tracking_config: NotRequired[pulumi.Input['ModelServingAiGatewayUsageTrackingConfigArgsDict']]
        """
        Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
elif False:
    ModelServingAiGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayArgs:
    def __init__(__self__, *,
                 guardrails: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsArgs']] = None,
                 inference_table_config: Optional[pulumi.Input['ModelServingAiGatewayInferenceTableConfigArgs']] = None,
                 rate_limits: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingAiGatewayRateLimitArgs']]]] = None,
                 usage_tracking_config: Optional[pulumi.Input['ModelServingAiGatewayUsageTrackingConfigArgs']] = None):
        """
        :param pulumi.Input['ModelServingAiGatewayGuardrailsArgs'] guardrails: Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        :param pulumi.Input['ModelServingAiGatewayInferenceTableConfigArgs'] inference_table_config: Block describing the configuration of usage tracking. Consists of the following attributes:
        :param pulumi.Input[Sequence[pulumi.Input['ModelServingAiGatewayRateLimitArgs']]] rate_limits: Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        :param pulumi.Input['ModelServingAiGatewayUsageTrackingConfigArgs'] usage_tracking_config: Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if inference_table_config is not None:
            pulumi.set(__self__, "inference_table_config", inference_table_config)
        if rate_limits is not None:
            pulumi.set(__self__, "rate_limits", rate_limits)
        if usage_tracking_config is not None:
            pulumi.set(__self__, "usage_tracking_config", usage_tracking_config)

    @property
    @pulumi.getter
    def guardrails(self) -> Optional[pulumi.Input['ModelServingAiGatewayGuardrailsArgs']]:
        """
        Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        """
        return pulumi.get(self, "guardrails")

    @guardrails.setter
    def guardrails(self, value: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsArgs']]):
        pulumi.set(self, "guardrails", value)

    @property
    @pulumi.getter(name="inferenceTableConfig")
    def inference_table_config(self) -> Optional[pulumi.Input['ModelServingAiGatewayInferenceTableConfigArgs']]:
        """
        Block describing the configuration of usage tracking. Consists of the following attributes:
        """
        return pulumi.get(self, "inference_table_config")

    @inference_table_config.setter
    def inference_table_config(self, value: Optional[pulumi.Input['ModelServingAiGatewayInferenceTableConfigArgs']]):
        pulumi.set(self, "inference_table_config", value)

    @property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingAiGatewayRateLimitArgs']]]]:
        """
        Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        """
        return pulumi.get(self, "rate_limits")

    @rate_limits.setter
    def rate_limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingAiGatewayRateLimitArgs']]]]):
        pulumi.set(self, "rate_limits", value)

    @property
    @pulumi.getter(name="usageTrackingConfig")
    def usage_tracking_config(self) -> Optional[pulumi.Input['ModelServingAiGatewayUsageTrackingConfigArgs']]:
        """
        Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
        return pulumi.get(self, "usage_tracking_config")

    @usage_tracking_config.setter
    def usage_tracking_config(self, value: Optional[pulumi.Input['ModelServingAiGatewayUsageTrackingConfigArgs']]):
        pulumi.set(self, "usage_tracking_config", value)


if not MYPY:
    class ModelServingAiGatewayGuardrailsArgsDict(TypedDict):
        input: NotRequired[pulumi.Input['ModelServingAiGatewayGuardrailsInputArgsDict']]
        """
        A block with configuration for input guardrail filters:
        """
        output: NotRequired[pulumi.Input['ModelServingAiGatewayGuardrailsOutputArgsDict']]
        """
        A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
elif False:
    ModelServingAiGatewayGuardrailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayGuardrailsArgs:
    def __init__(__self__, *,
                 input: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsInputArgs']] = None,
                 output: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsOutputArgs']] = None):
        """
        :param pulumi.Input['ModelServingAiGatewayGuardrailsInputArgs'] input: A block with configuration for input guardrail filters:
        :param pulumi.Input['ModelServingAiGatewayGuardrailsOutputArgs'] output: A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input['ModelServingAiGatewayGuardrailsInputArgs']]:
        """
        A block with configuration for input guardrail filters:
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsInputArgs']]):
        pulumi.set(self, "input", value)

    @property
    @pulumi.getter
    def output(self) -> Optional[pulumi.Input['ModelServingAiGatewayGuardrailsOutputArgs']]:
        """
        A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsOutputArgs']]):
        pulumi.set(self, "output", value)


if not MYPY:
    class ModelServingAiGatewayGuardrailsInputArgsDict(TypedDict):
        invalid_keywords: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        pii: NotRequired[pulumi.Input['ModelServingAiGatewayGuardrailsInputPiiArgsDict']]
        """
        Block with configuration for guardrail PII filter:
        """
        safety: NotRequired[pulumi.Input[bool]]
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        valid_topics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
elif False:
    ModelServingAiGatewayGuardrailsInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayGuardrailsInputArgs:
    def __init__(__self__, *,
                 invalid_keywords: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pii: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsInputPiiArgs']] = None,
                 safety: Optional[pulumi.Input[bool]] = None,
                 valid_topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] invalid_keywords: List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        :param pulumi.Input['ModelServingAiGatewayGuardrailsInputPiiArgs'] pii: Block with configuration for guardrail PII filter:
        :param pulumi.Input[bool] safety: the boolean flag that indicates whether the safety filter is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_topics: The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if pii is not None:
            pulumi.set(__self__, "pii", pii)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @property
    @pulumi.getter(name="invalidKeywords")
    def invalid_keywords(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        return pulumi.get(self, "invalid_keywords")

    @invalid_keywords.setter
    def invalid_keywords(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "invalid_keywords", value)

    @property
    @pulumi.getter
    def pii(self) -> Optional[pulumi.Input['ModelServingAiGatewayGuardrailsInputPiiArgs']]:
        """
        Block with configuration for guardrail PII filter:
        """
        return pulumi.get(self, "pii")

    @pii.setter
    def pii(self, value: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsInputPiiArgs']]):
        pulumi.set(self, "pii", value)

    @property
    @pulumi.getter
    def safety(self) -> Optional[pulumi.Input[bool]]:
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        return pulumi.get(self, "safety")

    @safety.setter
    def safety(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "safety", value)

    @property
    @pulumi.getter(name="validTopics")
    def valid_topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        return pulumi.get(self, "valid_topics")

    @valid_topics.setter
    def valid_topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "valid_topics", value)


if not MYPY:
    class ModelServingAiGatewayGuardrailsInputPiiArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
elif False:
    ModelServingAiGatewayGuardrailsInputPiiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayGuardrailsInputPiiArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior: a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        pulumi.set(__self__, "behavior", behavior)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)


if not MYPY:
    class ModelServingAiGatewayGuardrailsOutputArgsDict(TypedDict):
        invalid_keywords: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        pii: NotRequired[pulumi.Input['ModelServingAiGatewayGuardrailsOutputPiiArgsDict']]
        """
        Block with configuration for guardrail PII filter:
        """
        safety: NotRequired[pulumi.Input[bool]]
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        valid_topics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
elif False:
    ModelServingAiGatewayGuardrailsOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayGuardrailsOutputArgs:
    def __init__(__self__, *,
                 invalid_keywords: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pii: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsOutputPiiArgs']] = None,
                 safety: Optional[pulumi.Input[bool]] = None,
                 valid_topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] invalid_keywords: List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        :param pulumi.Input['ModelServingAiGatewayGuardrailsOutputPiiArgs'] pii: Block with configuration for guardrail PII filter:
        :param pulumi.Input[bool] safety: the boolean flag that indicates whether the safety filter is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] valid_topics: The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if pii is not None:
            pulumi.set(__self__, "pii", pii)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @property
    @pulumi.getter(name="invalidKeywords")
    def invalid_keywords(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        return pulumi.get(self, "invalid_keywords")

    @invalid_keywords.setter
    def invalid_keywords(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "invalid_keywords", value)

    @property
    @pulumi.getter
    def pii(self) -> Optional[pulumi.Input['ModelServingAiGatewayGuardrailsOutputPiiArgs']]:
        """
        Block with configuration for guardrail PII filter:
        """
        return pulumi.get(self, "pii")

    @pii.setter
    def pii(self, value: Optional[pulumi.Input['ModelServingAiGatewayGuardrailsOutputPiiArgs']]):
        pulumi.set(self, "pii", value)

    @property
    @pulumi.getter
    def safety(self) -> Optional[pulumi.Input[bool]]:
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        return pulumi.get(self, "safety")

    @safety.setter
    def safety(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "safety", value)

    @property
    @pulumi.getter(name="validTopics")
    def valid_topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        return pulumi.get(self, "valid_topics")

    @valid_topics.setter
    def valid_topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "valid_topics", value)


if not MYPY:
    class ModelServingAiGatewayGuardrailsOutputPiiArgsDict(TypedDict):
        behavior: pulumi.Input[str]
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
elif False:
    ModelServingAiGatewayGuardrailsOutputPiiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayGuardrailsOutputPiiArgs:
    def __init__(__self__, *,
                 behavior: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior: a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        pulumi.set(__self__, "behavior", behavior)

    @property
    @pulumi.getter
    def behavior(self) -> pulumi.Input[str]:
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior", value)


if not MYPY:
    class ModelServingAiGatewayInferenceTableConfigArgsDict(TypedDict):
        catalog_name: NotRequired[pulumi.Input[str]]
        """
        The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        boolean flag specifying if usage tracking is enabled.
        """
        schema_name: NotRequired[pulumi.Input[str]]
        """
        The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        """
        table_name_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
elif False:
    ModelServingAiGatewayInferenceTableConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayInferenceTableConfigArgs:
    def __init__(__self__, *,
                 catalog_name: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 schema_name: Optional[pulumi.Input[str]] = None,
                 table_name_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] catalog_name: The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        :param pulumi.Input[bool] enabled: boolean flag specifying if usage tracking is enabled.
        :param pulumi.Input[str] schema_name: The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        :param pulumi.Input[str] table_name_prefix: The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if table_name_prefix is not None:
            pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        boolean flag specifying if usage tracking is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_name", value)

    @property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        return pulumi.get(self, "table_name_prefix")

    @table_name_prefix.setter
    def table_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_name_prefix", value)


if not MYPY:
    class ModelServingAiGatewayRateLimitArgsDict(TypedDict):
        calls: pulumi.Input[int]
        """
        Used to specify how many calls are allowed for a key within the renewal_period.
        """
        renewal_period: pulumi.Input[str]
        """
        Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key field for a serving endpoint rate limit. Currently, only `user` and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
elif False:
    ModelServingAiGatewayRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayRateLimitArgs:
    def __init__(__self__, *,
                 calls: pulumi.Input[int],
                 renewal_period: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] calls: Used to specify how many calls are allowed for a key within the renewal_period.
        :param pulumi.Input[str] renewal_period: Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        :param pulumi.Input[str] key: Key field for a serving endpoint rate limit. Currently, only `user` and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        pulumi.set(__self__, "calls", calls)
        pulumi.set(__self__, "renewal_period", renewal_period)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def calls(self) -> pulumi.Input[int]:
        """
        Used to specify how many calls are allowed for a key within the renewal_period.
        """
        return pulumi.get(self, "calls")

    @calls.setter
    def calls(self, value: pulumi.Input[int]):
        pulumi.set(self, "calls", value)

    @property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> pulumi.Input[str]:
        """
        Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        """
        return pulumi.get(self, "renewal_period")

    @renewal_period.setter
    def renewal_period(self, value: pulumi.Input[str]):
        pulumi.set(self, "renewal_period", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key field for a serving endpoint rate limit. Currently, only `user` and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ModelServingAiGatewayUsageTrackingConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    ModelServingAiGatewayUsageTrackingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingAiGatewayUsageTrackingConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ModelServingConfigArgsDict(TypedDict):
        auto_capture_config: NotRequired[pulumi.Input['ModelServingConfigAutoCaptureConfigArgsDict']]
        """
        Configuration for Inference Tables which automatically logs requests and responses to Unity Catalog.
        """
        served_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedEntityArgsDict']]]]
        """
        A list of served entities for the endpoint to serve. A serving endpoint can have up to 10 served entities.
        """
        served_models: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgsDict']]]]
        """
        Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        """
        traffic_config: NotRequired[pulumi.Input['ModelServingConfigTrafficConfigArgsDict']]
        """
        A single block represents the traffic split configuration amongst the served models.
        """
elif False:
    ModelServingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigArgs:
    def __init__(__self__, *,
                 auto_capture_config: Optional[pulumi.Input['ModelServingConfigAutoCaptureConfigArgs']] = None,
                 served_entities: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedEntityArgs']]]] = None,
                 served_models: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]]] = None,
                 traffic_config: Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']] = None):
        """
        :param pulumi.Input['ModelServingConfigAutoCaptureConfigArgs'] auto_capture_config: Configuration for Inference Tables which automatically logs requests and responses to Unity Catalog.
        :param pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedEntityArgs']]] served_entities: A list of served entities for the endpoint to serve. A serving endpoint can have up to 10 served entities.
        :param pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]] served_models: Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        :param pulumi.Input['ModelServingConfigTrafficConfigArgs'] traffic_config: A single block represents the traffic split configuration amongst the served models.
        """
        if auto_capture_config is not None:
            pulumi.set(__self__, "auto_capture_config", auto_capture_config)
        if served_entities is not None:
            pulumi.set(__self__, "served_entities", served_entities)
        if served_models is not None:
            warnings.warn("""Please use 'config.served_entities' instead of 'config.served_models'.""", DeprecationWarning)
            pulumi.log.warn("""served_models is deprecated: Please use 'config.served_entities' instead of 'config.served_models'.""")
        if served_models is not None:
            pulumi.set(__self__, "served_models", served_models)
        if traffic_config is not None:
            pulumi.set(__self__, "traffic_config", traffic_config)

    @property
    @pulumi.getter(name="autoCaptureConfig")
    def auto_capture_config(self) -> Optional[pulumi.Input['ModelServingConfigAutoCaptureConfigArgs']]:
        """
        Configuration for Inference Tables which automatically logs requests and responses to Unity Catalog.
        """
        return pulumi.get(self, "auto_capture_config")

    @auto_capture_config.setter
    def auto_capture_config(self, value: Optional[pulumi.Input['ModelServingConfigAutoCaptureConfigArgs']]):
        pulumi.set(self, "auto_capture_config", value)

    @property
    @pulumi.getter(name="servedEntities")
    def served_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedEntityArgs']]]]:
        """
        A list of served entities for the endpoint to serve. A serving endpoint can have up to 10 served entities.
        """
        return pulumi.get(self, "served_entities")

    @served_entities.setter
    def served_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedEntityArgs']]]]):
        pulumi.set(self, "served_entities", value)

    @property
    @pulumi.getter(name="servedModels")
    @_utilities.deprecated("""Please use 'config.served_entities' instead of 'config.served_models'.""")
    def served_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]]]:
        """
        Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        """
        return pulumi.get(self, "served_models")

    @served_models.setter
    def served_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]]]):
        pulumi.set(self, "served_models", value)

    @property
    @pulumi.getter(name="trafficConfig")
    def traffic_config(self) -> Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']]:
        """
        A single block represents the traffic split configuration amongst the served models.
        """
        return pulumi.get(self, "traffic_config")

    @traffic_config.setter
    def traffic_config(self, value: Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']]):
        pulumi.set(self, "traffic_config", value)


if not MYPY:
    class ModelServingConfigAutoCaptureConfigArgsDict(TypedDict):
        catalog_name: NotRequired[pulumi.Input[str]]
        """
        The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        If inference tables are enabled or not. NOTE: If you have already disabled payload logging once, you cannot enable it again.
        """
        schema_name: NotRequired[pulumi.Input[str]]
        """
        The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        """
        table_name_prefix: NotRequired[pulumi.Input[str]]
        """
        The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
elif False:
    ModelServingConfigAutoCaptureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigAutoCaptureConfigArgs:
    def __init__(__self__, *,
                 catalog_name: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 schema_name: Optional[pulumi.Input[str]] = None,
                 table_name_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] catalog_name: The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        :param pulumi.Input[bool] enabled: If inference tables are enabled or not. NOTE: If you have already disabled payload logging once, you cannot enable it again.
        :param pulumi.Input[str] schema_name: The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        :param pulumi.Input[str] table_name_prefix: The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if table_name_prefix is not None:
            pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If inference tables are enabled or not. NOTE: If you have already disabled payload logging once, you cannot enable it again.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_name", value)

    @property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        return pulumi.get(self, "table_name_prefix")

    @table_name_prefix.setter
    def table_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_name_prefix", value)


if not MYPY:
    class ModelServingConfigServedEntityArgsDict(TypedDict):
        entity_name: NotRequired[pulumi.Input[str]]
        """
        The name of the entity to be served. The entity may be a model in the Databricks Model Registry, a model in the Unity Catalog (UC), or a function of type `FEATURE_SPEC` in the UC. If it is a UC object, the full name of the object should be given in the form of `catalog_name.schema_name.model_name`.
        """
        entity_version: NotRequired[pulumi.Input[str]]
        """
        The version of the model in Databricks Model Registry to be served or empty if the entity is a `FEATURE_SPEC`.
        """
        environment_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        An object containing a set of optional, user-specified environment variable key-value pairs used for serving this entity. Note: this is an experimental feature and is subject to change. Example entity environment variables that refer to Databricks secrets: ```{"OPENAI_API_KEY": "{{secrets/my_scope/my_key}}", "DATABRICKS_TOKEN": "{{secrets/my_scope2/my_key2}}"}```
        """
        external_model: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelArgsDict']]
        """
        The external model to be served. NOTE: Only one of `external_model` and (`entity_name`, `entity_version`, `workload_size`, `workload_type`, and `scale_to_zero_enabled`) can be specified with the latter set being used for custom model serving for a Databricks registered model. When an `external_model` is present, the served entities list can only have one `served_entity` object. An existing endpoint with `external_model` can not be updated to an endpoint without `external_model`. If the endpoint is created without `external_model`, users cannot update it to add `external_model` later.
        """
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the instance profile that the served entity uses to access AWS resources.
        """
        max_provisioned_throughput: NotRequired[pulumi.Input[int]]
        """
        The maximum tokens per second that the endpoint can scale up to.
        """
        min_provisioned_throughput: NotRequired[pulumi.Input[int]]
        """
        The minimum tokens per second that the endpoint can scale down to.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field defaults to `external_model.name`, with '.' and ':' replaced with '-', and if not specified for other entities, it defaults to -.
        """
        scale_to_zero_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the compute resources for the served entity should scale down to zero.
        """
        workload_size: NotRequired[pulumi.Input[str]]
        """
        The workload size of the served entity. The workload size corresponds to a range of provisioned concurrency that the compute autoscales between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency). If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size is 0.
        """
        workload_type: NotRequired[pulumi.Input[str]]
        """
        The workload type of the served entity. The workload type selects which type of compute to use in the endpoint. The default value for this parameter is `CPU`. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the available [GPU types](https://docs.databricks.com/machine-learning/model-serving/create-manage-serving-endpoints.html#gpu-workload-types).
        """
elif False:
    ModelServingConfigServedEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityArgs:
    def __init__(__self__, *,
                 entity_name: Optional[pulumi.Input[str]] = None,
                 entity_version: Optional[pulumi.Input[str]] = None,
                 environment_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 external_model: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelArgs']] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 max_provisioned_throughput: Optional[pulumi.Input[int]] = None,
                 min_provisioned_throughput: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 scale_to_zero_enabled: Optional[pulumi.Input[bool]] = None,
                 workload_size: Optional[pulumi.Input[str]] = None,
                 workload_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entity_name: The name of the entity to be served. The entity may be a model in the Databricks Model Registry, a model in the Unity Catalog (UC), or a function of type `FEATURE_SPEC` in the UC. If it is a UC object, the full name of the object should be given in the form of `catalog_name.schema_name.model_name`.
        :param pulumi.Input[str] entity_version: The version of the model in Databricks Model Registry to be served or empty if the entity is a `FEATURE_SPEC`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_vars: An object containing a set of optional, user-specified environment variable key-value pairs used for serving this entity. Note: this is an experimental feature and is subject to change. Example entity environment variables that refer to Databricks secrets: ```{"OPENAI_API_KEY": "{{secrets/my_scope/my_key}}", "DATABRICKS_TOKEN": "{{secrets/my_scope2/my_key2}}"}```
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelArgs'] external_model: The external model to be served. NOTE: Only one of `external_model` and (`entity_name`, `entity_version`, `workload_size`, `workload_type`, and `scale_to_zero_enabled`) can be specified with the latter set being used for custom model serving for a Databricks registered model. When an `external_model` is present, the served entities list can only have one `served_entity` object. An existing endpoint with `external_model` can not be updated to an endpoint without `external_model`. If the endpoint is created without `external_model`, users cannot update it to add `external_model` later.
        :param pulumi.Input[str] instance_profile_arn: ARN of the instance profile that the served entity uses to access AWS resources.
        :param pulumi.Input[int] max_provisioned_throughput: The maximum tokens per second that the endpoint can scale up to.
        :param pulumi.Input[int] min_provisioned_throughput: The minimum tokens per second that the endpoint can scale down to.
        :param pulumi.Input[str] name: The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field defaults to `external_model.name`, with '.' and ':' replaced with '-', and if not specified for other entities, it defaults to -.
        :param pulumi.Input[bool] scale_to_zero_enabled: Whether the compute resources for the served entity should scale down to zero.
        :param pulumi.Input[str] workload_size: The workload size of the served entity. The workload size corresponds to a range of provisioned concurrency that the compute autoscales between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency). If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size is 0.
        :param pulumi.Input[str] workload_type: The workload type of the served entity. The workload type selects which type of compute to use in the endpoint. The default value for this parameter is `CPU`. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the available [GPU types](https://docs.databricks.com/machine-learning/model-serving/create-manage-serving-endpoints.html#gpu-workload-types).
        """
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if entity_version is not None:
            pulumi.set(__self__, "entity_version", entity_version)
        if environment_vars is not None:
            pulumi.set(__self__, "environment_vars", environment_vars)
        if external_model is not None:
            pulumi.set(__self__, "external_model", external_model)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if max_provisioned_throughput is not None:
            pulumi.set(__self__, "max_provisioned_throughput", max_provisioned_throughput)
        if min_provisioned_throughput is not None:
            pulumi.set(__self__, "min_provisioned_throughput", min_provisioned_throughput)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scale_to_zero_enabled is not None:
            pulumi.set(__self__, "scale_to_zero_enabled", scale_to_zero_enabled)
        if workload_size is not None:
            pulumi.set(__self__, "workload_size", workload_size)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the entity to be served. The entity may be a model in the Databricks Model Registry, a model in the Unity Catalog (UC), or a function of type `FEATURE_SPEC` in the UC. If it is a UC object, the full name of the object should be given in the form of `catalog_name.schema_name.model_name`.
        """
        return pulumi.get(self, "entity_name")

    @entity_name.setter
    def entity_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_name", value)

    @property
    @pulumi.getter(name="entityVersion")
    def entity_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the model in Databricks Model Registry to be served or empty if the entity is a `FEATURE_SPEC`.
        """
        return pulumi.get(self, "entity_version")

    @entity_version.setter
    def entity_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_version", value)

    @property
    @pulumi.getter(name="environmentVars")
    def environment_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        An object containing a set of optional, user-specified environment variable key-value pairs used for serving this entity. Note: this is an experimental feature and is subject to change. Example entity environment variables that refer to Databricks secrets: ```{"OPENAI_API_KEY": "{{secrets/my_scope/my_key}}", "DATABRICKS_TOKEN": "{{secrets/my_scope2/my_key2}}"}```
        """
        return pulumi.get(self, "environment_vars")

    @environment_vars.setter
    def environment_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_vars", value)

    @property
    @pulumi.getter(name="externalModel")
    def external_model(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelArgs']]:
        """
        The external model to be served. NOTE: Only one of `external_model` and (`entity_name`, `entity_version`, `workload_size`, `workload_type`, and `scale_to_zero_enabled`) can be specified with the latter set being used for custom model serving for a Databricks registered model. When an `external_model` is present, the served entities list can only have one `served_entity` object. An existing endpoint with `external_model` can not be updated to an endpoint without `external_model`. If the endpoint is created without `external_model`, users cannot update it to add `external_model` later.
        """
        return pulumi.get(self, "external_model")

    @external_model.setter
    def external_model(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelArgs']]):
        pulumi.set(self, "external_model", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the instance profile that the served entity uses to access AWS resources.
        """
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="maxProvisionedThroughput")
    def max_provisioned_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum tokens per second that the endpoint can scale up to.
        """
        return pulumi.get(self, "max_provisioned_throughput")

    @max_provisioned_throughput.setter
    def max_provisioned_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_provisioned_throughput", value)

    @property
    @pulumi.getter(name="minProvisionedThroughput")
    def min_provisioned_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum tokens per second that the endpoint can scale down to.
        """
        return pulumi.get(self, "min_provisioned_throughput")

    @min_provisioned_throughput.setter
    def min_provisioned_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_provisioned_throughput", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field defaults to `external_model.name`, with '.' and ':' replaced with '-', and if not specified for other entities, it defaults to -.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scaleToZeroEnabled")
    def scale_to_zero_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the compute resources for the served entity should scale down to zero.
        """
        return pulumi.get(self, "scale_to_zero_enabled")

    @scale_to_zero_enabled.setter
    def scale_to_zero_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scale_to_zero_enabled", value)

    @property
    @pulumi.getter(name="workloadSize")
    def workload_size(self) -> Optional[pulumi.Input[str]]:
        """
        The workload size of the served entity. The workload size corresponds to a range of provisioned concurrency that the compute autoscales between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency). If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size is 0.
        """
        return pulumi.get(self, "workload_size")

    @workload_size.setter
    def workload_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_size", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input[str]]:
        """
        The workload type of the served entity. The workload type selects which type of compute to use in the endpoint. The default value for this parameter is `CPU`. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the available [GPU types](https://docs.databricks.com/machine-learning/model-serving/create-manage-serving-endpoints.html#gpu-workload-types).
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the external model.
        """
        provider: pulumi.Input[str]
        """
        The name of the provider for the external model. Currently, the supported providers are `ai21labs`, `anthropic`, `amazon-bedrock`, `cohere`, `databricks-model-serving`, `google-cloud-vertex-ai`, `openai`, and `palm`.
        """
        task: pulumi.Input[str]
        """
        The task type of the external model.
        """
        ai21labs_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelAi21labsConfigArgsDict']]
        """
        AI21Labs Config
        """
        amazon_bedrock_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgsDict']]
        """
        Amazon Bedrock Config
        """
        anthropic_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelAnthropicConfigArgsDict']]
        """
        Anthropic Config
        """
        cohere_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelCohereConfigArgsDict']]
        """
        Cohere Config
        """
        databricks_model_serving_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgsDict']]
        """
        Databricks Model Serving Config
        """
        google_cloud_vertex_ai_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgsDict']]
        """
        Google Cloud Vertex AI Config.
        """
        openai_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelOpenaiConfigArgsDict']]
        """
        OpenAI Config
        """
        palm_config: NotRequired[pulumi.Input['ModelServingConfigServedEntityExternalModelPalmConfigArgsDict']]
        """
        PaLM Config
        """
elif False:
    ModelServingConfigServedEntityExternalModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 provider: pulumi.Input[str],
                 task: pulumi.Input[str],
                 ai21labs_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAi21labsConfigArgs']] = None,
                 amazon_bedrock_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs']] = None,
                 anthropic_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAnthropicConfigArgs']] = None,
                 cohere_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelCohereConfigArgs']] = None,
                 databricks_model_serving_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs']] = None,
                 google_cloud_vertex_ai_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs']] = None,
                 openai_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelOpenaiConfigArgs']] = None,
                 palm_config: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelPalmConfigArgs']] = None):
        """
        :param pulumi.Input[str] name: The name of the external model.
        :param pulumi.Input[str] provider: The name of the provider for the external model. Currently, the supported providers are `ai21labs`, `anthropic`, `amazon-bedrock`, `cohere`, `databricks-model-serving`, `google-cloud-vertex-ai`, `openai`, and `palm`.
        :param pulumi.Input[str] task: The task type of the external model.
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelAi21labsConfigArgs'] ai21labs_config: AI21Labs Config
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs'] amazon_bedrock_config: Amazon Bedrock Config
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelAnthropicConfigArgs'] anthropic_config: Anthropic Config
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelCohereConfigArgs'] cohere_config: Cohere Config
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs'] databricks_model_serving_config: Databricks Model Serving Config
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs'] google_cloud_vertex_ai_config: Google Cloud Vertex AI Config.
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelOpenaiConfigArgs'] openai_config: OpenAI Config
        :param pulumi.Input['ModelServingConfigServedEntityExternalModelPalmConfigArgs'] palm_config: PaLM Config
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "task", task)
        if ai21labs_config is not None:
            pulumi.set(__self__, "ai21labs_config", ai21labs_config)
        if amazon_bedrock_config is not None:
            pulumi.set(__self__, "amazon_bedrock_config", amazon_bedrock_config)
        if anthropic_config is not None:
            pulumi.set(__self__, "anthropic_config", anthropic_config)
        if cohere_config is not None:
            pulumi.set(__self__, "cohere_config", cohere_config)
        if databricks_model_serving_config is not None:
            pulumi.set(__self__, "databricks_model_serving_config", databricks_model_serving_config)
        if google_cloud_vertex_ai_config is not None:
            pulumi.set(__self__, "google_cloud_vertex_ai_config", google_cloud_vertex_ai_config)
        if openai_config is not None:
            pulumi.set(__self__, "openai_config", openai_config)
        if palm_config is not None:
            pulumi.set(__self__, "palm_config", palm_config)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the external model.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        """
        The name of the provider for the external model. Currently, the supported providers are `ai21labs`, `anthropic`, `amazon-bedrock`, `cohere`, `databricks-model-serving`, `google-cloud-vertex-ai`, `openai`, and `palm`.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def task(self) -> pulumi.Input[str]:
        """
        The task type of the external model.
        """
        return pulumi.get(self, "task")

    @task.setter
    def task(self, value: pulumi.Input[str]):
        pulumi.set(self, "task", value)

    @property
    @pulumi.getter(name="ai21labsConfig")
    def ai21labs_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAi21labsConfigArgs']]:
        """
        AI21Labs Config
        """
        return pulumi.get(self, "ai21labs_config")

    @ai21labs_config.setter
    def ai21labs_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAi21labsConfigArgs']]):
        pulumi.set(self, "ai21labs_config", value)

    @property
    @pulumi.getter(name="amazonBedrockConfig")
    def amazon_bedrock_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs']]:
        """
        Amazon Bedrock Config
        """
        return pulumi.get(self, "amazon_bedrock_config")

    @amazon_bedrock_config.setter
    def amazon_bedrock_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs']]):
        pulumi.set(self, "amazon_bedrock_config", value)

    @property
    @pulumi.getter(name="anthropicConfig")
    def anthropic_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAnthropicConfigArgs']]:
        """
        Anthropic Config
        """
        return pulumi.get(self, "anthropic_config")

    @anthropic_config.setter
    def anthropic_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelAnthropicConfigArgs']]):
        pulumi.set(self, "anthropic_config", value)

    @property
    @pulumi.getter(name="cohereConfig")
    def cohere_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelCohereConfigArgs']]:
        """
        Cohere Config
        """
        return pulumi.get(self, "cohere_config")

    @cohere_config.setter
    def cohere_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelCohereConfigArgs']]):
        pulumi.set(self, "cohere_config", value)

    @property
    @pulumi.getter(name="databricksModelServingConfig")
    def databricks_model_serving_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs']]:
        """
        Databricks Model Serving Config
        """
        return pulumi.get(self, "databricks_model_serving_config")

    @databricks_model_serving_config.setter
    def databricks_model_serving_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs']]):
        pulumi.set(self, "databricks_model_serving_config", value)

    @property
    @pulumi.getter(name="googleCloudVertexAiConfig")
    def google_cloud_vertex_ai_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs']]:
        """
        Google Cloud Vertex AI Config.
        """
        return pulumi.get(self, "google_cloud_vertex_ai_config")

    @google_cloud_vertex_ai_config.setter
    def google_cloud_vertex_ai_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs']]):
        pulumi.set(self, "google_cloud_vertex_ai_config", value)

    @property
    @pulumi.getter(name="openaiConfig")
    def openai_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelOpenaiConfigArgs']]:
        """
        OpenAI Config
        """
        return pulumi.get(self, "openai_config")

    @openai_config.setter
    def openai_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelOpenaiConfigArgs']]):
        pulumi.set(self, "openai_config", value)

    @property
    @pulumi.getter(name="palmConfig")
    def palm_config(self) -> Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelPalmConfigArgs']]:
        """
        PaLM Config
        """
        return pulumi.get(self, "palm_config")

    @palm_config.setter
    def palm_config(self, value: Optional[pulumi.Input['ModelServingConfigServedEntityExternalModelPalmConfigArgs']]):
        pulumi.set(self, "palm_config", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelAi21labsConfigArgsDict(TypedDict):
        ai21labs_api_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for an AI21Labs API key.
        """
        ai21labs_api_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        An AI21 Labs API key provided as a plaintext string.
        """
elif False:
    ModelServingConfigServedEntityExternalModelAi21labsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelAi21labsConfigArgs:
    def __init__(__self__, *,
                 ai21labs_api_key: Optional[pulumi.Input[str]] = None,
                 ai21labs_api_key_plaintext: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ai21labs_api_key: The Databricks secret key reference for an AI21Labs API key.
        :param pulumi.Input[str] ai21labs_api_key_plaintext: An AI21 Labs API key provided as a plaintext string.
        """
        if ai21labs_api_key is not None:
            pulumi.set(__self__, "ai21labs_api_key", ai21labs_api_key)
        if ai21labs_api_key_plaintext is not None:
            pulumi.set(__self__, "ai21labs_api_key_plaintext", ai21labs_api_key_plaintext)

    @property
    @pulumi.getter(name="ai21labsApiKey")
    def ai21labs_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for an AI21Labs API key.
        """
        return pulumi.get(self, "ai21labs_api_key")

    @ai21labs_api_key.setter
    def ai21labs_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ai21labs_api_key", value)

    @property
    @pulumi.getter(name="ai21labsApiKeyPlaintext")
    def ai21labs_api_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        An AI21 Labs API key provided as a plaintext string.
        """
        return pulumi.get(self, "ai21labs_api_key_plaintext")

    @ai21labs_api_key_plaintext.setter
    def ai21labs_api_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ai21labs_api_key_plaintext", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgsDict(TypedDict):
        aws_region: pulumi.Input[str]
        """
        The AWS region to use. Bedrock has to be enabled there.
        """
        bedrock_provider: pulumi.Input[str]
        """
        The underlying provider in Amazon Bedrock. Supported values (case insensitive) include: `Anthropic`, `Cohere`, `AI21Labs`, `Amazon`.
        """
        aws_access_key_id: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for an AWS Access Key ID with permissions to interact with Bedrock services.
        """
        aws_access_key_id_plaintext: NotRequired[pulumi.Input[str]]
        """
        An AWS access key ID with permissions to interact with Bedrock services provided as a plaintext string.
        """
        aws_secret_access_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for an AWS Secret Access Key paired with the access key ID, with permissions to interact with Bedrock services.
        """
        aws_secret_access_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        An AWS secret access key paired with the access key ID, with permissions to interact with Bedrock services provided as a plaintext string.
        """
elif False:
    ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs:
    def __init__(__self__, *,
                 aws_region: pulumi.Input[str],
                 bedrock_provider: pulumi.Input[str],
                 aws_access_key_id: Optional[pulumi.Input[str]] = None,
                 aws_access_key_id_plaintext: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key_plaintext: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_region: The AWS region to use. Bedrock has to be enabled there.
        :param pulumi.Input[str] bedrock_provider: The underlying provider in Amazon Bedrock. Supported values (case insensitive) include: `Anthropic`, `Cohere`, `AI21Labs`, `Amazon`.
        :param pulumi.Input[str] aws_access_key_id: The Databricks secret key reference for an AWS Access Key ID with permissions to interact with Bedrock services.
        :param pulumi.Input[str] aws_access_key_id_plaintext: An AWS access key ID with permissions to interact with Bedrock services provided as a plaintext string.
        :param pulumi.Input[str] aws_secret_access_key: The Databricks secret key reference for an AWS Secret Access Key paired with the access key ID, with permissions to interact with Bedrock services.
        :param pulumi.Input[str] aws_secret_access_key_plaintext: An AWS secret access key paired with the access key ID, with permissions to interact with Bedrock services provided as a plaintext string.
        """
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "bedrock_provider", bedrock_provider)
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_access_key_id_plaintext is not None:
            pulumi.set(__self__, "aws_access_key_id_plaintext", aws_access_key_id_plaintext)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_secret_access_key_plaintext is not None:
            pulumi.set(__self__, "aws_secret_access_key_plaintext", aws_secret_access_key_plaintext)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> pulumi.Input[str]:
        """
        The AWS region to use. Bedrock has to be enabled there.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter(name="bedrockProvider")
    def bedrock_provider(self) -> pulumi.Input[str]:
        """
        The underlying provider in Amazon Bedrock. Supported values (case insensitive) include: `Anthropic`, `Cohere`, `AI21Labs`, `Amazon`.
        """
        return pulumi.get(self, "bedrock_provider")

    @bedrock_provider.setter
    def bedrock_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "bedrock_provider", value)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for an AWS Access Key ID with permissions to interact with Bedrock services.
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsAccessKeyIdPlaintext")
    def aws_access_key_id_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        An AWS access key ID with permissions to interact with Bedrock services provided as a plaintext string.
        """
        return pulumi.get(self, "aws_access_key_id_plaintext")

    @aws_access_key_id_plaintext.setter
    def aws_access_key_id_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id_plaintext", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for an AWS Secret Access Key paired with the access key ID, with permissions to interact with Bedrock services.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter(name="awsSecretAccessKeyPlaintext")
    def aws_secret_access_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        An AWS secret access key paired with the access key ID, with permissions to interact with Bedrock services provided as a plaintext string.
        """
        return pulumi.get(self, "aws_secret_access_key_plaintext")

    @aws_secret_access_key_plaintext.setter
    def aws_secret_access_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key_plaintext", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelAnthropicConfigArgsDict(TypedDict):
        anthropic_api_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for an Anthropic API key.
        """
        anthropic_api_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        The Anthropic API key provided as a plaintext string.
        """
elif False:
    ModelServingConfigServedEntityExternalModelAnthropicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelAnthropicConfigArgs:
    def __init__(__self__, *,
                 anthropic_api_key: Optional[pulumi.Input[str]] = None,
                 anthropic_api_key_plaintext: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] anthropic_api_key: The Databricks secret key reference for an Anthropic API key.
        :param pulumi.Input[str] anthropic_api_key_plaintext: The Anthropic API key provided as a plaintext string.
        """
        if anthropic_api_key is not None:
            pulumi.set(__self__, "anthropic_api_key", anthropic_api_key)
        if anthropic_api_key_plaintext is not None:
            pulumi.set(__self__, "anthropic_api_key_plaintext", anthropic_api_key_plaintext)

    @property
    @pulumi.getter(name="anthropicApiKey")
    def anthropic_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for an Anthropic API key.
        """
        return pulumi.get(self, "anthropic_api_key")

    @anthropic_api_key.setter
    def anthropic_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "anthropic_api_key", value)

    @property
    @pulumi.getter(name="anthropicApiKeyPlaintext")
    def anthropic_api_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The Anthropic API key provided as a plaintext string.
        """
        return pulumi.get(self, "anthropic_api_key_plaintext")

    @anthropic_api_key_plaintext.setter
    def anthropic_api_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "anthropic_api_key_plaintext", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelCohereConfigArgsDict(TypedDict):
        cohere_api_base: NotRequired[pulumi.Input[str]]
        cohere_api_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for a Cohere API key.
        """
        cohere_api_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        The Cohere API key provided as a plaintext string.
        """
elif False:
    ModelServingConfigServedEntityExternalModelCohereConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelCohereConfigArgs:
    def __init__(__self__, *,
                 cohere_api_base: Optional[pulumi.Input[str]] = None,
                 cohere_api_key: Optional[pulumi.Input[str]] = None,
                 cohere_api_key_plaintext: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cohere_api_key: The Databricks secret key reference for a Cohere API key.
        :param pulumi.Input[str] cohere_api_key_plaintext: The Cohere API key provided as a plaintext string.
        """
        if cohere_api_base is not None:
            pulumi.set(__self__, "cohere_api_base", cohere_api_base)
        if cohere_api_key is not None:
            pulumi.set(__self__, "cohere_api_key", cohere_api_key)
        if cohere_api_key_plaintext is not None:
            pulumi.set(__self__, "cohere_api_key_plaintext", cohere_api_key_plaintext)

    @property
    @pulumi.getter(name="cohereApiBase")
    def cohere_api_base(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cohere_api_base")

    @cohere_api_base.setter
    def cohere_api_base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cohere_api_base", value)

    @property
    @pulumi.getter(name="cohereApiKey")
    def cohere_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for a Cohere API key.
        """
        return pulumi.get(self, "cohere_api_key")

    @cohere_api_key.setter
    def cohere_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cohere_api_key", value)

    @property
    @pulumi.getter(name="cohereApiKeyPlaintext")
    def cohere_api_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The Cohere API key provided as a plaintext string.
        """
        return pulumi.get(self, "cohere_api_key_plaintext")

    @cohere_api_key_plaintext.setter
    def cohere_api_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cohere_api_key_plaintext", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgsDict(TypedDict):
        databricks_workspace_url: pulumi.Input[str]
        """
        The URL of the Databricks workspace containing the model serving endpoint pointed to by this external model.
        """
        databricks_api_token: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for a Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model.
        """
        databricks_api_token_plaintext: NotRequired[pulumi.Input[str]]
        """
        The Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model provided as a plaintext string.
        """
elif False:
    ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs:
    def __init__(__self__, *,
                 databricks_workspace_url: pulumi.Input[str],
                 databricks_api_token: Optional[pulumi.Input[str]] = None,
                 databricks_api_token_plaintext: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] databricks_workspace_url: The URL of the Databricks workspace containing the model serving endpoint pointed to by this external model.
        :param pulumi.Input[str] databricks_api_token: The Databricks secret key reference for a Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model.
        :param pulumi.Input[str] databricks_api_token_plaintext: The Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model provided as a plaintext string.
        """
        pulumi.set(__self__, "databricks_workspace_url", databricks_workspace_url)
        if databricks_api_token is not None:
            pulumi.set(__self__, "databricks_api_token", databricks_api_token)
        if databricks_api_token_plaintext is not None:
            pulumi.set(__self__, "databricks_api_token_plaintext", databricks_api_token_plaintext)

    @property
    @pulumi.getter(name="databricksWorkspaceUrl")
    def databricks_workspace_url(self) -> pulumi.Input[str]:
        """
        The URL of the Databricks workspace containing the model serving endpoint pointed to by this external model.
        """
        return pulumi.get(self, "databricks_workspace_url")

    @databricks_workspace_url.setter
    def databricks_workspace_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "databricks_workspace_url", value)

    @property
    @pulumi.getter(name="databricksApiToken")
    def databricks_api_token(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for a Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model.
        """
        return pulumi.get(self, "databricks_api_token")

    @databricks_api_token.setter
    def databricks_api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "databricks_api_token", value)

    @property
    @pulumi.getter(name="databricksApiTokenPlaintext")
    def databricks_api_token_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model provided as a plaintext string.
        """
        return pulumi.get(self, "databricks_api_token_plaintext")

    @databricks_api_token_plaintext.setter
    def databricks_api_token_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "databricks_api_token_plaintext", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgsDict(TypedDict):
        private_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for a private key for the service account that has access to the Google Cloud Vertex AI Service.
        """
        private_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        The private key for the service account that has access to the Google Cloud Vertex AI Service is provided as a plaintext secret.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        This is the Google Cloud project id that the service account is associated with.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        This is the region for the Google Cloud Vertex AI Service.
        """
elif False:
    ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs:
    def __init__(__self__, *,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_plaintext: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_key: The Databricks secret key reference for a private key for the service account that has access to the Google Cloud Vertex AI Service.
        :param pulumi.Input[str] private_key_plaintext: The private key for the service account that has access to the Google Cloud Vertex AI Service is provided as a plaintext secret.
        :param pulumi.Input[str] project_id: This is the Google Cloud project id that the service account is associated with.
        :param pulumi.Input[str] region: This is the region for the Google Cloud Vertex AI Service.
        """
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_plaintext is not None:
            pulumi.set(__self__, "private_key_plaintext", private_key_plaintext)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for a private key for the service account that has access to the Google Cloud Vertex AI Service.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyPlaintext")
    def private_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The private key for the service account that has access to the Google Cloud Vertex AI Service is provided as a plaintext secret.
        """
        return pulumi.get(self, "private_key_plaintext")

    @private_key_plaintext.setter
    def private_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_plaintext", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        This is the Google Cloud project id that the service account is associated with.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        This is the region for the Google Cloud Vertex AI Service.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelOpenaiConfigArgsDict(TypedDict):
        microsoft_entra_client_id: NotRequired[pulumi.Input[str]]
        """
        This field is only required for Azure AD OpenAI and is the Microsoft Entra Client ID.
        """
        microsoft_entra_client_secret: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for a client secret used for Microsoft Entra ID authentication.
        """
        microsoft_entra_client_secret_plaintext: NotRequired[pulumi.Input[str]]
        """
        The client secret used for Microsoft Entra ID authentication provided as a plaintext string.
        """
        microsoft_entra_tenant_id: NotRequired[pulumi.Input[str]]
        """
        This field is only required for Azure AD OpenAI and is the Microsoft Entra Tenant ID.
        """
        openai_api_base: NotRequired[pulumi.Input[str]]
        """
        This is the base URL for the OpenAI API (default: "https://api.openai.com/v1"). For Azure OpenAI, this field is required and is the base URL for the Azure OpenAI API service provided by Azure.
        """
        openai_api_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for an OpenAI or Azure OpenAI API key.
        """
        openai_api_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        The OpenAI API key using the OpenAI or Azure service provided as a plaintext string.
        """
        openai_api_type: NotRequired[pulumi.Input[str]]
        """
        This is an optional field to specify the type of OpenAI API to use. For Azure OpenAI, this field is required, and this parameter represents the preferred security access validation protocol. For access token validation, use `azure`. For authentication using Azure Active Directory (Azure AD) use, `azuread`.
        """
        openai_api_version: NotRequired[pulumi.Input[str]]
        """
        This is an optional field to specify the OpenAI API version. For Azure OpenAI, this field is required and is the version of the Azure OpenAI service to utilize, specified by a date.
        """
        openai_deployment_name: NotRequired[pulumi.Input[str]]
        """
        This field is only required for Azure OpenAI and is the name of the deployment resource for the Azure OpenAI service.
        """
        openai_organization: NotRequired[pulumi.Input[str]]
        """
        This is an optional field to specify the organization in OpenAI or Azure OpenAI.
        """
elif False:
    ModelServingConfigServedEntityExternalModelOpenaiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelOpenaiConfigArgs:
    def __init__(__self__, *,
                 microsoft_entra_client_id: Optional[pulumi.Input[str]] = None,
                 microsoft_entra_client_secret: Optional[pulumi.Input[str]] = None,
                 microsoft_entra_client_secret_plaintext: Optional[pulumi.Input[str]] = None,
                 microsoft_entra_tenant_id: Optional[pulumi.Input[str]] = None,
                 openai_api_base: Optional[pulumi.Input[str]] = None,
                 openai_api_key: Optional[pulumi.Input[str]] = None,
                 openai_api_key_plaintext: Optional[pulumi.Input[str]] = None,
                 openai_api_type: Optional[pulumi.Input[str]] = None,
                 openai_api_version: Optional[pulumi.Input[str]] = None,
                 openai_deployment_name: Optional[pulumi.Input[str]] = None,
                 openai_organization: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] microsoft_entra_client_id: This field is only required for Azure AD OpenAI and is the Microsoft Entra Client ID.
        :param pulumi.Input[str] microsoft_entra_client_secret: The Databricks secret key reference for a client secret used for Microsoft Entra ID authentication.
        :param pulumi.Input[str] microsoft_entra_client_secret_plaintext: The client secret used for Microsoft Entra ID authentication provided as a plaintext string.
        :param pulumi.Input[str] microsoft_entra_tenant_id: This field is only required for Azure AD OpenAI and is the Microsoft Entra Tenant ID.
        :param pulumi.Input[str] openai_api_base: This is the base URL for the OpenAI API (default: "https://api.openai.com/v1"). For Azure OpenAI, this field is required and is the base URL for the Azure OpenAI API service provided by Azure.
        :param pulumi.Input[str] openai_api_key: The Databricks secret key reference for an OpenAI or Azure OpenAI API key.
        :param pulumi.Input[str] openai_api_key_plaintext: The OpenAI API key using the OpenAI or Azure service provided as a plaintext string.
        :param pulumi.Input[str] openai_api_type: This is an optional field to specify the type of OpenAI API to use. For Azure OpenAI, this field is required, and this parameter represents the preferred security access validation protocol. For access token validation, use `azure`. For authentication using Azure Active Directory (Azure AD) use, `azuread`.
        :param pulumi.Input[str] openai_api_version: This is an optional field to specify the OpenAI API version. For Azure OpenAI, this field is required and is the version of the Azure OpenAI service to utilize, specified by a date.
        :param pulumi.Input[str] openai_deployment_name: This field is only required for Azure OpenAI and is the name of the deployment resource for the Azure OpenAI service.
        :param pulumi.Input[str] openai_organization: This is an optional field to specify the organization in OpenAI or Azure OpenAI.
        """
        if microsoft_entra_client_id is not None:
            pulumi.set(__self__, "microsoft_entra_client_id", microsoft_entra_client_id)
        if microsoft_entra_client_secret is not None:
            pulumi.set(__self__, "microsoft_entra_client_secret", microsoft_entra_client_secret)
        if microsoft_entra_client_secret_plaintext is not None:
            pulumi.set(__self__, "microsoft_entra_client_secret_plaintext", microsoft_entra_client_secret_plaintext)
        if microsoft_entra_tenant_id is not None:
            pulumi.set(__self__, "microsoft_entra_tenant_id", microsoft_entra_tenant_id)
        if openai_api_base is not None:
            pulumi.set(__self__, "openai_api_base", openai_api_base)
        if openai_api_key is not None:
            pulumi.set(__self__, "openai_api_key", openai_api_key)
        if openai_api_key_plaintext is not None:
            pulumi.set(__self__, "openai_api_key_plaintext", openai_api_key_plaintext)
        if openai_api_type is not None:
            pulumi.set(__self__, "openai_api_type", openai_api_type)
        if openai_api_version is not None:
            pulumi.set(__self__, "openai_api_version", openai_api_version)
        if openai_deployment_name is not None:
            pulumi.set(__self__, "openai_deployment_name", openai_deployment_name)
        if openai_organization is not None:
            pulumi.set(__self__, "openai_organization", openai_organization)

    @property
    @pulumi.getter(name="microsoftEntraClientId")
    def microsoft_entra_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        This field is only required for Azure AD OpenAI and is the Microsoft Entra Client ID.
        """
        return pulumi.get(self, "microsoft_entra_client_id")

    @microsoft_entra_client_id.setter
    def microsoft_entra_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_entra_client_id", value)

    @property
    @pulumi.getter(name="microsoftEntraClientSecret")
    def microsoft_entra_client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for a client secret used for Microsoft Entra ID authentication.
        """
        return pulumi.get(self, "microsoft_entra_client_secret")

    @microsoft_entra_client_secret.setter
    def microsoft_entra_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_entra_client_secret", value)

    @property
    @pulumi.getter(name="microsoftEntraClientSecretPlaintext")
    def microsoft_entra_client_secret_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The client secret used for Microsoft Entra ID authentication provided as a plaintext string.
        """
        return pulumi.get(self, "microsoft_entra_client_secret_plaintext")

    @microsoft_entra_client_secret_plaintext.setter
    def microsoft_entra_client_secret_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_entra_client_secret_plaintext", value)

    @property
    @pulumi.getter(name="microsoftEntraTenantId")
    def microsoft_entra_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        This field is only required for Azure AD OpenAI and is the Microsoft Entra Tenant ID.
        """
        return pulumi.get(self, "microsoft_entra_tenant_id")

    @microsoft_entra_tenant_id.setter
    def microsoft_entra_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "microsoft_entra_tenant_id", value)

    @property
    @pulumi.getter(name="openaiApiBase")
    def openai_api_base(self) -> Optional[pulumi.Input[str]]:
        """
        This is the base URL for the OpenAI API (default: "https://api.openai.com/v1"). For Azure OpenAI, this field is required and is the base URL for the Azure OpenAI API service provided by Azure.
        """
        return pulumi.get(self, "openai_api_base")

    @openai_api_base.setter
    def openai_api_base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_api_base", value)

    @property
    @pulumi.getter(name="openaiApiKey")
    def openai_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for an OpenAI or Azure OpenAI API key.
        """
        return pulumi.get(self, "openai_api_key")

    @openai_api_key.setter
    def openai_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_api_key", value)

    @property
    @pulumi.getter(name="openaiApiKeyPlaintext")
    def openai_api_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenAI API key using the OpenAI or Azure service provided as a plaintext string.
        """
        return pulumi.get(self, "openai_api_key_plaintext")

    @openai_api_key_plaintext.setter
    def openai_api_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_api_key_plaintext", value)

    @property
    @pulumi.getter(name="openaiApiType")
    def openai_api_type(self) -> Optional[pulumi.Input[str]]:
        """
        This is an optional field to specify the type of OpenAI API to use. For Azure OpenAI, this field is required, and this parameter represents the preferred security access validation protocol. For access token validation, use `azure`. For authentication using Azure Active Directory (Azure AD) use, `azuread`.
        """
        return pulumi.get(self, "openai_api_type")

    @openai_api_type.setter
    def openai_api_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_api_type", value)

    @property
    @pulumi.getter(name="openaiApiVersion")
    def openai_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        This is an optional field to specify the OpenAI API version. For Azure OpenAI, this field is required and is the version of the Azure OpenAI service to utilize, specified by a date.
        """
        return pulumi.get(self, "openai_api_version")

    @openai_api_version.setter
    def openai_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_api_version", value)

    @property
    @pulumi.getter(name="openaiDeploymentName")
    def openai_deployment_name(self) -> Optional[pulumi.Input[str]]:
        """
        This field is only required for Azure OpenAI and is the name of the deployment resource for the Azure OpenAI service.
        """
        return pulumi.get(self, "openai_deployment_name")

    @openai_deployment_name.setter
    def openai_deployment_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_deployment_name", value)

    @property
    @pulumi.getter(name="openaiOrganization")
    def openai_organization(self) -> Optional[pulumi.Input[str]]:
        """
        This is an optional field to specify the organization in OpenAI or Azure OpenAI.
        """
        return pulumi.get(self, "openai_organization")

    @openai_organization.setter
    def openai_organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "openai_organization", value)


if not MYPY:
    class ModelServingConfigServedEntityExternalModelPalmConfigArgsDict(TypedDict):
        palm_api_key: NotRequired[pulumi.Input[str]]
        """
        The Databricks secret key reference for a PaLM API key.
        """
        palm_api_key_plaintext: NotRequired[pulumi.Input[str]]
        """
        The PaLM API key provided as a plaintext string.
        """
elif False:
    ModelServingConfigServedEntityExternalModelPalmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedEntityExternalModelPalmConfigArgs:
    def __init__(__self__, *,
                 palm_api_key: Optional[pulumi.Input[str]] = None,
                 palm_api_key_plaintext: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] palm_api_key: The Databricks secret key reference for a PaLM API key.
        :param pulumi.Input[str] palm_api_key_plaintext: The PaLM API key provided as a plaintext string.
        """
        if palm_api_key is not None:
            pulumi.set(__self__, "palm_api_key", palm_api_key)
        if palm_api_key_plaintext is not None:
            pulumi.set(__self__, "palm_api_key_plaintext", palm_api_key_plaintext)

    @property
    @pulumi.getter(name="palmApiKey")
    def palm_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Databricks secret key reference for a PaLM API key.
        """
        return pulumi.get(self, "palm_api_key")

    @palm_api_key.setter
    def palm_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palm_api_key", value)

    @property
    @pulumi.getter(name="palmApiKeyPlaintext")
    def palm_api_key_plaintext(self) -> Optional[pulumi.Input[str]]:
        """
        The PaLM API key provided as a plaintext string.
        """
        return pulumi.get(self, "palm_api_key_plaintext")

    @palm_api_key_plaintext.setter
    def palm_api_key_plaintext(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "palm_api_key_plaintext", value)


if not MYPY:
    class ModelServingConfigServedModelArgsDict(TypedDict):
        model_name: pulumi.Input[str]
        """
        The name of the model in Databricks Model Registry to be served.
        """
        model_version: pulumi.Input[str]
        """
        The version of the model in Databricks Model Registry to be served.
        """
        environment_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        a map of environment variable names/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        """
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        """
        ARN of the instance profile that the served model will use to access AWS resources.
        """
        max_provisioned_throughput: NotRequired[pulumi.Input[int]]
        """
        The maximum tokens per second that the endpoint can scale up to.
        """
        min_provisioned_throughput: NotRequired[pulumi.Input[int]]
        """
        The minimum tokens per second that the endpoint can scale down to.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        """
        scale_to_zero_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether the compute resources for the served model should scale down to zero. If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        """
        workload_size: NotRequired[pulumi.Input[str]]
        """
        The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency).
        """
        workload_type: NotRequired[pulumi.Input[str]]
        """
        The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the documentation for all options. The default value is `CPU`.
        """
elif False:
    ModelServingConfigServedModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigServedModelArgs:
    def __init__(__self__, *,
                 model_name: pulumi.Input[str],
                 model_version: pulumi.Input[str],
                 environment_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 max_provisioned_throughput: Optional[pulumi.Input[int]] = None,
                 min_provisioned_throughput: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 scale_to_zero_enabled: Optional[pulumi.Input[bool]] = None,
                 workload_size: Optional[pulumi.Input[str]] = None,
                 workload_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] model_name: The name of the model in Databricks Model Registry to be served.
        :param pulumi.Input[str] model_version: The version of the model in Databricks Model Registry to be served.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_vars: a map of environment variable names/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        :param pulumi.Input[str] instance_profile_arn: ARN of the instance profile that the served model will use to access AWS resources.
        :param pulumi.Input[int] max_provisioned_throughput: The maximum tokens per second that the endpoint can scale up to.
        :param pulumi.Input[int] min_provisioned_throughput: The minimum tokens per second that the endpoint can scale down to.
        :param pulumi.Input[str] name: The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        :param pulumi.Input[bool] scale_to_zero_enabled: Whether the compute resources for the served model should scale down to zero. If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        :param pulumi.Input[str] workload_size: The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency).
        :param pulumi.Input[str] workload_type: The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the documentation for all options. The default value is `CPU`.
        """
        pulumi.set(__self__, "model_name", model_name)
        pulumi.set(__self__, "model_version", model_version)
        if environment_vars is not None:
            pulumi.set(__self__, "environment_vars", environment_vars)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if max_provisioned_throughput is not None:
            pulumi.set(__self__, "max_provisioned_throughput", max_provisioned_throughput)
        if min_provisioned_throughput is not None:
            pulumi.set(__self__, "min_provisioned_throughput", min_provisioned_throughput)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scale_to_zero_enabled is not None:
            pulumi.set(__self__, "scale_to_zero_enabled", scale_to_zero_enabled)
        if workload_size is not None:
            pulumi.set(__self__, "workload_size", workload_size)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> pulumi.Input[str]:
        """
        The name of the model in Databricks Model Registry to be served.
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_name", value)

    @property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> pulumi.Input[str]:
        """
        The version of the model in Databricks Model Registry to be served.
        """
        return pulumi.get(self, "model_version")

    @model_version.setter
    def model_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_version", value)

    @property
    @pulumi.getter(name="environmentVars")
    def environment_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        a map of environment variable names/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        """
        return pulumi.get(self, "environment_vars")

    @environment_vars.setter
    def environment_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_vars", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the instance profile that the served model will use to access AWS resources.
        """
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="maxProvisionedThroughput")
    def max_provisioned_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum tokens per second that the endpoint can scale up to.
        """
        return pulumi.get(self, "max_provisioned_throughput")

    @max_provisioned_throughput.setter
    def max_provisioned_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_provisioned_throughput", value)

    @property
    @pulumi.getter(name="minProvisionedThroughput")
    def min_provisioned_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum tokens per second that the endpoint can scale down to.
        """
        return pulumi.get(self, "min_provisioned_throughput")

    @min_provisioned_throughput.setter
    def min_provisioned_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_provisioned_throughput", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scaleToZeroEnabled")
    def scale_to_zero_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the compute resources for the served model should scale down to zero. If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        """
        return pulumi.get(self, "scale_to_zero_enabled")

    @scale_to_zero_enabled.setter
    def scale_to_zero_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scale_to_zero_enabled", value)

    @property
    @pulumi.getter(name="workloadSize")
    def workload_size(self) -> Optional[pulumi.Input[str]]:
        """
        The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency).
        """
        return pulumi.get(self, "workload_size")

    @workload_size.setter
    def workload_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_size", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input[str]]:
        """
        The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the documentation for all options. The default value is `CPU`.
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class ModelServingConfigTrafficConfigArgsDict(TypedDict):
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgsDict']]]]
        """
        Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
elif False:
    ModelServingConfigTrafficConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigTrafficConfigArgs:
    def __init__(__self__, *,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]] routes: Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]]:
        """
        Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class ModelServingConfigTrafficConfigRouteArgsDict(TypedDict):
        served_model_name: pulumi.Input[str]
        traffic_percentage: pulumi.Input[int]
        """
        The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
elif False:
    ModelServingConfigTrafficConfigRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingConfigTrafficConfigRouteArgs:
    def __init__(__self__, *,
                 served_model_name: pulumi.Input[str],
                 traffic_percentage: pulumi.Input[int]):
        """
        :param pulumi.Input[int] traffic_percentage: The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
        pulumi.set(__self__, "served_model_name", served_model_name)
        pulumi.set(__self__, "traffic_percentage", traffic_percentage)

    @property
    @pulumi.getter(name="servedModelName")
    def served_model_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "served_model_name")

    @served_model_name.setter
    def served_model_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "served_model_name", value)

    @property
    @pulumi.getter(name="trafficPercentage")
    def traffic_percentage(self) -> pulumi.Input[int]:
        """
        The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
        return pulumi.get(self, "traffic_percentage")

    @traffic_percentage.setter
    def traffic_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "traffic_percentage", value)


if not MYPY:
    class ModelServingRateLimitArgsDict(TypedDict):
        calls: pulumi.Input[int]
        """
        Used to specify how many calls are allowed for a key within the renewal_period.
        """
        renewal_period: pulumi.Input[str]
        """
        Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key field for a serving endpoint rate limit. Currently, only `user` and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
elif False:
    ModelServingRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingRateLimitArgs:
    def __init__(__self__, *,
                 calls: pulumi.Input[int],
                 renewal_period: pulumi.Input[str],
                 key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] calls: Used to specify how many calls are allowed for a key within the renewal_period.
        :param pulumi.Input[str] renewal_period: Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        :param pulumi.Input[str] key: Key field for a serving endpoint rate limit. Currently, only `user` and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        pulumi.set(__self__, "calls", calls)
        pulumi.set(__self__, "renewal_period", renewal_period)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def calls(self) -> pulumi.Input[int]:
        """
        Used to specify how many calls are allowed for a key within the renewal_period.
        """
        return pulumi.get(self, "calls")

    @calls.setter
    def calls(self, value: pulumi.Input[int]):
        pulumi.set(self, "calls", value)

    @property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> pulumi.Input[str]:
        """
        Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        """
        return pulumi.get(self, "renewal_period")

    @renewal_period.setter
    def renewal_period(self, value: pulumi.Input[str]):
        pulumi.set(self, "renewal_period", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key field for a serving endpoint rate limit. Currently, only `user` and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ModelServingTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key field for a tag.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value field for a tag.
        """
elif False:
    ModelServingTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelServingTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key field for a tag.
        :param pulumi.Input[str] value: The value field for a tag.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key field for a tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value field for a tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MountAbfsArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        client_secret_key: pulumi.Input[str]
        client_secret_scope: pulumi.Input[str]
        initialize_file_system: pulumi.Input[bool]
        container_name: NotRequired[pulumi.Input[str]]
        directory: NotRequired[pulumi.Input[str]]
        storage_account_name: NotRequired[pulumi.Input[str]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    MountAbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MountAbfsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_key: pulumi.Input[str],
                 client_secret_scope: pulumi.Input[str],
                 initialize_file_system: pulumi.Input[bool],
                 container_name: Optional[pulumi.Input[str]] = None,
                 directory: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_key", client_secret_key)
        pulumi.set(__self__, "client_secret_scope", client_secret_scope)
        pulumi.set(__self__, "initialize_file_system", initialize_file_system)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_key")

    @client_secret_key.setter
    def client_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_key", value)

    @property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_scope")

    @client_secret_scope.setter
    def client_secret_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_scope", value)

    @property
    @pulumi.getter(name="initializeFileSystem")
    def initialize_file_system(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "initialize_file_system")

    @initialize_file_system.setter
    def initialize_file_system(self, value: pulumi.Input[bool]):
        pulumi.set(self, "initialize_file_system", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class MountAdlArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        client_secret_key: pulumi.Input[str]
        client_secret_scope: pulumi.Input[str]
        directory: NotRequired[pulumi.Input[str]]
        spark_conf_prefix: NotRequired[pulumi.Input[str]]
        storage_resource_name: NotRequired[pulumi.Input[str]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    MountAdlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MountAdlArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_key: pulumi.Input[str],
                 client_secret_scope: pulumi.Input[str],
                 directory: Optional[pulumi.Input[str]] = None,
                 spark_conf_prefix: Optional[pulumi.Input[str]] = None,
                 storage_resource_name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_key", client_secret_key)
        pulumi.set(__self__, "client_secret_scope", client_secret_scope)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if spark_conf_prefix is not None:
            pulumi.set(__self__, "spark_conf_prefix", spark_conf_prefix)
        if storage_resource_name is not None:
            pulumi.set(__self__, "storage_resource_name", storage_resource_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_key")

    @client_secret_key.setter
    def client_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_key", value)

    @property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_scope")

    @client_secret_scope.setter
    def client_secret_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_scope", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter(name="sparkConfPrefix")
    def spark_conf_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spark_conf_prefix")

    @spark_conf_prefix.setter
    def spark_conf_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_conf_prefix", value)

    @property
    @pulumi.getter(name="storageResourceName")
    def storage_resource_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_resource_name")

    @storage_resource_name.setter
    def storage_resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_resource_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class MountGsArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        service_account: NotRequired[pulumi.Input[str]]
elif False:
    MountGsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MountGsArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 service_account: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class MountS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        instance_profile: NotRequired[pulumi.Input[str]]
elif False:
    MountS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MountS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 instance_profile: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if instance_profile is not None:
            pulumi.set(__self__, "instance_profile", instance_profile)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="instanceProfile")
    def instance_profile(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile")

    @instance_profile.setter
    def instance_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile", value)


if not MYPY:
    class MountWasbArgsDict(TypedDict):
        auth_type: pulumi.Input[str]
        token_secret_key: pulumi.Input[str]
        token_secret_scope: pulumi.Input[str]
        container_name: NotRequired[pulumi.Input[str]]
        directory: NotRequired[pulumi.Input[str]]
        storage_account_name: NotRequired[pulumi.Input[str]]
elif False:
    MountWasbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MountWasbArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[str],
                 token_secret_key: pulumi.Input[str],
                 token_secret_scope: pulumi.Input[str],
                 container_name: Optional[pulumi.Input[str]] = None,
                 directory: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "token_secret_key", token_secret_key)
        pulumi.set(__self__, "token_secret_scope", token_secret_scope)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="tokenSecretKey")
    def token_secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token_secret_key")

    @token_secret_key.setter
    def token_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_secret_key", value)

    @property
    @pulumi.getter(name="tokenSecretScope")
    def token_secret_scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token_secret_scope")

    @token_secret_scope.setter
    def token_secret_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_secret_scope", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)


if not MYPY:
    class MwsCustomerManagedKeysAwsKeyInfoArgsDict(TypedDict):
        key_arn: pulumi.Input[str]
        """
        The AWS KMS key's Amazon Resource Name (ARN).
        """
        key_alias: NotRequired[pulumi.Input[str]]
        """
        The AWS KMS key alias.
        """
        key_region: NotRequired[pulumi.Input[str]]
        """
        (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
elif False:
    MwsCustomerManagedKeysAwsKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsCustomerManagedKeysAwsKeyInfoArgs:
    def __init__(__self__, *,
                 key_arn: pulumi.Input[str],
                 key_alias: Optional[pulumi.Input[str]] = None,
                 key_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_arn: The AWS KMS key's Amazon Resource Name (ARN).
        :param pulumi.Input[str] key_alias: The AWS KMS key alias.
        :param pulumi.Input[str] key_region: (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        pulumi.set(__self__, "key_arn", key_arn)
        if key_alias is not None:
            pulumi.set(__self__, "key_alias", key_alias)
        if key_region is not None:
            pulumi.set(__self__, "key_region", key_region)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> pulumi.Input[str]:
        """
        The AWS KMS key's Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_arn", value)

    @property
    @pulumi.getter(name="keyAlias")
    def key_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS KMS key alias.
        """
        return pulumi.get(self, "key_alias")

    @key_alias.setter
    def key_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_alias", value)

    @property
    @pulumi.getter(name="keyRegion")
    def key_region(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        return pulumi.get(self, "key_region")

    @key_region.setter
    def key_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_region", value)


if not MYPY:
    class MwsCustomerManagedKeysGcpKeyInfoArgsDict(TypedDict):
        kms_key_id: pulumi.Input[str]
        """
        The GCP KMS key's resource name.
        """
elif False:
    MwsCustomerManagedKeysGcpKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsCustomerManagedKeysGcpKeyInfoArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_key_id: The GCP KMS key's resource name.
        """
        pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[str]:
        """
        The GCP KMS key's resource name.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class MwsNetworkConnectivityConfigEgressConfigArgsDict(TypedDict):
        default_rules: NotRequired[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgsDict']]
        """
        block describing network connectivity rules that are applied by default without resource specific configurations.  Consists of the following fields:
        """
        target_rules: NotRequired[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesArgsDict']]
        """
        block describing network connectivity rules that configured for each destinations. These rules override default rules.  Consists of the following fields:
        """
elif False:
    MwsNetworkConnectivityConfigEgressConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworkConnectivityConfigEgressConfigArgs:
    def __init__(__self__, *,
                 default_rules: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs']] = None,
                 target_rules: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs']] = None):
        """
        :param pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs'] default_rules: block describing network connectivity rules that are applied by default without resource specific configurations.  Consists of the following fields:
        :param pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs'] target_rules: block describing network connectivity rules that configured for each destinations. These rules override default rules.  Consists of the following fields:
        """
        if default_rules is not None:
            pulumi.set(__self__, "default_rules", default_rules)
        if target_rules is not None:
            pulumi.set(__self__, "target_rules", target_rules)

    @property
    @pulumi.getter(name="defaultRules")
    def default_rules(self) -> Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs']]:
        """
        block describing network connectivity rules that are applied by default without resource specific configurations.  Consists of the following fields:
        """
        return pulumi.get(self, "default_rules")

    @default_rules.setter
    def default_rules(self, value: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs']]):
        pulumi.set(self, "default_rules", value)

    @property
    @pulumi.getter(name="targetRules")
    def target_rules(self) -> Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs']]:
        """
        block describing network connectivity rules that configured for each destinations. These rules override default rules.  Consists of the following fields:
        """
        return pulumi.get(self, "target_rules")

    @target_rules.setter
    def target_rules(self, value: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs']]):
        pulumi.set(self, "target_rules", value)


if not MYPY:
    class MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgsDict(TypedDict):
        aws_stable_ip_rule: NotRequired[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgsDict']]
        """
        (AWS only) - block with information about stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.  Consists of the following fields:
        """
        azure_service_endpoint_rule: NotRequired[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgsDict']]
        """
        (Azure only) - block with information about stable Azure service endpoints. You can configure the firewall of your Azure resources to allow traffic from your Databricks serverless compute resources.  Consists of the following fields:
        """
elif False:
    MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs:
    def __init__(__self__, *,
                 aws_stable_ip_rule: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs']] = None,
                 azure_service_endpoint_rule: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs']] = None):
        """
        :param pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs'] aws_stable_ip_rule: (AWS only) - block with information about stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.  Consists of the following fields:
        :param pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs'] azure_service_endpoint_rule: (Azure only) - block with information about stable Azure service endpoints. You can configure the firewall of your Azure resources to allow traffic from your Databricks serverless compute resources.  Consists of the following fields:
        """
        if aws_stable_ip_rule is not None:
            pulumi.set(__self__, "aws_stable_ip_rule", aws_stable_ip_rule)
        if azure_service_endpoint_rule is not None:
            pulumi.set(__self__, "azure_service_endpoint_rule", azure_service_endpoint_rule)

    @property
    @pulumi.getter(name="awsStableIpRule")
    def aws_stable_ip_rule(self) -> Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs']]:
        """
        (AWS only) - block with information about stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.  Consists of the following fields:
        """
        return pulumi.get(self, "aws_stable_ip_rule")

    @aws_stable_ip_rule.setter
    def aws_stable_ip_rule(self, value: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs']]):
        pulumi.set(self, "aws_stable_ip_rule", value)

    @property
    @pulumi.getter(name="azureServiceEndpointRule")
    def azure_service_endpoint_rule(self) -> Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs']]:
        """
        (Azure only) - block with information about stable Azure service endpoints. You can configure the firewall of your Azure resources to allow traffic from your Databricks serverless compute resources.  Consists of the following fields:
        """
        return pulumi.get(self, "azure_service_endpoint_rule")

    @azure_service_endpoint_rule.setter
    def azure_service_endpoint_rule(self, value: Optional[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs']]):
        pulumi.set(self, "azure_service_endpoint_rule", value)


if not MYPY:
    class MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgsDict(TypedDict):
        cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of IP CIDR blocks.
        """
elif False:
    MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs:
    def __init__(__self__, *,
                 cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidr_blocks: list of IP CIDR blocks.
        """
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of IP CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidr_blocks", value)


if not MYPY:
    class MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgsDict(TypedDict):
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of subnets from which Databricks network traffic originates when accessing your Azure resources.
        """
        target_region: NotRequired[pulumi.Input[str]]
        """
        the Azure region in which this service endpoint rule applies.
        """
        target_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        the Azure services to which this service endpoint rule applies to.
        """
elif False:
    MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs:
    def __init__(__self__, *,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_region: Optional[pulumi.Input[str]] = None,
                 target_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: list of subnets from which Databricks network traffic originates when accessing your Azure resources.
        :param pulumi.Input[str] target_region: the Azure region in which this service endpoint rule applies.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_services: the Azure services to which this service endpoint rule applies to.
        """
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if target_region is not None:
            pulumi.set(__self__, "target_region", target_region)
        if target_services is not None:
            pulumi.set(__self__, "target_services", target_services)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of subnets from which Databricks network traffic originates when accessing your Azure resources.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> Optional[pulumi.Input[str]]:
        """
        the Azure region in which this service endpoint rule applies.
        """
        return pulumi.get(self, "target_region")

    @target_region.setter
    def target_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_region", value)

    @property
    @pulumi.getter(name="targetServices")
    def target_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        the Azure services to which this service endpoint rule applies to.
        """
        return pulumi.get(self, "target_services")

    @target_services.setter
    def target_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_services", value)


if not MYPY:
    class MwsNetworkConnectivityConfigEgressConfigTargetRulesArgsDict(TypedDict):
        azure_private_endpoint_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgsDict']]]]
        """
        (Azure only) - list containing information about configure Azure Private Endpoints.
        """
elif False:
    MwsNetworkConnectivityConfigEgressConfigTargetRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs:
    def __init__(__self__, *,
                 azure_private_endpoint_rules: Optional[pulumi.Input[Sequence[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs']]] azure_private_endpoint_rules: (Azure only) - list containing information about configure Azure Private Endpoints.
        """
        if azure_private_endpoint_rules is not None:
            pulumi.set(__self__, "azure_private_endpoint_rules", azure_private_endpoint_rules)

    @property
    @pulumi.getter(name="azurePrivateEndpointRules")
    def azure_private_endpoint_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs']]]]:
        """
        (Azure only) - list containing information about configure Azure Private Endpoints.
        """
        return pulumi.get(self, "azure_private_endpoint_rules")

    @azure_private_endpoint_rules.setter
    def azure_private_endpoint_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs']]]]):
        pulumi.set(self, "azure_private_endpoint_rules", value)


if not MYPY:
    class MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgsDict(TypedDict):
        connection_state: NotRequired[pulumi.Input[str]]
        creation_time: NotRequired[pulumi.Input[int]]
        deactivated: NotRequired[pulumi.Input[bool]]
        deactivated_at: NotRequired[pulumi.Input[int]]
        endpoint_name: NotRequired[pulumi.Input[str]]
        group_id: NotRequired[pulumi.Input[str]]
        network_connectivity_config_id: NotRequired[pulumi.Input[str]]
        """
        Canonical unique identifier of Network Connectivity Config in Databricks Account
        """
        resource_id: NotRequired[pulumi.Input[str]]
        rule_id: NotRequired[pulumi.Input[str]]
        updated_time: NotRequired[pulumi.Input[int]]
elif False:
    MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs:
    def __init__(__self__, *,
                 connection_state: Optional[pulumi.Input[str]] = None,
                 creation_time: Optional[pulumi.Input[int]] = None,
                 deactivated: Optional[pulumi.Input[bool]] = None,
                 deactivated_at: Optional[pulumi.Input[int]] = None,
                 endpoint_name: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[str]] = None,
                 network_connectivity_config_id: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None,
                 rule_id: Optional[pulumi.Input[str]] = None,
                 updated_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] network_connectivity_config_id: Canonical unique identifier of Network Connectivity Config in Databricks Account
        """
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if deactivated is not None:
            pulumi.set(__self__, "deactivated", deactivated)
        if deactivated_at is not None:
            pulumi.set(__self__, "deactivated_at", deactivated_at)
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if network_connectivity_config_id is not None:
            pulumi.set(__self__, "network_connectivity_config_id", network_connectivity_config_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if updated_time is not None:
            pulumi.set(__self__, "updated_time", updated_time)

    @property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_state")

    @connection_state.setter
    def connection_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_state", value)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "creation_time")

    @creation_time.setter
    def creation_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "creation_time", value)

    @property
    @pulumi.getter
    def deactivated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deactivated")

    @deactivated.setter
    def deactivated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deactivated", value)

    @property
    @pulumi.getter(name="deactivatedAt")
    def deactivated_at(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "deactivated_at")

    @deactivated_at.setter
    def deactivated_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "deactivated_at", value)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="networkConnectivityConfigId")
    def network_connectivity_config_id(self) -> Optional[pulumi.Input[str]]:
        """
        Canonical unique identifier of Network Connectivity Config in Databricks Account
        """
        return pulumi.get(self, "network_connectivity_config_id")

    @network_connectivity_config_id.setter
    def network_connectivity_config_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_connectivity_config_id", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="updatedTime")
    def updated_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "updated_time")

    @updated_time.setter
    def updated_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "updated_time", value)


if not MYPY:
    class MwsNetworksErrorMessageArgsDict(TypedDict):
        error_message: NotRequired[pulumi.Input[str]]
        error_type: NotRequired[pulumi.Input[str]]
elif False:
    MwsNetworksErrorMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworksErrorMessageArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[str]] = None,
                 error_type: Optional[pulumi.Input[str]] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if error_type is not None:
            pulumi.set(__self__, "error_type", error_type)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter(name="errorType")
    def error_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_type")

    @error_type.setter
    def error_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_type", value)


if not MYPY:
    class MwsNetworksGcpNetworkInfoArgsDict(TypedDict):
        network_project_id: pulumi.Input[str]
        """
        The Google Cloud project ID of the VPC network.
        """
        pod_ip_range_name: pulumi.Input[str]
        """
        The name of the secondary IP range for pods. A Databricks-managed GKE cluster uses this IP range for its pods. This secondary IP range can only be used by one workspace.
        """
        service_ip_range_name: pulumi.Input[str]
        """
        The name of the secondary IP range for services. A Databricks-managed GKE cluster uses this IP range for its services. This secondary IP range can only be used by one workspace.
        """
        subnet_id: pulumi.Input[str]
        """
        The ID of the subnet associated with this network.
        """
        subnet_region: pulumi.Input[str]
        """
        The Google Cloud region of the workspace data plane. For example, `us-east4`.
        """
        vpc_id: pulumi.Input[str]
        """
        The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
elif False:
    MwsNetworksGcpNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworksGcpNetworkInfoArgs:
    def __init__(__self__, *,
                 network_project_id: pulumi.Input[str],
                 pod_ip_range_name: pulumi.Input[str],
                 service_ip_range_name: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 subnet_region: pulumi.Input[str],
                 vpc_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] network_project_id: The Google Cloud project ID of the VPC network.
        :param pulumi.Input[str] pod_ip_range_name: The name of the secondary IP range for pods. A Databricks-managed GKE cluster uses this IP range for its pods. This secondary IP range can only be used by one workspace.
        :param pulumi.Input[str] service_ip_range_name: The name of the secondary IP range for services. A Databricks-managed GKE cluster uses this IP range for its services. This secondary IP range can only be used by one workspace.
        :param pulumi.Input[str] subnet_id: The ID of the subnet associated with this network.
        :param pulumi.Input[str] subnet_region: The Google Cloud region of the workspace data plane. For example, `us-east4`.
        :param pulumi.Input[str] vpc_id: The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
        pulumi.set(__self__, "network_project_id", network_project_id)
        pulumi.set(__self__, "pod_ip_range_name", pod_ip_range_name)
        pulumi.set(__self__, "service_ip_range_name", service_ip_range_name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subnet_region", subnet_region)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="networkProjectId")
    def network_project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud project ID of the VPC network.
        """
        return pulumi.get(self, "network_project_id")

    @network_project_id.setter
    def network_project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_project_id", value)

    @property
    @pulumi.getter(name="podIpRangeName")
    def pod_ip_range_name(self) -> pulumi.Input[str]:
        """
        The name of the secondary IP range for pods. A Databricks-managed GKE cluster uses this IP range for its pods. This secondary IP range can only be used by one workspace.
        """
        return pulumi.get(self, "pod_ip_range_name")

    @pod_ip_range_name.setter
    def pod_ip_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "pod_ip_range_name", value)

    @property
    @pulumi.getter(name="serviceIpRangeName")
    def service_ip_range_name(self) -> pulumi.Input[str]:
        """
        The name of the secondary IP range for services. A Databricks-managed GKE cluster uses this IP range for its services. This secondary IP range can only be used by one workspace.
        """
        return pulumi.get(self, "service_ip_range_name")

    @service_ip_range_name.setter
    def service_ip_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_ip_range_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the subnet associated with this network.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="subnetRegion")
    def subnet_region(self) -> pulumi.Input[str]:
        """
        The Google Cloud region of the workspace data plane. For example, `us-east4`.
        """
        return pulumi.get(self, "subnet_region")

    @subnet_region.setter
    def subnet_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_region", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        """
        The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class MwsNetworksVpcEndpointsArgsDict(TypedDict):
        dataplane_relays: pulumi.Input[Sequence[pulumi.Input[str]]]
        rest_apis: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MwsNetworksVpcEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsNetworksVpcEndpointsArgs:
    def __init__(__self__, *,
                 dataplane_relays: pulumi.Input[Sequence[pulumi.Input[str]]],
                 rest_apis: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "dataplane_relays", dataplane_relays)
        pulumi.set(__self__, "rest_apis", rest_apis)

    @property
    @pulumi.getter(name="dataplaneRelays")
    def dataplane_relays(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "dataplane_relays")

    @dataplane_relays.setter
    def dataplane_relays(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dataplane_relays", value)

    @property
    @pulumi.getter(name="restApis")
    def rest_apis(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "rest_apis")

    @rest_apis.setter
    def rest_apis(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "rest_apis", value)


if not MYPY:
    class MwsVpcEndpointGcpVpcEndpointInfoArgsDict(TypedDict):
        endpoint_region: pulumi.Input[str]
        """
        Region of the PSC endpoint.
        """
        project_id: pulumi.Input[str]
        """
        The Google Cloud project ID of the VPC network where the PSC connection resides.
        """
        psc_endpoint_name: pulumi.Input[str]
        """
        The name of the PSC endpoint in the Google Cloud project.
        """
        psc_connection_id: NotRequired[pulumi.Input[str]]
        """
        The unique ID of this PSC connection.
        """
        service_attachment_id: NotRequired[pulumi.Input[str]]
        """
        The service attachment this PSC connection connects to.
        """
elif False:
    MwsVpcEndpointGcpVpcEndpointInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsVpcEndpointGcpVpcEndpointInfoArgs:
    def __init__(__self__, *,
                 endpoint_region: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 psc_endpoint_name: pulumi.Input[str],
                 psc_connection_id: Optional[pulumi.Input[str]] = None,
                 service_attachment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_region: Region of the PSC endpoint.
        :param pulumi.Input[str] project_id: The Google Cloud project ID of the VPC network where the PSC connection resides.
        :param pulumi.Input[str] psc_endpoint_name: The name of the PSC endpoint in the Google Cloud project.
        :param pulumi.Input[str] psc_connection_id: The unique ID of this PSC connection.
        :param pulumi.Input[str] service_attachment_id: The service attachment this PSC connection connects to.
        """
        pulumi.set(__self__, "endpoint_region", endpoint_region)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "psc_endpoint_name", psc_endpoint_name)
        if psc_connection_id is not None:
            pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        if service_attachment_id is not None:
            pulumi.set(__self__, "service_attachment_id", service_attachment_id)

    @property
    @pulumi.getter(name="endpointRegion")
    def endpoint_region(self) -> pulumi.Input[str]:
        """
        Region of the PSC endpoint.
        """
        return pulumi.get(self, "endpoint_region")

    @endpoint_region.setter
    def endpoint_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_region", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud project ID of the VPC network where the PSC connection resides.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="pscEndpointName")
    def psc_endpoint_name(self) -> pulumi.Input[str]:
        """
        The name of the PSC endpoint in the Google Cloud project.
        """
        return pulumi.get(self, "psc_endpoint_name")

    @psc_endpoint_name.setter
    def psc_endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "psc_endpoint_name", value)

    @property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID of this PSC connection.
        """
        return pulumi.get(self, "psc_connection_id")

    @psc_connection_id.setter
    def psc_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psc_connection_id", value)

    @property
    @pulumi.getter(name="serviceAttachmentId")
    def service_attachment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The service attachment this PSC connection connects to.
        """
        return pulumi.get(self, "service_attachment_id")

    @service_attachment_id.setter
    def service_attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_attachment_id", value)


if not MYPY:
    class MwsWorkspacesCloudResourceContainerArgsDict(TypedDict):
        gcp: pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgsDict']
        """
        A block that consists of the following field:
        """
elif False:
    MwsWorkspacesCloudResourceContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsWorkspacesCloudResourceContainerArgs:
    def __init__(__self__, *,
                 gcp: pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']):
        """
        :param pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs'] gcp: A block that consists of the following field:
        """
        pulumi.set(__self__, "gcp", gcp)

    @property
    @pulumi.getter
    def gcp(self) -> pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']:
        """
        A block that consists of the following field:
        """
        return pulumi.get(self, "gcp")

    @gcp.setter
    def gcp(self, value: pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']):
        pulumi.set(self, "gcp", value)


if not MYPY:
    class MwsWorkspacesCloudResourceContainerGcpArgsDict(TypedDict):
        project_id: pulumi.Input[str]
        """
        The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
elif False:
    MwsWorkspacesCloudResourceContainerGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsWorkspacesCloudResourceContainerGcpArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] project_id: The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class MwsWorkspacesExternalCustomerInfoArgsDict(TypedDict):
        authoritative_user_email: pulumi.Input[str]
        authoritative_user_full_name: pulumi.Input[str]
        customer_name: pulumi.Input[str]
elif False:
    MwsWorkspacesExternalCustomerInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsWorkspacesExternalCustomerInfoArgs:
    def __init__(__self__, *,
                 authoritative_user_email: pulumi.Input[str],
                 authoritative_user_full_name: pulumi.Input[str],
                 customer_name: pulumi.Input[str]):
        pulumi.set(__self__, "authoritative_user_email", authoritative_user_email)
        pulumi.set(__self__, "authoritative_user_full_name", authoritative_user_full_name)
        pulumi.set(__self__, "customer_name", customer_name)

    @property
    @pulumi.getter(name="authoritativeUserEmail")
    def authoritative_user_email(self) -> pulumi.Input[str]:
        return pulumi.get(self, "authoritative_user_email")

    @authoritative_user_email.setter
    def authoritative_user_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "authoritative_user_email", value)

    @property
    @pulumi.getter(name="authoritativeUserFullName")
    def authoritative_user_full_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "authoritative_user_full_name")

    @authoritative_user_full_name.setter
    def authoritative_user_full_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "authoritative_user_full_name", value)

    @property
    @pulumi.getter(name="customerName")
    def customer_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "customer_name")

    @customer_name.setter
    def customer_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "customer_name", value)


if not MYPY:
    class MwsWorkspacesGcpManagedNetworkConfigArgsDict(TypedDict):
        gke_cluster_pod_ip_range: pulumi.Input[str]
        gke_cluster_service_ip_range: pulumi.Input[str]
        subnet_cidr: pulumi.Input[str]
elif False:
    MwsWorkspacesGcpManagedNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsWorkspacesGcpManagedNetworkConfigArgs:
    def __init__(__self__, *,
                 gke_cluster_pod_ip_range: pulumi.Input[str],
                 gke_cluster_service_ip_range: pulumi.Input[str],
                 subnet_cidr: pulumi.Input[str]):
        pulumi.set(__self__, "gke_cluster_pod_ip_range", gke_cluster_pod_ip_range)
        pulumi.set(__self__, "gke_cluster_service_ip_range", gke_cluster_service_ip_range)
        pulumi.set(__self__, "subnet_cidr", subnet_cidr)

    @property
    @pulumi.getter(name="gkeClusterPodIpRange")
    def gke_cluster_pod_ip_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gke_cluster_pod_ip_range")

    @gke_cluster_pod_ip_range.setter
    def gke_cluster_pod_ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "gke_cluster_pod_ip_range", value)

    @property
    @pulumi.getter(name="gkeClusterServiceIpRange")
    def gke_cluster_service_ip_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gke_cluster_service_ip_range")

    @gke_cluster_service_ip_range.setter
    def gke_cluster_service_ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "gke_cluster_service_ip_range", value)

    @property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnet_cidr")

    @subnet_cidr.setter
    def subnet_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_cidr", value)


if not MYPY:
    class MwsWorkspacesGkeConfigArgsDict(TypedDict):
        connectivity_type: pulumi.Input[str]
        """
        Specifies the network connectivity types for the GKE nodes and the GKE master network. Possible values are: `PRIVATE_NODE_PUBLIC_MASTER`, `PUBLIC_NODE_PUBLIC_MASTER`.
        """
        master_ip_range: pulumi.Input[str]
        """
        The IP range from which to allocate GKE cluster master resources. This field will be ignored if GKE private cluster is not enabled. It must be exactly as big as `/28`.
        """
elif False:
    MwsWorkspacesGkeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsWorkspacesGkeConfigArgs:
    def __init__(__self__, *,
                 connectivity_type: pulumi.Input[str],
                 master_ip_range: pulumi.Input[str]):
        """
        :param pulumi.Input[str] connectivity_type: Specifies the network connectivity types for the GKE nodes and the GKE master network. Possible values are: `PRIVATE_NODE_PUBLIC_MASTER`, `PUBLIC_NODE_PUBLIC_MASTER`.
        :param pulumi.Input[str] master_ip_range: The IP range from which to allocate GKE cluster master resources. This field will be ignored if GKE private cluster is not enabled. It must be exactly as big as `/28`.
        """
        pulumi.set(__self__, "connectivity_type", connectivity_type)
        pulumi.set(__self__, "master_ip_range", master_ip_range)

    @property
    @pulumi.getter(name="connectivityType")
    def connectivity_type(self) -> pulumi.Input[str]:
        """
        Specifies the network connectivity types for the GKE nodes and the GKE master network. Possible values are: `PRIVATE_NODE_PUBLIC_MASTER`, `PUBLIC_NODE_PUBLIC_MASTER`.
        """
        return pulumi.get(self, "connectivity_type")

    @connectivity_type.setter
    def connectivity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connectivity_type", value)

    @property
    @pulumi.getter(name="masterIpRange")
    def master_ip_range(self) -> pulumi.Input[str]:
        """
        The IP range from which to allocate GKE cluster master resources. This field will be ignored if GKE private cluster is not enabled. It must be exactly as big as `/28`.
        """
        return pulumi.get(self, "master_ip_range")

    @master_ip_range.setter
    def master_ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_ip_range", value)


if not MYPY:
    class MwsWorkspacesTokenArgsDict(TypedDict):
        comment: NotRequired[pulumi.Input[str]]
        """
        Comment, that will appear in "User Settings / Access Tokens" page on Workspace UI. By default it's "Pulumi PAT".
        """
        lifetime_seconds: NotRequired[pulumi.Input[int]]
        """
        Token expiry lifetime. By default its 2592000 (30 days).
        """
        token_id: NotRequired[pulumi.Input[str]]
        token_value: NotRequired[pulumi.Input[str]]
elif False:
    MwsWorkspacesTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MwsWorkspacesTokenArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[str]] = None,
                 lifetime_seconds: Optional[pulumi.Input[int]] = None,
                 token_id: Optional[pulumi.Input[str]] = None,
                 token_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] comment: Comment, that will appear in "User Settings / Access Tokens" page on Workspace UI. By default it's "Pulumi PAT".
        :param pulumi.Input[int] lifetime_seconds: Token expiry lifetime. By default its 2592000 (30 days).
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if token_id is not None:
            pulumi.set(__self__, "token_id", token_id)
        if token_value is not None:
            pulumi.set(__self__, "token_value", token_value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Comment, that will appear in "User Settings / Access Tokens" page on Workspace UI. By default it's "Pulumi PAT".
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Token expiry lifetime. By default its 2592000 (30 days).
        """
        return pulumi.get(self, "lifetime_seconds")

    @lifetime_seconds.setter
    def lifetime_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime_seconds", value)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_id", value)

    @property
    @pulumi.getter(name="tokenValue")
    def token_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_value")

    @token_value.setter
    def token_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_value", value)


if not MYPY:
    class NotificationDestinationConfigArgsDict(TypedDict):
        email: NotRequired[pulumi.Input['NotificationDestinationConfigEmailArgsDict']]
        """
        The email configuration of the Notification Destination. It must contain the following:
        """
        generic_webhook: NotRequired[pulumi.Input['NotificationDestinationConfigGenericWebhookArgsDict']]
        """
        The Generic Webhook configuration of the Notification Destination. It must contain the following:
        """
        microsoft_teams: NotRequired[pulumi.Input['NotificationDestinationConfigMicrosoftTeamsArgsDict']]
        """
        The Microsoft Teams configuration of the Notification Destination. It must contain the following:
        """
        pagerduty: NotRequired[pulumi.Input['NotificationDestinationConfigPagerdutyArgsDict']]
        """
        The PagerDuty configuration of the Notification Destination. It must contain the following:
        """
        slack: NotRequired[pulumi.Input['NotificationDestinationConfigSlackArgsDict']]
        """
        The Slack configuration of the Notification Destination. It must contain the following:
        """
elif False:
    NotificationDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationDestinationConfigArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input['NotificationDestinationConfigEmailArgs']] = None,
                 generic_webhook: Optional[pulumi.Input['NotificationDestinationConfigGenericWebhookArgs']] = None,
                 microsoft_teams: Optional[pulumi.Input['NotificationDestinationConfigMicrosoftTeamsArgs']] = None,
                 pagerduty: Optional[pulumi.Input['NotificationDestinationConfigPagerdutyArgs']] = None,
                 slack: Optional[pulumi.Input['NotificationDestinationConfigSlackArgs']] = None):
        """
        :param pulumi.Input['NotificationDestinationConfigEmailArgs'] email: The email configuration of the Notification Destination. It must contain the following:
        :param pulumi.Input['NotificationDestinationConfigGenericWebhookArgs'] generic_webhook: The Generic Webhook configuration of the Notification Destination. It must contain the following:
        :param pulumi.Input['NotificationDestinationConfigMicrosoftTeamsArgs'] microsoft_teams: The Microsoft Teams configuration of the Notification Destination. It must contain the following:
        :param pulumi.Input['NotificationDestinationConfigPagerdutyArgs'] pagerduty: The PagerDuty configuration of the Notification Destination. It must contain the following:
        :param pulumi.Input['NotificationDestinationConfigSlackArgs'] slack: The Slack configuration of the Notification Destination. It must contain the following:
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if generic_webhook is not None:
            pulumi.set(__self__, "generic_webhook", generic_webhook)
        if microsoft_teams is not None:
            pulumi.set(__self__, "microsoft_teams", microsoft_teams)
        if pagerduty is not None:
            pulumi.set(__self__, "pagerduty", pagerduty)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['NotificationDestinationConfigEmailArgs']]:
        """
        The email configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['NotificationDestinationConfigEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="genericWebhook")
    def generic_webhook(self) -> Optional[pulumi.Input['NotificationDestinationConfigGenericWebhookArgs']]:
        """
        The Generic Webhook configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "generic_webhook")

    @generic_webhook.setter
    def generic_webhook(self, value: Optional[pulumi.Input['NotificationDestinationConfigGenericWebhookArgs']]):
        pulumi.set(self, "generic_webhook", value)

    @property
    @pulumi.getter(name="microsoftTeams")
    def microsoft_teams(self) -> Optional[pulumi.Input['NotificationDestinationConfigMicrosoftTeamsArgs']]:
        """
        The Microsoft Teams configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "microsoft_teams")

    @microsoft_teams.setter
    def microsoft_teams(self, value: Optional[pulumi.Input['NotificationDestinationConfigMicrosoftTeamsArgs']]):
        pulumi.set(self, "microsoft_teams", value)

    @property
    @pulumi.getter
    def pagerduty(self) -> Optional[pulumi.Input['NotificationDestinationConfigPagerdutyArgs']]:
        """
        The PagerDuty configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "pagerduty")

    @pagerduty.setter
    def pagerduty(self, value: Optional[pulumi.Input['NotificationDestinationConfigPagerdutyArgs']]):
        pulumi.set(self, "pagerduty", value)

    @property
    @pulumi.getter
    def slack(self) -> Optional[pulumi.Input['NotificationDestinationConfigSlackArgs']]:
        """
        The Slack configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "slack")

    @slack.setter
    def slack(self, value: Optional[pulumi.Input['NotificationDestinationConfigSlackArgs']]):
        pulumi.set(self, "slack", value)


if not MYPY:
    class NotificationDestinationConfigEmailArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of email addresses to send notifications to.
        """
elif False:
    NotificationDestinationConfigEmailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationDestinationConfigEmailArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The list of email addresses to send notifications to.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of email addresses to send notifications to.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)


if not MYPY:
    class NotificationDestinationConfigGenericWebhookArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        The password for basic authentication.

        > **NOTE** If the type of notification destination is changed, the existing notification destination will be deleted and a new notification destination will be created with the new type.
        """
        password_set: NotRequired[pulumi.Input[bool]]
        url: NotRequired[pulumi.Input[str]]
        """
        The Generic Webhook URL.
        """
        url_set: NotRequired[pulumi.Input[bool]]
        username: NotRequired[pulumi.Input[str]]
        """
        The username for basic authentication.
        """
        username_set: NotRequired[pulumi.Input[bool]]
elif False:
    NotificationDestinationConfigGenericWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationDestinationConfigGenericWebhookArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 password_set: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 url_set: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 username_set: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] password: The password for basic authentication.
               
               > **NOTE** If the type of notification destination is changed, the existing notification destination will be deleted and a new notification destination will be created with the new type.
        :param pulumi.Input[str] url: The Generic Webhook URL.
        :param pulumi.Input[str] username: The username for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if password_set is not None:
            pulumi.set(__self__, "password_set", password_set)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_set is not None:
            pulumi.set(__self__, "url_set", url_set)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_set is not None:
            pulumi.set(__self__, "username_set", username_set)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for basic authentication.

        > **NOTE** If the type of notification destination is changed, the existing notification destination will be deleted and a new notification destination will be created with the new type.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="passwordSet")
    def password_set(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "password_set")

    @password_set.setter
    def password_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "password_set", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The Generic Webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="urlSet")
    def url_set(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "url_set")

    @url_set.setter
    def url_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "url_set", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username for basic authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameSet")
    def username_set(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "username_set")

    @username_set.setter
    def username_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "username_set", value)


if not MYPY:
    class NotificationDestinationConfigMicrosoftTeamsArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        The Microsoft Teams webhook URL.
        """
        url_set: NotRequired[pulumi.Input[bool]]
elif False:
    NotificationDestinationConfigMicrosoftTeamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationDestinationConfigMicrosoftTeamsArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None,
                 url_set: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The Microsoft Teams webhook URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_set is not None:
            pulumi.set(__self__, "url_set", url_set)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The Microsoft Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="urlSet")
    def url_set(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "url_set")

    @url_set.setter
    def url_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "url_set", value)


if not MYPY:
    class NotificationDestinationConfigPagerdutyArgsDict(TypedDict):
        integration_key: NotRequired[pulumi.Input[str]]
        """
        The PagerDuty integration key.
        """
        integration_key_set: NotRequired[pulumi.Input[bool]]
elif False:
    NotificationDestinationConfigPagerdutyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationDestinationConfigPagerdutyArgs:
    def __init__(__self__, *,
                 integration_key: Optional[pulumi.Input[str]] = None,
                 integration_key_set: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] integration_key: The PagerDuty integration key.
        """
        if integration_key is not None:
            pulumi.set(__self__, "integration_key", integration_key)
        if integration_key_set is not None:
            pulumi.set(__self__, "integration_key_set", integration_key_set)

    @property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> Optional[pulumi.Input[str]]:
        """
        The PagerDuty integration key.
        """
        return pulumi.get(self, "integration_key")

    @integration_key.setter
    def integration_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integration_key", value)

    @property
    @pulumi.getter(name="integrationKeySet")
    def integration_key_set(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "integration_key_set")

    @integration_key_set.setter
    def integration_key_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "integration_key_set", value)


if not MYPY:
    class NotificationDestinationConfigSlackArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[str]]
        """
        The Slack webhook URL.
        """
        url_set: NotRequired[pulumi.Input[bool]]
elif False:
    NotificationDestinationConfigSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationDestinationConfigSlackArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None,
                 url_set: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The Slack webhook URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_set is not None:
            pulumi.set(__self__, "url_set", url_set)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="urlSet")
    def url_set(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "url_set")

    @url_set.setter
    def url_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "url_set", value)


if not MYPY:
    class OnlineTableSpecArgsDict(TypedDict):
        perform_full_copy: NotRequired[pulumi.Input[bool]]
        """
        Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports "triggered" scheduling policy.
        """
        pipeline_id: NotRequired[pulumi.Input[str]]
        """
        ID of the associated Delta Live Table pipeline.
        """
        primary_key_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of the columns comprising the primary key.
        """
        run_continuously: NotRequired[pulumi.Input['OnlineTableSpecRunContinuouslyArgsDict']]
        """
        empty block that specifies that pipeline runs continuously after generating the initial data.  Conflicts with `run_triggered`.
        """
        run_triggered: NotRequired[pulumi.Input['OnlineTableSpecRunTriggeredArgsDict']]
        """
        empty block that specifies that pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers).
        """
        source_table_full_name: NotRequired[pulumi.Input[str]]
        """
        full name of the source table.
        """
        timeseries_key: NotRequired[pulumi.Input[str]]
        """
        Time series key to deduplicate (tie-break) rows with the same primary key.
        """
elif False:
    OnlineTableSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableSpecArgs:
    def __init__(__self__, *,
                 perform_full_copy: Optional[pulumi.Input[bool]] = None,
                 pipeline_id: Optional[pulumi.Input[str]] = None,
                 primary_key_columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 run_continuously: Optional[pulumi.Input['OnlineTableSpecRunContinuouslyArgs']] = None,
                 run_triggered: Optional[pulumi.Input['OnlineTableSpecRunTriggeredArgs']] = None,
                 source_table_full_name: Optional[pulumi.Input[str]] = None,
                 timeseries_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] perform_full_copy: Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports "triggered" scheduling policy.
        :param pulumi.Input[str] pipeline_id: ID of the associated Delta Live Table pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] primary_key_columns: list of the columns comprising the primary key.
        :param pulumi.Input['OnlineTableSpecRunContinuouslyArgs'] run_continuously: empty block that specifies that pipeline runs continuously after generating the initial data.  Conflicts with `run_triggered`.
        :param pulumi.Input['OnlineTableSpecRunTriggeredArgs'] run_triggered: empty block that specifies that pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers).
        :param pulumi.Input[str] source_table_full_name: full name of the source table.
        :param pulumi.Input[str] timeseries_key: Time series key to deduplicate (tie-break) rows with the same primary key.
        """
        if perform_full_copy is not None:
            pulumi.set(__self__, "perform_full_copy", perform_full_copy)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if primary_key_columns is not None:
            pulumi.set(__self__, "primary_key_columns", primary_key_columns)
        if run_continuously is not None:
            pulumi.set(__self__, "run_continuously", run_continuously)
        if run_triggered is not None:
            pulumi.set(__self__, "run_triggered", run_triggered)
        if source_table_full_name is not None:
            pulumi.set(__self__, "source_table_full_name", source_table_full_name)
        if timeseries_key is not None:
            pulumi.set(__self__, "timeseries_key", timeseries_key)

    @property
    @pulumi.getter(name="performFullCopy")
    def perform_full_copy(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports "triggered" scheduling policy.
        """
        return pulumi.get(self, "perform_full_copy")

    @perform_full_copy.setter
    def perform_full_copy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "perform_full_copy", value)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the associated Delta Live Table pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="primaryKeyColumns")
    def primary_key_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of the columns comprising the primary key.
        """
        return pulumi.get(self, "primary_key_columns")

    @primary_key_columns.setter
    def primary_key_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "primary_key_columns", value)

    @property
    @pulumi.getter(name="runContinuously")
    def run_continuously(self) -> Optional[pulumi.Input['OnlineTableSpecRunContinuouslyArgs']]:
        """
        empty block that specifies that pipeline runs continuously after generating the initial data.  Conflicts with `run_triggered`.
        """
        return pulumi.get(self, "run_continuously")

    @run_continuously.setter
    def run_continuously(self, value: Optional[pulumi.Input['OnlineTableSpecRunContinuouslyArgs']]):
        pulumi.set(self, "run_continuously", value)

    @property
    @pulumi.getter(name="runTriggered")
    def run_triggered(self) -> Optional[pulumi.Input['OnlineTableSpecRunTriggeredArgs']]:
        """
        empty block that specifies that pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers).
        """
        return pulumi.get(self, "run_triggered")

    @run_triggered.setter
    def run_triggered(self, value: Optional[pulumi.Input['OnlineTableSpecRunTriggeredArgs']]):
        pulumi.set(self, "run_triggered", value)

    @property
    @pulumi.getter(name="sourceTableFullName")
    def source_table_full_name(self) -> Optional[pulumi.Input[str]]:
        """
        full name of the source table.
        """
        return pulumi.get(self, "source_table_full_name")

    @source_table_full_name.setter
    def source_table_full_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_table_full_name", value)

    @property
    @pulumi.getter(name="timeseriesKey")
    def timeseries_key(self) -> Optional[pulumi.Input[str]]:
        """
        Time series key to deduplicate (tie-break) rows with the same primary key.
        """
        return pulumi.get(self, "timeseries_key")

    @timeseries_key.setter
    def timeseries_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeseries_key", value)


if not MYPY:
    class OnlineTableSpecRunContinuouslyArgsDict(TypedDict):
        pass
elif False:
    OnlineTableSpecRunContinuouslyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableSpecRunContinuouslyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class OnlineTableSpecRunTriggeredArgsDict(TypedDict):
        pass
elif False:
    OnlineTableSpecRunTriggeredArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableSpecRunTriggeredArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class OnlineTableStatusArgsDict(TypedDict):
        continuous_update_status: NotRequired[pulumi.Input['OnlineTableStatusContinuousUpdateStatusArgsDict']]
        detailed_state: NotRequired[pulumi.Input[str]]
        """
        The state of the online table.
        """
        failed_status: NotRequired[pulumi.Input['OnlineTableStatusFailedStatusArgsDict']]
        message: NotRequired[pulumi.Input[str]]
        """
        A text description of the current state of the online table.
        """
        provisioning_status: NotRequired[pulumi.Input['OnlineTableStatusProvisioningStatusArgsDict']]
        triggered_update_status: NotRequired[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusArgsDict']]
elif False:
    OnlineTableStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusArgs:
    def __init__(__self__, *,
                 continuous_update_status: Optional[pulumi.Input['OnlineTableStatusContinuousUpdateStatusArgs']] = None,
                 detailed_state: Optional[pulumi.Input[str]] = None,
                 failed_status: Optional[pulumi.Input['OnlineTableStatusFailedStatusArgs']] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 provisioning_status: Optional[pulumi.Input['OnlineTableStatusProvisioningStatusArgs']] = None,
                 triggered_update_status: Optional[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusArgs']] = None):
        """
        :param pulumi.Input[str] detailed_state: The state of the online table.
        :param pulumi.Input[str] message: A text description of the current state of the online table.
        """
        if continuous_update_status is not None:
            pulumi.set(__self__, "continuous_update_status", continuous_update_status)
        if detailed_state is not None:
            pulumi.set(__self__, "detailed_state", detailed_state)
        if failed_status is not None:
            pulumi.set(__self__, "failed_status", failed_status)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if triggered_update_status is not None:
            pulumi.set(__self__, "triggered_update_status", triggered_update_status)

    @property
    @pulumi.getter(name="continuousUpdateStatus")
    def continuous_update_status(self) -> Optional[pulumi.Input['OnlineTableStatusContinuousUpdateStatusArgs']]:
        return pulumi.get(self, "continuous_update_status")

    @continuous_update_status.setter
    def continuous_update_status(self, value: Optional[pulumi.Input['OnlineTableStatusContinuousUpdateStatusArgs']]):
        pulumi.set(self, "continuous_update_status", value)

    @property
    @pulumi.getter(name="detailedState")
    def detailed_state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the online table.
        """
        return pulumi.get(self, "detailed_state")

    @detailed_state.setter
    def detailed_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detailed_state", value)

    @property
    @pulumi.getter(name="failedStatus")
    def failed_status(self) -> Optional[pulumi.Input['OnlineTableStatusFailedStatusArgs']]:
        return pulumi.get(self, "failed_status")

    @failed_status.setter
    def failed_status(self, value: Optional[pulumi.Input['OnlineTableStatusFailedStatusArgs']]):
        pulumi.set(self, "failed_status", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A text description of the current state of the online table.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional[pulumi.Input['OnlineTableStatusProvisioningStatusArgs']]:
        return pulumi.get(self, "provisioning_status")

    @provisioning_status.setter
    def provisioning_status(self, value: Optional[pulumi.Input['OnlineTableStatusProvisioningStatusArgs']]):
        pulumi.set(self, "provisioning_status", value)

    @property
    @pulumi.getter(name="triggeredUpdateStatus")
    def triggered_update_status(self) -> Optional[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusArgs']]:
        return pulumi.get(self, "triggered_update_status")

    @triggered_update_status.setter
    def triggered_update_status(self, value: Optional[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusArgs']]):
        pulumi.set(self, "triggered_update_status", value)


if not MYPY:
    class OnlineTableStatusContinuousUpdateStatusArgsDict(TypedDict):
        initial_pipeline_sync_progress: NotRequired[pulumi.Input['OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgsDict']]
        last_processed_commit_version: NotRequired[pulumi.Input[int]]
        timestamp: NotRequired[pulumi.Input[str]]
elif False:
    OnlineTableStatusContinuousUpdateStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusContinuousUpdateStatusArgs:
    def __init__(__self__, *,
                 initial_pipeline_sync_progress: Optional[pulumi.Input['OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs']] = None,
                 last_processed_commit_version: Optional[pulumi.Input[int]] = None,
                 timestamp: Optional[pulumi.Input[str]] = None):
        if initial_pipeline_sync_progress is not None:
            pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> Optional[pulumi.Input['OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs']]:
        return pulumi.get(self, "initial_pipeline_sync_progress")

    @initial_pipeline_sync_progress.setter
    def initial_pipeline_sync_progress(self, value: Optional[pulumi.Input['OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs']]):
        pulumi.set(self, "initial_pipeline_sync_progress", value)

    @property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "last_processed_commit_version")

    @last_processed_commit_version.setter
    def last_processed_commit_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_processed_commit_version", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgsDict(TypedDict):
        estimated_completion_time_seconds: NotRequired[pulumi.Input[float]]
        latest_version_currently_processing: NotRequired[pulumi.Input[int]]
        sync_progress_completion: NotRequired[pulumi.Input[float]]
        synced_row_count: NotRequired[pulumi.Input[int]]
        total_row_count: NotRequired[pulumi.Input[int]]
elif False:
    OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs:
    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[pulumi.Input[float]] = None,
                 latest_version_currently_processing: Optional[pulumi.Input[int]] = None,
                 sync_progress_completion: Optional[pulumi.Input[float]] = None,
                 synced_row_count: Optional[pulumi.Input[int]] = None,
                 total_row_count: Optional[pulumi.Input[int]] = None):
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "estimated_completion_time_seconds")

    @estimated_completion_time_seconds.setter
    def estimated_completion_time_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "estimated_completion_time_seconds", value)

    @property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "latest_version_currently_processing")

    @latest_version_currently_processing.setter
    def latest_version_currently_processing(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "latest_version_currently_processing", value)

    @property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "sync_progress_completion")

    @sync_progress_completion.setter
    def sync_progress_completion(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sync_progress_completion", value)

    @property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "synced_row_count")

    @synced_row_count.setter
    def synced_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "synced_row_count", value)

    @property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "total_row_count")

    @total_row_count.setter
    def total_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_row_count", value)


if not MYPY:
    class OnlineTableStatusFailedStatusArgsDict(TypedDict):
        last_processed_commit_version: NotRequired[pulumi.Input[int]]
        timestamp: NotRequired[pulumi.Input[str]]
elif False:
    OnlineTableStatusFailedStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusFailedStatusArgs:
    def __init__(__self__, *,
                 last_processed_commit_version: Optional[pulumi.Input[int]] = None,
                 timestamp: Optional[pulumi.Input[str]] = None):
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "last_processed_commit_version")

    @last_processed_commit_version.setter
    def last_processed_commit_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_processed_commit_version", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class OnlineTableStatusProvisioningStatusArgsDict(TypedDict):
        initial_pipeline_sync_progress: NotRequired[pulumi.Input['OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgsDict']]
elif False:
    OnlineTableStatusProvisioningStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusProvisioningStatusArgs:
    def __init__(__self__, *,
                 initial_pipeline_sync_progress: Optional[pulumi.Input['OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgs']] = None):
        if initial_pipeline_sync_progress is not None:
            pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)

    @property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> Optional[pulumi.Input['OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgs']]:
        return pulumi.get(self, "initial_pipeline_sync_progress")

    @initial_pipeline_sync_progress.setter
    def initial_pipeline_sync_progress(self, value: Optional[pulumi.Input['OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgs']]):
        pulumi.set(self, "initial_pipeline_sync_progress", value)


if not MYPY:
    class OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgsDict(TypedDict):
        estimated_completion_time_seconds: NotRequired[pulumi.Input[float]]
        latest_version_currently_processing: NotRequired[pulumi.Input[int]]
        sync_progress_completion: NotRequired[pulumi.Input[float]]
        synced_row_count: NotRequired[pulumi.Input[int]]
        total_row_count: NotRequired[pulumi.Input[int]]
elif False:
    OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusProvisioningStatusInitialPipelineSyncProgressArgs:
    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[pulumi.Input[float]] = None,
                 latest_version_currently_processing: Optional[pulumi.Input[int]] = None,
                 sync_progress_completion: Optional[pulumi.Input[float]] = None,
                 synced_row_count: Optional[pulumi.Input[int]] = None,
                 total_row_count: Optional[pulumi.Input[int]] = None):
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "estimated_completion_time_seconds")

    @estimated_completion_time_seconds.setter
    def estimated_completion_time_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "estimated_completion_time_seconds", value)

    @property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "latest_version_currently_processing")

    @latest_version_currently_processing.setter
    def latest_version_currently_processing(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "latest_version_currently_processing", value)

    @property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "sync_progress_completion")

    @sync_progress_completion.setter
    def sync_progress_completion(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sync_progress_completion", value)

    @property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "synced_row_count")

    @synced_row_count.setter
    def synced_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "synced_row_count", value)

    @property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "total_row_count")

    @total_row_count.setter
    def total_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_row_count", value)


if not MYPY:
    class OnlineTableStatusTriggeredUpdateStatusArgsDict(TypedDict):
        last_processed_commit_version: NotRequired[pulumi.Input[int]]
        timestamp: NotRequired[pulumi.Input[str]]
        triggered_update_progress: NotRequired[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgsDict']]
elif False:
    OnlineTableStatusTriggeredUpdateStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusTriggeredUpdateStatusArgs:
    def __init__(__self__, *,
                 last_processed_commit_version: Optional[pulumi.Input[int]] = None,
                 timestamp: Optional[pulumi.Input[str]] = None,
                 triggered_update_progress: Optional[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs']] = None):
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)
        if triggered_update_progress is not None:
            pulumi.set(__self__, "triggered_update_progress", triggered_update_progress)

    @property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "last_processed_commit_version")

    @last_processed_commit_version.setter
    def last_processed_commit_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_processed_commit_version", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp", value)

    @property
    @pulumi.getter(name="triggeredUpdateProgress")
    def triggered_update_progress(self) -> Optional[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs']]:
        return pulumi.get(self, "triggered_update_progress")

    @triggered_update_progress.setter
    def triggered_update_progress(self, value: Optional[pulumi.Input['OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs']]):
        pulumi.set(self, "triggered_update_progress", value)


if not MYPY:
    class OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgsDict(TypedDict):
        estimated_completion_time_seconds: NotRequired[pulumi.Input[float]]
        latest_version_currently_processing: NotRequired[pulumi.Input[int]]
        sync_progress_completion: NotRequired[pulumi.Input[float]]
        synced_row_count: NotRequired[pulumi.Input[int]]
        total_row_count: NotRequired[pulumi.Input[int]]
elif False:
    OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs:
    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[pulumi.Input[float]] = None,
                 latest_version_currently_processing: Optional[pulumi.Input[int]] = None,
                 sync_progress_completion: Optional[pulumi.Input[float]] = None,
                 synced_row_count: Optional[pulumi.Input[int]] = None,
                 total_row_count: Optional[pulumi.Input[int]] = None):
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "estimated_completion_time_seconds")

    @estimated_completion_time_seconds.setter
    def estimated_completion_time_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "estimated_completion_time_seconds", value)

    @property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "latest_version_currently_processing")

    @latest_version_currently_processing.setter
    def latest_version_currently_processing(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "latest_version_currently_processing", value)

    @property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "sync_progress_completion")

    @sync_progress_completion.setter
    def sync_progress_completion(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sync_progress_completion", value)

    @property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "synced_row_count")

    @synced_row_count.setter
    def synced_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "synced_row_count", value)

    @property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "total_row_count")

    @total_row_count.setter
    def total_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_row_count", value)


if not MYPY:
    class PermissionsAccessControlArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[str]]
        """
        name of the group. We recommend setting permissions on groups.
        """
        permission_level: NotRequired[pulumi.Input[str]]
        """
        permission level according to specific resource. See examples above for the reference.

        Exactly one of the below arguments is required:
        """
        service_principal_name: NotRequired[pulumi.Input[str]]
        """
        Application ID of the service_principal.
        """
        user_name: NotRequired[pulumi.Input[str]]
        """
        name of the user.
        """
elif False:
    PermissionsAccessControlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsAccessControlArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[str]] = None,
                 permission_level: Optional[pulumi.Input[str]] = None,
                 service_principal_name: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group_name: name of the group. We recommend setting permissions on groups.
        :param pulumi.Input[str] permission_level: permission level according to specific resource. See examples above for the reference.
               
               Exactly one of the below arguments is required:
        :param pulumi.Input[str] service_principal_name: Application ID of the service_principal.
        :param pulumi.Input[str] user_name: name of the user.
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the group. We recommend setting permissions on groups.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[pulumi.Input[str]]:
        """
        permission level according to specific resource. See examples above for the reference.

        Exactly one of the below arguments is required:
        """
        return pulumi.get(self, "permission_level")

    @permission_level.setter
    def permission_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permission_level", value)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        Application ID of the service_principal.
        """
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the user.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class PipelineClusterArgsDict(TypedDict):
        apply_policy_default_values: NotRequired[pulumi.Input[bool]]
        autoscale: NotRequired[pulumi.Input['PipelineClusterAutoscaleArgsDict']]
        aws_attributes: NotRequired[pulumi.Input['PipelineClusterAwsAttributesArgsDict']]
        azure_attributes: NotRequired[pulumi.Input['PipelineClusterAzureAttributesArgsDict']]
        cluster_log_conf: NotRequired[pulumi.Input['PipelineClusterClusterLogConfArgsDict']]
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        driver_instance_pool_id: NotRequired[pulumi.Input[str]]
        driver_node_type_id: NotRequired[pulumi.Input[str]]
        enable_local_disk_encryption: NotRequired[pulumi.Input[bool]]
        gcp_attributes: NotRequired[pulumi.Input['PipelineClusterGcpAttributesArgsDict']]
        init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgsDict']]]]
        instance_pool_id: NotRequired[pulumi.Input[str]]
        label: NotRequired[pulumi.Input[str]]
        node_type_id: NotRequired[pulumi.Input[str]]
        num_workers: NotRequired[pulumi.Input[int]]
        policy_id: NotRequired[pulumi.Input[str]]
        spark_conf: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        spark_env_vars: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        ssh_public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    PipelineClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterArgs:
    def __init__(__self__, *,
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['PipelineClusterAutoscaleArgs']] = None,
                 aws_attributes: Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']] = None,
                 cluster_log_conf: Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['PipelineClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['PipelineClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)


if not MYPY:
    class PipelineClusterAutoscaleArgsDict(TypedDict):
        max_workers: pulumi.Input[int]
        min_workers: pulumi.Input[int]
        mode: NotRequired[pulumi.Input[str]]
elif False:
    PipelineClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: pulumi.Input[int],
                 min_workers: pulumi.Input[int],
                 mode: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "max_workers", max_workers)
        pulumi.set(__self__, "min_workers", min_workers)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_workers", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class PipelineClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        ebs_volume_count: NotRequired[pulumi.Input[int]]
        ebs_volume_iops: NotRequired[pulumi.Input[int]]
        ebs_volume_size: NotRequired[pulumi.Input[int]]
        ebs_volume_throughput: NotRequired[pulumi.Input[int]]
        ebs_volume_type: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        instance_profile_arn: NotRequired[pulumi.Input[str]]
        spot_bid_price_percent: NotRequired[pulumi.Input[int]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    PipelineClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_throughput: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class PipelineClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        first_on_demand: NotRequired[pulumi.Input[int]]
        log_analytics_info: NotRequired[pulumi.Input['PipelineClusterAzureAttributesLogAnalyticsInfoArgsDict']]
        spot_bid_max_price: NotRequired[pulumi.Input[float]]
elif False:
    PipelineClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 log_analytics_info: Optional[pulumi.Input['PipelineClusterAzureAttributesLogAnalyticsInfoArgs']] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional[pulumi.Input['PipelineClusterAzureAttributesLogAnalyticsInfoArgs']]:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional[pulumi.Input['PipelineClusterAzureAttributesLogAnalyticsInfoArgs']]):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class PipelineClusterAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[pulumi.Input[str]]
        log_analytics_workspace_id: NotRequired[pulumi.Input[str]]
elif False:
    PipelineClusterAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_id: Optional[pulumi.Input[str]] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class PipelineClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired[pulumi.Input['PipelineClusterClusterLogConfDbfsArgsDict']]
        s3: NotRequired[pulumi.Input['PipelineClusterClusterLogConfS3ArgsDict']]
elif False:
    PipelineClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class PipelineClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    PipelineClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PipelineClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[pulumi.Input[str]]
        google_service_account: NotRequired[pulumi.Input[str]]
        local_ssd_count: NotRequired[pulumi.Input[int]]
        zone_id: NotRequired[pulumi.Input[str]]
elif False:
    PipelineClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class PipelineClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired[pulumi.Input['PipelineClusterInitScriptAbfssArgsDict']]
        dbfs: NotRequired[pulumi.Input['PipelineClusterInitScriptDbfsArgsDict']]
        file: NotRequired[pulumi.Input['PipelineClusterInitScriptFileArgsDict']]
        gcs: NotRequired[pulumi.Input['PipelineClusterInitScriptGcsArgsDict']]
        s3: NotRequired[pulumi.Input['PipelineClusterInitScriptS3ArgsDict']]
        volumes: NotRequired[pulumi.Input['PipelineClusterInitScriptVolumesArgsDict']]
        workspace: NotRequired[pulumi.Input['PipelineClusterInitScriptWorkspaceArgsDict']]
elif False:
    PipelineClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['PipelineClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['PipelineClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['PipelineClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class PipelineClusterInitScriptAbfssArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineClusterInitScriptDbfsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineClusterInitScriptFileArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineClusterInitScriptGcsArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineClusterInitScriptS3ArgsDict(TypedDict):
        destination: pulumi.Input[str]
        canned_acl: NotRequired[pulumi.Input[str]]
        enable_encryption: NotRequired[pulumi.Input[bool]]
        encryption_type: NotRequired[pulumi.Input[str]]
        endpoint: NotRequired[pulumi.Input[str]]
        kms_key: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
elif False:
    PipelineClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PipelineClusterInitScriptVolumesArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: pulumi.Input[str]
elif False:
    PipelineClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


if not MYPY:
    class PipelineDeploymentArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        The deployment method that manages the pipeline.
        """
        metadata_file_path: NotRequired[pulumi.Input[str]]
        """
        The path to the file containing metadata about the deployment.
        """
elif False:
    PipelineDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineDeploymentArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 metadata_file_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: The deployment method that manages the pipeline.
        :param pulumi.Input[str] metadata_file_path: The path to the file containing metadata about the deployment.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if metadata_file_path is not None:
            pulumi.set(__self__, "metadata_file_path", metadata_file_path)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        The deployment method that manages the pipeline.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the file containing metadata about the deployment.
        """
        return pulumi.get(self, "metadata_file_path")

    @metadata_file_path.setter
    def metadata_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_file_path", value)


if not MYPY:
    class PipelineFiltersArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Paths to exclude.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Paths to include.
        """
elif False:
    PipelineFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Paths to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Paths to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Paths to exclude.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Paths to include.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class PipelineGatewayDefinitionArgsDict(TypedDict):
        connection_id: NotRequired[pulumi.Input[str]]
        """
        Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
        """
        connection_name: NotRequired[pulumi.Input[str]]
        gateway_storage_catalog: NotRequired[pulumi.Input[str]]
        """
        Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
        """
        gateway_storage_name: NotRequired[pulumi.Input[str]]
        """
        Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Delta Live Tables system will automatically create the storage location under the catalog and schema.
        """
        gateway_storage_schema: NotRequired[pulumi.Input[str]]
        """
        Required, Immutable. The name of the schema for the gateway pipelines's storage location.
        """
elif False:
    PipelineGatewayDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineGatewayDefinitionArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 connection_name: Optional[pulumi.Input[str]] = None,
                 gateway_storage_catalog: Optional[pulumi.Input[str]] = None,
                 gateway_storage_name: Optional[pulumi.Input[str]] = None,
                 gateway_storage_schema: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_id: Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
        :param pulumi.Input[str] gateway_storage_catalog: Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
        :param pulumi.Input[str] gateway_storage_name: Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Delta Live Tables system will automatically create the storage location under the catalog and schema.
        :param pulumi.Input[str] gateway_storage_schema: Required, Immutable. The name of the schema for the gateway pipelines's storage location.
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if gateway_storage_catalog is not None:
            pulumi.set(__self__, "gateway_storage_catalog", gateway_storage_catalog)
        if gateway_storage_name is not None:
            pulumi.set(__self__, "gateway_storage_name", gateway_storage_name)
        if gateway_storage_schema is not None:
            pulumi.set(__self__, "gateway_storage_schema", gateway_storage_schema)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_name", value)

    @property
    @pulumi.getter(name="gatewayStorageCatalog")
    def gateway_storage_catalog(self) -> Optional[pulumi.Input[str]]:
        """
        Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
        """
        return pulumi.get(self, "gateway_storage_catalog")

    @gateway_storage_catalog.setter
    def gateway_storage_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_storage_catalog", value)

    @property
    @pulumi.getter(name="gatewayStorageName")
    def gateway_storage_name(self) -> Optional[pulumi.Input[str]]:
        """
        Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Delta Live Tables system will automatically create the storage location under the catalog and schema.
        """
        return pulumi.get(self, "gateway_storage_name")

    @gateway_storage_name.setter
    def gateway_storage_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_storage_name", value)

    @property
    @pulumi.getter(name="gatewayStorageSchema")
    def gateway_storage_schema(self) -> Optional[pulumi.Input[str]]:
        """
        Required, Immutable. The name of the schema for the gateway pipelines's storage location.
        """
        return pulumi.get(self, "gateway_storage_schema")

    @gateway_storage_schema.setter
    def gateway_storage_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_storage_schema", value)


if not MYPY:
    class PipelineIngestionDefinitionArgsDict(TypedDict):
        connection_name: NotRequired[pulumi.Input[str]]
        ingestion_gateway_id: NotRequired[pulumi.Input[str]]
        objects: NotRequired[pulumi.Input[Sequence[pulumi.Input['PipelineIngestionDefinitionObjectArgsDict']]]]
        table_configuration: NotRequired[pulumi.Input['PipelineIngestionDefinitionTableConfigurationArgsDict']]
elif False:
    PipelineIngestionDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionArgs:
    def __init__(__self__, *,
                 connection_name: Optional[pulumi.Input[str]] = None,
                 ingestion_gateway_id: Optional[pulumi.Input[str]] = None,
                 objects: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineIngestionDefinitionObjectArgs']]]] = None,
                 table_configuration: Optional[pulumi.Input['PipelineIngestionDefinitionTableConfigurationArgs']] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if ingestion_gateway_id is not None:
            pulumi.set(__self__, "ingestion_gateway_id", ingestion_gateway_id)
        if objects is not None:
            pulumi.set(__self__, "objects", objects)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_name", value)

    @property
    @pulumi.getter(name="ingestionGatewayId")
    def ingestion_gateway_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ingestion_gateway_id")

    @ingestion_gateway_id.setter
    def ingestion_gateway_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingestion_gateway_id", value)

    @property
    @pulumi.getter
    def objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineIngestionDefinitionObjectArgs']]]]:
        return pulumi.get(self, "objects")

    @objects.setter
    def objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineIngestionDefinitionObjectArgs']]]]):
        pulumi.set(self, "objects", value)

    @property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionTableConfigurationArgs']]:
        return pulumi.get(self, "table_configuration")

    @table_configuration.setter
    def table_configuration(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionTableConfigurationArgs']]):
        pulumi.set(self, "table_configuration", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectArgsDict(TypedDict):
        report: NotRequired[pulumi.Input['PipelineIngestionDefinitionObjectReportArgsDict']]
        schema: NotRequired[pulumi.Input['PipelineIngestionDefinitionObjectSchemaArgsDict']]
        """
        The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
        """
        table: NotRequired[pulumi.Input['PipelineIngestionDefinitionObjectTableArgsDict']]
elif False:
    PipelineIngestionDefinitionObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectArgs:
    def __init__(__self__, *,
                 report: Optional[pulumi.Input['PipelineIngestionDefinitionObjectReportArgs']] = None,
                 schema: Optional[pulumi.Input['PipelineIngestionDefinitionObjectSchemaArgs']] = None,
                 table: Optional[pulumi.Input['PipelineIngestionDefinitionObjectTableArgs']] = None):
        """
        :param pulumi.Input['PipelineIngestionDefinitionObjectSchemaArgs'] schema: The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
        """
        if report is not None:
            pulumi.set(__self__, "report", report)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def report(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionObjectReportArgs']]:
        return pulumi.get(self, "report")

    @report.setter
    def report(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionObjectReportArgs']]):
        pulumi.set(self, "report", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionObjectSchemaArgs']]:
        """
        The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionObjectSchemaArgs']]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def table(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionObjectTableArgs']]:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionObjectTableArgs']]):
        pulumi.set(self, "table", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectReportArgsDict(TypedDict):
        destination_catalog: NotRequired[pulumi.Input[str]]
        destination_schema: NotRequired[pulumi.Input[str]]
        destination_table: NotRequired[pulumi.Input[str]]
        source_url: NotRequired[pulumi.Input[str]]
        table_configuration: NotRequired[pulumi.Input['PipelineIngestionDefinitionObjectReportTableConfigurationArgsDict']]
elif False:
    PipelineIngestionDefinitionObjectReportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectReportArgs:
    def __init__(__self__, *,
                 destination_catalog: Optional[pulumi.Input[str]] = None,
                 destination_schema: Optional[pulumi.Input[str]] = None,
                 destination_table: Optional[pulumi.Input[str]] = None,
                 source_url: Optional[pulumi.Input[str]] = None,
                 table_configuration: Optional[pulumi.Input['PipelineIngestionDefinitionObjectReportTableConfigurationArgs']] = None):
        if destination_catalog is not None:
            pulumi.set(__self__, "destination_catalog", destination_catalog)
        if destination_schema is not None:
            pulumi.set(__self__, "destination_schema", destination_schema)
        if destination_table is not None:
            pulumi.set(__self__, "destination_table", destination_table)
        if source_url is not None:
            pulumi.set(__self__, "source_url", source_url)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @property
    @pulumi.getter(name="destinationCatalog")
    def destination_catalog(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_catalog")

    @destination_catalog.setter
    def destination_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_catalog", value)

    @property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_schema")

    @destination_schema.setter
    def destination_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_schema", value)

    @property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_table")

    @destination_table.setter
    def destination_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_table", value)

    @property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_url")

    @source_url.setter
    def source_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_url", value)

    @property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionObjectReportTableConfigurationArgs']]:
        return pulumi.get(self, "table_configuration")

    @table_configuration.setter
    def table_configuration(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionObjectReportTableConfigurationArgs']]):
        pulumi.set(self, "table_configuration", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectReportTableConfigurationArgsDict(TypedDict):
        primary_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        salesforce_include_formula_fields: NotRequired[pulumi.Input[bool]]
        scd_type: NotRequired[pulumi.Input[str]]
        sequence_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    PipelineIngestionDefinitionObjectReportTableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectReportTableConfigurationArgs:
    def __init__(__self__, *,
                 primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 salesforce_include_formula_fields: Optional[pulumi.Input[bool]] = None,
                 scd_type: Optional[pulumi.Input[str]] = None,
                 sequence_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "primary_keys")

    @primary_keys.setter
    def primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "primary_keys", value)

    @property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @salesforce_include_formula_fields.setter
    def salesforce_include_formula_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "salesforce_include_formula_fields", value)

    @property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scd_type")

    @scd_type.setter
    def scd_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scd_type", value)

    @property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sequence_bies")

    @sequence_bies.setter
    def sequence_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sequence_bies", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectSchemaArgsDict(TypedDict):
        destination_catalog: NotRequired[pulumi.Input[str]]
        destination_schema: NotRequired[pulumi.Input[str]]
        source_catalog: NotRequired[pulumi.Input[str]]
        source_schema: NotRequired[pulumi.Input[str]]
        table_configuration: NotRequired[pulumi.Input['PipelineIngestionDefinitionObjectSchemaTableConfigurationArgsDict']]
elif False:
    PipelineIngestionDefinitionObjectSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectSchemaArgs:
    def __init__(__self__, *,
                 destination_catalog: Optional[pulumi.Input[str]] = None,
                 destination_schema: Optional[pulumi.Input[str]] = None,
                 source_catalog: Optional[pulumi.Input[str]] = None,
                 source_schema: Optional[pulumi.Input[str]] = None,
                 table_configuration: Optional[pulumi.Input['PipelineIngestionDefinitionObjectSchemaTableConfigurationArgs']] = None):
        if destination_catalog is not None:
            pulumi.set(__self__, "destination_catalog", destination_catalog)
        if destination_schema is not None:
            pulumi.set(__self__, "destination_schema", destination_schema)
        if source_catalog is not None:
            pulumi.set(__self__, "source_catalog", source_catalog)
        if source_schema is not None:
            pulumi.set(__self__, "source_schema", source_schema)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @property
    @pulumi.getter(name="destinationCatalog")
    def destination_catalog(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_catalog")

    @destination_catalog.setter
    def destination_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_catalog", value)

    @property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_schema")

    @destination_schema.setter
    def destination_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_schema", value)

    @property
    @pulumi.getter(name="sourceCatalog")
    def source_catalog(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_catalog")

    @source_catalog.setter
    def source_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_catalog", value)

    @property
    @pulumi.getter(name="sourceSchema")
    def source_schema(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_schema")

    @source_schema.setter
    def source_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_schema", value)

    @property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionObjectSchemaTableConfigurationArgs']]:
        return pulumi.get(self, "table_configuration")

    @table_configuration.setter
    def table_configuration(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionObjectSchemaTableConfigurationArgs']]):
        pulumi.set(self, "table_configuration", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectSchemaTableConfigurationArgsDict(TypedDict):
        primary_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        salesforce_include_formula_fields: NotRequired[pulumi.Input[bool]]
        scd_type: NotRequired[pulumi.Input[str]]
        sequence_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    PipelineIngestionDefinitionObjectSchemaTableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectSchemaTableConfigurationArgs:
    def __init__(__self__, *,
                 primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 salesforce_include_formula_fields: Optional[pulumi.Input[bool]] = None,
                 scd_type: Optional[pulumi.Input[str]] = None,
                 sequence_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "primary_keys")

    @primary_keys.setter
    def primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "primary_keys", value)

    @property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @salesforce_include_formula_fields.setter
    def salesforce_include_formula_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "salesforce_include_formula_fields", value)

    @property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scd_type")

    @scd_type.setter
    def scd_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scd_type", value)

    @property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sequence_bies")

    @sequence_bies.setter
    def sequence_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sequence_bies", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectTableArgsDict(TypedDict):
        destination_catalog: NotRequired[pulumi.Input[str]]
        destination_schema: NotRequired[pulumi.Input[str]]
        destination_table: NotRequired[pulumi.Input[str]]
        source_catalog: NotRequired[pulumi.Input[str]]
        source_schema: NotRequired[pulumi.Input[str]]
        source_table: NotRequired[pulumi.Input[str]]
        table_configuration: NotRequired[pulumi.Input['PipelineIngestionDefinitionObjectTableTableConfigurationArgsDict']]
elif False:
    PipelineIngestionDefinitionObjectTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectTableArgs:
    def __init__(__self__, *,
                 destination_catalog: Optional[pulumi.Input[str]] = None,
                 destination_schema: Optional[pulumi.Input[str]] = None,
                 destination_table: Optional[pulumi.Input[str]] = None,
                 source_catalog: Optional[pulumi.Input[str]] = None,
                 source_schema: Optional[pulumi.Input[str]] = None,
                 source_table: Optional[pulumi.Input[str]] = None,
                 table_configuration: Optional[pulumi.Input['PipelineIngestionDefinitionObjectTableTableConfigurationArgs']] = None):
        if destination_catalog is not None:
            pulumi.set(__self__, "destination_catalog", destination_catalog)
        if destination_schema is not None:
            pulumi.set(__self__, "destination_schema", destination_schema)
        if destination_table is not None:
            pulumi.set(__self__, "destination_table", destination_table)
        if source_catalog is not None:
            pulumi.set(__self__, "source_catalog", source_catalog)
        if source_schema is not None:
            pulumi.set(__self__, "source_schema", source_schema)
        if source_table is not None:
            pulumi.set(__self__, "source_table", source_table)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @property
    @pulumi.getter(name="destinationCatalog")
    def destination_catalog(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_catalog")

    @destination_catalog.setter
    def destination_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_catalog", value)

    @property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_schema")

    @destination_schema.setter
    def destination_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_schema", value)

    @property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_table")

    @destination_table.setter
    def destination_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_table", value)

    @property
    @pulumi.getter(name="sourceCatalog")
    def source_catalog(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_catalog")

    @source_catalog.setter
    def source_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_catalog", value)

    @property
    @pulumi.getter(name="sourceSchema")
    def source_schema(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_schema")

    @source_schema.setter
    def source_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_schema", value)

    @property
    @pulumi.getter(name="sourceTable")
    def source_table(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_table")

    @source_table.setter
    def source_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_table", value)

    @property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional[pulumi.Input['PipelineIngestionDefinitionObjectTableTableConfigurationArgs']]:
        return pulumi.get(self, "table_configuration")

    @table_configuration.setter
    def table_configuration(self, value: Optional[pulumi.Input['PipelineIngestionDefinitionObjectTableTableConfigurationArgs']]):
        pulumi.set(self, "table_configuration", value)


if not MYPY:
    class PipelineIngestionDefinitionObjectTableTableConfigurationArgsDict(TypedDict):
        primary_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        salesforce_include_formula_fields: NotRequired[pulumi.Input[bool]]
        scd_type: NotRequired[pulumi.Input[str]]
        sequence_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    PipelineIngestionDefinitionObjectTableTableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionObjectTableTableConfigurationArgs:
    def __init__(__self__, *,
                 primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 salesforce_include_formula_fields: Optional[pulumi.Input[bool]] = None,
                 scd_type: Optional[pulumi.Input[str]] = None,
                 sequence_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "primary_keys")

    @primary_keys.setter
    def primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "primary_keys", value)

    @property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @salesforce_include_formula_fields.setter
    def salesforce_include_formula_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "salesforce_include_formula_fields", value)

    @property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scd_type")

    @scd_type.setter
    def scd_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scd_type", value)

    @property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sequence_bies")

    @sequence_bies.setter
    def sequence_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sequence_bies", value)


if not MYPY:
    class PipelineIngestionDefinitionTableConfigurationArgsDict(TypedDict):
        primary_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        salesforce_include_formula_fields: NotRequired[pulumi.Input[bool]]
        scd_type: NotRequired[pulumi.Input[str]]
        sequence_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    PipelineIngestionDefinitionTableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineIngestionDefinitionTableConfigurationArgs:
    def __init__(__self__, *,
                 primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 salesforce_include_formula_fields: Optional[pulumi.Input[bool]] = None,
                 scd_type: Optional[pulumi.Input[str]] = None,
                 sequence_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "primary_keys")

    @primary_keys.setter
    def primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "primary_keys", value)

    @property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @salesforce_include_formula_fields.setter
    def salesforce_include_formula_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "salesforce_include_formula_fields", value)

    @property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scd_type")

    @scd_type.setter
    def scd_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scd_type", value)

    @property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sequence_bies")

    @sequence_bies.setter
    def sequence_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sequence_bies", value)


if not MYPY:
    class PipelineLatestUpdateArgsDict(TypedDict):
        creation_time: NotRequired[pulumi.Input[str]]
        state: NotRequired[pulumi.Input[str]]
        update_id: NotRequired[pulumi.Input[str]]
elif False:
    PipelineLatestUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLatestUpdateArgs:
    def __init__(__self__, *,
                 creation_time: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 update_id: Optional[pulumi.Input[str]] = None):
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_id is not None:
            pulumi.set(__self__, "update_id", update_id)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation_time")

    @creation_time.setter
    def creation_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_time", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="updateId")
    def update_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "update_id")

    @update_id.setter
    def update_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_id", value)


if not MYPY:
    class PipelineLibraryArgsDict(TypedDict):
        file: NotRequired[pulumi.Input['PipelineLibraryFileArgsDict']]
        jar: NotRequired[pulumi.Input[str]]
        maven: NotRequired[pulumi.Input['PipelineLibraryMavenArgsDict']]
        notebook: NotRequired[pulumi.Input['PipelineLibraryNotebookArgsDict']]
        whl: NotRequired[pulumi.Input[str]]
elif False:
    PipelineLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLibraryArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['PipelineLibraryFileArgs']] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['PipelineLibraryMavenArgs']] = None,
                 notebook: Optional[pulumi.Input['PipelineLibraryNotebookArgs']] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        if file is not None:
            pulumi.set(__self__, "file", file)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if notebook is not None:
            pulumi.set(__self__, "notebook", notebook)
        if whl is not None:
            warnings.warn("""The 'whl' field is deprecated""", DeprecationWarning)
            pulumi.log.warn("""whl is deprecated: The 'whl' field is deprecated""")
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['PipelineLibraryFileArgs']]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['PipelineLibraryFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['PipelineLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['PipelineLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def notebook(self) -> Optional[pulumi.Input['PipelineLibraryNotebookArgs']]:
        return pulumi.get(self, "notebook")

    @notebook.setter
    def notebook(self, value: Optional[pulumi.Input['PipelineLibraryNotebookArgs']]):
        pulumi.set(self, "notebook", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""The 'whl' field is deprecated""")
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class PipelineLibraryFileArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
elif False:
    PipelineLibraryFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLibraryFileArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PipelineLibraryMavenArgsDict(TypedDict):
        coordinates: pulumi.Input[str]
        exclusions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        repo: NotRequired[pulumi.Input[str]]
elif False:
    PipelineLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class PipelineLibraryNotebookArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
elif False:
    PipelineLibraryNotebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineLibraryNotebookArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None):
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PipelineNotificationArgsDict(TypedDict):
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
        * `on-update-success` - a pipeline update completes successfully.
        * `on-update-failure` - a pipeline update fails with a retryable error.
        * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
        * `on-flow-failure` - a single data flow fails.
        """
        email_recipients: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        non-empty list of emails to notify.
        """
elif False:
    PipelineNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineNotificationArgs:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alerts: non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
               * `on-update-success` - a pipeline update completes successfully.
               * `on-update-failure` - a pipeline update fails with a retryable error.
               * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
               * `on-flow-failure` - a single data flow fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_recipients: non-empty list of emails to notify.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if email_recipients is not None:
            pulumi.set(__self__, "email_recipients", email_recipients)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
        * `on-update-success` - a pipeline update completes successfully.
        * `on-update-failure` - a pipeline update fails with a retryable error.
        * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
        * `on-flow-failure` - a single data flow fails.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="emailRecipients")
    def email_recipients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        non-empty list of emails to notify.
        """
        return pulumi.get(self, "email_recipients")

    @email_recipients.setter
    def email_recipients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_recipients", value)


if not MYPY:
    class PipelineRestartWindowArgsDict(TypedDict):
        start_hour: pulumi.Input[int]
        days_of_week: NotRequired[pulumi.Input[str]]
        time_zone_id: NotRequired[pulumi.Input[str]]
elif False:
    PipelineRestartWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineRestartWindowArgs:
    def __init__(__self__, *,
                 start_hour: pulumi.Input[int],
                 days_of_week: Optional[pulumi.Input[str]] = None,
                 time_zone_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "start_hour", start_hour)
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)
        if time_zone_id is not None:
            pulumi.set(__self__, "time_zone_id", time_zone_id)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "days_of_week")

    @days_of_week.setter
    def days_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "days_of_week", value)

    @property
    @pulumi.getter(name="timeZoneId")
    def time_zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone_id")

    @time_zone_id.setter
    def time_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone_id", value)


if not MYPY:
    class PipelineTriggerArgsDict(TypedDict):
        cron: NotRequired[pulumi.Input['PipelineTriggerCronArgsDict']]
        manual: NotRequired[pulumi.Input['PipelineTriggerManualArgsDict']]
elif False:
    PipelineTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerArgs:
    def __init__(__self__, *,
                 cron: Optional[pulumi.Input['PipelineTriggerCronArgs']] = None,
                 manual: Optional[pulumi.Input['PipelineTriggerManualArgs']] = None):
        if cron is not None:
            pulumi.set(__self__, "cron", cron)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def cron(self) -> Optional[pulumi.Input['PipelineTriggerCronArgs']]:
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: Optional[pulumi.Input['PipelineTriggerCronArgs']]):
        pulumi.set(self, "cron", value)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['PipelineTriggerManualArgs']]:
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['PipelineTriggerManualArgs']]):
        pulumi.set(self, "manual", value)


if not MYPY:
    class PipelineTriggerCronArgsDict(TypedDict):
        quartz_cron_schedule: NotRequired[pulumi.Input[str]]
        timezone_id: NotRequired[pulumi.Input[str]]
elif False:
    PipelineTriggerCronArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerCronArgs:
    def __init__(__self__, *,
                 quartz_cron_schedule: Optional[pulumi.Input[str]] = None,
                 timezone_id: Optional[pulumi.Input[str]] = None):
        if quartz_cron_schedule is not None:
            pulumi.set(__self__, "quartz_cron_schedule", quartz_cron_schedule)
        if timezone_id is not None:
            pulumi.set(__self__, "timezone_id", timezone_id)

    @property
    @pulumi.getter(name="quartzCronSchedule")
    def quartz_cron_schedule(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "quartz_cron_schedule")

    @quartz_cron_schedule.setter
    def quartz_cron_schedule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quartz_cron_schedule", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone_id", value)


if not MYPY:
    class PipelineTriggerManualArgsDict(TypedDict):
        pass
elif False:
    PipelineTriggerManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineTriggerManualArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class QualityMonitorCustomMetricArgsDict(TypedDict):
        definition: pulumi.Input[str]
        """
        [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        input_columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Columns on the monitored table to apply the custom metrics to.
        """
        name: pulumi.Input[str]
        """
        Name of the custom metric.
        """
        output_data_type: pulumi.Input[str]
        """
        The output type of the custom metric.
        """
        type: pulumi.Input[str]
        """
        The type of the custom metric.
        """
elif False:
    QualityMonitorCustomMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorCustomMetricArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 input_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 output_data_type: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] definition: [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] input_columns: Columns on the monitored table to apply the custom metrics to.
        :param pulumi.Input[str] name: Name of the custom metric.
        :param pulumi.Input[str] output_data_type: The output type of the custom metric.
        :param pulumi.Input[str] type: The type of the custom metric.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Columns on the monitored table to apply the custom metrics to.
        """
        return pulumi.get(self, "input_columns")

    @input_columns.setter
    def input_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "input_columns", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the custom metric.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> pulumi.Input[str]:
        """
        The output type of the custom metric.
        """
        return pulumi.get(self, "output_data_type")

    @output_data_type.setter
    def output_data_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_data_type", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the custom metric.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class QualityMonitorDataClassificationConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    QualityMonitorDataClassificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorDataClassificationConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class QualityMonitorInferenceLogArgsDict(TypedDict):
        granularities: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        model_id_col: pulumi.Input[str]
        """
        Column of the model id or version
        """
        prediction_col: pulumi.Input[str]
        """
        Column of the model prediction
        """
        problem_type: pulumi.Input[str]
        """
        Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        """
        timestamp_col: pulumi.Input[str]
        """
        Column of the timestamp of predictions
        """
        label_col: NotRequired[pulumi.Input[str]]
        """
        Column of the model label
        """
        prediction_proba_col: NotRequired[pulumi.Input[str]]
        """
        Column of the model prediction probabilities
        """
elif False:
    QualityMonitorInferenceLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorInferenceLogArgs:
    def __init__(__self__, *,
                 granularities: pulumi.Input[Sequence[pulumi.Input[str]]],
                 model_id_col: pulumi.Input[str],
                 prediction_col: pulumi.Input[str],
                 problem_type: pulumi.Input[str],
                 timestamp_col: pulumi.Input[str],
                 label_col: Optional[pulumi.Input[str]] = None,
                 prediction_proba_col: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param pulumi.Input[str] model_id_col: Column of the model id or version
        :param pulumi.Input[str] prediction_col: Column of the model prediction
        :param pulumi.Input[str] problem_type: Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        :param pulumi.Input[str] timestamp_col: Column of the timestamp of predictions
        :param pulumi.Input[str] label_col: Column of the model label
        :param pulumi.Input[str] prediction_proba_col: Column of the model prediction probabilities
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_col", model_id_col)
        pulumi.set(__self__, "prediction_col", prediction_col)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_col", timestamp_col)
        if label_col is not None:
            pulumi.set(__self__, "label_col", label_col)
        if prediction_proba_col is not None:
            pulumi.set(__self__, "prediction_proba_col", prediction_proba_col)

    @property
    @pulumi.getter
    def granularities(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @granularities.setter
    def granularities(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "granularities", value)

    @property
    @pulumi.getter(name="modelIdCol")
    def model_id_col(self) -> pulumi.Input[str]:
        """
        Column of the model id or version
        """
        return pulumi.get(self, "model_id_col")

    @model_id_col.setter
    def model_id_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_id_col", value)

    @property
    @pulumi.getter(name="predictionCol")
    def prediction_col(self) -> pulumi.Input[str]:
        """
        Column of the model prediction
        """
        return pulumi.get(self, "prediction_col")

    @prediction_col.setter
    def prediction_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "prediction_col", value)

    @property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> pulumi.Input[str]:
        """
        Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @problem_type.setter
    def problem_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "problem_type", value)

    @property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> pulumi.Input[str]:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")

    @timestamp_col.setter
    def timestamp_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "timestamp_col", value)

    @property
    @pulumi.getter(name="labelCol")
    def label_col(self) -> Optional[pulumi.Input[str]]:
        """
        Column of the model label
        """
        return pulumi.get(self, "label_col")

    @label_col.setter
    def label_col(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label_col", value)

    @property
    @pulumi.getter(name="predictionProbaCol")
    def prediction_proba_col(self) -> Optional[pulumi.Input[str]]:
        """
        Column of the model prediction probabilities
        """
        return pulumi.get(self, "prediction_proba_col")

    @prediction_proba_col.setter
    def prediction_proba_col(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prediction_proba_col", value)


if not MYPY:
    class QualityMonitorNotificationsArgsDict(TypedDict):
        on_failure: NotRequired[pulumi.Input['QualityMonitorNotificationsOnFailureArgsDict']]
        """
        who to send notifications to on monitor failure.
        """
        on_new_classification_tag_detected: NotRequired[pulumi.Input['QualityMonitorNotificationsOnNewClassificationTagDetectedArgsDict']]
        """
        Who to send notifications to when new data classification tags are detected.
        """
elif False:
    QualityMonitorNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorNotificationsArgs:
    def __init__(__self__, *,
                 on_failure: Optional[pulumi.Input['QualityMonitorNotificationsOnFailureArgs']] = None,
                 on_new_classification_tag_detected: Optional[pulumi.Input['QualityMonitorNotificationsOnNewClassificationTagDetectedArgs']] = None):
        """
        :param pulumi.Input['QualityMonitorNotificationsOnFailureArgs'] on_failure: who to send notifications to on monitor failure.
        :param pulumi.Input['QualityMonitorNotificationsOnNewClassificationTagDetectedArgs'] on_new_classification_tag_detected: Who to send notifications to when new data classification tags are detected.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_new_classification_tag_detected is not None:
            pulumi.set(__self__, "on_new_classification_tag_detected", on_new_classification_tag_detected)

    @property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional[pulumi.Input['QualityMonitorNotificationsOnFailureArgs']]:
        """
        who to send notifications to on monitor failure.
        """
        return pulumi.get(self, "on_failure")

    @on_failure.setter
    def on_failure(self, value: Optional[pulumi.Input['QualityMonitorNotificationsOnFailureArgs']]):
        pulumi.set(self, "on_failure", value)

    @property
    @pulumi.getter(name="onNewClassificationTagDetected")
    def on_new_classification_tag_detected(self) -> Optional[pulumi.Input['QualityMonitorNotificationsOnNewClassificationTagDetectedArgs']]:
        """
        Who to send notifications to when new data classification tags are detected.
        """
        return pulumi.get(self, "on_new_classification_tag_detected")

    @on_new_classification_tag_detected.setter
    def on_new_classification_tag_detected(self, value: Optional[pulumi.Input['QualityMonitorNotificationsOnNewClassificationTagDetectedArgs']]):
        pulumi.set(self, "on_new_classification_tag_detected", value)


if not MYPY:
    class QualityMonitorNotificationsOnFailureArgsDict(TypedDict):
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    QualityMonitorNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)


if not MYPY:
    class QualityMonitorNotificationsOnNewClassificationTagDetectedArgsDict(TypedDict):
        email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    QualityMonitorNotificationsOnNewClassificationTagDetectedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorNotificationsOnNewClassificationTagDetectedArgs:
    def __init__(__self__, *,
                 email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "email_addresses")

    @email_addresses.setter
    def email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_addresses", value)


if not MYPY:
    class QualityMonitorScheduleArgsDict(TypedDict):
        quartz_cron_expression: pulumi.Input[str]
        """
        string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        """
        timezone_id: pulumi.Input[str]
        """
        string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        pause_status: NotRequired[pulumi.Input[str]]
elif False:
    QualityMonitorScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorScheduleArgs:
    def __init__(__self__, *,
                 quartz_cron_expression: pulumi.Input[str],
                 timezone_id: pulumi.Input[str],
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] quartz_cron_expression: string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        :param pulumi.Input[str] timezone_id: string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> pulumi.Input[str]:
        """
        string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @quartz_cron_expression.setter
    def quartz_cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "quartz_cron_expression", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> pulumi.Input[str]:
        """
        string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone_id", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


if not MYPY:
    class QualityMonitorSnapshotArgsDict(TypedDict):
        pass
elif False:
    QualityMonitorSnapshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorSnapshotArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class QualityMonitorTimeSeriesArgsDict(TypedDict):
        granularities: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        timestamp_col: pulumi.Input[str]
        """
        Column of the timestamp of predictions
        """
elif False:
    QualityMonitorTimeSeriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QualityMonitorTimeSeriesArgs:
    def __init__(__self__, *,
                 granularities: pulumi.Input[Sequence[pulumi.Input[str]]],
                 timestamp_col: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param pulumi.Input[str] timestamp_col: Column of the timestamp of predictions
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_col", timestamp_col)

    @property
    @pulumi.getter
    def granularities(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @granularities.setter
    def granularities(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "granularities", value)

    @property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> pulumi.Input[str]:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")

    @timestamp_col.setter
    def timestamp_col(self, value: pulumi.Input[str]):
        pulumi.set(self, "timestamp_col", value)


if not MYPY:
    class QueryParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Literal parameter marker that appears between double curly braces in the query text.
        """
        date_range_value: NotRequired[pulumi.Input['QueryParameterDateRangeValueArgsDict']]
        """
        Date-range query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_range_value` or `date_range_value`):
        """
        date_value: NotRequired[pulumi.Input['QueryParameterDateValueArgsDict']]
        """
        Date query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_value` or `date_value`):
        """
        enum_value: NotRequired[pulumi.Input['QueryParameterEnumValueArgsDict']]
        """
        Dropdown parameter value. Consists of following attributes:
        """
        numeric_value: NotRequired[pulumi.Input['QueryParameterNumericValueArgsDict']]
        """
        Numeric parameter value. Consists of following attributes:
        """
        query_backed_value: NotRequired[pulumi.Input['QueryParameterQueryBackedValueArgsDict']]
        """
        Query-based dropdown parameter value. Consists of following attributes:
        """
        text_value: NotRequired[pulumi.Input['QueryParameterTextValueArgsDict']]
        """
        Text parameter value. Consists of following attributes:
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Text displayed in the user-facing parameter widget in the UI.
        """
elif False:
    QueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 date_range_value: Optional[pulumi.Input['QueryParameterDateRangeValueArgs']] = None,
                 date_value: Optional[pulumi.Input['QueryParameterDateValueArgs']] = None,
                 enum_value: Optional[pulumi.Input['QueryParameterEnumValueArgs']] = None,
                 numeric_value: Optional[pulumi.Input['QueryParameterNumericValueArgs']] = None,
                 query_backed_value: Optional[pulumi.Input['QueryParameterQueryBackedValueArgs']] = None,
                 text_value: Optional[pulumi.Input['QueryParameterTextValueArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Literal parameter marker that appears between double curly braces in the query text.
        :param pulumi.Input['QueryParameterDateRangeValueArgs'] date_range_value: Date-range query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_range_value` or `date_range_value`):
        :param pulumi.Input['QueryParameterDateValueArgs'] date_value: Date query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_value` or `date_value`):
        :param pulumi.Input['QueryParameterEnumValueArgs'] enum_value: Dropdown parameter value. Consists of following attributes:
        :param pulumi.Input['QueryParameterNumericValueArgs'] numeric_value: Numeric parameter value. Consists of following attributes:
        :param pulumi.Input['QueryParameterQueryBackedValueArgs'] query_backed_value: Query-based dropdown parameter value. Consists of following attributes:
        :param pulumi.Input['QueryParameterTextValueArgs'] text_value: Text parameter value. Consists of following attributes:
        :param pulumi.Input[str] title: Text displayed in the user-facing parameter widget in the UI.
        """
        pulumi.set(__self__, "name", name)
        if date_range_value is not None:
            pulumi.set(__self__, "date_range_value", date_range_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if numeric_value is not None:
            pulumi.set(__self__, "numeric_value", numeric_value)
        if query_backed_value is not None:
            pulumi.set(__self__, "query_backed_value", query_backed_value)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Literal parameter marker that appears between double curly braces in the query text.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dateRangeValue")
    def date_range_value(self) -> Optional[pulumi.Input['QueryParameterDateRangeValueArgs']]:
        """
        Date-range query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_range_value` or `date_range_value`):
        """
        return pulumi.get(self, "date_range_value")

    @date_range_value.setter
    def date_range_value(self, value: Optional[pulumi.Input['QueryParameterDateRangeValueArgs']]):
        pulumi.set(self, "date_range_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['QueryParameterDateValueArgs']]:
        """
        Date query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_value` or `date_value`):
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['QueryParameterDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional[pulumi.Input['QueryParameterEnumValueArgs']]:
        """
        Dropdown parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "enum_value")

    @enum_value.setter
    def enum_value(self, value: Optional[pulumi.Input['QueryParameterEnumValueArgs']]):
        pulumi.set(self, "enum_value", value)

    @property
    @pulumi.getter(name="numericValue")
    def numeric_value(self) -> Optional[pulumi.Input['QueryParameterNumericValueArgs']]:
        """
        Numeric parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "numeric_value")

    @numeric_value.setter
    def numeric_value(self, value: Optional[pulumi.Input['QueryParameterNumericValueArgs']]):
        pulumi.set(self, "numeric_value", value)

    @property
    @pulumi.getter(name="queryBackedValue")
    def query_backed_value(self) -> Optional[pulumi.Input['QueryParameterQueryBackedValueArgs']]:
        """
        Query-based dropdown parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "query_backed_value")

    @query_backed_value.setter
    def query_backed_value(self, value: Optional[pulumi.Input['QueryParameterQueryBackedValueArgs']]):
        pulumi.set(self, "query_backed_value", value)

    @property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional[pulumi.Input['QueryParameterTextValueArgs']]:
        """
        Text parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "text_value")

    @text_value.setter
    def text_value(self, value: Optional[pulumi.Input['QueryParameterTextValueArgs']]):
        pulumi.set(self, "text_value", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Text displayed in the user-facing parameter widget in the UI.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class QueryParameterDateRangeValueArgsDict(TypedDict):
        date_range_value: NotRequired[pulumi.Input['QueryParameterDateRangeValueDateRangeValueArgsDict']]
        """
        Manually specified date-time range value.  Consists of the following attributes:
        """
        dynamic_date_range_value: NotRequired[pulumi.Input[str]]
        """
        Dynamic date-time range value based on current date-time.  Possible values are `TODAY`, `YESTERDAY`, `THIS_WEEK`, `THIS_MONTH`, `THIS_YEAR`, `LAST_WEEK`, `LAST_MONTH`, `LAST_YEAR`, `LAST_HOUR`, `LAST_8_HOURS`, `LAST_24_HOURS`, `LAST_7_DAYS`, `LAST_14_DAYS`, `LAST_30_DAYS`, `LAST_60_DAYS`, `LAST_90_DAYS`, `LAST_12_MONTHS`.
        """
        precision: NotRequired[pulumi.Input[str]]
        """
        Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        start_day_of_week: NotRequired[pulumi.Input[int]]
        """
        Specify what day that starts the week.
        """
elif False:
    QueryParameterDateRangeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterDateRangeValueArgs:
    def __init__(__self__, *,
                 date_range_value: Optional[pulumi.Input['QueryParameterDateRangeValueDateRangeValueArgs']] = None,
                 dynamic_date_range_value: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[str]] = None,
                 start_day_of_week: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['QueryParameterDateRangeValueDateRangeValueArgs'] date_range_value: Manually specified date-time range value.  Consists of the following attributes:
        :param pulumi.Input[str] dynamic_date_range_value: Dynamic date-time range value based on current date-time.  Possible values are `TODAY`, `YESTERDAY`, `THIS_WEEK`, `THIS_MONTH`, `THIS_YEAR`, `LAST_WEEK`, `LAST_MONTH`, `LAST_YEAR`, `LAST_HOUR`, `LAST_8_HOURS`, `LAST_24_HOURS`, `LAST_7_DAYS`, `LAST_14_DAYS`, `LAST_30_DAYS`, `LAST_60_DAYS`, `LAST_90_DAYS`, `LAST_12_MONTHS`.
        :param pulumi.Input[str] precision: Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        :param pulumi.Input[int] start_day_of_week: Specify what day that starts the week.
        """
        if date_range_value is not None:
            pulumi.set(__self__, "date_range_value", date_range_value)
        if dynamic_date_range_value is not None:
            pulumi.set(__self__, "dynamic_date_range_value", dynamic_date_range_value)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="dateRangeValue")
    def date_range_value(self) -> Optional[pulumi.Input['QueryParameterDateRangeValueDateRangeValueArgs']]:
        """
        Manually specified date-time range value.  Consists of the following attributes:
        """
        return pulumi.get(self, "date_range_value")

    @date_range_value.setter
    def date_range_value(self, value: Optional[pulumi.Input['QueryParameterDateRangeValueDateRangeValueArgs']]):
        pulumi.set(self, "date_range_value", value)

    @property
    @pulumi.getter(name="dynamicDateRangeValue")
    def dynamic_date_range_value(self) -> Optional[pulumi.Input[str]]:
        """
        Dynamic date-time range value based on current date-time.  Possible values are `TODAY`, `YESTERDAY`, `THIS_WEEK`, `THIS_MONTH`, `THIS_YEAR`, `LAST_WEEK`, `LAST_MONTH`, `LAST_YEAR`, `LAST_HOUR`, `LAST_8_HOURS`, `LAST_24_HOURS`, `LAST_7_DAYS`, `LAST_14_DAYS`, `LAST_30_DAYS`, `LAST_60_DAYS`, `LAST_90_DAYS`, `LAST_12_MONTHS`.
        """
        return pulumi.get(self, "dynamic_date_range_value")

    @dynamic_date_range_value.setter
    def dynamic_date_range_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamic_date_range_value", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[str]]:
        """
        Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[pulumi.Input[int]]:
        """
        Specify what day that starts the week.
        """
        return pulumi.get(self, "start_day_of_week")

    @start_day_of_week.setter
    def start_day_of_week(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_day_of_week", value)


if not MYPY:
    class QueryParameterDateRangeValueDateRangeValueArgsDict(TypedDict):
        end: pulumi.Input[str]
        """
        end of the date range.
        """
        start: pulumi.Input[str]
        """
        begin of the date range.
        """
elif False:
    QueryParameterDateRangeValueDateRangeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterDateRangeValueDateRangeValueArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end: end of the date range.
        :param pulumi.Input[str] start: begin of the date range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        end of the date range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        begin of the date range.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class QueryParameterDateValueArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input[str]]
        """
        Manually specified date-time value
        """
        dynamic_date_value: NotRequired[pulumi.Input[str]]
        """
        Dynamic date-time value based on current date-time.  Possible values are `NOW`, `YESTERDAY`.
        """
        precision: NotRequired[pulumi.Input[str]]
        """
        Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
elif False:
    QueryParameterDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterDateValueArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input[str]] = None,
                 dynamic_date_value: Optional[pulumi.Input[str]] = None,
                 precision: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_value: Manually specified date-time value
        :param pulumi.Input[str] dynamic_date_value: Dynamic date-time value based on current date-time.  Possible values are `NOW`, `YESTERDAY`.
        :param pulumi.Input[str] precision: Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if dynamic_date_value is not None:
            pulumi.set(__self__, "dynamic_date_value", dynamic_date_value)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input[str]]:
        """
        Manually specified date-time value
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dynamicDateValue")
    def dynamic_date_value(self) -> Optional[pulumi.Input[str]]:
        """
        Dynamic date-time value based on current date-time.  Possible values are `NOW`, `YESTERDAY`.
        """
        return pulumi.get(self, "dynamic_date_value")

    @dynamic_date_value.setter
    def dynamic_date_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamic_date_value", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[str]]:
        """
        Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "precision", value)


if not MYPY:
    class QueryParameterEnumValueArgsDict(TypedDict):
        enum_options: NotRequired[pulumi.Input[str]]
        """
        List of valid query parameter values, newline delimited.
        """
        multi_values_options: NotRequired[pulumi.Input['QueryParameterEnumValueMultiValuesOptionsArgsDict']]
        """
        If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of selected query parameter values.
        """
elif False:
    QueryParameterEnumValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterEnumValueArgs:
    def __init__(__self__, *,
                 enum_options: Optional[pulumi.Input[str]] = None,
                 multi_values_options: Optional[pulumi.Input['QueryParameterEnumValueMultiValuesOptionsArgs']] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] enum_options: List of valid query parameter values, newline delimited.
        :param pulumi.Input['QueryParameterEnumValueMultiValuesOptionsArgs'] multi_values_options: If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of selected query parameter values.
        """
        if enum_options is not None:
            pulumi.set(__self__, "enum_options", enum_options)
        if multi_values_options is not None:
            pulumi.set(__self__, "multi_values_options", multi_values_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Optional[pulumi.Input[str]]:
        """
        List of valid query parameter values, newline delimited.
        """
        return pulumi.get(self, "enum_options")

    @enum_options.setter
    def enum_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enum_options", value)

    @property
    @pulumi.getter(name="multiValuesOptions")
    def multi_values_options(self) -> Optional[pulumi.Input['QueryParameterEnumValueMultiValuesOptionsArgs']]:
        """
        If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        """
        return pulumi.get(self, "multi_values_options")

    @multi_values_options.setter
    def multi_values_options(self, value: Optional[pulumi.Input['QueryParameterEnumValueMultiValuesOptionsArgs']]):
        pulumi.set(self, "multi_values_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of selected query parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class QueryParameterEnumValueMultiValuesOptionsArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[str]]
        """
        Character that prefixes each selected parameter value.
        """
        separator: NotRequired[pulumi.Input[str]]
        """
        Character that separates each selected parameter value. Defaults to a comma.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Character that suffixes each selected parameter value.
        """
elif False:
    QueryParameterEnumValueMultiValuesOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterEnumValueMultiValuesOptionsArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[str]] = None,
                 separator: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] prefix: Character that prefixes each selected parameter value.
        :param pulumi.Input[str] separator: Character that separates each selected parameter value. Defaults to a comma.
        :param pulumi.Input[str] suffix: Character that suffixes each selected parameter value.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Character that prefixes each selected parameter value.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        Character that separates each selected parameter value. Defaults to a comma.
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Character that suffixes each selected parameter value.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class QueryParameterNumericValueArgsDict(TypedDict):
        value: pulumi.Input[float]
        """
        actual numeric value.
        """
elif False:
    QueryParameterNumericValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterNumericValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[float] value: actual numeric value.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        actual numeric value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class QueryParameterQueryBackedValueArgsDict(TypedDict):
        query_id: pulumi.Input[str]
        """
        ID of the query that provides the parameter values.
        """
        multi_values_options: NotRequired[pulumi.Input['QueryParameterQueryBackedValueMultiValuesOptionsArgsDict']]
        """
        If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of selected query parameter values.
        """
elif False:
    QueryParameterQueryBackedValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterQueryBackedValueArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str],
                 multi_values_options: Optional[pulumi.Input['QueryParameterQueryBackedValueMultiValuesOptionsArgs']] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] query_id: ID of the query that provides the parameter values.
        :param pulumi.Input['QueryParameterQueryBackedValueMultiValuesOptionsArgs'] multi_values_options: If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of selected query parameter values.
        """
        pulumi.set(__self__, "query_id", query_id)
        if multi_values_options is not None:
            pulumi.set(__self__, "multi_values_options", multi_values_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        """
        ID of the query that provides the parameter values.
        """
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)

    @property
    @pulumi.getter(name="multiValuesOptions")
    def multi_values_options(self) -> Optional[pulumi.Input['QueryParameterQueryBackedValueMultiValuesOptionsArgs']]:
        """
        If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        """
        return pulumi.get(self, "multi_values_options")

    @multi_values_options.setter
    def multi_values_options(self, value: Optional[pulumi.Input['QueryParameterQueryBackedValueMultiValuesOptionsArgs']]):
        pulumi.set(self, "multi_values_options", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of selected query parameter values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class QueryParameterQueryBackedValueMultiValuesOptionsArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[str]]
        """
        Character that prefixes each selected parameter value.
        """
        separator: NotRequired[pulumi.Input[str]]
        """
        Character that separates each selected parameter value. Defaults to a comma.
        """
        suffix: NotRequired[pulumi.Input[str]]
        """
        Character that suffixes each selected parameter value.
        """
elif False:
    QueryParameterQueryBackedValueMultiValuesOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterQueryBackedValueMultiValuesOptionsArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[str]] = None,
                 separator: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] prefix: Character that prefixes each selected parameter value.
        :param pulumi.Input[str] separator: Character that separates each selected parameter value. Defaults to a comma.
        :param pulumi.Input[str] suffix: Character that suffixes each selected parameter value.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Character that prefixes each selected parameter value.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        Character that separates each selected parameter value. Defaults to a comma.
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Character that suffixes each selected parameter value.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class QueryParameterTextValueArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        actual text value.
        """
elif False:
    QueryParameterTextValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueryParameterTextValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: actual text value.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        actual text value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RecipientIpAccessListArgsDict(TypedDict):
        allowed_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allowed IP Addresses in CIDR notation. Limit of 100.
        """
elif False:
    RecipientIpAccessListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecipientIpAccessListArgs:
    def __init__(__self__, *,
                 allowed_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_ip_addresses: Allowed IP Addresses in CIDR notation. Limit of 100.
        """
        if allowed_ip_addresses is not None:
            pulumi.set(__self__, "allowed_ip_addresses", allowed_ip_addresses)

    @property
    @pulumi.getter(name="allowedIpAddresses")
    def allowed_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allowed IP Addresses in CIDR notation. Limit of 100.
        """
        return pulumi.get(self, "allowed_ip_addresses")

    @allowed_ip_addresses.setter
    def allowed_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_ip_addresses", value)


if not MYPY:
    class RecipientPropertiesKvpairsArgsDict(TypedDict):
        properties: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        a map of string key-value pairs with recipient's properties.  Properties with name starting with `databricks.` are reserved.
        """
elif False:
    RecipientPropertiesKvpairsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecipientPropertiesKvpairsArgs:
    def __init__(__self__, *,
                 properties: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: a map of string key-value pairs with recipient's properties.  Properties with name starting with `databricks.` are reserved.
        """
        pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        a map of string key-value pairs with recipient's properties.  Properties with name starting with `databricks.` are reserved.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class RecipientTokenArgsDict(TypedDict):
        activation_url: NotRequired[pulumi.Input[str]]
        """
        Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        """
        created_at: NotRequired[pulumi.Input[int]]
        """
        Time at which this recipient was created, in epoch milliseconds.
        """
        created_by: NotRequired[pulumi.Input[str]]
        """
        Username of recipient creator.
        """
        expiration_time: NotRequired[pulumi.Input[int]]
        """
        Expiration timestamp of the token in epoch milliseconds.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique ID of the recipient token.
        """
        updated_at: NotRequired[pulumi.Input[int]]
        """
        Time at which this recipient was updated, in epoch milliseconds.
        """
        updated_by: NotRequired[pulumi.Input[str]]
        """
        Username of recipient Token updater.
        """
elif False:
    RecipientTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecipientTokenArgs:
    def __init__(__self__, *,
                 activation_url: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[int]] = None,
                 created_by: Optional[pulumi.Input[str]] = None,
                 expiration_time: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[int]] = None,
                 updated_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] activation_url: Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        :param pulumi.Input[int] created_at: Time at which this recipient was created, in epoch milliseconds.
        :param pulumi.Input[str] created_by: Username of recipient creator.
        :param pulumi.Input[int] expiration_time: Expiration timestamp of the token in epoch milliseconds.
        :param pulumi.Input[str] id: Unique ID of the recipient token.
        :param pulumi.Input[int] updated_at: Time at which this recipient was updated, in epoch milliseconds.
        :param pulumi.Input[str] updated_by: Username of recipient Token updater.
        """
        if activation_url is not None:
            pulumi.set(__self__, "activation_url", activation_url)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter(name="activationUrl")
    def activation_url(self) -> Optional[pulumi.Input[str]]:
        """
        Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        """
        return pulumi.get(self, "activation_url")

    @activation_url.setter
    def activation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "activation_url", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[int]]:
        """
        Time at which this recipient was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[str]]:
        """
        Username of recipient creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[int]]:
        """
        Expiration timestamp of the token in epoch milliseconds.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique ID of the recipient token.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[int]]:
        """
        Time at which this recipient was updated, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[str]]:
        """
        Username of recipient Token updater.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class RepoSparseCheckoutArgsDict(TypedDict):
        patterns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.

        Addition or removal of the `sparse_checkout` configuration block will lead to recreation of the Git folder.
        """
elif False:
    RepoSparseCheckoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepoSparseCheckoutArgs:
    def __init__(__self__, *,
                 patterns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns: array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.
               
               Addition or removal of the `sparse_checkout` configuration block will lead to recreation of the Git folder.
        """
        pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter
    def patterns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.

        Addition or removal of the `sparse_checkout` configuration block will lead to recreation of the Git folder.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "patterns", value)


if not MYPY:
    class RestrictWorkspaceAdminsSettingRestrictWorkspaceAdminsArgsDict(TypedDict):
        status: pulumi.Input[str]
        """
        The restrict workspace admins status for the workspace.
        """
elif False:
    RestrictWorkspaceAdminsSettingRestrictWorkspaceAdminsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestrictWorkspaceAdminsSettingRestrictWorkspaceAdminsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str]):
        """
        :param pulumi.Input[str] status: The restrict workspace admins status for the workspace.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        The restrict workspace admins status for the workspace.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SecretScopeKeyvaultMetadataArgsDict(TypedDict):
        dns_name: pulumi.Input[str]
        resource_id: pulumi.Input[str]
elif False:
    SecretScopeKeyvaultMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretScopeKeyvaultMetadataArgs:
    def __init__(__self__, *,
                 dns_name: pulumi.Input[str],
                 resource_id: pulumi.Input[str]):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class ShareObjectArgsDict(TypedDict):
        data_object_type: pulumi.Input[str]
        """
        Type of the data object, currently `TABLE`, `SCHEMA`, `VOLUME`, and `MODEL` are supported.
        """
        name: pulumi.Input[str]
        """
        Full name of the object, e.g. `catalog.schema.name` for a tables, volumes and models, or `catalog.schema` for schemas.
        """
        added_at: NotRequired[pulumi.Input[int]]
        added_by: NotRequired[pulumi.Input[str]]
        cdf_enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        Description about the object.
        """
        content: NotRequired[pulumi.Input[str]]
        history_data_sharing_status: NotRequired[pulumi.Input[str]]
        """
        Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.

        To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        """
        partitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgsDict']]]]
        shared_as: NotRequired[pulumi.Input[str]]
        """
        A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        """
        start_version: NotRequired[pulumi.Input[int]]
        """
        The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        string_shared_as: NotRequired[pulumi.Input[str]]
elif False:
    ShareObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShareObjectArgs:
    def __init__(__self__, *,
                 data_object_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 added_at: Optional[pulumi.Input[int]] = None,
                 added_by: Optional[pulumi.Input[str]] = None,
                 cdf_enabled: Optional[pulumi.Input[bool]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 history_data_sharing_status: Optional[pulumi.Input[str]] = None,
                 partitions: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]] = None,
                 shared_as: Optional[pulumi.Input[str]] = None,
                 start_version: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 string_shared_as: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_object_type: Type of the data object, currently `TABLE`, `SCHEMA`, `VOLUME`, and `MODEL` are supported.
        :param pulumi.Input[str] name: Full name of the object, e.g. `catalog.schema.name` for a tables, volumes and models, or `catalog.schema` for schemas.
        :param pulumi.Input[bool] cdf_enabled: Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        :param pulumi.Input[str] comment: Description about the object.
        :param pulumi.Input[str] history_data_sharing_status: Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.
               
               To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        :param pulumi.Input[str] shared_as: A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        :param pulumi.Input[int] start_version: The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        :param pulumi.Input[str] status: Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        pulumi.set(__self__, "data_object_type", data_object_type)
        pulumi.set(__self__, "name", name)
        if added_at is not None:
            pulumi.set(__self__, "added_at", added_at)
        if added_by is not None:
            pulumi.set(__self__, "added_by", added_by)
        if cdf_enabled is not None:
            pulumi.set(__self__, "cdf_enabled", cdf_enabled)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if history_data_sharing_status is not None:
            pulumi.set(__self__, "history_data_sharing_status", history_data_sharing_status)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if shared_as is not None:
            pulumi.set(__self__, "shared_as", shared_as)
        if start_version is not None:
            pulumi.set(__self__, "start_version", start_version)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if string_shared_as is not None:
            pulumi.set(__self__, "string_shared_as", string_shared_as)

    @property
    @pulumi.getter(name="dataObjectType")
    def data_object_type(self) -> pulumi.Input[str]:
        """
        Type of the data object, currently `TABLE`, `SCHEMA`, `VOLUME`, and `MODEL` are supported.
        """
        return pulumi.get(self, "data_object_type")

    @data_object_type.setter
    def data_object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_object_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full name of the object, e.g. `catalog.schema.name` for a tables, volumes and models, or `catalog.schema` for schemas.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "added_at")

    @added_at.setter
    def added_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "added_at", value)

    @property
    @pulumi.getter(name="addedBy")
    def added_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "added_by")

    @added_by.setter
    def added_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "added_by", value)

    @property
    @pulumi.getter(name="cdfEnabled")
    def cdf_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        """
        return pulumi.get(self, "cdf_enabled")

    @cdf_enabled.setter
    def cdf_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cdf_enabled", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Description about the object.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="historyDataSharingStatus")
    def history_data_sharing_status(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.

        To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        """
        return pulumi.get(self, "history_data_sharing_status")

    @history_data_sharing_status.setter
    def history_data_sharing_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "history_data_sharing_status", value)

    @property
    @pulumi.getter
    def partitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="sharedAs")
    def shared_as(self) -> Optional[pulumi.Input[str]]:
        """
        A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        """
        return pulumi.get(self, "shared_as")

    @shared_as.setter
    def shared_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_as", value)

    @property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> Optional[pulumi.Input[int]]:
        """
        The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        """
        return pulumi.get(self, "start_version")

    @start_version.setter
    def start_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_version", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="stringSharedAs")
    def string_shared_as(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string_shared_as")

    @string_shared_as.setter
    def string_shared_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_shared_as", value)


if not MYPY:
    class ShareObjectPartitionArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgsDict']]]]
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
elif False:
    ShareObjectPartitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShareObjectPartitionArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]] values: The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]]:
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ShareObjectPartitionValueArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the partition column.
        """
        op: pulumi.Input[str]
        """
        The operator to apply for the value, one of: `EQUAL`, `LIKE`
        """
        recipient_property_key: NotRequired[pulumi.Input[str]]
        """
        The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
elif False:
    ShareObjectPartitionValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ShareObjectPartitionValueArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 op: pulumi.Input[str],
                 recipient_property_key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the partition column.
        :param pulumi.Input[str] op: The operator to apply for the value, one of: `EQUAL`, `LIKE`
        :param pulumi.Input[str] recipient_property_key: The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        :param pulumi.Input[str] value: The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "op", op)
        if recipient_property_key is not None:
            pulumi.set(__self__, "recipient_property_key", recipient_property_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the partition column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        The operator to apply for the value, one of: `EQUAL`, `LIKE`
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter(name="recipientPropertyKey")
    def recipient_property_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        """
        return pulumi.get(self, "recipient_property_key")

    @recipient_property_key.setter
    def recipient_property_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recipient_property_key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlAlertOptionsArgsDict(TypedDict):
        column: pulumi.Input[str]
        """
        Name of column in the query result to compare in alert evaluation.
        """
        op: pulumi.Input[str]
        """
        Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        """
        value: pulumi.Input[str]
        """
        Value used to compare in alert evaluation.
        """
        custom_body: NotRequired[pulumi.Input[str]]
        """
        Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        custom_subject: NotRequired[pulumi.Input[str]]
        """
        Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        empty_result_state: NotRequired[pulumi.Input[str]]
        """
        State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        """
        muted: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
elif False:
    SqlAlertOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAlertOptionsArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 op: pulumi.Input[str],
                 value: pulumi.Input[str],
                 custom_body: Optional[pulumi.Input[str]] = None,
                 custom_subject: Optional[pulumi.Input[str]] = None,
                 empty_result_state: Optional[pulumi.Input[str]] = None,
                 muted: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] column: Name of column in the query result to compare in alert evaluation.
        :param pulumi.Input[str] op: Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        :param pulumi.Input[str] value: Value used to compare in alert evaluation.
        :param pulumi.Input[str] custom_body: Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        :param pulumi.Input[str] custom_subject: Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        :param pulumi.Input[str] empty_result_state: State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        :param pulumi.Input[bool] muted: Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if custom_body is not None:
            pulumi.set(__self__, "custom_body", custom_body)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if muted is not None:
            pulumi.set(__self__, "muted", muted)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        Name of column in the query result to compare in alert evaluation.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value used to compare in alert evaluation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBody")
    def custom_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        return pulumi.get(self, "custom_body")

    @custom_body.setter
    def custom_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_body", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[pulumi.Input[str]]:
        """
        State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        """
        return pulumi.get(self, "empty_result_state")

    @empty_result_state.setter
    def empty_result_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "empty_result_state", value)

    @property
    @pulumi.getter
    def muted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
        return pulumi.get(self, "muted")

    @muted.setter
    def muted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "muted", value)


if not MYPY:
    class SqlEndpointChannelArgsDict(TypedDict):
        dbsql_version: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
elif False:
    SqlEndpointChannelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlEndpointChannelArgs:
    def __init__(__self__, *,
                 dbsql_version: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        if dbsql_version is not None:
            pulumi.set(__self__, "dbsql_version", dbsql_version)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dbsqlVersion")
    def dbsql_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dbsql_version")

    @dbsql_version.setter
    def dbsql_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbsql_version", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SqlEndpointHealthArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[str]]
        failure_reason: NotRequired[pulumi.Input['SqlEndpointHealthFailureReasonArgsDict']]
        message: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        summary: NotRequired[pulumi.Input[str]]
elif False:
    SqlEndpointHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlEndpointHealthArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input['SqlEndpointHealthFailureReasonArgs']] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 summary: Optional[pulumi.Input[str]] = None):
        if details is not None:
            pulumi.set(__self__, "details", details)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input['SqlEndpointHealthFailureReasonArgs']]:
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input['SqlEndpointHealthFailureReasonArgs']]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def summary(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "summary", value)


if not MYPY:
    class SqlEndpointHealthFailureReasonArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    SqlEndpointHealthFailureReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlEndpointHealthFailureReasonArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SqlEndpointOdbcParamsArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[str]]
        path: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[int]]
        protocol: NotRequired[pulumi.Input[str]]
elif False:
    SqlEndpointOdbcParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlEndpointOdbcParamsArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class SqlEndpointTagsArgsDict(TypedDict):
        custom_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgsDict']]]]
elif False:
    SqlEndpointTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlEndpointTagsArgs:
    def __init__(__self__, *,
                 custom_tags: Optional[pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]] = None):
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class SqlEndpointTagsCustomTagArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    SqlEndpointTagsCustomTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlEndpointTagsCustomTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlPermissionsPrivilegeAssignmentArgsDict(TypedDict):
        principal: pulumi.Input[str]
        """
        `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        """
        privileges: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    SqlPermissionsPrivilegeAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlPermissionsPrivilegeAssignmentArgs:
    def __init__(__self__, *,
                 principal: pulumi.Input[str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] principal: `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        """
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "privileges", privileges)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[str]:
        """
        `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "privileges", value)


if not MYPY:
    class SqlQueryParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The literal parameter marker that appears between double curly braces in the query text.
        Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.

        For `text`, `number`, `date`, `datetime`, `datetimesec` block
        """
        date: NotRequired[pulumi.Input['SqlQueryParameterDateArgsDict']]
        date_range: NotRequired[pulumi.Input['SqlQueryParameterDateRangeArgsDict']]
        datetime: NotRequired[pulumi.Input['SqlQueryParameterDatetimeArgsDict']]
        datetime_range: NotRequired[pulumi.Input['SqlQueryParameterDatetimeRangeArgsDict']]
        datetimesec: NotRequired[pulumi.Input['SqlQueryParameterDatetimesecArgsDict']]
        datetimesec_range: NotRequired[pulumi.Input['SqlQueryParameterDatetimesecRangeArgsDict']]
        enum: NotRequired[pulumi.Input['SqlQueryParameterEnumArgsDict']]
        number: NotRequired[pulumi.Input['SqlQueryParameterNumberArgsDict']]
        query: NotRequired[pulumi.Input['SqlQueryParameterQueryArgsDict']]
        """
        The text of the query to be run.
        """
        text: NotRequired[pulumi.Input['SqlQueryParameterTextArgsDict']]
        title: NotRequired[pulumi.Input[str]]
        """
        The text displayed in a parameter picking widget.
        """
elif False:
    SqlQueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 date: Optional[pulumi.Input['SqlQueryParameterDateArgs']] = None,
                 date_range: Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']] = None,
                 datetime: Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']] = None,
                 datetime_range: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']] = None,
                 datetimesec: Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']] = None,
                 datetimesec_range: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']] = None,
                 enum: Optional[pulumi.Input['SqlQueryParameterEnumArgs']] = None,
                 number: Optional[pulumi.Input['SqlQueryParameterNumberArgs']] = None,
                 query: Optional[pulumi.Input['SqlQueryParameterQueryArgs']] = None,
                 text: Optional[pulumi.Input['SqlQueryParameterTextArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The literal parameter marker that appears between double curly braces in the query text.
               Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.
               
               For `text`, `number`, `date`, `datetime`, `datetimesec` block
        :param pulumi.Input['SqlQueryParameterQueryArgs'] query: The text of the query to be run.
        :param pulumi.Input[str] title: The text displayed in a parameter picking widget.
        """
        pulumi.set(__self__, "name", name)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if date_range is not None:
            pulumi.set(__self__, "date_range", date_range)
        if datetime is not None:
            pulumi.set(__self__, "datetime", datetime)
        if datetime_range is not None:
            pulumi.set(__self__, "datetime_range", datetime_range)
        if datetimesec is not None:
            pulumi.set(__self__, "datetimesec", datetimesec)
        if datetimesec_range is not None:
            pulumi.set(__self__, "datetimesec_range", datetimesec_range)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The literal parameter marker that appears between double curly braces in the query text.
        Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.

        For `text`, `number`, `date`, `datetime`, `datetimesec` block
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input['SqlQueryParameterDateArgs']]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input['SqlQueryParameterDateArgs']]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']]:
        return pulumi.get(self, "date_range")

    @date_range.setter
    def date_range(self, value: Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']]):
        pulumi.set(self, "date_range", value)

    @property
    @pulumi.getter
    def datetime(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']]:
        return pulumi.get(self, "datetime")

    @datetime.setter
    def datetime(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']]):
        pulumi.set(self, "datetime", value)

    @property
    @pulumi.getter(name="datetimeRange")
    def datetime_range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']]:
        return pulumi.get(self, "datetime_range")

    @datetime_range.setter
    def datetime_range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']]):
        pulumi.set(self, "datetime_range", value)

    @property
    @pulumi.getter
    def datetimesec(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']]:
        return pulumi.get(self, "datetimesec")

    @datetimesec.setter
    def datetimesec(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']]):
        pulumi.set(self, "datetimesec", value)

    @property
    @pulumi.getter(name="datetimesecRange")
    def datetimesec_range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']]:
        return pulumi.get(self, "datetimesec_range")

    @datetimesec_range.setter
    def datetimesec_range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']]):
        pulumi.set(self, "datetimesec_range", value)

    @property
    @pulumi.getter
    def enum(self) -> Optional[pulumi.Input['SqlQueryParameterEnumArgs']]:
        return pulumi.get(self, "enum")

    @enum.setter
    def enum(self, value: Optional[pulumi.Input['SqlQueryParameterEnumArgs']]):
        pulumi.set(self, "enum", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input['SqlQueryParameterNumberArgs']]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input['SqlQueryParameterNumberArgs']]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['SqlQueryParameterQueryArgs']]:
        """
        The text of the query to be run.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['SqlQueryParameterQueryArgs']]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['SqlQueryParameterTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['SqlQueryParameterTextArgs']]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The text displayed in a parameter picking widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class SqlQueryParameterDateArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDateArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterDateRangeArgsDict(TypedDict):
        range: NotRequired[pulumi.Input['SqlQueryParameterDateRangeRangeArgsDict']]
        value: NotRequired[pulumi.Input[str]]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterDateRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDateRangeArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterDateRangeRangeArgsDict(TypedDict):
        end: pulumi.Input[str]
        start: pulumi.Input[str]
elif False:
    SqlQueryParameterDateRangeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDateRangeRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SqlQueryParameterDatetimeArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterDatetimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDatetimeArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterDatetimeRangeArgsDict(TypedDict):
        range: NotRequired[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgsDict']]
        value: NotRequired[pulumi.Input[str]]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterDatetimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDatetimeRangeArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterDatetimeRangeRangeArgsDict(TypedDict):
        end: pulumi.Input[str]
        start: pulumi.Input[str]
elif False:
    SqlQueryParameterDatetimeRangeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDatetimeRangeRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SqlQueryParameterDatetimesecArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterDatetimesecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDatetimesecArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterDatetimesecRangeArgsDict(TypedDict):
        range: NotRequired[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgsDict']]
        value: NotRequired[pulumi.Input[str]]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterDatetimesecRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDatetimesecRangeArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterDatetimesecRangeRangeArgsDict(TypedDict):
        end: pulumi.Input[str]
        start: pulumi.Input[str]
elif False:
    SqlQueryParameterDatetimesecRangeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterDatetimesecRangeRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


if not MYPY:
    class SqlQueryParameterEnumArgsDict(TypedDict):
        options: pulumi.Input[Sequence[pulumi.Input[str]]]
        multiple: NotRequired[pulumi.Input['SqlQueryParameterEnumMultipleArgsDict']]
        value: NotRequired[pulumi.Input[str]]
        """
        The default value for this parameter.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SqlQueryParameterEnumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterEnumArgs:
    def __init__(__self__, *,
                 options: pulumi.Input[Sequence[pulumi.Input[str]]],
                 multiple: Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        pulumi.set(__self__, "options", options)
        if multiple is not None:
            pulumi.set(__self__, "multiple", multiple)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def multiple(self) -> Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']]:
        return pulumi.get(self, "multiple")

    @multiple.setter
    def multiple(self, value: Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']]):
        pulumi.set(self, "multiple", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SqlQueryParameterEnumMultipleArgsDict(TypedDict):
        separator: pulumi.Input[str]
        prefix: NotRequired[pulumi.Input[str]]
        suffix: NotRequired[pulumi.Input[str]]
elif False:
    SqlQueryParameterEnumMultipleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterEnumMultipleArgs:
    def __init__(__self__, *,
                 separator: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "separator", separator)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def separator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: pulumi.Input[str]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class SqlQueryParameterNumberArgsDict(TypedDict):
        value: pulumi.Input[float]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterNumberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterNumberArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[float] value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryParameterQueryArgsDict(TypedDict):
        query_id: pulumi.Input[str]
        multiple: NotRequired[pulumi.Input['SqlQueryParameterQueryMultipleArgsDict']]
        value: NotRequired[pulumi.Input[str]]
        """
        The default value for this parameter.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SqlQueryParameterQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterQueryArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str],
                 multiple: Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        pulumi.set(__self__, "query_id", query_id)
        if multiple is not None:
            pulumi.set(__self__, "multiple", multiple)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)

    @property
    @pulumi.getter
    def multiple(self) -> Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']]:
        return pulumi.get(self, "multiple")

    @multiple.setter
    def multiple(self, value: Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']]):
        pulumi.set(self, "multiple", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SqlQueryParameterQueryMultipleArgsDict(TypedDict):
        separator: pulumi.Input[str]
        prefix: NotRequired[pulumi.Input[str]]
        suffix: NotRequired[pulumi.Input[str]]
elif False:
    SqlQueryParameterQueryMultipleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterQueryMultipleArgs:
    def __init__(__self__, *,
                 separator: pulumi.Input[str],
                 prefix: Optional[pulumi.Input[str]] = None,
                 suffix: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "separator", separator)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def separator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: pulumi.Input[str]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class SqlQueryParameterTextArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        The default value for this parameter.
        """
elif False:
    SqlQueryParameterTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryParameterTextArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlQueryScheduleArgsDict(TypedDict):
        continuous: NotRequired[pulumi.Input['SqlQueryScheduleContinuousArgsDict']]
        daily: NotRequired[pulumi.Input['SqlQueryScheduleDailyArgsDict']]
        weekly: NotRequired[pulumi.Input['SqlQueryScheduleWeeklyArgsDict']]
elif False:
    SqlQueryScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryScheduleArgs:
    def __init__(__self__, *,
                 continuous: Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']] = None,
                 daily: Optional[pulumi.Input['SqlQueryScheduleDailyArgs']] = None,
                 weekly: Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']] = None):
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @property
    @pulumi.getter
    def continuous(self) -> Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']]:
        return pulumi.get(self, "continuous")

    @continuous.setter
    def continuous(self, value: Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']]):
        pulumi.set(self, "continuous", value)

    @property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['SqlQueryScheduleDailyArgs']]:
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['SqlQueryScheduleDailyArgs']]):
        pulumi.set(self, "daily", value)

    @property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']]:
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class SqlQueryScheduleContinuousArgsDict(TypedDict):
        interval_seconds: pulumi.Input[int]
        until_date: NotRequired[pulumi.Input[str]]
elif False:
    SqlQueryScheduleContinuousArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryScheduleContinuousArgs:
    def __init__(__self__, *,
                 interval_seconds: pulumi.Input[int],
                 until_date: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "interval_seconds", interval_seconds)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> pulumi.Input[int]:
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_seconds", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "until_date", value)


if not MYPY:
    class SqlQueryScheduleDailyArgsDict(TypedDict):
        interval_days: pulumi.Input[int]
        time_of_day: pulumi.Input[str]
        until_date: NotRequired[pulumi.Input[str]]
elif False:
    SqlQueryScheduleDailyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryScheduleDailyArgs:
    def __init__(__self__, *,
                 interval_days: pulumi.Input[int],
                 time_of_day: pulumi.Input[str],
                 until_date: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "time_of_day", time_of_day)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> pulumi.Input[int]:
        return pulumi.get(self, "interval_days")

    @interval_days.setter
    def interval_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_days", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_of_day", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "until_date", value)


if not MYPY:
    class SqlQueryScheduleWeeklyArgsDict(TypedDict):
        day_of_week: pulumi.Input[str]
        interval_weeks: pulumi.Input[int]
        time_of_day: pulumi.Input[str]
        until_date: NotRequired[pulumi.Input[str]]
elif False:
    SqlQueryScheduleWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlQueryScheduleWeeklyArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 interval_weeks: pulumi.Input[int],
                 time_of_day: pulumi.Input[str],
                 until_date: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "interval_weeks", interval_weeks)
        pulumi.set(__self__, "time_of_day", time_of_day)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="intervalWeeks")
    def interval_weeks(self) -> pulumi.Input[int]:
        return pulumi.get(self, "interval_weeks")

    @interval_weeks.setter
    def interval_weeks(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_weeks", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_of_day", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "until_date", value)


if not MYPY:
    class SqlTableColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        User-visible name of column
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        User-supplied free-form text.
        """
        identity: NotRequired[pulumi.Input[str]]
        """
        Whether field is an identity column. Can be `default`, `always` or unset. It is unset by default.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether field is nullable (Default: `true`)
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        type_json: NotRequired[pulumi.Input[str]]
elif False:
    SqlTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlTableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 comment: Optional[pulumi.Input[str]] = None,
                 identity: Optional[pulumi.Input[str]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 type_json: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: User-visible name of column
        :param pulumi.Input[str] comment: User-supplied free-form text.
        :param pulumi.Input[str] identity: Whether field is an identity column. Can be `default`, `always` or unset. It is unset by default.
        :param pulumi.Input[bool] nullable: Whether field is nullable (Default: `true`)
        :param pulumi.Input[str] type: Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-visible name of column
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        User-supplied free-form text.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[str]]:
        """
        Whether field is an identity column. Can be `default`, `always` or unset. It is unset by default.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether field is nullable (Default: `true`)
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type_json")

    @type_json.setter
    def type_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_json", value)


if not MYPY:
    class SqlWidgetParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        type: pulumi.Input[str]
        map_to: NotRequired[pulumi.Input[str]]
        title: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    SqlWidgetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlWidgetParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 map_to: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if map_to is not None:
            pulumi.set(__self__, "map_to", map_to)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mapTo")
    def map_to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "map_to")

    @map_to.setter
    def map_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_to", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SqlWidgetPositionArgsDict(TypedDict):
        size_x: pulumi.Input[int]
        size_y: pulumi.Input[int]
        auto_height: NotRequired[pulumi.Input[bool]]
        pos_x: NotRequired[pulumi.Input[int]]
        pos_y: NotRequired[pulumi.Input[int]]
elif False:
    SqlWidgetPositionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlWidgetPositionArgs:
    def __init__(__self__, *,
                 size_x: pulumi.Input[int],
                 size_y: pulumi.Input[int],
                 auto_height: Optional[pulumi.Input[bool]] = None,
                 pos_x: Optional[pulumi.Input[int]] = None,
                 pos_y: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "size_x", size_x)
        pulumi.set(__self__, "size_y", size_y)
        if auto_height is not None:
            pulumi.set(__self__, "auto_height", auto_height)
        if pos_x is not None:
            pulumi.set(__self__, "pos_x", pos_x)
        if pos_y is not None:
            pulumi.set(__self__, "pos_y", pos_y)

    @property
    @pulumi.getter(name="sizeX")
    def size_x(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_x")

    @size_x.setter
    def size_x(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_x", value)

    @property
    @pulumi.getter(name="sizeY")
    def size_y(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_y")

    @size_y.setter
    def size_y(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_y", value)

    @property
    @pulumi.getter(name="autoHeight")
    def auto_height(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_height")

    @auto_height.setter
    def auto_height(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_height", value)

    @property
    @pulumi.getter(name="posX")
    def pos_x(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pos_x")

    @pos_x.setter
    def pos_x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pos_x", value)

    @property
    @pulumi.getter(name="posY")
    def pos_y(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pos_y")

    @pos_y.setter
    def pos_y(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pos_y", value)


if not MYPY:
    class StorageCredentialAwsIamRoleArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`

        `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        """
        external_id: NotRequired[pulumi.Input[str]]
        unity_catalog_iam_arn: NotRequired[pulumi.Input[str]]
elif False:
    StorageCredentialAwsIamRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCredentialAwsIamRoleArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 external_id: Optional[pulumi.Input[str]] = None,
                 unity_catalog_iam_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
               
               `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`

        `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unity_catalog_iam_arn")

    @unity_catalog_iam_arn.setter
    def unity_catalog_iam_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unity_catalog_iam_arn", value)


if not MYPY:
    class StorageCredentialAzureManagedIdentityArgsDict(TypedDict):
        access_connector_id: pulumi.Input[str]
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        credential_id: NotRequired[pulumi.Input[str]]
        managed_identity_id: NotRequired[pulumi.Input[str]]
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.

        `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
elif False:
    StorageCredentialAzureManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCredentialAzureManagedIdentityArgs:
    def __init__(__self__, *,
                 access_connector_id: pulumi.Input[str],
                 credential_id: Optional[pulumi.Input[str]] = None,
                 managed_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param pulumi.Input[str] managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
               
               `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> pulumi.Input[str]:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @access_connector_id.setter
    def access_connector_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_connector_id", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.

        `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        return pulumi.get(self, "managed_identity_id")

    @managed_identity_id.setter
    def managed_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_identity_id", value)


if not MYPY:
    class StorageCredentialAzureServicePrincipalArgsDict(TypedDict):
        application_id: pulumi.Input[str]
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        client_secret: pulumi.Input[str]
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        directory_id: pulumi.Input[str]
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
elif False:
    StorageCredentialAzureServicePrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCredentialAzureServicePrincipalArgs:
    def __init__(__self__, *,
                 application_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 directory_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] application_id: The application ID of the application registration within the referenced AAD tenant
        :param pulumi.Input[str] client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
        :param pulumi.Input[str] directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> pulumi.Input[str]:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> pulumi.Input[str]:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "directory_id", value)


if not MYPY:
    class StorageCredentialCloudflareApiTokenArgsDict(TypedDict):
        access_key_id: pulumi.Input[str]
        """
        R2 API token access key ID
        """
        account_id: pulumi.Input[str]
        """
        R2 account ID
        """
        secret_access_key: pulumi.Input[str]
        """
        R2 API token secret access key

        `azure_service_principal` optional configuration block to use service principal as credential details for Azure (Legacy):
        """
elif False:
    StorageCredentialCloudflareApiTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCredentialCloudflareApiTokenArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[str],
                 account_id: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_key_id: R2 API token access key ID
        :param pulumi.Input[str] account_id: R2 account ID
        :param pulumi.Input[str] secret_access_key: R2 API token secret access key
               
               `azure_service_principal` optional configuration block to use service principal as credential details for Azure (Legacy):
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[str]:
        """
        R2 API token access key ID
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        R2 account ID
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        """
        R2 API token secret access key

        `azure_service_principal` optional configuration block to use service principal as credential details for Azure (Legacy):
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class StorageCredentialDatabricksGcpServiceAccountArgsDict(TypedDict):
        credential_id: NotRequired[pulumi.Input[str]]
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
elif False:
    StorageCredentialDatabricksGcpServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCredentialDatabricksGcpServiceAccountArgs:
    def __init__(__self__, *,
                 credential_id: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: The email of the GCP service account created, to be granted access to relevant buckets.
               
               `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


if not MYPY:
    class StorageCredentialGcpServiceAccountKeyArgsDict(TypedDict):
        email: pulumi.Input[str]
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        private_key: pulumi.Input[str]
        private_key_id: pulumi.Input[str]
elif False:
    StorageCredentialGcpServiceAccountKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageCredentialGcpServiceAccountKeyArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 private_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the GCP service account created, to be granted access to relevant buckets.
               
               `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_id", value)


if not MYPY:
    class TableColumnArgsDict(TypedDict):
        name: pulumi.Input[str]
        position: pulumi.Input[int]
        type_name: pulumi.Input[str]
        type_text: pulumi.Input[str]
        comment: NotRequired[pulumi.Input[str]]
        nullable: NotRequired[pulumi.Input[bool]]
        partition_index: NotRequired[pulumi.Input[int]]
        type_interval_type: NotRequired[pulumi.Input[str]]
        type_json: NotRequired[pulumi.Input[str]]
        type_precision: NotRequired[pulumi.Input[int]]
        type_scale: NotRequired[pulumi.Input[int]]
elif False:
    TableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 position: pulumi.Input[int],
                 type_name: pulumi.Input[str],
                 type_text: pulumi.Input[str],
                 comment: Optional[pulumi.Input[str]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 partition_index: Optional[pulumi.Input[int]] = None,
                 type_interval_type: Optional[pulumi.Input[str]] = None,
                 type_json: Optional[pulumi.Input[str]] = None,
                 type_precision: Optional[pulumi.Input[int]] = None,
                 type_scale: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if partition_index is not None:
            pulumi.set(__self__, "partition_index", partition_index)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[int]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[int]):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="typeText")
    def type_text(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_text")

    @type_text.setter
    def type_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_text", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="partitionIndex")
    def partition_index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "partition_index")

    @partition_index.setter
    def partition_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_index", value)

    @property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type_interval_type")

    @type_interval_type.setter
    def type_interval_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_interval_type", value)

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type_json")

    @type_json.setter
    def type_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_json", value)

    @property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "type_precision")

    @type_precision.setter
    def type_precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type_precision", value)

    @property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "type_scale")

    @type_scale.setter
    def type_scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type_scale", value)


if not MYPY:
    class VectorSearchEndpointEndpointStatusArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[str]]
        """
        Additional status message.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        Current state of the endpoint. Currently following values are supported: `PROVISIONING`, `ONLINE`, and `OFFLINE`.
        """
elif False:
    VectorSearchEndpointEndpointStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchEndpointEndpointStatusArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] message: Additional status message.
        :param pulumi.Input[str] state: Current state of the endpoint. Currently following values are supported: `PROVISIONING`, `ONLINE`, and `OFFLINE`.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Additional status message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Current state of the endpoint. Currently following values are supported: `PROVISIONING`, `ONLINE`, and `OFFLINE`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class VectorSearchIndexDeltaSyncIndexSpecArgsDict(TypedDict):
        embedding_source_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgsDict']]]]
        """
        array of objects representing columns that contain the embedding source.  Each entry consists of:
        """
        embedding_vector_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgsDict']]]]
        embedding_writeback_table: NotRequired[pulumi.Input[str]]
        pipeline_id: NotRequired[pulumi.Input[str]]
        """
        ID of the associated Delta Live Table pipeline.
        """
        pipeline_type: NotRequired[pulumi.Input[str]]
        """
        Pipeline execution mode. Possible values are:
        * `TRIGGERED`: If the pipeline uses the triggered execution mode, the system stops processing after successfully refreshing the source table in the pipeline once, ensuring the table is updated based on the data available when the update started.
        * `CONTINUOUS`: If the pipeline uses continuous execution, the pipeline processes new data as it arrives in the source table to keep the vector index fresh.
        """
        source_table: NotRequired[pulumi.Input[str]]
        """
        The name of the source table.
        """
elif False:
    VectorSearchIndexDeltaSyncIndexSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexDeltaSyncIndexSpecArgs:
    def __init__(__self__, *,
                 embedding_source_columns: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs']]]] = None,
                 embedding_vector_columns: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgs']]]] = None,
                 embedding_writeback_table: Optional[pulumi.Input[str]] = None,
                 pipeline_id: Optional[pulumi.Input[str]] = None,
                 pipeline_type: Optional[pulumi.Input[str]] = None,
                 source_table: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs']]] embedding_source_columns: array of objects representing columns that contain the embedding source.  Each entry consists of:
        :param pulumi.Input[str] pipeline_id: ID of the associated Delta Live Table pipeline.
        :param pulumi.Input[str] pipeline_type: Pipeline execution mode. Possible values are:
               * `TRIGGERED`: If the pipeline uses the triggered execution mode, the system stops processing after successfully refreshing the source table in the pipeline once, ensuring the table is updated based on the data available when the update started.
               * `CONTINUOUS`: If the pipeline uses continuous execution, the pipeline processes new data as it arrives in the source table to keep the vector index fresh.
        :param pulumi.Input[str] source_table: The name of the source table.
        """
        if embedding_source_columns is not None:
            pulumi.set(__self__, "embedding_source_columns", embedding_source_columns)
        if embedding_vector_columns is not None:
            pulumi.set(__self__, "embedding_vector_columns", embedding_vector_columns)
        if embedding_writeback_table is not None:
            pulumi.set(__self__, "embedding_writeback_table", embedding_writeback_table)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if pipeline_type is not None:
            pulumi.set(__self__, "pipeline_type", pipeline_type)
        if source_table is not None:
            pulumi.set(__self__, "source_table", source_table)

    @property
    @pulumi.getter(name="embeddingSourceColumns")
    def embedding_source_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs']]]]:
        """
        array of objects representing columns that contain the embedding source.  Each entry consists of:
        """
        return pulumi.get(self, "embedding_source_columns")

    @embedding_source_columns.setter
    def embedding_source_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs']]]]):
        pulumi.set(self, "embedding_source_columns", value)

    @property
    @pulumi.getter(name="embeddingVectorColumns")
    def embedding_vector_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgs']]]]:
        return pulumi.get(self, "embedding_vector_columns")

    @embedding_vector_columns.setter
    def embedding_vector_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgs']]]]):
        pulumi.set(self, "embedding_vector_columns", value)

    @property
    @pulumi.getter(name="embeddingWritebackTable")
    def embedding_writeback_table(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "embedding_writeback_table")

    @embedding_writeback_table.setter
    def embedding_writeback_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "embedding_writeback_table", value)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the associated Delta Live Table pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="pipelineType")
    def pipeline_type(self) -> Optional[pulumi.Input[str]]:
        """
        Pipeline execution mode. Possible values are:
        * `TRIGGERED`: If the pipeline uses the triggered execution mode, the system stops processing after successfully refreshing the source table in the pipeline once, ensuring the table is updated based on the data available when the update started.
        * `CONTINUOUS`: If the pipeline uses continuous execution, the pipeline processes new data as it arrives in the source table to keep the vector index fresh.
        """
        return pulumi.get(self, "pipeline_type")

    @pipeline_type.setter
    def pipeline_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_type", value)

    @property
    @pulumi.getter(name="sourceTable")
    def source_table(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the source table.
        """
        return pulumi.get(self, "source_table")

    @source_table.setter
    def source_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_table", value)


if not MYPY:
    class VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgsDict(TypedDict):
        embedding_model_endpoint_name: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
elif False:
    VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs:
    def __init__(__self__, *,
                 embedding_model_endpoint_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        if embedding_model_endpoint_name is not None:
            pulumi.set(__self__, "embedding_model_endpoint_name", embedding_model_endpoint_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="embeddingModelEndpointName")
    def embedding_model_endpoint_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "embedding_model_endpoint_name")

    @embedding_model_endpoint_name.setter
    def embedding_model_endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "embedding_model_endpoint_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgsDict(TypedDict):
        embedding_dimension: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
elif False:
    VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgs:
    def __init__(__self__, *,
                 embedding_dimension: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        if embedding_dimension is not None:
            pulumi.set(__self__, "embedding_dimension", embedding_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="embeddingDimension")
    def embedding_dimension(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "embedding_dimension")

    @embedding_dimension.setter
    def embedding_dimension(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "embedding_dimension", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VectorSearchIndexDirectAccessIndexSpecArgsDict(TypedDict):
        embedding_source_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgsDict']]]]
        """
        array of objects representing columns that contain the embedding source.  Each entry consists of:
        """
        embedding_vector_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgsDict']]]]
        schema_json: NotRequired[pulumi.Input[str]]
        """
        The schema of the index in JSON format.  Check the [API documentation](https://docs.databricks.com/api/workspace/vectorsearchindexes/createindex#direct_access_index_spec-schema_json) for a list of supported data types.
        """
elif False:
    VectorSearchIndexDirectAccessIndexSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexDirectAccessIndexSpecArgs:
    def __init__(__self__, *,
                 embedding_source_columns: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs']]]] = None,
                 embedding_vector_columns: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgs']]]] = None,
                 schema_json: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs']]] embedding_source_columns: array of objects representing columns that contain the embedding source.  Each entry consists of:
        :param pulumi.Input[str] schema_json: The schema of the index in JSON format.  Check the [API documentation](https://docs.databricks.com/api/workspace/vectorsearchindexes/createindex#direct_access_index_spec-schema_json) for a list of supported data types.
        """
        if embedding_source_columns is not None:
            pulumi.set(__self__, "embedding_source_columns", embedding_source_columns)
        if embedding_vector_columns is not None:
            pulumi.set(__self__, "embedding_vector_columns", embedding_vector_columns)
        if schema_json is not None:
            pulumi.set(__self__, "schema_json", schema_json)

    @property
    @pulumi.getter(name="embeddingSourceColumns")
    def embedding_source_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs']]]]:
        """
        array of objects representing columns that contain the embedding source.  Each entry consists of:
        """
        return pulumi.get(self, "embedding_source_columns")

    @embedding_source_columns.setter
    def embedding_source_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs']]]]):
        pulumi.set(self, "embedding_source_columns", value)

    @property
    @pulumi.getter(name="embeddingVectorColumns")
    def embedding_vector_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgs']]]]:
        return pulumi.get(self, "embedding_vector_columns")

    @embedding_vector_columns.setter
    def embedding_vector_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgs']]]]):
        pulumi.set(self, "embedding_vector_columns", value)

    @property
    @pulumi.getter(name="schemaJson")
    def schema_json(self) -> Optional[pulumi.Input[str]]:
        """
        The schema of the index in JSON format.  Check the [API documentation](https://docs.databricks.com/api/workspace/vectorsearchindexes/createindex#direct_access_index_spec-schema_json) for a list of supported data types.
        """
        return pulumi.get(self, "schema_json")

    @schema_json.setter
    def schema_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_json", value)


if not MYPY:
    class VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgsDict(TypedDict):
        embedding_model_endpoint_name: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
elif False:
    VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs:
    def __init__(__self__, *,
                 embedding_model_endpoint_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        if embedding_model_endpoint_name is not None:
            pulumi.set(__self__, "embedding_model_endpoint_name", embedding_model_endpoint_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="embeddingModelEndpointName")
    def embedding_model_endpoint_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "embedding_model_endpoint_name")

    @embedding_model_endpoint_name.setter
    def embedding_model_endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "embedding_model_endpoint_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgsDict(TypedDict):
        embedding_dimension: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
elif False:
    VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgs:
    def __init__(__self__, *,
                 embedding_dimension: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        if embedding_dimension is not None:
            pulumi.set(__self__, "embedding_dimension", embedding_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="embeddingDimension")
    def embedding_dimension(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "embedding_dimension")

    @embedding_dimension.setter
    def embedding_dimension(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "embedding_dimension", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Three-level name of the Mosaic AI Vector Search Index to create (`catalog.schema.index_name`).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VectorSearchIndexStatusArgsDict(TypedDict):
        index_url: NotRequired[pulumi.Input[str]]
        """
        Index API Url to be used to perform operations on the index
        """
        indexed_row_count: NotRequired[pulumi.Input[int]]
        """
        Number of rows indexed
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Message associated with the index status
        """
        ready: NotRequired[pulumi.Input[bool]]
        """
        Whether the index is ready for search
        """
elif False:
    VectorSearchIndexStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorSearchIndexStatusArgs:
    def __init__(__self__, *,
                 index_url: Optional[pulumi.Input[str]] = None,
                 indexed_row_count: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 ready: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] index_url: Index API Url to be used to perform operations on the index
        :param pulumi.Input[int] indexed_row_count: Number of rows indexed
        :param pulumi.Input[str] message: Message associated with the index status
        :param pulumi.Input[bool] ready: Whether the index is ready for search
        """
        if index_url is not None:
            pulumi.set(__self__, "index_url", index_url)
        if indexed_row_count is not None:
            pulumi.set(__self__, "indexed_row_count", indexed_row_count)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ready is not None:
            pulumi.set(__self__, "ready", ready)

    @property
    @pulumi.getter(name="indexUrl")
    def index_url(self) -> Optional[pulumi.Input[str]]:
        """
        Index API Url to be used to perform operations on the index
        """
        return pulumi.get(self, "index_url")

    @index_url.setter
    def index_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_url", value)

    @property
    @pulumi.getter(name="indexedRowCount")
    def indexed_row_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of rows indexed
        """
        return pulumi.get(self, "indexed_row_count")

    @indexed_row_count.setter
    def indexed_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "indexed_row_count", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Message associated with the index status
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def ready(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the index is ready for search
        """
        return pulumi.get(self, "ready")

    @ready.setter
    def ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ready", value)


if not MYPY:
    class GetCatalogCatalogInfoArgsDict(TypedDict):
        browse_only: NotRequired[bool]
        catalog_type: NotRequired[str]
        """
        Type of the catalog, e.g. `MANAGED_CATALOG`, `DELTASHARING_CATALOG`, `SYSTEM_CATALOG`,
        """
        comment: NotRequired[str]
        """
        Free-form text description
        """
        connection_name: NotRequired[str]
        """
        The name of the connection to an external data source.
        """
        created_at: NotRequired[int]
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        created_by: NotRequired[str]
        """
        Username of catalog creator.
        """
        effective_predictive_optimization_flag: NotRequired['GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgsDict']
        """
        object describing applied predictive optimization flag.
        """
        enable_predictive_optimization: NotRequired[str]
        """
        Whether predictive optimization should be enabled for this object and objects under it.
        """
        full_name: NotRequired[str]
        """
        The full name of the catalog. Corresponds with the name field.
        """
        isolation_mode: NotRequired[str]
        """
        Whether the current securable is accessible from all workspaces or a  specific set of workspaces.
        """
        metastore_id: NotRequired[str]
        """
        Unique identifier of parent metastore.
        """
        name: NotRequired[str]
        """
        name of the catalog
        """
        options: NotRequired[Mapping[str, str]]
        """
        A map of key-value properties attached to the securable.
        """
        owner: NotRequired[str]
        """
        Current owner of the catalog
        """
        properties: NotRequired[Mapping[str, str]]
        """
        A map of key-value properties attached to the securable.
        """
        provider_name: NotRequired[str]
        """
        The name of delta sharing provider.
        """
        provisioning_info: NotRequired['GetCatalogCatalogInfoProvisioningInfoArgsDict']
        securable_kind: NotRequired[str]
        """
        Kind of catalog securable.
        """
        securable_type: NotRequired[str]
        """
        Securable type.
        """
        share_name: NotRequired[str]
        """
        The name of the share under the share provider.
        """
        storage_location: NotRequired[str]
        """
        Storage Location URL (full path) for managed tables within catalog.
        """
        storage_root: NotRequired[str]
        """
        Storage root URL for managed tables within catalog.
        """
        updated_at: NotRequired[int]
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        updated_by: NotRequired[str]
        """
        Username of user who last modified catalog.
        """
elif False:
    GetCatalogCatalogInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogCatalogInfoArgs:
    def __init__(__self__, *,
                 browse_only: Optional[bool] = None,
                 catalog_type: Optional[str] = None,
                 comment: Optional[str] = None,
                 connection_name: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 effective_predictive_optimization_flag: Optional['GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs'] = None,
                 enable_predictive_optimization: Optional[str] = None,
                 full_name: Optional[str] = None,
                 isolation_mode: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 options: Optional[Mapping[str, str]] = None,
                 owner: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 provider_name: Optional[str] = None,
                 provisioning_info: Optional['GetCatalogCatalogInfoProvisioningInfoArgs'] = None,
                 securable_kind: Optional[str] = None,
                 securable_type: Optional[str] = None,
                 share_name: Optional[str] = None,
                 storage_location: Optional[str] = None,
                 storage_root: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param str catalog_type: Type of the catalog, e.g. `MANAGED_CATALOG`, `DELTASHARING_CATALOG`, `SYSTEM_CATALOG`,
        :param str comment: Free-form text description
        :param str connection_name: The name of the connection to an external data source.
        :param int created_at: Time at which this catalog was created, in epoch milliseconds.
        :param str created_by: Username of catalog creator.
        :param 'GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs' effective_predictive_optimization_flag: object describing applied predictive optimization flag.
        :param str enable_predictive_optimization: Whether predictive optimization should be enabled for this object and objects under it.
        :param str full_name: The full name of the catalog. Corresponds with the name field.
        :param str isolation_mode: Whether the current securable is accessible from all workspaces or a  specific set of workspaces.
        :param str metastore_id: Unique identifier of parent metastore.
        :param str name: name of the catalog
        :param Mapping[str, str] options: A map of key-value properties attached to the securable.
        :param str owner: Current owner of the catalog
        :param Mapping[str, str] properties: A map of key-value properties attached to the securable.
        :param str provider_name: The name of delta sharing provider.
        :param str securable_kind: Kind of catalog securable.
        :param str securable_type: Securable type.
        :param str share_name: The name of the share under the share provider.
        :param str storage_location: Storage Location URL (full path) for managed tables within catalog.
        :param str storage_root: Storage root URL for managed tables within catalog.
        :param int updated_at: Time at which this catalog was last modified, in epoch milliseconds.
        :param str updated_by: Username of user who last modified catalog.
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_type is not None:
            pulumi.set(__self__, "catalog_type", catalog_type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if effective_predictive_optimization_flag is not None:
            pulumi.set(__self__, "effective_predictive_optimization_flag", effective_predictive_optimization_flag)
        if enable_predictive_optimization is not None:
            pulumi.set(__self__, "enable_predictive_optimization", enable_predictive_optimization)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if provisioning_info is not None:
            pulumi.set(__self__, "provisioning_info", provisioning_info)
        if securable_kind is not None:
            pulumi.set(__self__, "securable_kind", securable_kind)
        if securable_type is not None:
            pulumi.set(__self__, "securable_type", securable_type)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter(name="catalogType")
    def catalog_type(self) -> Optional[str]:
        """
        Type of the catalog, e.g. `MANAGED_CATALOG`, `DELTASHARING_CATALOG`, `SYSTEM_CATALOG`,
        """
        return pulumi.get(self, "catalog_type")

    @catalog_type.setter
    def catalog_type(self, value: Optional[str]):
        pulumi.set(self, "catalog_type", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Free-form text description
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the connection to an external data source.
        """
        return pulumi.get(self, "connection_name")

    @connection_name.setter
    def connection_name(self, value: Optional[str]):
        pulumi.set(self, "connection_name", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        Username of catalog creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="effectivePredictiveOptimizationFlag")
    def effective_predictive_optimization_flag(self) -> Optional['GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs']:
        """
        object describing applied predictive optimization flag.
        """
        return pulumi.get(self, "effective_predictive_optimization_flag")

    @effective_predictive_optimization_flag.setter
    def effective_predictive_optimization_flag(self, value: Optional['GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs']):
        pulumi.set(self, "effective_predictive_optimization_flag", value)

    @property
    @pulumi.getter(name="enablePredictiveOptimization")
    def enable_predictive_optimization(self) -> Optional[str]:
        """
        Whether predictive optimization should be enabled for this object and objects under it.
        """
        return pulumi.get(self, "enable_predictive_optimization")

    @enable_predictive_optimization.setter
    def enable_predictive_optimization(self, value: Optional[str]):
        pulumi.set(self, "enable_predictive_optimization", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        The full name of the catalog. Corresponds with the name field.
        """
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[str]:
        """
        Whether the current securable is accessible from all workspaces or a  specific set of workspaces.
        """
        return pulumi.get(self, "isolation_mode")

    @isolation_mode.setter
    def isolation_mode(self, value: Optional[str]):
        pulumi.set(self, "isolation_mode", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        Unique identifier of parent metastore.
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name of the catalog
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value properties attached to the securable.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Current owner of the catalog
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        A map of key-value properties attached to the securable.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        The name of delta sharing provider.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: Optional[str]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter(name="provisioningInfo")
    def provisioning_info(self) -> Optional['GetCatalogCatalogInfoProvisioningInfoArgs']:
        return pulumi.get(self, "provisioning_info")

    @provisioning_info.setter
    def provisioning_info(self, value: Optional['GetCatalogCatalogInfoProvisioningInfoArgs']):
        pulumi.set(self, "provisioning_info", value)

    @property
    @pulumi.getter(name="securableKind")
    def securable_kind(self) -> Optional[str]:
        """
        Kind of catalog securable.
        """
        return pulumi.get(self, "securable_kind")

    @securable_kind.setter
    def securable_kind(self, value: Optional[str]):
        pulumi.set(self, "securable_kind", value)

    @property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> Optional[str]:
        """
        Securable type.
        """
        return pulumi.get(self, "securable_type")

    @securable_type.setter
    def securable_type(self, value: Optional[str]):
        pulumi.set(self, "securable_type", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[str]:
        """
        The name of the share under the share provider.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[str]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        """
        Storage Location URL (full path) for managed tables within catalog.
        """
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[str]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[str]:
        """
        Storage root URL for managed tables within catalog.
        """
        return pulumi.get(self, "storage_root")

    @storage_root.setter
    def storage_root(self, value: Optional[str]):
        pulumi.set(self, "storage_root", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        Username of user who last modified catalog.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgsDict(TypedDict):
        value: str
        inherited_from_name: NotRequired[str]
        inherited_from_type: NotRequired[str]
elif False:
    GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs:
    def __init__(__self__, *,
                 value: str,
                 inherited_from_name: Optional[str] = None,
                 inherited_from_type: Optional[str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[str]:
        return pulumi.get(self, "inherited_from_name")

    @inherited_from_name.setter
    def inherited_from_name(self, value: Optional[str]):
        pulumi.set(self, "inherited_from_name", value)

    @property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[str]:
        return pulumi.get(self, "inherited_from_type")

    @inherited_from_type.setter
    def inherited_from_type(self, value: Optional[str]):
        pulumi.set(self, "inherited_from_type", value)


if not MYPY:
    class GetCatalogCatalogInfoProvisioningInfoArgsDict(TypedDict):
        state: NotRequired[str]
elif False:
    GetCatalogCatalogInfoProvisioningInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogCatalogInfoProvisioningInfoArgs:
    def __init__(__self__, *,
                 state: Optional[str] = None):
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[str]):
        pulumi.set(self, "state", value)


if not MYPY:
    class GetClusterClusterInfoArgsDict(TypedDict):
        autoscale: NotRequired['GetClusterClusterInfoAutoscaleArgsDict']
        autotermination_minutes: NotRequired[int]
        """
        Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        """
        aws_attributes: NotRequired['GetClusterClusterInfoAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetClusterClusterInfoAzureAttributesArgsDict']
        cluster_cores: NotRequired[float]
        cluster_id: NotRequired[str]
        """
        The id of the cluster
        """
        cluster_log_conf: NotRequired['GetClusterClusterInfoClusterLogConfArgsDict']
        cluster_log_status: NotRequired['GetClusterClusterInfoClusterLogStatusArgsDict']
        cluster_memory_mb: NotRequired[int]
        cluster_name: NotRequired[str]
        """
        The exact name of the cluster to search
        """
        cluster_source: NotRequired[str]
        creator_user_name: NotRequired[str]
        custom_tags: NotRequired[Mapping[str, str]]
        """
        Additional tags for cluster resources.
        """
        data_security_mode: NotRequired[str]
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        default_tags: NotRequired[Mapping[str, str]]
        docker_image: NotRequired['GetClusterClusterInfoDockerImageArgsDict']
        driver: NotRequired['GetClusterClusterInfoDriverArgsDict']
        driver_instance_pool_id: NotRequired[str]
        """
        similar to `instance_pool_id`, but for driver node.
        """
        driver_node_type_id: NotRequired[str]
        """
        The node type of the Spark driver.
        """
        enable_elastic_disk: NotRequired[bool]
        """
        Use autoscaling local storage.
        """
        enable_local_disk_encryption: NotRequired[bool]
        """
        Enable local disk encryption.
        """
        executors: NotRequired[Sequence['GetClusterClusterInfoExecutorArgsDict']]
        gcp_attributes: NotRequired['GetClusterClusterInfoGcpAttributesArgsDict']
        init_scripts: NotRequired[Sequence['GetClusterClusterInfoInitScriptArgsDict']]
        instance_pool_id: NotRequired[str]
        """
        The pool of idle instances the cluster is attached to.
        """
        jdbc_port: NotRequired[int]
        last_restarted_time: NotRequired[int]
        last_state_loss_time: NotRequired[int]
        node_type_id: NotRequired[str]
        """
        Any supported get_node_type id.
        """
        num_workers: NotRequired[int]
        policy_id: NotRequired[str]
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        runtime_engine: NotRequired[str]
        """
        The type of runtime of the cluster
        """
        single_user_name: NotRequired[str]
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        spark_conf: NotRequired[Mapping[str, str]]
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        spark_context_id: NotRequired[int]
        spark_env_vars: NotRequired[Mapping[str, str]]
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        spark_version: NotRequired[str]
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        spec: NotRequired['GetClusterClusterInfoSpecArgsDict']
        ssh_public_keys: NotRequired[Sequence[str]]
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        start_time: NotRequired[int]
        state: NotRequired[str]
        state_message: NotRequired[str]
        terminated_time: NotRequired[int]
        termination_reason: NotRequired['GetClusterClusterInfoTerminationReasonArgsDict']
        workload_type: NotRequired['GetClusterClusterInfoWorkloadTypeArgsDict']
elif False:
    GetClusterClusterInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoArgs:
    def __init__(__self__, *,
                 autoscale: Optional['GetClusterClusterInfoAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetClusterClusterInfoAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetClusterClusterInfoAzureAttributesArgs'] = None,
                 cluster_cores: Optional[float] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetClusterClusterInfoClusterLogConfArgs'] = None,
                 cluster_log_status: Optional['GetClusterClusterInfoClusterLogStatusArgs'] = None,
                 cluster_memory_mb: Optional[int] = None,
                 cluster_name: Optional[str] = None,
                 cluster_source: Optional[str] = None,
                 creator_user_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 data_security_mode: Optional[str] = None,
                 default_tags: Optional[Mapping[str, str]] = None,
                 docker_image: Optional['GetClusterClusterInfoDockerImageArgs'] = None,
                 driver: Optional['GetClusterClusterInfoDriverArgs'] = None,
                 driver_instance_pool_id: Optional[str] = None,
                 driver_node_type_id: Optional[str] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 enable_local_disk_encryption: Optional[bool] = None,
                 executors: Optional[Sequence['GetClusterClusterInfoExecutorArgs']] = None,
                 gcp_attributes: Optional['GetClusterClusterInfoGcpAttributesArgs'] = None,
                 init_scripts: Optional[Sequence['GetClusterClusterInfoInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 jdbc_port: Optional[int] = None,
                 last_restarted_time: Optional[int] = None,
                 last_state_loss_time: Optional[int] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, str]] = None,
                 spark_context_id: Optional[int] = None,
                 spark_env_vars: Optional[Mapping[str, str]] = None,
                 spark_version: Optional[str] = None,
                 spec: Optional['GetClusterClusterInfoSpecArgs'] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 start_time: Optional[int] = None,
                 state: Optional[str] = None,
                 state_message: Optional[str] = None,
                 terminated_time: Optional[int] = None,
                 termination_reason: Optional['GetClusterClusterInfoTerminationReasonArgs'] = None,
                 workload_type: Optional['GetClusterClusterInfoWorkloadTypeArgs'] = None):
        """
        :param int autotermination_minutes: Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        :param str cluster_id: The id of the cluster
        :param str cluster_name: The exact name of the cluster to search
        :param Mapping[str, str] custom_tags: Additional tags for cluster resources.
        :param str data_security_mode: Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        :param str driver_instance_pool_id: similar to `instance_pool_id`, but for driver node.
        :param str driver_node_type_id: The node type of the Spark driver.
        :param bool enable_elastic_disk: Use autoscaling local storage.
        :param bool enable_local_disk_encryption: Enable local disk encryption.
        :param str instance_pool_id: The pool of idle instances the cluster is attached to.
        :param str node_type_id: Any supported get_node_type id.
        :param str policy_id: Identifier of Cluster Policy to validate cluster and preset certain defaults.
        :param str runtime_engine: The type of runtime of the cluster
        :param str single_user_name: The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        :param Mapping[str, str] spark_conf: Map with key-value pairs to fine-tune Spark clusters.
        :param Mapping[str, str] spark_env_vars: Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        :param str spark_version: [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        :param Sequence[str] ssh_public_keys: SSH public key contents that will be added to each Spark node in this cluster.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_cores is not None:
            pulumi.set(__self__, "cluster_cores", cluster_cores)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_log_status is not None:
            pulumi.set(__self__, "cluster_log_status", cluster_log_status)
        if cluster_memory_mb is not None:
            pulumi.set(__self__, "cluster_memory_mb", cluster_memory_mb)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_source is not None:
            pulumi.set(__self__, "cluster_source", cluster_source)
        if creator_user_name is not None:
            pulumi.set(__self__, "creator_user_name", creator_user_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if default_tags is not None:
            pulumi.set(__self__, "default_tags", default_tags)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if executors is not None:
            pulumi.set(__self__, "executors", executors)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if jdbc_port is not None:
            pulumi.set(__self__, "jdbc_port", jdbc_port)
        if last_restarted_time is not None:
            pulumi.set(__self__, "last_restarted_time", last_restarted_time)
        if last_state_loss_time is not None:
            pulumi.set(__self__, "last_state_loss_time", last_state_loss_time)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_context_id is not None:
            pulumi.set(__self__, "spark_context_id", spark_context_id)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)
        if terminated_time is not None:
            pulumi.set(__self__, "terminated_time", terminated_time)
        if termination_reason is not None:
            pulumi.set(__self__, "termination_reason", termination_reason)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetClusterClusterInfoAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetClusterClusterInfoAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        """
        Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        """
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetClusterClusterInfoAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetClusterClusterInfoAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetClusterClusterInfoAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetClusterClusterInfoAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterCores")
    def cluster_cores(self) -> Optional[float]:
        return pulumi.get(self, "cluster_cores")

    @cluster_cores.setter
    def cluster_cores(self, value: Optional[float]):
        pulumi.set(self, "cluster_cores", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The id of the cluster
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetClusterClusterInfoClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetClusterClusterInfoClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterLogStatus")
    def cluster_log_status(self) -> Optional['GetClusterClusterInfoClusterLogStatusArgs']:
        return pulumi.get(self, "cluster_log_status")

    @cluster_log_status.setter
    def cluster_log_status(self, value: Optional['GetClusterClusterInfoClusterLogStatusArgs']):
        pulumi.set(self, "cluster_log_status", value)

    @property
    @pulumi.getter(name="clusterMemoryMb")
    def cluster_memory_mb(self) -> Optional[int]:
        return pulumi.get(self, "cluster_memory_mb")

    @cluster_memory_mb.setter
    def cluster_memory_mb(self, value: Optional[int]):
        pulumi.set(self, "cluster_memory_mb", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The exact name of the cluster to search
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterSource")
    def cluster_source(self) -> Optional[str]:
        return pulumi.get(self, "cluster_source")

    @cluster_source.setter
    def cluster_source(self, value: Optional[str]):
        pulumi.set(self, "cluster_source", value)

    @property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[str]:
        return pulumi.get(self, "creator_user_name")

    @creator_user_name.setter
    def creator_user_name(self, value: Optional[str]):
        pulumi.set(self, "creator_user_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Additional tags for cluster resources.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "default_tags")

    @default_tags.setter
    def default_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "default_tags", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetClusterClusterInfoDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetClusterClusterInfoDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter
    def driver(self) -> Optional['GetClusterClusterInfoDriverArgs']:
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: Optional['GetClusterClusterInfoDriverArgs']):
        pulumi.set(self, "driver", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[str]:
        """
        similar to `instance_pool_id`, but for driver node.
        """
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        """
        The node type of the Spark driver.
        """
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[str]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        """
        Use autoscaling local storage.
        """
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[bool]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[bool]:
        """
        Enable local disk encryption.
        """
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter
    def executors(self) -> Optional[Sequence['GetClusterClusterInfoExecutorArgs']]:
        return pulumi.get(self, "executors")

    @executors.setter
    def executors(self, value: Optional[Sequence['GetClusterClusterInfoExecutorArgs']]):
        pulumi.set(self, "executors", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetClusterClusterInfoGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetClusterClusterInfoGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetClusterClusterInfoInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetClusterClusterInfoInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        """
        The pool of idle instances the cluster is attached to.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="jdbcPort")
    def jdbc_port(self) -> Optional[int]:
        return pulumi.get(self, "jdbc_port")

    @jdbc_port.setter
    def jdbc_port(self, value: Optional[int]):
        pulumi.set(self, "jdbc_port", value)

    @property
    @pulumi.getter(name="lastRestartedTime")
    def last_restarted_time(self) -> Optional[int]:
        return pulumi.get(self, "last_restarted_time")

    @last_restarted_time.setter
    def last_restarted_time(self, value: Optional[int]):
        pulumi.set(self, "last_restarted_time", value)

    @property
    @pulumi.getter(name="lastStateLossTime")
    def last_state_loss_time(self) -> Optional[int]:
        return pulumi.get(self, "last_state_loss_time")

    @last_state_loss_time.setter
    def last_state_loss_time(self, value: Optional[int]):
        pulumi.set(self, "last_state_loss_time", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        """
        Any supported get_node_type id.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[int]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        """
        The type of runtime of the cluster
        """
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, str]]:
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkContextId")
    def spark_context_id(self) -> Optional[int]:
        return pulumi.get(self, "spark_context_id")

    @spark_context_id.setter
    def spark_context_id(self, value: Optional[int]):
        pulumi.set(self, "spark_context_id", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, str]]:
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[str]:
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: Optional[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional['GetClusterClusterInfoSpecArgs']:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional['GetClusterClusterInfoSpecArgs']):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[int]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[str]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[str]:
        return pulumi.get(self, "state_message")

    @state_message.setter
    def state_message(self, value: Optional[str]):
        pulumi.set(self, "state_message", value)

    @property
    @pulumi.getter(name="terminatedTime")
    def terminated_time(self) -> Optional[int]:
        return pulumi.get(self, "terminated_time")

    @terminated_time.setter
    def terminated_time(self, value: Optional[int]):
        pulumi.set(self, "terminated_time", value)

    @property
    @pulumi.getter(name="terminationReason")
    def termination_reason(self) -> Optional['GetClusterClusterInfoTerminationReasonArgs']:
        return pulumi.get(self, "termination_reason")

    @termination_reason.setter
    def termination_reason(self, value: Optional['GetClusterClusterInfoTerminationReasonArgs']):
        pulumi.set(self, "termination_reason", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetClusterClusterInfoWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetClusterClusterInfoWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class GetClusterClusterInfoAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[int]
        min_workers: NotRequired[int]
elif False:
    GetClusterClusterInfoAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class GetClusterClusterInfoAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        ebs_volume_count: NotRequired[int]
        ebs_volume_iops: NotRequired[int]
        ebs_volume_size: NotRequired[int]
        ebs_volume_throughput: NotRequired[int]
        ebs_volume_type: NotRequired[str]
        first_on_demand: NotRequired[int]
        instance_profile_arn: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
        zone_id: NotRequired[str]
elif False:
    GetClusterClusterInfoAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_iops: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_throughput: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetClusterClusterInfoAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        first_on_demand: NotRequired[int]
        log_analytics_info: NotRequired['GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgsDict']
        spot_bid_max_price: NotRequired[float]
elif False:
    GetClusterClusterInfoAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 log_analytics_info: Optional['GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgs'] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgs']:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional['GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgs']):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[str]
        log_analytics_workspace_id: NotRequired[str]
elif False:
    GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[str] = None,
                 log_analytics_workspace_id: Optional[str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[str]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[str]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[str]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class GetClusterClusterInfoClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired['GetClusterClusterInfoClusterLogConfDbfsArgsDict']
        s3: NotRequired['GetClusterClusterInfoClusterLogConfS3ArgsDict']
elif False:
    GetClusterClusterInfoClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetClusterClusterInfoClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetClusterClusterInfoClusterLogConfS3Args'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetClusterClusterInfoClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetClusterClusterInfoClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetClusterClusterInfoClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetClusterClusterInfoClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetClusterClusterInfoClusterLogConfDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoClusterLogConfS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetClusterClusterInfoClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetClusterClusterInfoClusterLogStatusArgsDict(TypedDict):
        last_attempted: NotRequired[int]
        last_exception: NotRequired[str]
elif False:
    GetClusterClusterInfoClusterLogStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoClusterLogStatusArgs:
    def __init__(__self__, *,
                 last_attempted: Optional[int] = None,
                 last_exception: Optional[str] = None):
        if last_attempted is not None:
            pulumi.set(__self__, "last_attempted", last_attempted)
        if last_exception is not None:
            pulumi.set(__self__, "last_exception", last_exception)

    @property
    @pulumi.getter(name="lastAttempted")
    def last_attempted(self) -> Optional[int]:
        return pulumi.get(self, "last_attempted")

    @last_attempted.setter
    def last_attempted(self, value: Optional[int]):
        pulumi.set(self, "last_attempted", value)

    @property
    @pulumi.getter(name="lastException")
    def last_exception(self) -> Optional[str]:
        return pulumi.get(self, "last_exception")

    @last_exception.setter
    def last_exception(self, value: Optional[str]):
        pulumi.set(self, "last_exception", value)


if not MYPY:
    class GetClusterClusterInfoDockerImageArgsDict(TypedDict):
        basic_auth: NotRequired['GetClusterClusterInfoDockerImageBasicAuthArgsDict']
        url: NotRequired[str]
elif False:
    GetClusterClusterInfoDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoDockerImageArgs:
    def __init__(__self__, *,
                 basic_auth: Optional['GetClusterClusterInfoDockerImageBasicAuthArgs'] = None,
                 url: Optional[str] = None):
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetClusterClusterInfoDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetClusterClusterInfoDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetClusterClusterInfoDockerImageBasicAuthArgsDict(TypedDict):
        password: NotRequired[str]
        username: NotRequired[str]
elif False:
    GetClusterClusterInfoDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetClusterClusterInfoDriverArgsDict(TypedDict):
        host_private_ip: NotRequired[str]
        instance_id: NotRequired[str]
        node_aws_attributes: NotRequired['GetClusterClusterInfoDriverNodeAwsAttributesArgsDict']
        node_id: NotRequired[str]
        private_ip: NotRequired[str]
        public_dns: NotRequired[str]
        start_timestamp: NotRequired[int]
elif False:
    GetClusterClusterInfoDriverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoDriverArgs:
    def __init__(__self__, *,
                 host_private_ip: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 node_aws_attributes: Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs'] = None,
                 node_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_dns: Optional[str] = None,
                 start_timestamp: Optional[int] = None):
        if host_private_ip is not None:
            pulumi.set(__self__, "host_private_ip", host_private_ip)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if node_aws_attributes is not None:
            pulumi.set(__self__, "node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_dns is not None:
            pulumi.set(__self__, "public_dns", public_dns)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[str]:
        return pulumi.get(self, "host_private_ip")

    @host_private_ip.setter
    def host_private_ip(self, value: Optional[str]):
        pulumi.set(self, "host_private_ip", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs']:
        return pulumi.get(self, "node_aws_attributes")

    @node_aws_attributes.setter
    def node_aws_attributes(self, value: Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs']):
        pulumi.set(self, "node_aws_attributes", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[str]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[str]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[str]:
        return pulumi.get(self, "public_dns")

    @public_dns.setter
    def public_dns(self, value: Optional[str]):
        pulumi.set(self, "public_dns", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[int]):
        pulumi.set(self, "start_timestamp", value)


if not MYPY:
    class GetClusterClusterInfoDriverNodeAwsAttributesArgsDict(TypedDict):
        is_spot: NotRequired[bool]
elif False:
    GetClusterClusterInfoDriverNodeAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoDriverNodeAwsAttributesArgs:
    def __init__(__self__, *,
                 is_spot: Optional[bool] = None):
        if is_spot is not None:
            pulumi.set(__self__, "is_spot", is_spot)

    @property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[bool]:
        return pulumi.get(self, "is_spot")

    @is_spot.setter
    def is_spot(self, value: Optional[bool]):
        pulumi.set(self, "is_spot", value)


if not MYPY:
    class GetClusterClusterInfoExecutorArgsDict(TypedDict):
        host_private_ip: NotRequired[str]
        instance_id: NotRequired[str]
        node_aws_attributes: NotRequired['GetClusterClusterInfoExecutorNodeAwsAttributesArgsDict']
        node_id: NotRequired[str]
        private_ip: NotRequired[str]
        public_dns: NotRequired[str]
        start_timestamp: NotRequired[int]
elif False:
    GetClusterClusterInfoExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoExecutorArgs:
    def __init__(__self__, *,
                 host_private_ip: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 node_aws_attributes: Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs'] = None,
                 node_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_dns: Optional[str] = None,
                 start_timestamp: Optional[int] = None):
        if host_private_ip is not None:
            pulumi.set(__self__, "host_private_ip", host_private_ip)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if node_aws_attributes is not None:
            pulumi.set(__self__, "node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_dns is not None:
            pulumi.set(__self__, "public_dns", public_dns)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[str]:
        return pulumi.get(self, "host_private_ip")

    @host_private_ip.setter
    def host_private_ip(self, value: Optional[str]):
        pulumi.set(self, "host_private_ip", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs']:
        return pulumi.get(self, "node_aws_attributes")

    @node_aws_attributes.setter
    def node_aws_attributes(self, value: Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs']):
        pulumi.set(self, "node_aws_attributes", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[str]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[str]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[str]:
        return pulumi.get(self, "public_dns")

    @public_dns.setter
    def public_dns(self, value: Optional[str]):
        pulumi.set(self, "public_dns", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[int]):
        pulumi.set(self, "start_timestamp", value)


if not MYPY:
    class GetClusterClusterInfoExecutorNodeAwsAttributesArgsDict(TypedDict):
        is_spot: NotRequired[bool]
elif False:
    GetClusterClusterInfoExecutorNodeAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoExecutorNodeAwsAttributesArgs:
    def __init__(__self__, *,
                 is_spot: Optional[bool] = None):
        if is_spot is not None:
            pulumi.set(__self__, "is_spot", is_spot)

    @property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[bool]:
        return pulumi.get(self, "is_spot")

    @is_spot.setter
    def is_spot(self, value: Optional[bool]):
        pulumi.set(self, "is_spot", value)


if not MYPY:
    class GetClusterClusterInfoGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        boot_disk_size: NotRequired[int]
        google_service_account: NotRequired[str]
        local_ssd_count: NotRequired[int]
        use_preemptible_executors: NotRequired[bool]
        zone_id: NotRequired[str]
elif False:
    GetClusterClusterInfoGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptArgsDict(TypedDict):
        abfss: NotRequired['GetClusterClusterInfoInitScriptAbfssArgsDict']
        dbfs: NotRequired['GetClusterClusterInfoInitScriptDbfsArgsDict']
        file: NotRequired['GetClusterClusterInfoInitScriptFileArgsDict']
        gcs: NotRequired['GetClusterClusterInfoInitScriptGcsArgsDict']
        s3: NotRequired['GetClusterClusterInfoInitScriptS3ArgsDict']
        volumes: NotRequired['GetClusterClusterInfoInitScriptVolumesArgsDict']
        workspace: NotRequired['GetClusterClusterInfoInitScriptWorkspaceArgsDict']
elif False:
    GetClusterClusterInfoInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetClusterClusterInfoInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetClusterClusterInfoInitScriptDbfsArgs'] = None,
                 file: Optional['GetClusterClusterInfoInitScriptFileArgs'] = None,
                 gcs: Optional['GetClusterClusterInfoInitScriptGcsArgs'] = None,
                 s3: Optional['GetClusterClusterInfoInitScriptS3Args'] = None,
                 volumes: Optional['GetClusterClusterInfoInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetClusterClusterInfoInitScriptWorkspaceArgs'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetClusterClusterInfoInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetClusterClusterInfoInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetClusterClusterInfoInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetClusterClusterInfoInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetClusterClusterInfoInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetClusterClusterInfoInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetClusterClusterInfoInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetClusterClusterInfoInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetClusterClusterInfoInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetClusterClusterInfoInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetClusterClusterInfoInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetClusterClusterInfoInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetClusterClusterInfoInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetClusterClusterInfoInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptAbfssArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptFileArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptGcsArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetClusterClusterInfoInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptVolumesArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoInitScriptWorkspaceArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecArgsDict(TypedDict):
        cluster_id: str
        """
        The id of the cluster
        """
        driver_instance_pool_id: str
        """
        similar to `instance_pool_id`, but for driver node.
        """
        driver_node_type_id: str
        """
        The node type of the Spark driver.
        """
        enable_elastic_disk: bool
        """
        Use autoscaling local storage.
        """
        enable_local_disk_encryption: bool
        """
        Enable local disk encryption.
        """
        node_type_id: str
        """
        Any supported get_node_type id.
        """
        spark_version: str
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        apply_policy_default_values: NotRequired[bool]
        autoscale: NotRequired['GetClusterClusterInfoSpecAutoscaleArgsDict']
        aws_attributes: NotRequired['GetClusterClusterInfoSpecAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetClusterClusterInfoSpecAzureAttributesArgsDict']
        cluster_log_conf: NotRequired['GetClusterClusterInfoSpecClusterLogConfArgsDict']
        cluster_mount_infos: NotRequired[Sequence['GetClusterClusterInfoSpecClusterMountInfoArgsDict']]
        cluster_name: NotRequired[str]
        """
        The exact name of the cluster to search
        """
        custom_tags: NotRequired[Mapping[str, str]]
        """
        Additional tags for cluster resources.
        """
        data_security_mode: NotRequired[str]
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        docker_image: NotRequired['GetClusterClusterInfoSpecDockerImageArgsDict']
        gcp_attributes: NotRequired['GetClusterClusterInfoSpecGcpAttributesArgsDict']
        idempotency_token: NotRequired[str]
        """
        An optional token to guarantee the idempotency of cluster creation requests.
        """
        init_scripts: NotRequired[Sequence['GetClusterClusterInfoSpecInitScriptArgsDict']]
        instance_pool_id: NotRequired[str]
        """
        The pool of idle instances the cluster is attached to.
        """
        libraries: NotRequired[Sequence['GetClusterClusterInfoSpecLibraryArgsDict']]
        num_workers: NotRequired[int]
        policy_id: NotRequired[str]
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        runtime_engine: NotRequired[str]
        """
        The type of runtime of the cluster
        """
        single_user_name: NotRequired[str]
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        spark_conf: NotRequired[Mapping[str, str]]
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        spark_env_vars: NotRequired[Mapping[str, str]]
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        ssh_public_keys: NotRequired[Sequence[str]]
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        workload_type: NotRequired['GetClusterClusterInfoSpecWorkloadTypeArgsDict']
elif False:
    GetClusterClusterInfoSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecArgs:
    def __init__(__self__, *,
                 cluster_id: str,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetClusterClusterInfoSpecAutoscaleArgs'] = None,
                 aws_attributes: Optional['GetClusterClusterInfoSpecAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetClusterClusterInfoSpecAzureAttributesArgs'] = None,
                 cluster_log_conf: Optional['GetClusterClusterInfoSpecClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetClusterClusterInfoSpecClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetClusterClusterInfoSpecDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetClusterClusterInfoSpecGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetClusterClusterInfoSpecInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 libraries: Optional[Sequence['GetClusterClusterInfoSpecLibraryArgs']] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, str]] = None,
                 spark_env_vars: Optional[Mapping[str, str]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetClusterClusterInfoSpecWorkloadTypeArgs'] = None):
        """
        :param str cluster_id: The id of the cluster
        :param str driver_instance_pool_id: similar to `instance_pool_id`, but for driver node.
        :param str driver_node_type_id: The node type of the Spark driver.
        :param bool enable_elastic_disk: Use autoscaling local storage.
        :param bool enable_local_disk_encryption: Enable local disk encryption.
        :param str node_type_id: Any supported get_node_type id.
        :param str spark_version: [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        :param str cluster_name: The exact name of the cluster to search
        :param Mapping[str, str] custom_tags: Additional tags for cluster resources.
        :param str data_security_mode: Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        :param str idempotency_token: An optional token to guarantee the idempotency of cluster creation requests.
        :param str instance_pool_id: The pool of idle instances the cluster is attached to.
        :param str policy_id: Identifier of Cluster Policy to validate cluster and preset certain defaults.
        :param str runtime_engine: The type of runtime of the cluster
        :param str single_user_name: The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        :param Mapping[str, str] spark_conf: Map with key-value pairs to fine-tune Spark clusters.
        :param Mapping[str, str] spark_env_vars: Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        :param Sequence[str] ssh_public_keys: SSH public key contents that will be added to each Spark node in this cluster.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        """
        The id of the cluster
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: str):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        """
        similar to `instance_pool_id`, but for driver node.
        """
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        """
        The node type of the Spark driver.
        """
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        """
        Use autoscaling local storage.
        """
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        """
        Enable local disk encryption.
        """
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        """
        Any supported get_node_type id.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetClusterClusterInfoSpecAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetClusterClusterInfoSpecAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetClusterClusterInfoSpecAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetClusterClusterInfoSpecAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetClusterClusterInfoSpecAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetClusterClusterInfoSpecAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetClusterClusterInfoSpecClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetClusterClusterInfoSpecClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetClusterClusterInfoSpecClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetClusterClusterInfoSpecClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The exact name of the cluster to search
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        """
        Additional tags for cluster resources.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetClusterClusterInfoSpecDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetClusterClusterInfoSpecDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetClusterClusterInfoSpecGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetClusterClusterInfoSpecGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        """
        An optional token to guarantee the idempotency of cluster creation requests.
        """
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetClusterClusterInfoSpecInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetClusterClusterInfoSpecInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        """
        The pool of idle instances the cluster is attached to.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['GetClusterClusterInfoSpecLibraryArgs']]:
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[Sequence['GetClusterClusterInfoSpecLibraryArgs']]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[int]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        """
        The type of runtime of the cluster
        """
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, str]]:
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, str]]:
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetClusterClusterInfoSpecWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetClusterClusterInfoSpecWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class GetClusterClusterInfoSpecAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[int]
        min_workers: NotRequired[int]
elif False:
    GetClusterClusterInfoSpecAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class GetClusterClusterInfoSpecAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        ebs_volume_count: NotRequired[int]
        ebs_volume_iops: NotRequired[int]
        ebs_volume_size: NotRequired[int]
        ebs_volume_throughput: NotRequired[int]
        ebs_volume_type: NotRequired[str]
        first_on_demand: NotRequired[int]
        instance_profile_arn: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
        zone_id: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_iops: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_throughput: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_iops")

    @ebs_volume_iops.setter
    def ebs_volume_iops(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @ebs_volume_throughput.setter
    def ebs_volume_throughput(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_throughput", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetClusterClusterInfoSpecAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        first_on_demand: NotRequired[int]
        log_analytics_info: NotRequired['GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgsDict']
        spot_bid_max_price: NotRequired[float]
elif False:
    GetClusterClusterInfoSpecAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 log_analytics_info: Optional['GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgs'] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgs']:
        return pulumi.get(self, "log_analytics_info")

    @log_analytics_info.setter
    def log_analytics_info(self, value: Optional['GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgs']):
        pulumi.set(self, "log_analytics_info", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgsDict(TypedDict):
        log_analytics_primary_key: NotRequired[str]
        log_analytics_workspace_id: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoArgs:
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[str] = None,
                 log_analytics_workspace_id: Optional[str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @log_analytics_primary_key.setter
    def log_analytics_primary_key(self, value: Optional[str]):
        pulumi.set(self, "log_analytics_primary_key", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[str]:
        return pulumi.get(self, "log_analytics_workspace_id")

    @log_analytics_workspace_id.setter
    def log_analytics_workspace_id(self, value: Optional[str]):
        pulumi.set(self, "log_analytics_workspace_id", value)


if not MYPY:
    class GetClusterClusterInfoSpecClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired['GetClusterClusterInfoSpecClusterLogConfDbfsArgsDict']
        s3: NotRequired['GetClusterClusterInfoSpecClusterLogConfS3ArgsDict']
elif False:
    GetClusterClusterInfoSpecClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetClusterClusterInfoSpecClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetClusterClusterInfoSpecClusterLogConfS3Args'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetClusterClusterInfoSpecClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetClusterClusterInfoSpecClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetClusterClusterInfoSpecClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetClusterClusterInfoSpecClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetClusterClusterInfoSpecClusterLogConfDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecClusterLogConfS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetClusterClusterInfoSpecClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: str
        network_filesystem_info: 'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgsDict'
        remote_mount_dir_path: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: str
        mount_options: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class GetClusterClusterInfoSpecDockerImageArgsDict(TypedDict):
        url: str
        basic_auth: NotRequired['GetClusterClusterInfoSpecDockerImageBasicAuthArgsDict']
elif False:
    GetClusterClusterInfoSpecDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetClusterClusterInfoSpecDockerImageBasicAuthArgs'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetClusterClusterInfoSpecDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetClusterClusterInfoSpecDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class GetClusterClusterInfoSpecDockerImageBasicAuthArgsDict(TypedDict):
        password: str
        username: str
elif False:
    GetClusterClusterInfoSpecDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetClusterClusterInfoSpecGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        boot_disk_size: NotRequired[int]
        google_service_account: NotRequired[str]
        local_ssd_count: NotRequired[int]
        use_preemptible_executors: NotRequired[bool]
        zone_id: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptArgsDict(TypedDict):
        abfss: NotRequired['GetClusterClusterInfoSpecInitScriptAbfssArgsDict']
        dbfs: NotRequired['GetClusterClusterInfoSpecInitScriptDbfsArgsDict']
        file: NotRequired['GetClusterClusterInfoSpecInitScriptFileArgsDict']
        gcs: NotRequired['GetClusterClusterInfoSpecInitScriptGcsArgsDict']
        s3: NotRequired['GetClusterClusterInfoSpecInitScriptS3ArgsDict']
        volumes: NotRequired['GetClusterClusterInfoSpecInitScriptVolumesArgsDict']
        workspace: NotRequired['GetClusterClusterInfoSpecInitScriptWorkspaceArgsDict']
elif False:
    GetClusterClusterInfoSpecInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetClusterClusterInfoSpecInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetClusterClusterInfoSpecInitScriptDbfsArgs'] = None,
                 file: Optional['GetClusterClusterInfoSpecInitScriptFileArgs'] = None,
                 gcs: Optional['GetClusterClusterInfoSpecInitScriptGcsArgs'] = None,
                 s3: Optional['GetClusterClusterInfoSpecInitScriptS3Args'] = None,
                 volumes: Optional['GetClusterClusterInfoSpecInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetClusterClusterInfoSpecInitScriptWorkspaceArgs'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetClusterClusterInfoSpecInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetClusterClusterInfoSpecInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['GetClusterClusterInfoSpecInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetClusterClusterInfoSpecInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetClusterClusterInfoSpecInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetClusterClusterInfoSpecInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetClusterClusterInfoSpecInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetClusterClusterInfoSpecInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetClusterClusterInfoSpecInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetClusterClusterInfoSpecInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetClusterClusterInfoSpecInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetClusterClusterInfoSpecInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetClusterClusterInfoSpecInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetClusterClusterInfoSpecInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptAbfssArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptFileArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptGcsArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptVolumesArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecInitScriptWorkspaceArgsDict(TypedDict):
        destination: str
elif False:
    GetClusterClusterInfoSpecInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetClusterClusterInfoSpecLibraryArgsDict(TypedDict):
        cran: NotRequired['GetClusterClusterInfoSpecLibraryCranArgsDict']
        egg: NotRequired[str]
        jar: NotRequired[str]
        maven: NotRequired['GetClusterClusterInfoSpecLibraryMavenArgsDict']
        pypi: NotRequired['GetClusterClusterInfoSpecLibraryPypiArgsDict']
        requirements: NotRequired[str]
        whl: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional['GetClusterClusterInfoSpecLibraryCranArgs'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['GetClusterClusterInfoSpecLibraryMavenArgs'] = None,
                 pypi: Optional['GetClusterClusterInfoSpecLibraryPypiArgs'] = None,
                 requirements: Optional[str] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['GetClusterClusterInfoSpecLibraryCranArgs']:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional['GetClusterClusterInfoSpecLibraryCranArgs']):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[str]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[str]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional['GetClusterClusterInfoSpecLibraryMavenArgs']:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional['GetClusterClusterInfoSpecLibraryMavenArgs']):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional['GetClusterClusterInfoSpecLibraryPypiArgs']:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional['GetClusterClusterInfoSpecLibraryPypiArgs']):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[str]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[str]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[str]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class GetClusterClusterInfoSpecLibraryCranArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecLibraryCranArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetClusterClusterInfoSpecLibraryMavenArgsDict(TypedDict):
        coordinates: str
        exclusions: NotRequired[Sequence[str]]
        repo: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: str):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetClusterClusterInfoSpecLibraryPypiArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetClusterClusterInfoSpecLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecLibraryPypiArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetClusterClusterInfoSpecWorkloadTypeArgsDict(TypedDict):
        clients: 'GetClusterClusterInfoSpecWorkloadTypeClientsArgsDict'
elif False:
    GetClusterClusterInfoSpecWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetClusterClusterInfoSpecWorkloadTypeClientsArgs'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetClusterClusterInfoSpecWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetClusterClusterInfoSpecWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


if not MYPY:
    class GetClusterClusterInfoSpecWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[bool]
        notebooks: NotRequired[bool]
elif False:
    GetClusterClusterInfoSpecWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoSpecWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class GetClusterClusterInfoTerminationReasonArgsDict(TypedDict):
        code: NotRequired[str]
        parameters: NotRequired[Mapping[str, str]]
        type: NotRequired[str]
elif False:
    GetClusterClusterInfoTerminationReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoTerminationReasonArgs:
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[str]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetClusterClusterInfoWorkloadTypeArgsDict(TypedDict):
        clients: 'GetClusterClusterInfoWorkloadTypeClientsArgsDict'
elif False:
    GetClusterClusterInfoWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetClusterClusterInfoWorkloadTypeClientsArgs'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetClusterClusterInfoWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetClusterClusterInfoWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


if not MYPY:
    class GetClusterClusterInfoWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[bool]
        notebooks: NotRequired[bool]
elif False:
    GetClusterClusterInfoWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterClusterInfoWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class GetClustersFilterByArgsDict(TypedDict):
        cluster_sources: NotRequired[Sequence[str]]
        """
        List of cluster sources to filter by. Possible values are `API`, `JOB`, `MODELS`, `PIPELINE`, `PIPELINE_MAINTENANCE`, `SQL`, and `UI`.
        """
        cluster_states: NotRequired[Sequence[str]]
        """
        List of cluster states to filter by. Possible values are `RUNNING`, `PENDING`, `RESIZING`, `RESTARTING`, `TERMINATING`, `TERMINATED`, `ERROR`, and `UNKNOWN`.
        """
        is_pinned: NotRequired[bool]
        """
        Whether to filter by pinned clusters.
        """
        policy_id: NotRequired[str]
        """
        Filter by ClusterPolicy id.
        """
elif False:
    GetClustersFilterByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClustersFilterByArgs:
    def __init__(__self__, *,
                 cluster_sources: Optional[Sequence[str]] = None,
                 cluster_states: Optional[Sequence[str]] = None,
                 is_pinned: Optional[bool] = None,
                 policy_id: Optional[str] = None):
        """
        :param Sequence[str] cluster_sources: List of cluster sources to filter by. Possible values are `API`, `JOB`, `MODELS`, `PIPELINE`, `PIPELINE_MAINTENANCE`, `SQL`, and `UI`.
        :param Sequence[str] cluster_states: List of cluster states to filter by. Possible values are `RUNNING`, `PENDING`, `RESIZING`, `RESTARTING`, `TERMINATING`, `TERMINATED`, `ERROR`, and `UNKNOWN`.
        :param bool is_pinned: Whether to filter by pinned clusters.
        :param str policy_id: Filter by ClusterPolicy id.
        """
        if cluster_sources is not None:
            pulumi.set(__self__, "cluster_sources", cluster_sources)
        if cluster_states is not None:
            pulumi.set(__self__, "cluster_states", cluster_states)
        if is_pinned is not None:
            pulumi.set(__self__, "is_pinned", is_pinned)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)

    @property
    @pulumi.getter(name="clusterSources")
    def cluster_sources(self) -> Optional[Sequence[str]]:
        """
        List of cluster sources to filter by. Possible values are `API`, `JOB`, `MODELS`, `PIPELINE`, `PIPELINE_MAINTENANCE`, `SQL`, and `UI`.
        """
        return pulumi.get(self, "cluster_sources")

    @cluster_sources.setter
    def cluster_sources(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "cluster_sources", value)

    @property
    @pulumi.getter(name="clusterStates")
    def cluster_states(self) -> Optional[Sequence[str]]:
        """
        List of cluster states to filter by. Possible values are `RUNNING`, `PENDING`, `RESIZING`, `RESTARTING`, `TERMINATING`, `TERMINATED`, `ERROR`, and `UNKNOWN`.
        """
        return pulumi.get(self, "cluster_states")

    @cluster_states.setter
    def cluster_states(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "cluster_states", value)

    @property
    @pulumi.getter(name="isPinned")
    def is_pinned(self) -> Optional[bool]:
        """
        Whether to filter by pinned clusters.
        """
        return pulumi.get(self, "is_pinned")

    @is_pinned.setter
    def is_pinned(self, value: Optional[bool]):
        pulumi.set(self, "is_pinned", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        """
        Filter by ClusterPolicy id.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)


if not MYPY:
    class GetCurrentMetastoreMetastoreInfoArgsDict(TypedDict):
        cloud: NotRequired[str]
        created_at: NotRequired[int]
        """
        Timestamp (in milliseconds) when the current metastore was created.
        """
        created_by: NotRequired[str]
        """
        the ID of the identity that created the current metastore.
        """
        default_data_access_config_id: NotRequired[str]
        """
        the ID of the default data access configuration.
        """
        delta_sharing_organization_name: NotRequired[str]
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        delta_sharing_recipient_token_lifetime_in_seconds: NotRequired[int]
        """
        the expiration duration in seconds on recipient data access tokens.
        """
        delta_sharing_scope: NotRequired[str]
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        """
        external_access_enabled: NotRequired[bool]
        global_metastore_id: NotRequired[str]
        """
        Identifier in form of `<cloud>:<region>:<metastore_id>` for use in Databricks to Databricks Delta Sharing.
        """
        metastore_id: NotRequired[str]
        """
        Metastore ID.
        """
        name: NotRequired[str]
        """
        Name of metastore.
        """
        owner: NotRequired[str]
        """
        Username/group name/sp application_id of the metastore owner.
        """
        privilege_model_version: NotRequired[str]
        """
        the version of the privilege model used by the metastore.
        """
        region: NotRequired[str]
        """
        (Mandatory for account-level) The region of the metastore.
        """
        storage_root: NotRequired[str]
        """
        Path on cloud storage account, where managed `Table` are stored.
        """
        storage_root_credential_id: NotRequired[str]
        """
        ID of a storage credential used for the `storage_root`.
        """
        storage_root_credential_name: NotRequired[str]
        """
        Name of a storage credential used for the `storage_root`.
        """
        updated_at: NotRequired[int]
        """
        Timestamp (in milliseconds) when the current metastore was updated.
        """
        updated_by: NotRequired[str]
        """
        the ID of the identity that updated the current metastore.
        """
elif False:
    GetCurrentMetastoreMetastoreInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCurrentMetastoreMetastoreInfoArgs:
    def __init__(__self__, *,
                 cloud: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 default_data_access_config_id: Optional[str] = None,
                 delta_sharing_organization_name: Optional[str] = None,
                 delta_sharing_recipient_token_lifetime_in_seconds: Optional[int] = None,
                 delta_sharing_scope: Optional[str] = None,
                 external_access_enabled: Optional[bool] = None,
                 global_metastore_id: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 privilege_model_version: Optional[str] = None,
                 region: Optional[str] = None,
                 storage_root: Optional[str] = None,
                 storage_root_credential_id: Optional[str] = None,
                 storage_root_credential_name: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param int created_at: Timestamp (in milliseconds) when the current metastore was created.
        :param str created_by: the ID of the identity that created the current metastore.
        :param str default_data_access_config_id: the ID of the default data access configuration.
        :param str delta_sharing_organization_name: The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        :param int delta_sharing_recipient_token_lifetime_in_seconds: the expiration duration in seconds on recipient data access tokens.
        :param str delta_sharing_scope: Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        :param str global_metastore_id: Identifier in form of `<cloud>:<region>:<metastore_id>` for use in Databricks to Databricks Delta Sharing.
        :param str metastore_id: Metastore ID.
        :param str name: Name of metastore.
        :param str owner: Username/group name/sp application_id of the metastore owner.
        :param str privilege_model_version: the version of the privilege model used by the metastore.
        :param str region: (Mandatory for account-level) The region of the metastore.
        :param str storage_root: Path on cloud storage account, where managed `Table` are stored.
        :param str storage_root_credential_id: ID of a storage credential used for the `storage_root`.
        :param str storage_root_credential_name: Name of a storage credential used for the `storage_root`.
        :param int updated_at: Timestamp (in milliseconds) when the current metastore was updated.
        :param str updated_by: the ID of the identity that updated the current metastore.
        """
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if default_data_access_config_id is not None:
            pulumi.set(__self__, "default_data_access_config_id", default_data_access_config_id)
        if delta_sharing_organization_name is not None:
            pulumi.set(__self__, "delta_sharing_organization_name", delta_sharing_organization_name)
        if delta_sharing_recipient_token_lifetime_in_seconds is not None:
            pulumi.set(__self__, "delta_sharing_recipient_token_lifetime_in_seconds", delta_sharing_recipient_token_lifetime_in_seconds)
        if delta_sharing_scope is not None:
            pulumi.set(__self__, "delta_sharing_scope", delta_sharing_scope)
        if external_access_enabled is not None:
            pulumi.set(__self__, "external_access_enabled", external_access_enabled)
        if global_metastore_id is not None:
            pulumi.set(__self__, "global_metastore_id", global_metastore_id)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if privilege_model_version is not None:
            pulumi.set(__self__, "privilege_model_version", privilege_model_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if storage_root_credential_id is not None:
            pulumi.set(__self__, "storage_root_credential_id", storage_root_credential_id)
        if storage_root_credential_name is not None:
            pulumi.set(__self__, "storage_root_credential_name", storage_root_credential_name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter
    def cloud(self) -> Optional[str]:
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[str]):
        pulumi.set(self, "cloud", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        Timestamp (in milliseconds) when the current metastore was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        the ID of the identity that created the current metastore.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="defaultDataAccessConfigId")
    def default_data_access_config_id(self) -> Optional[str]:
        """
        the ID of the default data access configuration.
        """
        return pulumi.get(self, "default_data_access_config_id")

    @default_data_access_config_id.setter
    def default_data_access_config_id(self, value: Optional[str]):
        pulumi.set(self, "default_data_access_config_id", value)

    @property
    @pulumi.getter(name="deltaSharingOrganizationName")
    def delta_sharing_organization_name(self) -> Optional[str]:
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        return pulumi.get(self, "delta_sharing_organization_name")

    @delta_sharing_organization_name.setter
    def delta_sharing_organization_name(self, value: Optional[str]):
        pulumi.set(self, "delta_sharing_organization_name", value)

    @property
    @pulumi.getter(name="deltaSharingRecipientTokenLifetimeInSeconds")
    def delta_sharing_recipient_token_lifetime_in_seconds(self) -> Optional[int]:
        """
        the expiration duration in seconds on recipient data access tokens.
        """
        return pulumi.get(self, "delta_sharing_recipient_token_lifetime_in_seconds")

    @delta_sharing_recipient_token_lifetime_in_seconds.setter
    def delta_sharing_recipient_token_lifetime_in_seconds(self, value: Optional[int]):
        pulumi.set(self, "delta_sharing_recipient_token_lifetime_in_seconds", value)

    @property
    @pulumi.getter(name="deltaSharingScope")
    def delta_sharing_scope(self) -> Optional[str]:
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        """
        return pulumi.get(self, "delta_sharing_scope")

    @delta_sharing_scope.setter
    def delta_sharing_scope(self, value: Optional[str]):
        pulumi.set(self, "delta_sharing_scope", value)

    @property
    @pulumi.getter(name="externalAccessEnabled")
    def external_access_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "external_access_enabled")

    @external_access_enabled.setter
    def external_access_enabled(self, value: Optional[bool]):
        pulumi.set(self, "external_access_enabled", value)

    @property
    @pulumi.getter(name="globalMetastoreId")
    def global_metastore_id(self) -> Optional[str]:
        """
        Identifier in form of `<cloud>:<region>:<metastore_id>` for use in Databricks to Databricks Delta Sharing.
        """
        return pulumi.get(self, "global_metastore_id")

    @global_metastore_id.setter
    def global_metastore_id(self, value: Optional[str]):
        pulumi.set(self, "global_metastore_id", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        Metastore ID.
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of metastore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Username/group name/sp application_id of the metastore owner.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="privilegeModelVersion")
    def privilege_model_version(self) -> Optional[str]:
        """
        the version of the privilege model used by the metastore.
        """
        return pulumi.get(self, "privilege_model_version")

    @privilege_model_version.setter
    def privilege_model_version(self, value: Optional[str]):
        pulumi.set(self, "privilege_model_version", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        (Mandatory for account-level) The region of the metastore.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[str]:
        """
        Path on cloud storage account, where managed `Table` are stored.
        """
        return pulumi.get(self, "storage_root")

    @storage_root.setter
    def storage_root(self, value: Optional[str]):
        pulumi.set(self, "storage_root", value)

    @property
    @pulumi.getter(name="storageRootCredentialId")
    def storage_root_credential_id(self) -> Optional[str]:
        """
        ID of a storage credential used for the `storage_root`.
        """
        return pulumi.get(self, "storage_root_credential_id")

    @storage_root_credential_id.setter
    def storage_root_credential_id(self, value: Optional[str]):
        pulumi.set(self, "storage_root_credential_id", value)

    @property
    @pulumi.getter(name="storageRootCredentialName")
    def storage_root_credential_name(self) -> Optional[str]:
        """
        Name of a storage credential used for the `storage_root`.
        """
        return pulumi.get(self, "storage_root_credential_name")

    @storage_root_credential_name.setter
    def storage_root_credential_name(self, value: Optional[str]):
        pulumi.set(self, "storage_root_credential_name", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        Timestamp (in milliseconds) when the current metastore was updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        the ID of the identity that updated the current metastore.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class GetExternalLocationExternalLocationInfoArgsDict(TypedDict):
        access_point: NotRequired[str]
        """
        The ARN of the s3 access point to use with the external location (AWS).
        """
        browse_only: NotRequired[bool]
        comment: NotRequired[str]
        """
        User-supplied comment.
        """
        created_at: NotRequired[int]
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        created_by: NotRequired[str]
        """
        Username of catalog creator.
        """
        credential_id: NotRequired[str]
        """
        Unique ID of storage credential.
        """
        credential_name: NotRequired[str]
        """
        Name of the StorageCredential to use with this external location.
        """
        encryption_details: NotRequired['GetExternalLocationExternalLocationInfoEncryptionDetailsArgsDict']
        """
        The options for Server-Side Encryption to be used by each Databricks s3 client when connecting to S3 cloud storage (AWS).
        """
        fallback: NotRequired[bool]
        isolation_mode: NotRequired[str]
        metastore_id: NotRequired[str]
        """
        Unique identifier of the parent Metastore.
        """
        name: NotRequired[str]
        """
        The name of the external location
        """
        owner: NotRequired[str]
        """
        Username/groupname/sp application_id of the external location owner.
        """
        read_only: NotRequired[bool]
        """
        Indicates whether the external location is read-only.
        """
        updated_at: NotRequired[int]
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        updated_by: NotRequired[str]
        """
        Username of user who last modified catalog.
        """
        url: NotRequired[str]
        """
        Path URL in cloud storage, of the form: `s3://[bucket-host]/[bucket-dir]` (AWS), `abfss://[user]@[host]/[path]` (Azure), `gs://[bucket-host]/[bucket-dir]` (GCP).
        """
elif False:
    GetExternalLocationExternalLocationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalLocationExternalLocationInfoArgs:
    def __init__(__self__, *,
                 access_point: Optional[str] = None,
                 browse_only: Optional[bool] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 credential_id: Optional[str] = None,
                 credential_name: Optional[str] = None,
                 encryption_details: Optional['GetExternalLocationExternalLocationInfoEncryptionDetailsArgs'] = None,
                 fallback: Optional[bool] = None,
                 isolation_mode: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str access_point: The ARN of the s3 access point to use with the external location (AWS).
        :param str comment: User-supplied comment.
        :param int created_at: Time at which this catalog was created, in epoch milliseconds.
        :param str created_by: Username of catalog creator.
        :param str credential_id: Unique ID of storage credential.
        :param str credential_name: Name of the StorageCredential to use with this external location.
        :param 'GetExternalLocationExternalLocationInfoEncryptionDetailsArgs' encryption_details: The options for Server-Side Encryption to be used by each Databricks s3 client when connecting to S3 cloud storage (AWS).
        :param str metastore_id: Unique identifier of the parent Metastore.
        :param str name: The name of the external location
        :param str owner: Username/groupname/sp application_id of the external location owner.
        :param bool read_only: Indicates whether the external location is read-only.
        :param int updated_at: Time at which this catalog was last modified, in epoch milliseconds.
        :param str updated_by: Username of user who last modified catalog.
        :param str url: Path URL in cloud storage, of the form: `s3://[bucket-host]/[bucket-dir]` (AWS), `abfss://[user]@[host]/[path]` (Azure), `gs://[bucket-host]/[bucket-dir]` (GCP).
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if encryption_details is not None:
            pulumi.set(__self__, "encryption_details", encryption_details)
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[str]:
        """
        The ARN of the s3 access point to use with the external location (AWS).
        """
        return pulumi.get(self, "access_point")

    @access_point.setter
    def access_point(self, value: Optional[str]):
        pulumi.set(self, "access_point", value)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        User-supplied comment.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        Username of catalog creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[str]:
        """
        Unique ID of storage credential.
        """
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[str]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        """
        Name of the StorageCredential to use with this external location.
        """
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[str]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="encryptionDetails")
    def encryption_details(self) -> Optional['GetExternalLocationExternalLocationInfoEncryptionDetailsArgs']:
        """
        The options for Server-Side Encryption to be used by each Databricks s3 client when connecting to S3 cloud storage (AWS).
        """
        return pulumi.get(self, "encryption_details")

    @encryption_details.setter
    def encryption_details(self, value: Optional['GetExternalLocationExternalLocationInfoEncryptionDetailsArgs']):
        pulumi.set(self, "encryption_details", value)

    @property
    @pulumi.getter
    def fallback(self) -> Optional[bool]:
        return pulumi.get(self, "fallback")

    @fallback.setter
    def fallback(self, value: Optional[bool]):
        pulumi.set(self, "fallback", value)

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[str]:
        return pulumi.get(self, "isolation_mode")

    @isolation_mode.setter
    def isolation_mode(self, value: Optional[str]):
        pulumi.set(self, "isolation_mode", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        Unique identifier of the parent Metastore.
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the external location
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Username/groupname/sp application_id of the external location owner.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Indicates whether the external location is read-only.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[bool]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        Username of user who last modified catalog.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        Path URL in cloud storage, of the form: `s3://[bucket-host]/[bucket-dir]` (AWS), `abfss://[user]@[host]/[path]` (Azure), `gs://[bucket-host]/[bucket-dir]` (GCP).
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetExternalLocationExternalLocationInfoEncryptionDetailsArgsDict(TypedDict):
        sse_encryption_details: NotRequired['GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgsDict']
elif False:
    GetExternalLocationExternalLocationInfoEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalLocationExternalLocationInfoEncryptionDetailsArgs:
    def __init__(__self__, *,
                 sse_encryption_details: Optional['GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgs'] = None):
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgs']:
        return pulumi.get(self, "sse_encryption_details")

    @sse_encryption_details.setter
    def sse_encryption_details(self, value: Optional['GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgs']):
        pulumi.set(self, "sse_encryption_details", value)


if not MYPY:
    class GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgsDict(TypedDict):
        algorithm: NotRequired[str]
        aws_kms_key_arn: NotRequired[str]
elif False:
    GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgs:
    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 aws_kms_key_arn: Optional[str] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[str]:
        return pulumi.get(self, "aws_kms_key_arn")

    @aws_kms_key_arn.setter
    def aws_kms_key_arn(self, value: Optional[str]):
        pulumi.set(self, "aws_kms_key_arn", value)


if not MYPY:
    class GetFunctionsFunctionArgsDict(TypedDict):
        browse_only: NotRequired[bool]
        """
        Indicates whether the principal is limited to retrieving metadata for the associated object through the `BROWSE` privilege when `include_browse` is enabled in the request.
        """
        catalog_name: NotRequired[str]
        """
        Name of databricks_catalog.
        """
        comment: NotRequired[str]
        """
        User-provided free-form text description.
        """
        created_at: NotRequired[int]
        """
        Time at which this function was created, in epoch milliseconds.
        """
        created_by: NotRequired[str]
        """
        Username of function creator.
        """
        data_type: NotRequired[str]
        """
        Scalar function return data type.
        """
        external_language: NotRequired[str]
        """
        External function language.
        """
        external_name: NotRequired[str]
        """
        External function name.
        """
        full_data_type: NotRequired[str]
        """
        Pretty printed function data type.
        """
        full_name: NotRequired[str]
        """
        Full name of function, in form of catalog_name.schema_name.function__name
        """
        function_id: NotRequired[str]
        """
        Id of Function, relative to parent schema.
        """
        input_params: NotRequired['GetFunctionsFunctionInputParamsArgsDict']
        """
        object describing input parameters. Consists of the single attribute:
        """
        is_deterministic: NotRequired[bool]
        """
        Boolean flag specifying whether the function is deterministic.
        """
        is_null_call: NotRequired[bool]
        """
        Boolean flag whether function null call.
        """
        metastore_id: NotRequired[str]
        """
        Unique identifier of parent metastore.
        """
        name: NotRequired[str]
        """
        Name of parameter.
        """
        owner: NotRequired[str]
        """
        Username of current owner of function.
        """
        parameter_style: NotRequired[str]
        """
        Function parameter style. `S` is the value for SQL.
        """
        properties: NotRequired[str]
        """
        JSON-serialized key-value pair map, encoded (escaped) as a string.
        """
        return_params: NotRequired['GetFunctionsFunctionReturnParamsArgsDict']
        """
        Table function return parameters.  See `input_params` for description.
        """
        routine_body: NotRequired[str]
        """
        Function language (`SQL` or `EXTERNAL`). When `EXTERNAL` is used, the language of the routine function should be specified in the `external_language` field, and the `return_params` of the function cannot be used (as `TABLE` return type is not supported), and the `sql_data_access` field must be `NO_SQL`.
        """
        routine_definition: NotRequired[str]
        """
        Function body.
        """
        routine_dependencies: NotRequired['GetFunctionsFunctionRoutineDependenciesArgsDict']
        """
        Function dependencies.
        """
        schema_name: NotRequired[str]
        """
        Name of databricks_schema.
        """
        security_type: NotRequired[str]
        """
        Function security type. (Enum: `DEFINER`).
        """
        specific_name: NotRequired[str]
        """
        Specific name of the function; Reserved for future use.
        """
        sql_data_access: NotRequired[str]
        """
        Function SQL data access (`CONTAINS_SQL`, `READS_SQL_DATA`, `NO_SQL`).
        """
        sql_path: NotRequired[str]
        """
        List of schemes whose objects can be referenced without qualification.
        """
        updated_at: NotRequired[int]
        """
        Time at which this function was created, in epoch milliseconds.
        """
        updated_by: NotRequired[str]
        """
        Username of user who last modified function.
        """
elif False:
    GetFunctionsFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionArgs:
    def __init__(__self__, *,
                 browse_only: Optional[bool] = None,
                 catalog_name: Optional[str] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 data_type: Optional[str] = None,
                 external_language: Optional[str] = None,
                 external_name: Optional[str] = None,
                 full_data_type: Optional[str] = None,
                 full_name: Optional[str] = None,
                 function_id: Optional[str] = None,
                 input_params: Optional['GetFunctionsFunctionInputParamsArgs'] = None,
                 is_deterministic: Optional[bool] = None,
                 is_null_call: Optional[bool] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 parameter_style: Optional[str] = None,
                 properties: Optional[str] = None,
                 return_params: Optional['GetFunctionsFunctionReturnParamsArgs'] = None,
                 routine_body: Optional[str] = None,
                 routine_definition: Optional[str] = None,
                 routine_dependencies: Optional['GetFunctionsFunctionRoutineDependenciesArgs'] = None,
                 schema_name: Optional[str] = None,
                 security_type: Optional[str] = None,
                 specific_name: Optional[str] = None,
                 sql_data_access: Optional[str] = None,
                 sql_path: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param bool browse_only: Indicates whether the principal is limited to retrieving metadata for the associated object through the `BROWSE` privilege when `include_browse` is enabled in the request.
        :param str catalog_name: Name of databricks_catalog.
        :param str comment: User-provided free-form text description.
        :param int created_at: Time at which this function was created, in epoch milliseconds.
        :param str created_by: Username of function creator.
        :param str data_type: Scalar function return data type.
        :param str external_language: External function language.
        :param str external_name: External function name.
        :param str full_data_type: Pretty printed function data type.
        :param str full_name: Full name of function, in form of catalog_name.schema_name.function__name
        :param str function_id: Id of Function, relative to parent schema.
        :param 'GetFunctionsFunctionInputParamsArgs' input_params: object describing input parameters. Consists of the single attribute:
        :param bool is_deterministic: Boolean flag specifying whether the function is deterministic.
        :param bool is_null_call: Boolean flag whether function null call.
        :param str metastore_id: Unique identifier of parent metastore.
        :param str name: Name of parameter.
        :param str owner: Username of current owner of function.
        :param str parameter_style: Function parameter style. `S` is the value for SQL.
        :param str properties: JSON-serialized key-value pair map, encoded (escaped) as a string.
        :param 'GetFunctionsFunctionReturnParamsArgs' return_params: Table function return parameters.  See `input_params` for description.
        :param str routine_body: Function language (`SQL` or `EXTERNAL`). When `EXTERNAL` is used, the language of the routine function should be specified in the `external_language` field, and the `return_params` of the function cannot be used (as `TABLE` return type is not supported), and the `sql_data_access` field must be `NO_SQL`.
        :param str routine_definition: Function body.
        :param 'GetFunctionsFunctionRoutineDependenciesArgs' routine_dependencies: Function dependencies.
        :param str schema_name: Name of databricks_schema.
        :param str security_type: Function security type. (Enum: `DEFINER`).
        :param str specific_name: Specific name of the function; Reserved for future use.
        :param str sql_data_access: Function SQL data access (`CONTAINS_SQL`, `READS_SQL_DATA`, `NO_SQL`).
        :param str sql_path: List of schemes whose objects can be referenced without qualification.
        :param int updated_at: Time at which this function was created, in epoch milliseconds.
        :param str updated_by: Username of user who last modified function.
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if external_language is not None:
            pulumi.set(__self__, "external_language", external_language)
        if external_name is not None:
            pulumi.set(__self__, "external_name", external_name)
        if full_data_type is not None:
            pulumi.set(__self__, "full_data_type", full_data_type)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if input_params is not None:
            pulumi.set(__self__, "input_params", input_params)
        if is_deterministic is not None:
            pulumi.set(__self__, "is_deterministic", is_deterministic)
        if is_null_call is not None:
            pulumi.set(__self__, "is_null_call", is_null_call)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if parameter_style is not None:
            pulumi.set(__self__, "parameter_style", parameter_style)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if return_params is not None:
            pulumi.set(__self__, "return_params", return_params)
        if routine_body is not None:
            pulumi.set(__self__, "routine_body", routine_body)
        if routine_definition is not None:
            pulumi.set(__self__, "routine_definition", routine_definition)
        if routine_dependencies is not None:
            pulumi.set(__self__, "routine_dependencies", routine_dependencies)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if specific_name is not None:
            pulumi.set(__self__, "specific_name", specific_name)
        if sql_data_access is not None:
            pulumi.set(__self__, "sql_data_access", sql_data_access)
        if sql_path is not None:
            pulumi.set(__self__, "sql_path", sql_path)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        """
        Indicates whether the principal is limited to retrieving metadata for the associated object through the `BROWSE` privilege when `include_browse` is enabled in the request.
        """
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[str]:
        """
        Name of databricks_catalog.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        User-provided free-form text description.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        Time at which this function was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        Username of function creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[str]:
        """
        Scalar function return data type.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[str]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter(name="externalLanguage")
    def external_language(self) -> Optional[str]:
        """
        External function language.
        """
        return pulumi.get(self, "external_language")

    @external_language.setter
    def external_language(self, value: Optional[str]):
        pulumi.set(self, "external_language", value)

    @property
    @pulumi.getter(name="externalName")
    def external_name(self) -> Optional[str]:
        """
        External function name.
        """
        return pulumi.get(self, "external_name")

    @external_name.setter
    def external_name(self, value: Optional[str]):
        pulumi.set(self, "external_name", value)

    @property
    @pulumi.getter(name="fullDataType")
    def full_data_type(self) -> Optional[str]:
        """
        Pretty printed function data type.
        """
        return pulumi.get(self, "full_data_type")

    @full_data_type.setter
    def full_data_type(self, value: Optional[str]):
        pulumi.set(self, "full_data_type", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        Full name of function, in form of catalog_name.schema_name.function__name
        """
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[str]:
        """
        Id of Function, relative to parent schema.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[str]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="inputParams")
    def input_params(self) -> Optional['GetFunctionsFunctionInputParamsArgs']:
        """
        object describing input parameters. Consists of the single attribute:
        """
        return pulumi.get(self, "input_params")

    @input_params.setter
    def input_params(self, value: Optional['GetFunctionsFunctionInputParamsArgs']):
        pulumi.set(self, "input_params", value)

    @property
    @pulumi.getter(name="isDeterministic")
    def is_deterministic(self) -> Optional[bool]:
        """
        Boolean flag specifying whether the function is deterministic.
        """
        return pulumi.get(self, "is_deterministic")

    @is_deterministic.setter
    def is_deterministic(self, value: Optional[bool]):
        pulumi.set(self, "is_deterministic", value)

    @property
    @pulumi.getter(name="isNullCall")
    def is_null_call(self) -> Optional[bool]:
        """
        Boolean flag whether function null call.
        """
        return pulumi.get(self, "is_null_call")

    @is_null_call.setter
    def is_null_call(self, value: Optional[bool]):
        pulumi.set(self, "is_null_call", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        Unique identifier of parent metastore.
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Username of current owner of function.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="parameterStyle")
    def parameter_style(self) -> Optional[str]:
        """
        Function parameter style. `S` is the value for SQL.
        """
        return pulumi.get(self, "parameter_style")

    @parameter_style.setter
    def parameter_style(self, value: Optional[str]):
        pulumi.set(self, "parameter_style", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[str]:
        """
        JSON-serialized key-value pair map, encoded (escaped) as a string.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[str]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="returnParams")
    def return_params(self) -> Optional['GetFunctionsFunctionReturnParamsArgs']:
        """
        Table function return parameters.  See `input_params` for description.
        """
        return pulumi.get(self, "return_params")

    @return_params.setter
    def return_params(self, value: Optional['GetFunctionsFunctionReturnParamsArgs']):
        pulumi.set(self, "return_params", value)

    @property
    @pulumi.getter(name="routineBody")
    def routine_body(self) -> Optional[str]:
        """
        Function language (`SQL` or `EXTERNAL`). When `EXTERNAL` is used, the language of the routine function should be specified in the `external_language` field, and the `return_params` of the function cannot be used (as `TABLE` return type is not supported), and the `sql_data_access` field must be `NO_SQL`.
        """
        return pulumi.get(self, "routine_body")

    @routine_body.setter
    def routine_body(self, value: Optional[str]):
        pulumi.set(self, "routine_body", value)

    @property
    @pulumi.getter(name="routineDefinition")
    def routine_definition(self) -> Optional[str]:
        """
        Function body.
        """
        return pulumi.get(self, "routine_definition")

    @routine_definition.setter
    def routine_definition(self, value: Optional[str]):
        pulumi.set(self, "routine_definition", value)

    @property
    @pulumi.getter(name="routineDependencies")
    def routine_dependencies(self) -> Optional['GetFunctionsFunctionRoutineDependenciesArgs']:
        """
        Function dependencies.
        """
        return pulumi.get(self, "routine_dependencies")

    @routine_dependencies.setter
    def routine_dependencies(self, value: Optional['GetFunctionsFunctionRoutineDependenciesArgs']):
        pulumi.set(self, "routine_dependencies", value)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        Name of databricks_schema.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[str]):
        pulumi.set(self, "schema_name", value)

    @property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[str]:
        """
        Function security type. (Enum: `DEFINER`).
        """
        return pulumi.get(self, "security_type")

    @security_type.setter
    def security_type(self, value: Optional[str]):
        pulumi.set(self, "security_type", value)

    @property
    @pulumi.getter(name="specificName")
    def specific_name(self) -> Optional[str]:
        """
        Specific name of the function; Reserved for future use.
        """
        return pulumi.get(self, "specific_name")

    @specific_name.setter
    def specific_name(self, value: Optional[str]):
        pulumi.set(self, "specific_name", value)

    @property
    @pulumi.getter(name="sqlDataAccess")
    def sql_data_access(self) -> Optional[str]:
        """
        Function SQL data access (`CONTAINS_SQL`, `READS_SQL_DATA`, `NO_SQL`).
        """
        return pulumi.get(self, "sql_data_access")

    @sql_data_access.setter
    def sql_data_access(self, value: Optional[str]):
        pulumi.set(self, "sql_data_access", value)

    @property
    @pulumi.getter(name="sqlPath")
    def sql_path(self) -> Optional[str]:
        """
        List of schemes whose objects can be referenced without qualification.
        """
        return pulumi.get(self, "sql_path")

    @sql_path.setter
    def sql_path(self, value: Optional[str]):
        pulumi.set(self, "sql_path", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        Time at which this function was created, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        Username of user who last modified function.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class GetFunctionsFunctionInputParamsArgsDict(TypedDict):
        parameters: NotRequired[Sequence['GetFunctionsFunctionInputParamsParameterArgsDict']]
        """
        The array of definitions of the function's parameters:
        """
elif False:
    GetFunctionsFunctionInputParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionInputParamsArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence['GetFunctionsFunctionInputParamsParameterArgs']] = None):
        """
        :param Sequence['GetFunctionsFunctionInputParamsParameterArgs'] parameters: The array of definitions of the function's parameters:
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['GetFunctionsFunctionInputParamsParameterArgs']]:
        """
        The array of definitions of the function's parameters:
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence['GetFunctionsFunctionInputParamsParameterArgs']]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetFunctionsFunctionInputParamsParameterArgsDict(TypedDict):
        name: str
        """
        Name of parameter.
        """
        position: int
        """
        Ordinal position of column (starting at position 0).
        """
        type_name: str
        """
        Name of type (INT, STRUCT, MAP, etc.).
        """
        type_text: str
        """
        Full data type spec, SQL/catalogString text.
        """
        comment: NotRequired[str]
        """
        User-provided free-form text description.
        """
        parameter_default: NotRequired[str]
        """
        Default value of the parameter.
        """
        parameter_mode: NotRequired[str]
        """
        The mode of the function parameter.
        """
        parameter_type: NotRequired[str]
        """
        The type of function parameter (`PARAM` or `COLUMN`).
        """
        type_interval_type: NotRequired[str]
        """
        Format of IntervalType.
        """
        type_json: NotRequired[str]
        """
        Full data type spec, JSON-serialized.
        """
        type_precision: NotRequired[int]
        """
        Digits of precision; required on Create for DecimalTypes.
        """
        type_scale: NotRequired[int]
        """
        Digits to right of decimal; Required on Create for DecimalTypes.
        """
elif False:
    GetFunctionsFunctionInputParamsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionInputParamsParameterArgs:
    def __init__(__self__, *,
                 name: str,
                 position: int,
                 type_name: str,
                 type_text: str,
                 comment: Optional[str] = None,
                 parameter_default: Optional[str] = None,
                 parameter_mode: Optional[str] = None,
                 parameter_type: Optional[str] = None,
                 type_interval_type: Optional[str] = None,
                 type_json: Optional[str] = None,
                 type_precision: Optional[int] = None,
                 type_scale: Optional[int] = None):
        """
        :param str name: Name of parameter.
        :param int position: Ordinal position of column (starting at position 0).
        :param str type_name: Name of type (INT, STRUCT, MAP, etc.).
        :param str type_text: Full data type spec, SQL/catalogString text.
        :param str comment: User-provided free-form text description.
        :param str parameter_default: Default value of the parameter.
        :param str parameter_mode: The mode of the function parameter.
        :param str parameter_type: The type of function parameter (`PARAM` or `COLUMN`).
        :param str type_interval_type: Format of IntervalType.
        :param str type_json: Full data type spec, JSON-serialized.
        :param int type_precision: Digits of precision; required on Create for DecimalTypes.
        :param int type_scale: Digits to right of decimal; Required on Create for DecimalTypes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameter_default is not None:
            pulumi.set(__self__, "parameter_default", parameter_default)
        if parameter_mode is not None:
            pulumi.set(__self__, "parameter_mode", parameter_mode)
        if parameter_type is not None:
            pulumi.set(__self__, "parameter_type", parameter_type)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def position(self) -> int:
        """
        Ordinal position of column (starting at position 0).
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: int):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Name of type (INT, STRUCT, MAP, etc.).
        """
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: str):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="typeText")
    def type_text(self) -> str:
        """
        Full data type spec, SQL/catalogString text.
        """
        return pulumi.get(self, "type_text")

    @type_text.setter
    def type_text(self, value: str):
        pulumi.set(self, "type_text", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        User-provided free-form text description.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="parameterDefault")
    def parameter_default(self) -> Optional[str]:
        """
        Default value of the parameter.
        """
        return pulumi.get(self, "parameter_default")

    @parameter_default.setter
    def parameter_default(self, value: Optional[str]):
        pulumi.set(self, "parameter_default", value)

    @property
    @pulumi.getter(name="parameterMode")
    def parameter_mode(self) -> Optional[str]:
        """
        The mode of the function parameter.
        """
        return pulumi.get(self, "parameter_mode")

    @parameter_mode.setter
    def parameter_mode(self, value: Optional[str]):
        pulumi.set(self, "parameter_mode", value)

    @property
    @pulumi.getter(name="parameterType")
    def parameter_type(self) -> Optional[str]:
        """
        The type of function parameter (`PARAM` or `COLUMN`).
        """
        return pulumi.get(self, "parameter_type")

    @parameter_type.setter
    def parameter_type(self, value: Optional[str]):
        pulumi.set(self, "parameter_type", value)

    @property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[str]:
        """
        Format of IntervalType.
        """
        return pulumi.get(self, "type_interval_type")

    @type_interval_type.setter
    def type_interval_type(self, value: Optional[str]):
        pulumi.set(self, "type_interval_type", value)

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[str]:
        """
        Full data type spec, JSON-serialized.
        """
        return pulumi.get(self, "type_json")

    @type_json.setter
    def type_json(self, value: Optional[str]):
        pulumi.set(self, "type_json", value)

    @property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[int]:
        """
        Digits of precision; required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_precision")

    @type_precision.setter
    def type_precision(self, value: Optional[int]):
        pulumi.set(self, "type_precision", value)

    @property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[int]:
        """
        Digits to right of decimal; Required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_scale")

    @type_scale.setter
    def type_scale(self, value: Optional[int]):
        pulumi.set(self, "type_scale", value)


if not MYPY:
    class GetFunctionsFunctionReturnParamsArgsDict(TypedDict):
        parameters: NotRequired[Sequence['GetFunctionsFunctionReturnParamsParameterArgsDict']]
        """
        The array of definitions of the function's parameters:
        """
elif False:
    GetFunctionsFunctionReturnParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionReturnParamsArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence['GetFunctionsFunctionReturnParamsParameterArgs']] = None):
        """
        :param Sequence['GetFunctionsFunctionReturnParamsParameterArgs'] parameters: The array of definitions of the function's parameters:
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['GetFunctionsFunctionReturnParamsParameterArgs']]:
        """
        The array of definitions of the function's parameters:
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence['GetFunctionsFunctionReturnParamsParameterArgs']]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetFunctionsFunctionReturnParamsParameterArgsDict(TypedDict):
        name: str
        """
        Name of parameter.
        """
        position: int
        """
        Ordinal position of column (starting at position 0).
        """
        type_name: str
        """
        Name of type (INT, STRUCT, MAP, etc.).
        """
        type_text: str
        """
        Full data type spec, SQL/catalogString text.
        """
        comment: NotRequired[str]
        """
        User-provided free-form text description.
        """
        parameter_default: NotRequired[str]
        """
        Default value of the parameter.
        """
        parameter_mode: NotRequired[str]
        """
        The mode of the function parameter.
        """
        parameter_type: NotRequired[str]
        """
        The type of function parameter (`PARAM` or `COLUMN`).
        """
        type_interval_type: NotRequired[str]
        """
        Format of IntervalType.
        """
        type_json: NotRequired[str]
        """
        Full data type spec, JSON-serialized.
        """
        type_precision: NotRequired[int]
        """
        Digits of precision; required on Create for DecimalTypes.
        """
        type_scale: NotRequired[int]
        """
        Digits to right of decimal; Required on Create for DecimalTypes.
        """
elif False:
    GetFunctionsFunctionReturnParamsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionReturnParamsParameterArgs:
    def __init__(__self__, *,
                 name: str,
                 position: int,
                 type_name: str,
                 type_text: str,
                 comment: Optional[str] = None,
                 parameter_default: Optional[str] = None,
                 parameter_mode: Optional[str] = None,
                 parameter_type: Optional[str] = None,
                 type_interval_type: Optional[str] = None,
                 type_json: Optional[str] = None,
                 type_precision: Optional[int] = None,
                 type_scale: Optional[int] = None):
        """
        :param str name: Name of parameter.
        :param int position: Ordinal position of column (starting at position 0).
        :param str type_name: Name of type (INT, STRUCT, MAP, etc.).
        :param str type_text: Full data type spec, SQL/catalogString text.
        :param str comment: User-provided free-form text description.
        :param str parameter_default: Default value of the parameter.
        :param str parameter_mode: The mode of the function parameter.
        :param str parameter_type: The type of function parameter (`PARAM` or `COLUMN`).
        :param str type_interval_type: Format of IntervalType.
        :param str type_json: Full data type spec, JSON-serialized.
        :param int type_precision: Digits of precision; required on Create for DecimalTypes.
        :param int type_scale: Digits to right of decimal; Required on Create for DecimalTypes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameter_default is not None:
            pulumi.set(__self__, "parameter_default", parameter_default)
        if parameter_mode is not None:
            pulumi.set(__self__, "parameter_mode", parameter_mode)
        if parameter_type is not None:
            pulumi.set(__self__, "parameter_type", parameter_type)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def position(self) -> int:
        """
        Ordinal position of column (starting at position 0).
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: int):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Name of type (INT, STRUCT, MAP, etc.).
        """
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: str):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="typeText")
    def type_text(self) -> str:
        """
        Full data type spec, SQL/catalogString text.
        """
        return pulumi.get(self, "type_text")

    @type_text.setter
    def type_text(self, value: str):
        pulumi.set(self, "type_text", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        User-provided free-form text description.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="parameterDefault")
    def parameter_default(self) -> Optional[str]:
        """
        Default value of the parameter.
        """
        return pulumi.get(self, "parameter_default")

    @parameter_default.setter
    def parameter_default(self, value: Optional[str]):
        pulumi.set(self, "parameter_default", value)

    @property
    @pulumi.getter(name="parameterMode")
    def parameter_mode(self) -> Optional[str]:
        """
        The mode of the function parameter.
        """
        return pulumi.get(self, "parameter_mode")

    @parameter_mode.setter
    def parameter_mode(self, value: Optional[str]):
        pulumi.set(self, "parameter_mode", value)

    @property
    @pulumi.getter(name="parameterType")
    def parameter_type(self) -> Optional[str]:
        """
        The type of function parameter (`PARAM` or `COLUMN`).
        """
        return pulumi.get(self, "parameter_type")

    @parameter_type.setter
    def parameter_type(self, value: Optional[str]):
        pulumi.set(self, "parameter_type", value)

    @property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[str]:
        """
        Format of IntervalType.
        """
        return pulumi.get(self, "type_interval_type")

    @type_interval_type.setter
    def type_interval_type(self, value: Optional[str]):
        pulumi.set(self, "type_interval_type", value)

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[str]:
        """
        Full data type spec, JSON-serialized.
        """
        return pulumi.get(self, "type_json")

    @type_json.setter
    def type_json(self, value: Optional[str]):
        pulumi.set(self, "type_json", value)

    @property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[int]:
        """
        Digits of precision; required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_precision")

    @type_precision.setter
    def type_precision(self, value: Optional[int]):
        pulumi.set(self, "type_precision", value)

    @property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[int]:
        """
        Digits to right of decimal; Required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_scale")

    @type_scale.setter
    def type_scale(self, value: Optional[int]):
        pulumi.set(self, "type_scale", value)


if not MYPY:
    class GetFunctionsFunctionRoutineDependenciesArgsDict(TypedDict):
        dependencies: NotRequired[Sequence['GetFunctionsFunctionRoutineDependenciesDependencyArgsDict']]
elif False:
    GetFunctionsFunctionRoutineDependenciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionRoutineDependenciesArgs:
    def __init__(__self__, *,
                 dependencies: Optional[Sequence['GetFunctionsFunctionRoutineDependenciesDependencyArgs']] = None):
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['GetFunctionsFunctionRoutineDependenciesDependencyArgs']]:
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[Sequence['GetFunctionsFunctionRoutineDependenciesDependencyArgs']]):
        pulumi.set(self, "dependencies", value)


if not MYPY:
    class GetFunctionsFunctionRoutineDependenciesDependencyArgsDict(TypedDict):
        function: NotRequired['GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgsDict']
        table: NotRequired['GetFunctionsFunctionRoutineDependenciesDependencyTableArgsDict']
elif False:
    GetFunctionsFunctionRoutineDependenciesDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionRoutineDependenciesDependencyArgs:
    def __init__(__self__, *,
                 function: Optional['GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgs'] = None,
                 table: Optional['GetFunctionsFunctionRoutineDependenciesDependencyTableArgs'] = None):
        if function is not None:
            pulumi.set(__self__, "function", function)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def function(self) -> Optional['GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgs']:
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional['GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgs']):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def table(self) -> Optional['GetFunctionsFunctionRoutineDependenciesDependencyTableArgs']:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional['GetFunctionsFunctionRoutineDependenciesDependencyTableArgs']):
        pulumi.set(self, "table", value)


if not MYPY:
    class GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgsDict(TypedDict):
        function_full_name: str
elif False:
    GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionRoutineDependenciesDependencyFunctionArgs:
    def __init__(__self__, *,
                 function_full_name: str):
        pulumi.set(__self__, "function_full_name", function_full_name)

    @property
    @pulumi.getter(name="functionFullName")
    def function_full_name(self) -> str:
        return pulumi.get(self, "function_full_name")

    @function_full_name.setter
    def function_full_name(self, value: str):
        pulumi.set(self, "function_full_name", value)


if not MYPY:
    class GetFunctionsFunctionRoutineDependenciesDependencyTableArgsDict(TypedDict):
        table_full_name: str
elif False:
    GetFunctionsFunctionRoutineDependenciesDependencyTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFunctionsFunctionRoutineDependenciesDependencyTableArgs:
    def __init__(__self__, *,
                 table_full_name: str):
        pulumi.set(__self__, "table_full_name", table_full_name)

    @property
    @pulumi.getter(name="tableFullName")
    def table_full_name(self) -> str:
        return pulumi.get(self, "table_full_name")

    @table_full_name.setter
    def table_full_name(self, value: str):
        pulumi.set(self, "table_full_name", value)


if not MYPY:
    class GetInstancePoolPoolInfoArgsDict(TypedDict):
        default_tags: Mapping[str, str]
        idle_instance_autotermination_minutes: int
        instance_pool_id: str
        instance_pool_name: str
        aws_attributes: NotRequired['GetInstancePoolPoolInfoAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetInstancePoolPoolInfoAzureAttributesArgsDict']
        custom_tags: NotRequired[Mapping[str, str]]
        disk_spec: NotRequired['GetInstancePoolPoolInfoDiskSpecArgsDict']
        enable_elastic_disk: NotRequired[bool]
        gcp_attributes: NotRequired['GetInstancePoolPoolInfoGcpAttributesArgsDict']
        instance_pool_fleet_attributes: NotRequired[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgsDict']]
        max_capacity: NotRequired[int]
        min_idle_instances: NotRequired[int]
        node_type_id: NotRequired[str]
        preloaded_docker_images: NotRequired[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgsDict']]
        preloaded_spark_versions: NotRequired[Sequence[str]]
        state: NotRequired[str]
        stats: NotRequired['GetInstancePoolPoolInfoStatsArgsDict']
elif False:
    GetInstancePoolPoolInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoArgs:
    def __init__(__self__, *,
                 default_tags: Mapping[str, str],
                 idle_instance_autotermination_minutes: int,
                 instance_pool_id: str,
                 instance_pool_name: str,
                 aws_attributes: Optional['GetInstancePoolPoolInfoAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetInstancePoolPoolInfoAzureAttributesArgs'] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 disk_spec: Optional['GetInstancePoolPoolInfoDiskSpecArgs'] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 gcp_attributes: Optional['GetInstancePoolPoolInfoGcpAttributesArgs'] = None,
                 instance_pool_fleet_attributes: Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']] = None,
                 max_capacity: Optional[int] = None,
                 min_idle_instances: Optional[int] = None,
                 node_type_id: Optional[str] = None,
                 preloaded_docker_images: Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']] = None,
                 preloaded_spark_versions: Optional[Sequence[str]] = None,
                 state: Optional[str] = None,
                 stats: Optional['GetInstancePoolPoolInfoStatsArgs'] = None):
        pulumi.set(__self__, "default_tags", default_tags)
        pulumi.set(__self__, "idle_instance_autotermination_minutes", idle_instance_autotermination_minutes)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "instance_pool_name", instance_pool_name)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if disk_spec is not None:
            pulumi.set(__self__, "disk_spec", disk_spec)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if instance_pool_fleet_attributes is not None:
            pulumi.set(__self__, "instance_pool_fleet_attributes", instance_pool_fleet_attributes)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_idle_instances is not None:
            pulumi.set(__self__, "min_idle_instances", min_idle_instances)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if preloaded_docker_images is not None:
            pulumi.set(__self__, "preloaded_docker_images", preloaded_docker_images)
        if preloaded_spark_versions is not None:
            pulumi.set(__self__, "preloaded_spark_versions", preloaded_spark_versions)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)

    @property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Mapping[str, str]:
        return pulumi.get(self, "default_tags")

    @default_tags.setter
    def default_tags(self, value: Mapping[str, str]):
        pulumi.set(self, "default_tags", value)

    @property
    @pulumi.getter(name="idleInstanceAutoterminationMinutes")
    def idle_instance_autotermination_minutes(self) -> int:
        return pulumi.get(self, "idle_instance_autotermination_minutes")

    @idle_instance_autotermination_minutes.setter
    def idle_instance_autotermination_minutes(self, value: int):
        pulumi.set(self, "idle_instance_autotermination_minutes", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: str):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="instancePoolName")
    def instance_pool_name(self) -> str:
        return pulumi.get(self, "instance_pool_name")

    @instance_pool_name.setter
    def instance_pool_name(self, value: str):
        pulumi.set(self, "instance_pool_name", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetInstancePoolPoolInfoAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetInstancePoolPoolInfoAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetInstancePoolPoolInfoAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetInstancePoolPoolInfoAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="diskSpec")
    def disk_spec(self) -> Optional['GetInstancePoolPoolInfoDiskSpecArgs']:
        return pulumi.get(self, "disk_spec")

    @disk_spec.setter
    def disk_spec(self, value: Optional['GetInstancePoolPoolInfoDiskSpecArgs']):
        pulumi.set(self, "disk_spec", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[bool]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetInstancePoolPoolInfoGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetInstancePoolPoolInfoGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="instancePoolFleetAttributes")
    def instance_pool_fleet_attributes(self) -> Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']]:
        return pulumi.get(self, "instance_pool_fleet_attributes")

    @instance_pool_fleet_attributes.setter
    def instance_pool_fleet_attributes(self, value: Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']]):
        pulumi.set(self, "instance_pool_fleet_attributes", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[int]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minIdleInstances")
    def min_idle_instances(self) -> Optional[int]:
        return pulumi.get(self, "min_idle_instances")

    @min_idle_instances.setter
    def min_idle_instances(self, value: Optional[int]):
        pulumi.set(self, "min_idle_instances", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="preloadedDockerImages")
    def preloaded_docker_images(self) -> Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']]:
        return pulumi.get(self, "preloaded_docker_images")

    @preloaded_docker_images.setter
    def preloaded_docker_images(self, value: Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']]):
        pulumi.set(self, "preloaded_docker_images", value)

    @property
    @pulumi.getter(name="preloadedSparkVersions")
    def preloaded_spark_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preloaded_spark_versions")

    @preloaded_spark_versions.setter
    def preloaded_spark_versions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "preloaded_spark_versions", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[str]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def stats(self) -> Optional['GetInstancePoolPoolInfoStatsArgs']:
        return pulumi.get(self, "stats")

    @stats.setter
    def stats(self, value: Optional['GetInstancePoolPoolInfoStatsArgs']):
        pulumi.set(self, "stats", value)


if not MYPY:
    class GetInstancePoolPoolInfoAwsAttributesArgsDict(TypedDict):
        zone_id: str
        availability: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
elif False:
    GetInstancePoolPoolInfoAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoAwsAttributesArgs:
    def __init__(__self__, *,
                 zone_id: str,
                 availability: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None):
        pulumi.set(__self__, "zone_id", zone_id)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: str):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)


if not MYPY:
    class GetInstancePoolPoolInfoAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        spot_bid_max_price: NotRequired[float]
elif False:
    GetInstancePoolPoolInfoAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetInstancePoolPoolInfoDiskSpecArgsDict(TypedDict):
        disk_count: NotRequired[int]
        disk_size: NotRequired[int]
        disk_type: NotRequired['GetInstancePoolPoolInfoDiskSpecDiskTypeArgsDict']
elif False:
    GetInstancePoolPoolInfoDiskSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoDiskSpecArgs:
    def __init__(__self__, *,
                 disk_count: Optional[int] = None,
                 disk_size: Optional[int] = None,
                 disk_type: Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs'] = None):
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[int]:
        return pulumi.get(self, "disk_count")

    @disk_count.setter
    def disk_count(self, value: Optional[int]):
        pulumi.set(self, "disk_count", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs']:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs']):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class GetInstancePoolPoolInfoDiskSpecDiskTypeArgsDict(TypedDict):
        azure_disk_volume_type: NotRequired[str]
        ebs_volume_type: NotRequired[str]
elif False:
    GetInstancePoolPoolInfoDiskSpecDiskTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoDiskSpecDiskTypeArgs:
    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[str] = None,
                 ebs_volume_type: Optional[str] = None):
        if azure_disk_volume_type is not None:
            pulumi.set(__self__, "azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)

    @property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "azure_disk_volume_type")

    @azure_disk_volume_type.setter
    def azure_disk_volume_type(self, value: Optional[str]):
        pulumi.set(self, "azure_disk_volume_type", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)


if not MYPY:
    class GetInstancePoolPoolInfoGcpAttributesArgsDict(TypedDict):
        local_ssd_count: int
        zone_id: str
        gcp_availability: NotRequired[str]
elif False:
    GetInstancePoolPoolInfoGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoGcpAttributesArgs:
    def __init__(__self__, *,
                 local_ssd_count: int,
                 zone_id: str,
                 gcp_availability: Optional[str] = None):
        pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        pulumi.set(__self__, "zone_id", zone_id)
        if gcp_availability is not None:
            pulumi.set(__self__, "gcp_availability", gcp_availability)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> int:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: int):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: str):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter(name="gcpAvailability")
    def gcp_availability(self) -> Optional[str]:
        return pulumi.get(self, "gcp_availability")

    @gcp_availability.setter
    def gcp_availability(self, value: Optional[str]):
        pulumi.set(self, "gcp_availability", value)


if not MYPY:
    class GetInstancePoolPoolInfoInstancePoolFleetAttributeArgsDict(TypedDict):
        launch_template_overrides: Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgsDict']
        fleet_on_demand_option: NotRequired['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgsDict']
        fleet_spot_option: NotRequired['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgsDict']
elif False:
    GetInstancePoolPoolInfoInstancePoolFleetAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs:
    def __init__(__self__, *,
                 launch_template_overrides: Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs'],
                 fleet_on_demand_option: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs'] = None,
                 fleet_spot_option: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs'] = None):
        pulumi.set(__self__, "launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            pulumi.set(__self__, "fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            pulumi.set(__self__, "fleet_spot_option", fleet_spot_option)

    @property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs']:
        return pulumi.get(self, "launch_template_overrides")

    @launch_template_overrides.setter
    def launch_template_overrides(self, value: Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs']):
        pulumi.set(self, "launch_template_overrides", value)

    @property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs']:
        return pulumi.get(self, "fleet_on_demand_option")

    @fleet_on_demand_option.setter
    def fleet_on_demand_option(self, value: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs']):
        pulumi.set(self, "fleet_on_demand_option", value)

    @property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs']:
        return pulumi.get(self, "fleet_spot_option")

    @fleet_spot_option.setter
    def fleet_spot_option(self, value: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs']):
        pulumi.set(self, "fleet_spot_option", value)


if not MYPY:
    class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgsDict(TypedDict):
        allocation_strategy: str
        instance_pools_to_use_count: NotRequired[int]
elif False:
    GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: str,
                 instance_pools_to_use_count: Optional[int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: str):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[int]):
        pulumi.set(self, "instance_pools_to_use_count", value)


if not MYPY:
    class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgsDict(TypedDict):
        allocation_strategy: str
        instance_pools_to_use_count: NotRequired[int]
elif False:
    GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: str,
                 instance_pools_to_use_count: Optional[int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: str):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[int]):
        pulumi.set(self, "instance_pools_to_use_count", value)


if not MYPY:
    class GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgsDict(TypedDict):
        availability_zone: str
        instance_type: str
elif False:
    GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: str,
                 instance_type: str):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: str):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: str):
        pulumi.set(self, "instance_type", value)


if not MYPY:
    class GetInstancePoolPoolInfoPreloadedDockerImageArgsDict(TypedDict):
        url: str
        basic_auth: NotRequired['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgsDict']
elif False:
    GetInstancePoolPoolInfoPreloadedDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoPreloadedDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgsDict(TypedDict):
        password: str
        username: str
elif False:
    GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetInstancePoolPoolInfoStatsArgsDict(TypedDict):
        idle_count: NotRequired[int]
        pending_idle_count: NotRequired[int]
        pending_used_count: NotRequired[int]
        used_count: NotRequired[int]
elif False:
    GetInstancePoolPoolInfoStatsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstancePoolPoolInfoStatsArgs:
    def __init__(__self__, *,
                 idle_count: Optional[int] = None,
                 pending_idle_count: Optional[int] = None,
                 pending_used_count: Optional[int] = None,
                 used_count: Optional[int] = None):
        if idle_count is not None:
            pulumi.set(__self__, "idle_count", idle_count)
        if pending_idle_count is not None:
            pulumi.set(__self__, "pending_idle_count", pending_idle_count)
        if pending_used_count is not None:
            pulumi.set(__self__, "pending_used_count", pending_used_count)
        if used_count is not None:
            pulumi.set(__self__, "used_count", used_count)

    @property
    @pulumi.getter(name="idleCount")
    def idle_count(self) -> Optional[int]:
        return pulumi.get(self, "idle_count")

    @idle_count.setter
    def idle_count(self, value: Optional[int]):
        pulumi.set(self, "idle_count", value)

    @property
    @pulumi.getter(name="pendingIdleCount")
    def pending_idle_count(self) -> Optional[int]:
        return pulumi.get(self, "pending_idle_count")

    @pending_idle_count.setter
    def pending_idle_count(self, value: Optional[int]):
        pulumi.set(self, "pending_idle_count", value)

    @property
    @pulumi.getter(name="pendingUsedCount")
    def pending_used_count(self) -> Optional[int]:
        return pulumi.get(self, "pending_used_count")

    @pending_used_count.setter
    def pending_used_count(self, value: Optional[int]):
        pulumi.set(self, "pending_used_count", value)

    @property
    @pulumi.getter(name="usedCount")
    def used_count(self) -> Optional[int]:
        return pulumi.get(self, "used_count")

    @used_count.setter
    def used_count(self, value: Optional[int]):
        pulumi.set(self, "used_count", value)


if not MYPY:
    class GetInstanceProfilesInstanceProfileArgsDict(TypedDict):
        arn: str
        """
        ARN of the instance profile.
        """
        is_meta: bool
        """
        Whether the instance profile is a meta instance profile or not.
        """
        name: str
        """
        Name of the instance profile.
        """
        role_arn: str
        """
        ARN of the role attached to the instance profile.
        """
elif False:
    GetInstanceProfilesInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInstanceProfilesInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: str,
                 is_meta: bool,
                 name: str,
                 role_arn: str):
        """
        :param str arn: ARN of the instance profile.
        :param bool is_meta: Whether the instance profile is a meta instance profile or not.
        :param str name: Name of the instance profile.
        :param str role_arn: ARN of the role attached to the instance profile.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "is_meta", is_meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        ARN of the instance profile.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: str):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isMeta")
    def is_meta(self) -> bool:
        """
        Whether the instance profile is a meta instance profile or not.
        """
        return pulumi.get(self, "is_meta")

    @is_meta.setter
    def is_meta(self, value: bool):
        pulumi.set(self, "is_meta", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the instance profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        ARN of the role attached to the instance profile.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: str):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class GetJobJobSettingsArgsDict(TypedDict):
        run_as_user_name: str
        created_time: NotRequired[int]
        creator_user_name: NotRequired[str]
        job_id: NotRequired[int]
        settings: NotRequired['GetJobJobSettingsSettingsArgsDict']
elif False:
    GetJobJobSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsArgs:
    def __init__(__self__, *,
                 run_as_user_name: str,
                 created_time: Optional[int] = None,
                 creator_user_name: Optional[str] = None,
                 job_id: Optional[int] = None,
                 settings: Optional['GetJobJobSettingsSettingsArgs'] = None):
        pulumi.set(__self__, "run_as_user_name", run_as_user_name)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if creator_user_name is not None:
            pulumi.set(__self__, "creator_user_name", creator_user_name)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> str:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: str):
        pulumi.set(self, "run_as_user_name", value)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[int]:
        return pulumi.get(self, "created_time")

    @created_time.setter
    def created_time(self, value: Optional[int]):
        pulumi.set(self, "created_time", value)

    @property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[str]:
        return pulumi.get(self, "creator_user_name")

    @creator_user_name.setter
    def creator_user_name(self, value: Optional[str]):
        pulumi.set(self, "creator_user_name", value)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[int]:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: Optional[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional['GetJobJobSettingsSettingsArgs']:
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional['GetJobJobSettingsSettingsArgs']):
        pulumi.set(self, "settings", value)


if not MYPY:
    class GetJobJobSettingsSettingsArgsDict(TypedDict):
        format: str
        run_as: 'GetJobJobSettingsSettingsRunAsArgsDict'
        continuous: NotRequired['GetJobJobSettingsSettingsContinuousArgsDict']
        dbt_task: NotRequired['GetJobJobSettingsSettingsDbtTaskArgsDict']
        deployment: NotRequired['GetJobJobSettingsSettingsDeploymentArgsDict']
        description: NotRequired[str]
        edit_mode: NotRequired[str]
        email_notifications: NotRequired['GetJobJobSettingsSettingsEmailNotificationsArgsDict']
        environments: NotRequired[Sequence['GetJobJobSettingsSettingsEnvironmentArgsDict']]
        existing_cluster_id: NotRequired[str]
        git_source: NotRequired['GetJobJobSettingsSettingsGitSourceArgsDict']
        health: NotRequired['GetJobJobSettingsSettingsHealthArgsDict']
        job_clusters: NotRequired[Sequence['GetJobJobSettingsSettingsJobClusterArgsDict']]
        libraries: NotRequired[Sequence['GetJobJobSettingsSettingsLibraryArgsDict']]
        max_concurrent_runs: NotRequired[int]
        max_retries: NotRequired[int]
        min_retry_interval_millis: NotRequired[int]
        name: NotRequired[str]
        """
        the job name of Job if the resource was matched by id.
        """
        new_cluster: NotRequired['GetJobJobSettingsSettingsNewClusterArgsDict']
        notebook_task: NotRequired['GetJobJobSettingsSettingsNotebookTaskArgsDict']
        notification_settings: NotRequired['GetJobJobSettingsSettingsNotificationSettingsArgsDict']
        parameters: NotRequired[Sequence['GetJobJobSettingsSettingsParameterArgsDict']]
        pipeline_task: NotRequired['GetJobJobSettingsSettingsPipelineTaskArgsDict']
        python_wheel_task: NotRequired['GetJobJobSettingsSettingsPythonWheelTaskArgsDict']
        queue: NotRequired['GetJobJobSettingsSettingsQueueArgsDict']
        retry_on_timeout: NotRequired[bool]
        run_job_task: NotRequired['GetJobJobSettingsSettingsRunJobTaskArgsDict']
        schedule: NotRequired['GetJobJobSettingsSettingsScheduleArgsDict']
        spark_jar_task: NotRequired['GetJobJobSettingsSettingsSparkJarTaskArgsDict']
        spark_python_task: NotRequired['GetJobJobSettingsSettingsSparkPythonTaskArgsDict']
        spark_submit_task: NotRequired['GetJobJobSettingsSettingsSparkSubmitTaskArgsDict']
        tags: NotRequired[Mapping[str, str]]
        tasks: NotRequired[Sequence['GetJobJobSettingsSettingsTaskArgsDict']]
        timeout_seconds: NotRequired[int]
        trigger: NotRequired['GetJobJobSettingsSettingsTriggerArgsDict']
        webhook_notifications: NotRequired['GetJobJobSettingsSettingsWebhookNotificationsArgsDict']
elif False:
    GetJobJobSettingsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsArgs:
    def __init__(__self__, *,
                 format: str,
                 run_as: 'GetJobJobSettingsSettingsRunAsArgs',
                 continuous: Optional['GetJobJobSettingsSettingsContinuousArgs'] = None,
                 dbt_task: Optional['GetJobJobSettingsSettingsDbtTaskArgs'] = None,
                 deployment: Optional['GetJobJobSettingsSettingsDeploymentArgs'] = None,
                 description: Optional[str] = None,
                 edit_mode: Optional[str] = None,
                 email_notifications: Optional['GetJobJobSettingsSettingsEmailNotificationsArgs'] = None,
                 environments: Optional[Sequence['GetJobJobSettingsSettingsEnvironmentArgs']] = None,
                 existing_cluster_id: Optional[str] = None,
                 git_source: Optional['GetJobJobSettingsSettingsGitSourceArgs'] = None,
                 health: Optional['GetJobJobSettingsSettingsHealthArgs'] = None,
                 job_clusters: Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']] = None,
                 libraries: Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']] = None,
                 max_concurrent_runs: Optional[int] = None,
                 max_retries: Optional[int] = None,
                 min_retry_interval_millis: Optional[int] = None,
                 name: Optional[str] = None,
                 new_cluster: Optional['GetJobJobSettingsSettingsNewClusterArgs'] = None,
                 notebook_task: Optional['GetJobJobSettingsSettingsNotebookTaskArgs'] = None,
                 notification_settings: Optional['GetJobJobSettingsSettingsNotificationSettingsArgs'] = None,
                 parameters: Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']] = None,
                 pipeline_task: Optional['GetJobJobSettingsSettingsPipelineTaskArgs'] = None,
                 python_wheel_task: Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs'] = None,
                 queue: Optional['GetJobJobSettingsSettingsQueueArgs'] = None,
                 retry_on_timeout: Optional[bool] = None,
                 run_job_task: Optional['GetJobJobSettingsSettingsRunJobTaskArgs'] = None,
                 schedule: Optional['GetJobJobSettingsSettingsScheduleArgs'] = None,
                 spark_jar_task: Optional['GetJobJobSettingsSettingsSparkJarTaskArgs'] = None,
                 spark_python_task: Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs'] = None,
                 spark_submit_task: Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs'] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tasks: Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']] = None,
                 timeout_seconds: Optional[int] = None,
                 trigger: Optional['GetJobJobSettingsSettingsTriggerArgs'] = None,
                 webhook_notifications: Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs'] = None):
        """
        :param str name: the job name of Job if the resource was matched by id.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "run_as", run_as)
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if edit_mode is not None:
            pulumi.set(__self__, "edit_mode", edit_mode)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if git_source is not None:
            pulumi.set(__self__, "git_source", git_source)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_clusters is not None:
            pulumi.set(__self__, "job_clusters", job_clusters)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: str):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="runAs")
    def run_as(self) -> 'GetJobJobSettingsSettingsRunAsArgs':
        return pulumi.get(self, "run_as")

    @run_as.setter
    def run_as(self, value: 'GetJobJobSettingsSettingsRunAsArgs'):
        pulumi.set(self, "run_as", value)

    @property
    @pulumi.getter
    def continuous(self) -> Optional['GetJobJobSettingsSettingsContinuousArgs']:
        return pulumi.get(self, "continuous")

    @continuous.setter
    def continuous(self, value: Optional['GetJobJobSettingsSettingsContinuousArgs']):
        pulumi.set(self, "continuous", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['GetJobJobSettingsSettingsDbtTaskArgs']:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional['GetJobJobSettingsSettingsDbtTaskArgs']):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional['GetJobJobSettingsSettingsDeploymentArgs']:
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional['GetJobJobSettingsSettingsDeploymentArgs']):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="editMode")
    def edit_mode(self) -> Optional[str]:
        return pulumi.get(self, "edit_mode")

    @edit_mode.setter
    def edit_mode(self, value: Optional[str]):
        pulumi.set(self, "edit_mode", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['GetJobJobSettingsSettingsEmailNotificationsArgs']:
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional['GetJobJobSettingsSettingsEmailNotificationsArgs']):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[Sequence['GetJobJobSettingsSettingsEnvironmentArgs']]:
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[Sequence['GetJobJobSettingsSettingsEnvironmentArgs']]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[str]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter(name="gitSource")
    def git_source(self) -> Optional['GetJobJobSettingsSettingsGitSourceArgs']:
        return pulumi.get(self, "git_source")

    @git_source.setter
    def git_source(self, value: Optional['GetJobJobSettingsSettingsGitSourceArgs']):
        pulumi.set(self, "git_source", value)

    @property
    @pulumi.getter
    def health(self) -> Optional['GetJobJobSettingsSettingsHealthArgs']:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional['GetJobJobSettingsSettingsHealthArgs']):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusters")
    def job_clusters(self) -> Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']]:
        return pulumi.get(self, "job_clusters")

    @job_clusters.setter
    def job_clusters(self, value: Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']]):
        pulumi.set(self, "job_clusters", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']]:
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrent_runs")

    @max_concurrent_runs.setter
    def max_concurrent_runs(self, value: Optional[int]):
        pulumi.set(self, "max_concurrent_runs", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[int]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['GetJobJobSettingsSettingsNewClusterArgs']:
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional['GetJobJobSettingsSettingsNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['GetJobJobSettingsSettingsNotebookTaskArgs']:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional['GetJobJobSettingsSettingsNotebookTaskArgs']):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['GetJobJobSettingsSettingsNotificationSettingsArgs']:
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional['GetJobJobSettingsSettingsNotificationSettingsArgs']):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['GetJobJobSettingsSettingsPipelineTaskArgs']:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional['GetJobJobSettingsSettingsPipelineTaskArgs']):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs']:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs']):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter
    def queue(self) -> Optional['GetJobJobSettingsSettingsQueueArgs']:
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: Optional['GetJobJobSettingsSettingsQueueArgs']):
        pulumi.set(self, "queue", value)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[bool]:
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: Optional[bool]):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['GetJobJobSettingsSettingsRunJobTaskArgs']:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional['GetJobJobSettingsSettingsRunJobTaskArgs']):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional['GetJobJobSettingsSettingsScheduleArgs']:
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional['GetJobJobSettingsSettingsScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['GetJobJobSettingsSettingsSparkJarTaskArgs']:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional['GetJobJobSettingsSettingsSparkJarTaskArgs']):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs']:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs']):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs']:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs']):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']]:
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']]):
        pulumi.set(self, "tasks", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[int]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional['GetJobJobSettingsSettingsTriggerArgs']:
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional['GetJobJobSettingsSettingsTriggerArgs']):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs']:
        return pulumi.get(self, "webhook_notifications")

    @webhook_notifications.setter
    def webhook_notifications(self, value: Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs']):
        pulumi.set(self, "webhook_notifications", value)


if not MYPY:
    class GetJobJobSettingsSettingsContinuousArgsDict(TypedDict):
        pause_status: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsContinuousArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsContinuousArgs:
    def __init__(__self__, *,
                 pause_status: Optional[str] = None):
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[str]):
        pulumi.set(self, "pause_status", value)


if not MYPY:
    class GetJobJobSettingsSettingsDbtTaskArgsDict(TypedDict):
        commands: Sequence[str]
        catalog: NotRequired[str]
        profiles_directory: NotRequired[str]
        project_directory: NotRequired[str]
        schema: NotRequired[str]
        source: NotRequired[str]
        warehouse_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsDbtTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsDbtTaskArgs:
    def __init__(__self__, *,
                 commands: Sequence[str],
                 catalog: Optional[str] = None,
                 profiles_directory: Optional[str] = None,
                 project_directory: Optional[str] = None,
                 schema: Optional[str] = None,
                 source: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[str]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[str]:
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[str]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[str]:
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[str]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsDeploymentArgsDict(TypedDict):
        kind: str
        metadata_file_path: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsDeploymentArgs:
    def __init__(__self__, *,
                 kind: str,
                 metadata_file_path: Optional[str] = None):
        pulumi.set(__self__, "kind", kind)
        if metadata_file_path is not None:
            pulumi.set(__self__, "metadata_file_path", metadata_file_path)

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[str]:
        return pulumi.get(self, "metadata_file_path")

    @metadata_file_path.setter
    def metadata_file_path(self, value: Optional[str]):
        pulumi.set(self, "metadata_file_path", value)


if not MYPY:
    class GetJobJobSettingsSettingsEmailNotificationsArgsDict(TypedDict):
        no_alert_for_skipped_runs: NotRequired[bool]
        on_duration_warning_threshold_exceededs: NotRequired[Sequence[str]]
        on_failures: NotRequired[Sequence[str]]
        on_starts: NotRequired[Sequence[str]]
        on_streaming_backlog_exceededs: NotRequired[Sequence[str]]
        on_successes: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsEmailNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsEmailNotificationsArgs:
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class GetJobJobSettingsSettingsEnvironmentArgsDict(TypedDict):
        environment_key: str
        spec: NotRequired['GetJobJobSettingsSettingsEnvironmentSpecArgsDict']
elif False:
    GetJobJobSettingsSettingsEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsEnvironmentArgs:
    def __init__(__self__, *,
                 environment_key: str,
                 spec: Optional['GetJobJobSettingsSettingsEnvironmentSpecArgs'] = None):
        pulumi.set(__self__, "environment_key", environment_key)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> str:
        return pulumi.get(self, "environment_key")

    @environment_key.setter
    def environment_key(self, value: str):
        pulumi.set(self, "environment_key", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional['GetJobJobSettingsSettingsEnvironmentSpecArgs']:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional['GetJobJobSettingsSettingsEnvironmentSpecArgs']):
        pulumi.set(self, "spec", value)


if not MYPY:
    class GetJobJobSettingsSettingsEnvironmentSpecArgsDict(TypedDict):
        client: str
        dependencies: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsEnvironmentSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsEnvironmentSpecArgs:
    def __init__(__self__, *,
                 client: str,
                 dependencies: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "client", client)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @property
    @pulumi.getter
    def client(self) -> str:
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: str):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "dependencies", value)


if not MYPY:
    class GetJobJobSettingsSettingsGitSourceArgsDict(TypedDict):
        url: str
        branch: NotRequired[str]
        commit: NotRequired[str]
        job_source: NotRequired['GetJobJobSettingsSettingsGitSourceJobSourceArgsDict']
        provider: NotRequired[str]
        tag: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsGitSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsGitSourceArgs:
    def __init__(__self__, *,
                 url: str,
                 branch: Optional[str] = None,
                 commit: Optional[str] = None,
                 job_source: Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs'] = None,
                 provider: Optional[str] = None,
                 tag: Optional[str] = None):
        pulumi.set(__self__, "url", url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if job_source is not None:
            pulumi.set(__self__, "job_source", job_source)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[str]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def commit(self) -> Optional[str]:
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: Optional[str]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter(name="jobSource")
    def job_source(self) -> Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs']:
        return pulumi.get(self, "job_source")

    @job_source.setter
    def job_source(self, value: Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs']):
        pulumi.set(self, "job_source", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[str]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class GetJobJobSettingsSettingsGitSourceJobSourceArgsDict(TypedDict):
        import_from_git_branch: str
        job_config_path: str
        dirty_state: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsGitSourceJobSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsGitSourceJobSourceArgs:
    def __init__(__self__, *,
                 import_from_git_branch: str,
                 job_config_path: str,
                 dirty_state: Optional[str] = None):
        pulumi.set(__self__, "import_from_git_branch", import_from_git_branch)
        pulumi.set(__self__, "job_config_path", job_config_path)
        if dirty_state is not None:
            pulumi.set(__self__, "dirty_state", dirty_state)

    @property
    @pulumi.getter(name="importFromGitBranch")
    def import_from_git_branch(self) -> str:
        return pulumi.get(self, "import_from_git_branch")

    @import_from_git_branch.setter
    def import_from_git_branch(self, value: str):
        pulumi.set(self, "import_from_git_branch", value)

    @property
    @pulumi.getter(name="jobConfigPath")
    def job_config_path(self) -> str:
        return pulumi.get(self, "job_config_path")

    @job_config_path.setter
    def job_config_path(self, value: str):
        pulumi.set(self, "job_config_path", value)

    @property
    @pulumi.getter(name="dirtyState")
    def dirty_state(self) -> Optional[str]:
        return pulumi.get(self, "dirty_state")

    @dirty_state.setter
    def dirty_state(self, value: Optional[str]):
        pulumi.set(self, "dirty_state", value)


if not MYPY:
    class GetJobJobSettingsSettingsHealthArgsDict(TypedDict):
        rules: Sequence['GetJobJobSettingsSettingsHealthRuleArgsDict']
elif False:
    GetJobJobSettingsSettingsHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsHealthArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetJobJobSettingsSettingsHealthRuleArgs']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetJobJobSettingsSettingsHealthRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetJobJobSettingsSettingsHealthRuleArgs']):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GetJobJobSettingsSettingsHealthRuleArgsDict(TypedDict):
        metric: str
        op: str
        value: int
elif False:
    GetJobJobSettingsSettingsHealthRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsHealthRuleArgs:
    def __init__(__self__, *,
                 metric: str,
                 op: str,
                 value: int):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: str):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterArgsDict(TypedDict):
        job_cluster_key: str
        new_cluster: 'GetJobJobSettingsSettingsJobClusterNewClusterArgsDict'
elif False:
    GetJobJobSettingsSettingsJobClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterArgs:
    def __init__(__self__, *,
                 job_cluster_key: str,
                 new_cluster: 'GetJobJobSettingsSettingsJobClusterNewClusterArgs'):
        pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        pulumi.set(__self__, "new_cluster", new_cluster)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> str:
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: str):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> 'GetJobJobSettingsSettingsJobClusterNewClusterArgs':
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: 'GetJobJobSettingsSettingsJobClusterNewClusterArgs'):
        pulumi.set(self, "new_cluster", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterArgsDict(TypedDict):
        driver_instance_pool_id: str
        driver_node_type_id: str
        enable_elastic_disk: bool
        enable_local_disk_encryption: bool
        node_type_id: str
        num_workers: int
        spark_version: str
        apply_policy_default_values: NotRequired[bool]
        autoscale: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgsDict']
        autotermination_minutes: NotRequired[int]
        aws_attributes: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgsDict']
        cluster_id: NotRequired[str]
        cluster_log_conf: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgsDict']
        cluster_mount_infos: NotRequired[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgsDict']]
        cluster_name: NotRequired[str]
        custom_tags: NotRequired[Mapping[str, str]]
        data_security_mode: NotRequired[str]
        docker_image: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgsDict']
        gcp_attributes: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgsDict']
        idempotency_token: NotRequired[str]
        init_scripts: NotRequired[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgsDict']]
        instance_pool_id: NotRequired[str]
        policy_id: NotRequired[str]
        runtime_engine: NotRequired[str]
        single_user_name: NotRequired[str]
        spark_conf: NotRequired[Mapping[str, str]]
        spark_env_vars: NotRequired[Mapping[str, str]]
        ssh_public_keys: NotRequired[Sequence[str]]
        workload_type: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgsDict']
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, str]] = None,
                 spark_env_vars: Optional[Mapping[str, str]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[int]
        min_workers: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        ebs_volume_count: NotRequired[int]
        ebs_volume_size: NotRequired[int]
        ebs_volume_type: NotRequired[str]
        first_on_demand: NotRequired[int]
        instance_profile_arn: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        first_on_demand: NotRequired[int]
        spot_bid_max_price: NotRequired[float]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3ArgsDict']
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: str
        network_filesystem_info: 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict'
        remote_mount_dir_path: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: str
        mount_options: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgsDict(TypedDict):
        url: str
        basic_auth: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgsDict']
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: str
        username: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        boot_disk_size: NotRequired[int]
        google_service_account: NotRequired[str]
        local_ssd_count: NotRequired[int]
        use_preemptible_executors: NotRequired[bool]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgsDict']
        dbfs: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgsDict']
        file: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgsDict']
        gcs: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3ArgsDict']
        volumes: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgsDict']
        workspace: NotRequired['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgsDict']
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgsDict'
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


if not MYPY:
    class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[bool]
        notebooks: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class GetJobJobSettingsSettingsLibraryArgsDict(TypedDict):
        cran: NotRequired['GetJobJobSettingsSettingsLibraryCranArgsDict']
        egg: NotRequired[str]
        jar: NotRequired[str]
        maven: NotRequired['GetJobJobSettingsSettingsLibraryMavenArgsDict']
        pypi: NotRequired['GetJobJobSettingsSettingsLibraryPypiArgsDict']
        requirements: NotRequired[str]
        whl: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional['GetJobJobSettingsSettingsLibraryCranArgs'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['GetJobJobSettingsSettingsLibraryMavenArgs'] = None,
                 pypi: Optional['GetJobJobSettingsSettingsLibraryPypiArgs'] = None,
                 requirements: Optional[str] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['GetJobJobSettingsSettingsLibraryCranArgs']:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional['GetJobJobSettingsSettingsLibraryCranArgs']):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[str]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[str]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional['GetJobJobSettingsSettingsLibraryMavenArgs']:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional['GetJobJobSettingsSettingsLibraryMavenArgs']):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional['GetJobJobSettingsSettingsLibraryPypiArgs']:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional['GetJobJobSettingsSettingsLibraryPypiArgs']):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[str]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[str]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[str]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class GetJobJobSettingsSettingsLibraryCranArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsLibraryCranArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsLibraryMavenArgsDict(TypedDict):
        coordinates: str
        exclusions: NotRequired[Sequence[str]]
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: str):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsLibraryPypiArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsLibraryPypiArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterArgsDict(TypedDict):
        driver_instance_pool_id: str
        driver_node_type_id: str
        enable_elastic_disk: bool
        enable_local_disk_encryption: bool
        node_type_id: str
        num_workers: int
        spark_version: str
        apply_policy_default_values: NotRequired[bool]
        autoscale: NotRequired['GetJobJobSettingsSettingsNewClusterAutoscaleArgsDict']
        autotermination_minutes: NotRequired[int]
        aws_attributes: NotRequired['GetJobJobSettingsSettingsNewClusterAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetJobJobSettingsSettingsNewClusterAzureAttributesArgsDict']
        cluster_id: NotRequired[str]
        cluster_log_conf: NotRequired['GetJobJobSettingsSettingsNewClusterClusterLogConfArgsDict']
        cluster_mount_infos: NotRequired[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgsDict']]
        cluster_name: NotRequired[str]
        custom_tags: NotRequired[Mapping[str, str]]
        data_security_mode: NotRequired[str]
        docker_image: NotRequired['GetJobJobSettingsSettingsNewClusterDockerImageArgsDict']
        gcp_attributes: NotRequired['GetJobJobSettingsSettingsNewClusterGcpAttributesArgsDict']
        idempotency_token: NotRequired[str]
        init_scripts: NotRequired[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgsDict']]
        instance_pool_id: NotRequired[str]
        policy_id: NotRequired[str]
        runtime_engine: NotRequired[str]
        single_user_name: NotRequired[str]
        spark_conf: NotRequired[Mapping[str, str]]
        spark_env_vars: NotRequired[Mapping[str, str]]
        ssh_public_keys: NotRequired[Sequence[str]]
        workload_type: NotRequired['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgsDict']
elif False:
    GetJobJobSettingsSettingsNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, str]] = None,
                 spark_env_vars: Optional[Mapping[str, str]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[int]
        min_workers: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        ebs_volume_count: NotRequired[int]
        ebs_volume_size: NotRequired[int]
        ebs_volume_type: NotRequired[str]
        first_on_demand: NotRequired[int]
        instance_profile_arn: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        first_on_demand: NotRequired[int]
        spot_bid_max_price: NotRequired[float]
elif False:
    GetJobJobSettingsSettingsNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsNewClusterClusterLogConfS3ArgsDict']
elif False:
    GetJobJobSettingsSettingsNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: str
        network_filesystem_info: 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict'
        remote_mount_dir_path: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: str
        mount_options: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterDockerImageArgsDict(TypedDict):
        url: str
        basic_auth: NotRequired['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgsDict']
elif False:
    GetJobJobSettingsSettingsNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: str
        username: str
elif False:
    GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        boot_disk_size: NotRequired[int]
        google_service_account: NotRequired[str]
        local_ssd_count: NotRequired[int]
        use_preemptible_executors: NotRequired[bool]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgsDict']
        dbfs: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgsDict']
        file: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptFileArgsDict']
        gcs: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptS3ArgsDict']
        volumes: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgsDict']
        workspace: NotRequired['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgsDict']
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptFileArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgsDict'
elif False:
    GetJobJobSettingsSettingsNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


if not MYPY:
    class GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[bool]
        notebooks: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class GetJobJobSettingsSettingsNotebookTaskArgsDict(TypedDict):
        notebook_path: str
        base_parameters: NotRequired[Mapping[str, str]]
        source: NotRequired[str]
        warehouse_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsNotebookTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, str]] = None,
                 source: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: str):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsNotificationSettingsArgsDict(TypedDict):
        no_alert_for_canceled_runs: NotRequired[bool]
        no_alert_for_skipped_runs: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 no_alert_for_canceled_runs: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None):
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


if not MYPY:
    class GetJobJobSettingsSettingsParameterArgsDict(TypedDict):
        default: str
        name: str
        """
        the job name of Job if the resource was matched by id.
        """
elif False:
    GetJobJobSettingsSettingsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsParameterArgs:
    def __init__(__self__, *,
                 default: str,
                 name: str):
        """
        :param str name: the job name of Job if the resource was matched by id.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> str:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: str):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetJobJobSettingsSettingsPipelineTaskArgsDict(TypedDict):
        pipeline_id: str
        full_refresh: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsPipelineTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: str,
                 full_refresh: Optional[bool] = None):
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: str):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[bool]:
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[bool]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class GetJobJobSettingsSettingsPythonWheelTaskArgsDict(TypedDict):
        entry_point: NotRequired[str]
        named_parameters: NotRequired[Mapping[str, str]]
        package_name: NotRequired[str]
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsPythonWheelTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, str]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[str]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsQueueArgsDict(TypedDict):
        enabled: bool
elif False:
    GetJobJobSettingsSettingsQueueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsQueueArgs:
    def __init__(__self__, *,
                 enabled: bool):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetJobJobSettingsSettingsRunAsArgsDict(TypedDict):
        service_principal_name: NotRequired[str]
        user_name: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsRunAsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsRunAsArgs:
    def __init__(__self__, *,
                 service_principal_name: Optional[str] = None,
                 user_name: Optional[str] = None):
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[str]:
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[str]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class GetJobJobSettingsSettingsRunJobTaskArgsDict(TypedDict):
        job_id: int
        job_parameters: NotRequired[Mapping[str, str]]
elif False:
    GetJobJobSettingsSettingsRunJobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: int,
                 job_parameters: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: int):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "job_parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsScheduleArgsDict(TypedDict):
        quartz_cron_expression: str
        timezone_id: str
        pause_status: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsScheduleArgs:
    def __init__(__self__, *,
                 quartz_cron_expression: str,
                 timezone_id: str,
                 pause_status: Optional[str] = None):
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> str:
        return pulumi.get(self, "quartz_cron_expression")

    @quartz_cron_expression.setter
    def quartz_cron_expression(self, value: str):
        pulumi.set(self, "quartz_cron_expression", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> str:
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: str):
        pulumi.set(self, "timezone_id", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[str]):
        pulumi.set(self, "pause_status", value)


if not MYPY:
    class GetJobJobSettingsSettingsSparkJarTaskArgsDict(TypedDict):
        jar_uri: NotRequired[str]
        main_class_name: NotRequired[str]
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsSparkJarTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[str]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[str]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsSparkPythonTaskArgsDict(TypedDict):
        python_file: str
        parameters: NotRequired[Sequence[str]]
        source: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsSparkPythonTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: str):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetJobJobSettingsSettingsSparkSubmitTaskArgsDict(TypedDict):
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsSparkSubmitTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskArgsDict(TypedDict):
        retry_on_timeout: bool
        task_key: str
        condition_task: NotRequired['GetJobJobSettingsSettingsTaskConditionTaskArgsDict']
        dbt_task: NotRequired['GetJobJobSettingsSettingsTaskDbtTaskArgsDict']
        depends_ons: NotRequired[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgsDict']]
        description: NotRequired[str]
        email_notifications: NotRequired['GetJobJobSettingsSettingsTaskEmailNotificationsArgsDict']
        environment_key: NotRequired[str]
        existing_cluster_id: NotRequired[str]
        for_each_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskArgsDict']
        health: NotRequired['GetJobJobSettingsSettingsTaskHealthArgsDict']
        job_cluster_key: NotRequired[str]
        libraries: NotRequired[Sequence['GetJobJobSettingsSettingsTaskLibraryArgsDict']]
        max_retries: NotRequired[int]
        min_retry_interval_millis: NotRequired[int]
        new_cluster: NotRequired['GetJobJobSettingsSettingsTaskNewClusterArgsDict']
        notebook_task: NotRequired['GetJobJobSettingsSettingsTaskNotebookTaskArgsDict']
        notification_settings: NotRequired['GetJobJobSettingsSettingsTaskNotificationSettingsArgsDict']
        pipeline_task: NotRequired['GetJobJobSettingsSettingsTaskPipelineTaskArgsDict']
        python_wheel_task: NotRequired['GetJobJobSettingsSettingsTaskPythonWheelTaskArgsDict']
        run_if: NotRequired[str]
        run_job_task: NotRequired['GetJobJobSettingsSettingsTaskRunJobTaskArgsDict']
        spark_jar_task: NotRequired['GetJobJobSettingsSettingsTaskSparkJarTaskArgsDict']
        spark_python_task: NotRequired['GetJobJobSettingsSettingsTaskSparkPythonTaskArgsDict']
        spark_submit_task: NotRequired['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgsDict']
        sql_task: NotRequired['GetJobJobSettingsSettingsTaskSqlTaskArgsDict']
        timeout_seconds: NotRequired[int]
        webhook_notifications: NotRequired['GetJobJobSettingsSettingsTaskWebhookNotificationsArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskArgs:
    def __init__(__self__, *,
                 retry_on_timeout: bool,
                 task_key: str,
                 condition_task: Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs'] = None,
                 dbt_task: Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs'] = None,
                 depends_ons: Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']] = None,
                 description: Optional[str] = None,
                 email_notifications: Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs'] = None,
                 environment_key: Optional[str] = None,
                 existing_cluster_id: Optional[str] = None,
                 for_each_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskArgs'] = None,
                 health: Optional['GetJobJobSettingsSettingsTaskHealthArgs'] = None,
                 job_cluster_key: Optional[str] = None,
                 libraries: Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']] = None,
                 max_retries: Optional[int] = None,
                 min_retry_interval_millis: Optional[int] = None,
                 new_cluster: Optional['GetJobJobSettingsSettingsTaskNewClusterArgs'] = None,
                 notebook_task: Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs'] = None,
                 notification_settings: Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs'] = None,
                 pipeline_task: Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs'] = None,
                 python_wheel_task: Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs'] = None,
                 run_if: Optional[str] = None,
                 run_job_task: Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs'] = None,
                 spark_jar_task: Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs'] = None,
                 spark_python_task: Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs'] = None,
                 spark_submit_task: Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs'] = None,
                 sql_task: Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs'] = None,
                 timeout_seconds: Optional[int] = None,
                 webhook_notifications: Optional['GetJobJobSettingsSettingsTaskWebhookNotificationsArgs'] = None):
        pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        pulumi.set(__self__, "task_key", task_key)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if for_each_task is not None:
            pulumi.set(__self__, "for_each_task", for_each_task)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> bool:
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: bool):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> str:
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: str):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs']:
        return pulumi.get(self, "condition_task")

    @condition_task.setter
    def condition_task(self, value: Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs']):
        pulumi.set(self, "condition_task", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs']:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs']):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']]:
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs']:
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs']):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[str]:
        return pulumi.get(self, "environment_key")

    @environment_key.setter
    def environment_key(self, value: Optional[str]):
        pulumi.set(self, "environment_key", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[str]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter(name="forEachTask")
    def for_each_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskArgs']:
        return pulumi.get(self, "for_each_task")

    @for_each_task.setter
    def for_each_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskArgs']):
        pulumi.set(self, "for_each_task", value)

    @property
    @pulumi.getter
    def health(self) -> Optional['GetJobJobSettingsSettingsTaskHealthArgs']:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional['GetJobJobSettingsSettingsTaskHealthArgs']):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[str]:
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[str]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']]:
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[int]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterArgs']:
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs']:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs']):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs']:
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs']):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs']:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs']):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs']:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs']):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[str]:
        return pulumi.get(self, "run_if")

    @run_if.setter
    def run_if(self, value: Optional[str]):
        pulumi.set(self, "run_if", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs']:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs']):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs']:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs']):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs']:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs']):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs']:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs']):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs']:
        return pulumi.get(self, "sql_task")

    @sql_task.setter
    def sql_task(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs']):
        pulumi.set(self, "sql_task", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[int]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['GetJobJobSettingsSettingsTaskWebhookNotificationsArgs']:
        return pulumi.get(self, "webhook_notifications")

    @webhook_notifications.setter
    def webhook_notifications(self, value: Optional['GetJobJobSettingsSettingsTaskWebhookNotificationsArgs']):
        pulumi.set(self, "webhook_notifications", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskConditionTaskArgsDict(TypedDict):
        left: str
        op: str
        right: str
elif False:
    GetJobJobSettingsSettingsTaskConditionTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskConditionTaskArgs:
    def __init__(__self__, *,
                 left: str,
                 op: str,
                 right: str):
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @property
    @pulumi.getter
    def left(self) -> str:
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: str):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def right(self) -> str:
        return pulumi.get(self, "right")

    @right.setter
    def right(self, value: str):
        pulumi.set(self, "right", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskDbtTaskArgsDict(TypedDict):
        commands: Sequence[str]
        catalog: NotRequired[str]
        profiles_directory: NotRequired[str]
        project_directory: NotRequired[str]
        schema: NotRequired[str]
        source: NotRequired[str]
        warehouse_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskDbtTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskDbtTaskArgs:
    def __init__(__self__, *,
                 commands: Sequence[str],
                 catalog: Optional[str] = None,
                 profiles_directory: Optional[str] = None,
                 project_directory: Optional[str] = None,
                 schema: Optional[str] = None,
                 source: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[str]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[str]:
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[str]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[str]:
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[str]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskDependsOnArgsDict(TypedDict):
        task_key: str
        outcome: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskDependsOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskDependsOnArgs:
    def __init__(__self__, *,
                 task_key: str,
                 outcome: Optional[str] = None):
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> str:
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: str):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter
    def outcome(self) -> Optional[str]:
        return pulumi.get(self, "outcome")

    @outcome.setter
    def outcome(self, value: Optional[str]):
        pulumi.set(self, "outcome", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskEmailNotificationsArgsDict(TypedDict):
        no_alert_for_skipped_runs: NotRequired[bool]
        on_duration_warning_threshold_exceededs: NotRequired[Sequence[str]]
        on_failures: NotRequired[Sequence[str]]
        on_starts: NotRequired[Sequence[str]]
        on_streaming_backlog_exceededs: NotRequired[Sequence[str]]
        on_successes: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskEmailNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskEmailNotificationsArgs:
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskArgsDict(TypedDict):
        inputs: str
        task: 'GetJobJobSettingsSettingsTaskForEachTaskTaskArgsDict'
        concurrency: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskArgs:
    def __init__(__self__, *,
                 inputs: str,
                 task: 'GetJobJobSettingsSettingsTaskForEachTaskTaskArgs',
                 concurrency: Optional[int] = None):
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "task", task)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)

    @property
    @pulumi.getter
    def inputs(self) -> str:
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: str):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter
    def task(self) -> 'GetJobJobSettingsSettingsTaskForEachTaskTaskArgs':
        return pulumi.get(self, "task")

    @task.setter
    def task(self, value: 'GetJobJobSettingsSettingsTaskForEachTaskTaskArgs'):
        pulumi.set(self, "task", value)

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[int]:
        return pulumi.get(self, "concurrency")

    @concurrency.setter
    def concurrency(self, value: Optional[int]):
        pulumi.set(self, "concurrency", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskArgsDict(TypedDict):
        retry_on_timeout: bool
        task_key: str
        condition_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgsDict']
        dbt_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgsDict']
        depends_ons: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgsDict']]
        description: NotRequired[str]
        email_notifications: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgsDict']
        environment_key: NotRequired[str]
        existing_cluster_id: NotRequired[str]
        health: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgsDict']
        job_cluster_key: NotRequired[str]
        libraries: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgsDict']]
        max_retries: NotRequired[int]
        min_retry_interval_millis: NotRequired[int]
        new_cluster: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgsDict']
        notebook_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgsDict']
        notification_settings: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgsDict']
        pipeline_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgsDict']
        python_wheel_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgsDict']
        run_if: NotRequired[str]
        run_job_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgsDict']
        spark_jar_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgsDict']
        spark_python_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgsDict']
        spark_submit_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgsDict']
        sql_task: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgsDict']
        timeout_seconds: NotRequired[int]
        webhook_notifications: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskArgs:
    def __init__(__self__, *,
                 retry_on_timeout: bool,
                 task_key: str,
                 condition_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgs'] = None,
                 dbt_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgs'] = None,
                 depends_ons: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgs']] = None,
                 description: Optional[str] = None,
                 email_notifications: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgs'] = None,
                 environment_key: Optional[str] = None,
                 existing_cluster_id: Optional[str] = None,
                 health: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgs'] = None,
                 job_cluster_key: Optional[str] = None,
                 libraries: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgs']] = None,
                 max_retries: Optional[int] = None,
                 min_retry_interval_millis: Optional[int] = None,
                 new_cluster: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgs'] = None,
                 notebook_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgs'] = None,
                 notification_settings: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgs'] = None,
                 pipeline_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgs'] = None,
                 python_wheel_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgs'] = None,
                 run_if: Optional[str] = None,
                 run_job_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgs'] = None,
                 spark_jar_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgs'] = None,
                 spark_python_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgs'] = None,
                 spark_submit_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgs'] = None,
                 sql_task: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgs'] = None,
                 timeout_seconds: Optional[int] = None,
                 webhook_notifications: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgs'] = None):
        pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        pulumi.set(__self__, "task_key", task_key)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> bool:
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: bool):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> str:
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: str):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgs']:
        return pulumi.get(self, "condition_task")

    @condition_task.setter
    def condition_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgs']):
        pulumi.set(self, "condition_task", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgs']:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgs']):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgs']]:
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgs']]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgs']:
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgs']):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[str]:
        return pulumi.get(self, "environment_key")

    @environment_key.setter
    def environment_key(self, value: Optional[str]):
        pulumi.set(self, "environment_key", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[str]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter
    def health(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgs']:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgs']):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[str]:
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[str]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgs']]:
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgs']]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[int]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgs']:
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgs']:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgs']):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgs']:
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgs']):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgs']:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgs']):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgs']:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgs']):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[str]:
        return pulumi.get(self, "run_if")

    @run_if.setter
    def run_if(self, value: Optional[str]):
        pulumi.set(self, "run_if", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgs']:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgs']):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgs']:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgs']):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgs']:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgs']):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgs']:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgs']):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgs']:
        return pulumi.get(self, "sql_task")

    @sql_task.setter
    def sql_task(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgs']):
        pulumi.set(self, "sql_task", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[int]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgs']:
        return pulumi.get(self, "webhook_notifications")

    @webhook_notifications.setter
    def webhook_notifications(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgs']):
        pulumi.set(self, "webhook_notifications", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgsDict(TypedDict):
        left: str
        op: str
        right: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskArgs:
    def __init__(__self__, *,
                 left: str,
                 op: str,
                 right: str):
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @property
    @pulumi.getter
    def left(self) -> str:
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: str):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def right(self) -> str:
        return pulumi.get(self, "right")

    @right.setter
    def right(self, value: str):
        pulumi.set(self, "right", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgsDict(TypedDict):
        commands: Sequence[str]
        catalog: NotRequired[str]
        profiles_directory: NotRequired[str]
        project_directory: NotRequired[str]
        schema: NotRequired[str]
        source: NotRequired[str]
        warehouse_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskArgs:
    def __init__(__self__, *,
                 commands: Sequence[str],
                 catalog: Optional[str] = None,
                 profiles_directory: Optional[str] = None,
                 project_directory: Optional[str] = None,
                 schema: Optional[str] = None,
                 source: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[str]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[str]:
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[str]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[str]:
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[str]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgsDict(TypedDict):
        task_key: str
        outcome: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnArgs:
    def __init__(__self__, *,
                 task_key: str,
                 outcome: Optional[str] = None):
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> str:
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: str):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter
    def outcome(self) -> Optional[str]:
        return pulumi.get(self, "outcome")

    @outcome.setter
    def outcome(self, value: Optional[str]):
        pulumi.set(self, "outcome", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgsDict(TypedDict):
        no_alert_for_skipped_runs: NotRequired[bool]
        on_duration_warning_threshold_exceededs: NotRequired[Sequence[str]]
        on_failures: NotRequired[Sequence[str]]
        on_starts: NotRequired[Sequence[str]]
        on_streaming_backlog_exceededs: NotRequired[Sequence[str]]
        on_successes: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsArgs:
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgsDict(TypedDict):
        rules: Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskHealthArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgs']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgs']):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgsDict(TypedDict):
        metric: str
        op: str
        value: int
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleArgs:
    def __init__(__self__, *,
                 metric: str,
                 op: str,
                 value: int):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: str):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgsDict(TypedDict):
        cran: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgsDict']
        egg: NotRequired[str]
        jar: NotRequired[str]
        maven: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgsDict']
        pypi: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgsDict']
        requirements: NotRequired[str]
        whl: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgs'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgs'] = None,
                 pypi: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgs'] = None,
                 requirements: Optional[str] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgs']:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgs']):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[str]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[str]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgs']:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgs']):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgs']:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgs']):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[str]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[str]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[str]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgsDict(TypedDict):
        coordinates: str
        exclusions: NotRequired[Sequence[str]]
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: str):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgsDict(TypedDict):
        driver_instance_pool_id: str
        driver_node_type_id: str
        enable_elastic_disk: bool
        enable_local_disk_encryption: bool
        node_type_id: str
        num_workers: int
        spark_version: str
        apply_policy_default_values: NotRequired[bool]
        autoscale: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgsDict']
        autotermination_minutes: NotRequired[int]
        aws_attributes: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgsDict']
        cluster_id: NotRequired[str]
        cluster_log_conf: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgsDict']
        cluster_mount_infos: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict']]
        cluster_name: NotRequired[str]
        custom_tags: NotRequired[Mapping[str, str]]
        data_security_mode: NotRequired[str]
        docker_image: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgsDict']
        gcp_attributes: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgsDict']
        idempotency_token: NotRequired[str]
        init_scripts: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgsDict']]
        instance_pool_id: NotRequired[str]
        policy_id: NotRequired[str]
        runtime_engine: NotRequired[str]
        single_user_name: NotRequired[str]
        spark_conf: NotRequired[Mapping[str, str]]
        spark_env_vars: NotRequired[Mapping[str, str]]
        ssh_public_keys: NotRequired[Sequence[str]]
        workload_type: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, str]] = None,
                 spark_env_vars: Optional[Mapping[str, str]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgs'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[int]
        min_workers: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        ebs_volume_count: NotRequired[int]
        ebs_volume_size: NotRequired[int]
        ebs_volume_type: NotRequired[str]
        first_on_demand: NotRequired[int]
        instance_profile_arn: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        first_on_demand: NotRequired[int]
        spot_bid_max_price: NotRequired[float]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Args'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: str
        network_filesystem_info: 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict'
        remote_mount_dir_path: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: str
        mount_options: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgsDict(TypedDict):
        url: str
        basic_auth: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: str
        username: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        boot_disk_size: NotRequired[int]
        google_service_account: NotRequired[str]
        local_ssd_count: NotRequired[int]
        use_preemptible_executors: NotRequired[bool]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict']
        dbfs: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict']
        file: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgsDict']
        gcs: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict']
        volumes: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict']
        workspace: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict'
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[bool]
        notebooks: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgsDict(TypedDict):
        notebook_path: str
        base_parameters: NotRequired[Mapping[str, str]]
        source: NotRequired[str]
        warehouse_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, str]] = None,
                 source: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: str):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgsDict(TypedDict):
        alert_on_last_attempt: NotRequired[bool]
        no_alert_for_canceled_runs: NotRequired[bool]
        no_alert_for_skipped_runs: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_canceled_runs: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None):
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[bool]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgsDict(TypedDict):
        pipeline_id: str
        full_refresh: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: str,
                 full_refresh: Optional[bool] = None):
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: str):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[bool]:
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[bool]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgsDict(TypedDict):
        entry_point: NotRequired[str]
        named_parameters: NotRequired[Mapping[str, str]]
        package_name: NotRequired[str]
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, str]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[str]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgsDict(TypedDict):
        job_id: int
        job_parameters: NotRequired[Mapping[str, str]]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: int,
                 job_parameters: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: int):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "job_parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgsDict(TypedDict):
        jar_uri: NotRequired[str]
        main_class_name: NotRequired[str]
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[str]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[str]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgsDict(TypedDict):
        python_file: str
        parameters: NotRequired[Sequence[str]]
        source: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: str):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgsDict(TypedDict):
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgsDict(TypedDict):
        warehouse_id: str
        alert: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgsDict']
        dashboard: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgsDict']
        file: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgsDict']
        parameters: NotRequired[Mapping[str, str]]
        query: NotRequired['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskArgs:
    def __init__(__self__, *,
                 warehouse_id: str,
                 alert: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgs'] = None,
                 dashboard: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgs'] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 query: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgs'] = None):
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> str:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: str):
        pulumi.set(self, "warehouse_id", value)

    @property
    @pulumi.getter
    def alert(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgs']:
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgs']):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def query(self) -> Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgs']:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgs']):
        pulumi.set(self, "query", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgsDict(TypedDict):
        alert_id: str
        pause_subscriptions: NotRequired[bool]
        subscriptions: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict']]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertArgs:
    def __init__(__self__, *,
                 alert_id: str,
                 pause_subscriptions: Optional[bool] = None,
                 subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: str):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[bool]:
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[bool]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']]:
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs']]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[str]
        user_name: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgsDict(TypedDict):
        dashboard_id: str
        custom_subject: NotRequired[str]
        pause_subscriptions: NotRequired[bool]
        subscriptions: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict']]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: str,
                 custom_subject: Optional[str] = None,
                 pause_subscriptions: Optional[bool] = None,
                 subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']] = None):
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> str:
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: str):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[str]:
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[str]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[bool]:
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[bool]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']]:
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs']]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[str]
        user_name: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgsDict(TypedDict):
        path: str
        source: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileArgs:
    def __init__(__self__, *,
                 path: str,
                 source: Optional[str] = None):
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgsDict(TypedDict):
        query_id: str
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryArgs:
    def __init__(__self__, *,
                 query_id: str):
        pulumi.set(__self__, "query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: str):
        pulumi.set(self, "query_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgsDict(TypedDict):
        on_duration_warning_threshold_exceededs: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict']]
        on_failures: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict']]
        on_starts: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict']]
        on_streaming_backlog_exceededs: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict']]
        on_successes: NotRequired[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict']]
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']] = None,
                 on_failures: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']] = None,
                 on_starts: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgs']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs']] = None,
                 on_successes: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']] = None):
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgs']]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgs']]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgs']]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs']]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskHealthArgsDict(TypedDict):
        rules: Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskHealthArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']):
        pulumi.set(self, "rules", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskHealthRuleArgsDict(TypedDict):
        metric: str
        op: str
        value: int
elif False:
    GetJobJobSettingsSettingsTaskHealthRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskHealthRuleArgs:
    def __init__(__self__, *,
                 metric: str,
                 op: str,
                 value: int):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: str):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: int):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskLibraryArgsDict(TypedDict):
        cran: NotRequired['GetJobJobSettingsSettingsTaskLibraryCranArgsDict']
        egg: NotRequired[str]
        jar: NotRequired[str]
        maven: NotRequired['GetJobJobSettingsSettingsTaskLibraryMavenArgsDict']
        pypi: NotRequired['GetJobJobSettingsSettingsTaskLibraryPypiArgsDict']
        requirements: NotRequired[str]
        whl: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskLibraryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs'] = None,
                 pypi: Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs'] = None,
                 requirements: Optional[str] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs']:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs']):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[str]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[str]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs']:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs']):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs']:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs']):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[str]:
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[str]):
        pulumi.set(self, "requirements", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[str]):
        pulumi.set(self, "whl", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskLibraryCranArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskLibraryCranArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryCranArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskLibraryMavenArgsDict(TypedDict):
        coordinates: str
        exclusions: NotRequired[Sequence[str]]
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskLibraryMavenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: str):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskLibraryPypiArgsDict(TypedDict):
        package: str
        repo: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskLibraryPypiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryPypiArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterArgsDict(TypedDict):
        driver_instance_pool_id: str
        driver_node_type_id: str
        enable_elastic_disk: bool
        enable_local_disk_encryption: bool
        node_type_id: str
        num_workers: int
        spark_version: str
        apply_policy_default_values: NotRequired[bool]
        autoscale: NotRequired['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgsDict']
        autotermination_minutes: NotRequired[int]
        aws_attributes: NotRequired['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgsDict']
        azure_attributes: NotRequired['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgsDict']
        cluster_id: NotRequired[str]
        cluster_log_conf: NotRequired['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgsDict']
        cluster_mount_infos: NotRequired[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgsDict']]
        cluster_name: NotRequired[str]
        custom_tags: NotRequired[Mapping[str, str]]
        data_security_mode: NotRequired[str]
        docker_image: NotRequired['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgsDict']
        gcp_attributes: NotRequired['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgsDict']
        idempotency_token: NotRequired[str]
        init_scripts: NotRequired[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgsDict']]
        instance_pool_id: NotRequired[str]
        policy_id: NotRequired[str]
        runtime_engine: NotRequired[str]
        single_user_name: NotRequired[str]
        spark_conf: NotRequired[Mapping[str, str]]
        spark_env_vars: NotRequired[Mapping[str, str]]
        ssh_public_keys: NotRequired[Sequence[str]]
        workload_type: NotRequired['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskNewClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, str]] = None,
                 spark_env_vars: Optional[Mapping[str, str]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgsDict(TypedDict):
        max_workers: NotRequired[int]
        min_workers: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        ebs_volume_count: NotRequired[int]
        ebs_volume_size: NotRequired[int]
        ebs_volume_type: NotRequired[str]
        first_on_demand: NotRequired[int]
        instance_profile_arn: NotRequired[str]
        spot_bid_price_percent: NotRequired[int]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        first_on_demand: NotRequired[int]
        spot_bid_max_price: NotRequired[float]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgsDict(TypedDict):
        dbfs: NotRequired['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3ArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgsDict(TypedDict):
        local_mount_dir_path: str
        network_filesystem_info: 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict'
        remote_mount_dir_path: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict(TypedDict):
        server_address: str
        mount_options: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterDockerImageArgsDict(TypedDict):
        url: str
        basic_auth: NotRequired['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskNewClusterDockerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgsDict(TypedDict):
        password: str
        username: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgsDict(TypedDict):
        availability: NotRequired[str]
        boot_disk_size: NotRequired[int]
        google_service_account: NotRequired[str]
        local_ssd_count: NotRequired[int]
        use_preemptible_executors: NotRequired[bool]
        zone_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptArgsDict(TypedDict):
        abfss: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgsDict']
        dbfs: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgsDict']
        file: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgsDict']
        gcs: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgsDict']
        s3: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3ArgsDict']
        volumes: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgsDict']
        workspace: NotRequired['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptS3ArgsDict(TypedDict):
        destination: str
        canned_acl: NotRequired[str]
        enable_encryption: NotRequired[bool]
        encryption_type: NotRequired[str]
        endpoint: NotRequired[str]
        kms_key: NotRequired[str]
        region: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgsDict(TypedDict):
        destination: str
elif False:
    GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgsDict(TypedDict):
        clients: 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgsDict'
elif False:
    GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgsDict(TypedDict):
        jobs: NotRequired[bool]
        notebooks: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNotebookTaskArgsDict(TypedDict):
        notebook_path: str
        base_parameters: NotRequired[Mapping[str, str]]
        source: NotRequired[str]
        warehouse_id: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskNotebookTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, str]] = None,
                 source: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: str):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskNotificationSettingsArgsDict(TypedDict):
        alert_on_last_attempt: NotRequired[bool]
        no_alert_for_canceled_runs: NotRequired[bool]
        no_alert_for_skipped_runs: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsTaskNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskNotificationSettingsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_canceled_runs: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None):
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[bool]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskPipelineTaskArgsDict(TypedDict):
        pipeline_id: str
        full_refresh: NotRequired[bool]
elif False:
    GetJobJobSettingsSettingsTaskPipelineTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: str,
                 full_refresh: Optional[bool] = None):
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: str):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[bool]:
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[bool]):
        pulumi.set(self, "full_refresh", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskPythonWheelTaskArgsDict(TypedDict):
        entry_point: NotRequired[str]
        named_parameters: NotRequired[Mapping[str, str]]
        package_name: NotRequired[str]
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskPythonWheelTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, str]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[str]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskRunJobTaskArgsDict(TypedDict):
        job_id: int
        job_parameters: NotRequired[Mapping[str, str]]
elif False:
    GetJobJobSettingsSettingsTaskRunJobTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: int,
                 job_parameters: Optional[Mapping[str, str]] = None):
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: int):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "job_parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSparkJarTaskArgsDict(TypedDict):
        jar_uri: NotRequired[str]
        main_class_name: NotRequired[str]
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskSparkJarTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[str]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[str]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSparkPythonTaskArgsDict(TypedDict):
        python_file: str
        parameters: NotRequired[Sequence[str]]
        source: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskSparkPythonTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None,
                 source: Optional[str] = None):
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: str):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSparkSubmitTaskArgsDict(TypedDict):
        parameters: NotRequired[Sequence[str]]
elif False:
    GetJobJobSettingsSettingsTaskSparkSubmitTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskArgsDict(TypedDict):
        warehouse_id: str
        alert: NotRequired['GetJobJobSettingsSettingsTaskSqlTaskAlertArgsDict']
        dashboard: NotRequired['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgsDict']
        file: NotRequired['GetJobJobSettingsSettingsTaskSqlTaskFileArgsDict']
        parameters: NotRequired[Mapping[str, str]]
        query: NotRequired['GetJobJobSettingsSettingsTaskSqlTaskQueryArgsDict']
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskArgs:
    def __init__(__self__, *,
                 warehouse_id: str,
                 alert: Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs'] = None,
                 dashboard: Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs'] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 query: Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs'] = None):
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> str:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: str):
        pulumi.set(self, "warehouse_id", value)

    @property
    @pulumi.getter
    def alert(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs']:
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs']):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def query(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs']:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs']):
        pulumi.set(self, "query", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskAlertArgsDict(TypedDict):
        alert_id: str
        pause_subscriptions: NotRequired[bool]
        subscriptions: NotRequired[Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgsDict']]
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskAlertArgs:
    def __init__(__self__, *,
                 alert_id: str,
                 pause_subscriptions: Optional[bool] = None,
                 subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs']] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: str):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[bool]:
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[bool]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs']]:
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs']]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[str]
        user_name: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskDashboardArgsDict(TypedDict):
        dashboard_id: str
        custom_subject: NotRequired[str]
        pause_subscriptions: NotRequired[bool]
        subscriptions: NotRequired[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgsDict']]
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: str,
                 custom_subject: Optional[str] = None,
                 pause_subscriptions: Optional[bool] = None,
                 subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']] = None):
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> str:
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: str):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[str]:
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[str]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[bool]:
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[bool]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']]:
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']]):
        pulumi.set(self, "subscriptions", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgsDict(TypedDict):
        destination_id: NotRequired[str]
        user_name: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskFileArgsDict(TypedDict):
        path: str
        source: NotRequired[str]
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskFileArgs:
    def __init__(__self__, *,
                 path: str,
                 source: Optional[str] = None):
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskSqlTaskQueryArgsDict(TypedDict):
        query_id: str
elif False:
    GetJobJobSettingsSettingsTaskSqlTaskQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskQueryArgs:
    def __init__(__self__, *,
                 query_id: str):
        pulumi.set(__self__, "query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: str):
        pulumi.set(self, "query_id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskWebhookNotificationsArgsDict(TypedDict):
        on_duration_warning_threshold_exceededs: NotRequired[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict']]
        on_failures: NotRequired[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgsDict']]
        on_starts: NotRequired[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgsDict']]
        on_streaming_backlog_exceededs: NotRequired[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict']]
        on_successes: NotRequired[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgsDict']]
elif False:
    GetJobJobSettingsSettingsTaskWebhookNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']] = None,
                 on_failures: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgs']] = None,
                 on_starts: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgs']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgs']] = None,
                 on_successes: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgs']] = None):
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs']]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgs']]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgs']]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgs']]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgs']]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgs']]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgs']]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgs']]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsTriggerArgsDict(TypedDict):
        file_arrival: NotRequired['GetJobJobSettingsSettingsTriggerFileArrivalArgsDict']
        pause_status: NotRequired[str]
        periodic: NotRequired['GetJobJobSettingsSettingsTriggerPeriodicArgsDict']
        table_update: NotRequired['GetJobJobSettingsSettingsTriggerTableUpdateArgsDict']
elif False:
    GetJobJobSettingsSettingsTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTriggerArgs:
    def __init__(__self__, *,
                 file_arrival: Optional['GetJobJobSettingsSettingsTriggerFileArrivalArgs'] = None,
                 pause_status: Optional[str] = None,
                 periodic: Optional['GetJobJobSettingsSettingsTriggerPeriodicArgs'] = None,
                 table_update: Optional['GetJobJobSettingsSettingsTriggerTableUpdateArgs'] = None):
        if file_arrival is not None:
            pulumi.set(__self__, "file_arrival", file_arrival)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)
        if periodic is not None:
            pulumi.set(__self__, "periodic", periodic)
        if table_update is not None:
            pulumi.set(__self__, "table_update", table_update)

    @property
    @pulumi.getter(name="fileArrival")
    def file_arrival(self) -> Optional['GetJobJobSettingsSettingsTriggerFileArrivalArgs']:
        return pulumi.get(self, "file_arrival")

    @file_arrival.setter
    def file_arrival(self, value: Optional['GetJobJobSettingsSettingsTriggerFileArrivalArgs']):
        pulumi.set(self, "file_arrival", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[str]):
        pulumi.set(self, "pause_status", value)

    @property
    @pulumi.getter
    def periodic(self) -> Optional['GetJobJobSettingsSettingsTriggerPeriodicArgs']:
        return pulumi.get(self, "periodic")

    @periodic.setter
    def periodic(self, value: Optional['GetJobJobSettingsSettingsTriggerPeriodicArgs']):
        pulumi.set(self, "periodic", value)

    @property
    @pulumi.getter(name="tableUpdate")
    def table_update(self) -> Optional['GetJobJobSettingsSettingsTriggerTableUpdateArgs']:
        return pulumi.get(self, "table_update")

    @table_update.setter
    def table_update(self, value: Optional['GetJobJobSettingsSettingsTriggerTableUpdateArgs']):
        pulumi.set(self, "table_update", value)


if not MYPY:
    class GetJobJobSettingsSettingsTriggerFileArrivalArgsDict(TypedDict):
        url: str
        min_time_between_triggers_seconds: NotRequired[int]
        wait_after_last_change_seconds: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsTriggerFileArrivalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTriggerFileArrivalArgs:
    def __init__(__self__, *,
                 url: str,
                 min_time_between_triggers_seconds: Optional[int] = None,
                 wait_after_last_change_seconds: Optional[int] = None):
        pulumi.set(__self__, "url", url)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[int]:
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[int]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[int]:
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[int]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


if not MYPY:
    class GetJobJobSettingsSettingsTriggerPeriodicArgsDict(TypedDict):
        interval: int
        unit: str
elif False:
    GetJobJobSettingsSettingsTriggerPeriodicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTriggerPeriodicArgs:
    def __init__(__self__, *,
                 interval: int,
                 unit: str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: int):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: str):
        pulumi.set(self, "unit", value)


if not MYPY:
    class GetJobJobSettingsSettingsTriggerTableUpdateArgsDict(TypedDict):
        table_names: Sequence[str]
        condition: NotRequired[str]
        min_time_between_triggers_seconds: NotRequired[int]
        wait_after_last_change_seconds: NotRequired[int]
elif False:
    GetJobJobSettingsSettingsTriggerTableUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsTriggerTableUpdateArgs:
    def __init__(__self__, *,
                 table_names: Sequence[str],
                 condition: Optional[str] = None,
                 min_time_between_triggers_seconds: Optional[int] = None,
                 wait_after_last_change_seconds: Optional[int] = None):
        pulumi.set(__self__, "table_names", table_names)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Sequence[str]:
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: Sequence[str]):
        pulumi.set(self, "table_names", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[int]:
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[int]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[int]:
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[int]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


if not MYPY:
    class GetJobJobSettingsSettingsWebhookNotificationsArgsDict(TypedDict):
        on_duration_warning_threshold_exceededs: NotRequired[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgsDict']]
        on_failures: NotRequired[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgsDict']]
        on_starts: NotRequired[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgsDict']]
        on_streaming_backlog_exceededs: NotRequired[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgsDict']]
        on_successes: NotRequired[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgsDict']]
elif False:
    GetJobJobSettingsSettingsWebhookNotificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']] = None,
                 on_failures: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']] = None,
                 on_starts: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgs']] = None,
                 on_successes: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']] = None):
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgs']]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @on_streaming_backlog_exceededs.setter
    def on_streaming_backlog_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgs']]):
        pulumi.set(self, "on_streaming_backlog_exceededs", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']]):
        pulumi.set(self, "on_successes", value)


if not MYPY:
    class GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsWebhookNotificationsOnStartArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsWebhookNotificationsOnStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgsDict(TypedDict):
        id: str
        """
        the id of Job if the resource was matched by name.
        """
elif False:
    GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetMetastoreMetastoreInfoArgsDict(TypedDict):
        cloud: NotRequired[str]
        created_at: NotRequired[int]
        created_by: NotRequired[str]
        default_data_access_config_id: NotRequired[str]
        delta_sharing_organization_name: NotRequired[str]
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        delta_sharing_recipient_token_lifetime_in_seconds: NotRequired[int]
        """
        Used to set expiration duration in seconds on recipient data access tokens.
        """
        delta_sharing_scope: NotRequired[str]
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        """
        external_access_enabled: NotRequired[bool]
        global_metastore_id: NotRequired[str]
        metastore_id: NotRequired[str]
        """
        ID of the metastore
        """
        name: NotRequired[str]
        """
        Name of the metastore
        """
        owner: NotRequired[str]
        """
        Username/groupname/sp application_id of the metastore owner.
        """
        privilege_model_version: NotRequired[str]
        region: NotRequired[str]
        """
        Region of the metastore
        """
        storage_root: NotRequired[str]
        """
        Path on cloud storage account, where managed `Table` are stored.
        """
        storage_root_credential_id: NotRequired[str]
        storage_root_credential_name: NotRequired[str]
        updated_at: NotRequired[int]
        updated_by: NotRequired[str]
elif False:
    GetMetastoreMetastoreInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMetastoreMetastoreInfoArgs:
    def __init__(__self__, *,
                 cloud: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 default_data_access_config_id: Optional[str] = None,
                 delta_sharing_organization_name: Optional[str] = None,
                 delta_sharing_recipient_token_lifetime_in_seconds: Optional[int] = None,
                 delta_sharing_scope: Optional[str] = None,
                 external_access_enabled: Optional[bool] = None,
                 global_metastore_id: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 privilege_model_version: Optional[str] = None,
                 region: Optional[str] = None,
                 storage_root: Optional[str] = None,
                 storage_root_credential_id: Optional[str] = None,
                 storage_root_credential_name: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param str delta_sharing_organization_name: The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        :param int delta_sharing_recipient_token_lifetime_in_seconds: Used to set expiration duration in seconds on recipient data access tokens.
        :param str delta_sharing_scope: Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        :param str metastore_id: ID of the metastore
        :param str name: Name of the metastore
        :param str owner: Username/groupname/sp application_id of the metastore owner.
        :param str region: Region of the metastore
        :param str storage_root: Path on cloud storage account, where managed `Table` are stored.
        """
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if default_data_access_config_id is not None:
            pulumi.set(__self__, "default_data_access_config_id", default_data_access_config_id)
        if delta_sharing_organization_name is not None:
            pulumi.set(__self__, "delta_sharing_organization_name", delta_sharing_organization_name)
        if delta_sharing_recipient_token_lifetime_in_seconds is not None:
            pulumi.set(__self__, "delta_sharing_recipient_token_lifetime_in_seconds", delta_sharing_recipient_token_lifetime_in_seconds)
        if delta_sharing_scope is not None:
            pulumi.set(__self__, "delta_sharing_scope", delta_sharing_scope)
        if external_access_enabled is not None:
            pulumi.set(__self__, "external_access_enabled", external_access_enabled)
        if global_metastore_id is not None:
            pulumi.set(__self__, "global_metastore_id", global_metastore_id)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if privilege_model_version is not None:
            pulumi.set(__self__, "privilege_model_version", privilege_model_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if storage_root_credential_id is not None:
            pulumi.set(__self__, "storage_root_credential_id", storage_root_credential_id)
        if storage_root_credential_name is not None:
            pulumi.set(__self__, "storage_root_credential_name", storage_root_credential_name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter
    def cloud(self) -> Optional[str]:
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[str]):
        pulumi.set(self, "cloud", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="defaultDataAccessConfigId")
    def default_data_access_config_id(self) -> Optional[str]:
        return pulumi.get(self, "default_data_access_config_id")

    @default_data_access_config_id.setter
    def default_data_access_config_id(self, value: Optional[str]):
        pulumi.set(self, "default_data_access_config_id", value)

    @property
    @pulumi.getter(name="deltaSharingOrganizationName")
    def delta_sharing_organization_name(self) -> Optional[str]:
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        return pulumi.get(self, "delta_sharing_organization_name")

    @delta_sharing_organization_name.setter
    def delta_sharing_organization_name(self, value: Optional[str]):
        pulumi.set(self, "delta_sharing_organization_name", value)

    @property
    @pulumi.getter(name="deltaSharingRecipientTokenLifetimeInSeconds")
    def delta_sharing_recipient_token_lifetime_in_seconds(self) -> Optional[int]:
        """
        Used to set expiration duration in seconds on recipient data access tokens.
        """
        return pulumi.get(self, "delta_sharing_recipient_token_lifetime_in_seconds")

    @delta_sharing_recipient_token_lifetime_in_seconds.setter
    def delta_sharing_recipient_token_lifetime_in_seconds(self, value: Optional[int]):
        pulumi.set(self, "delta_sharing_recipient_token_lifetime_in_seconds", value)

    @property
    @pulumi.getter(name="deltaSharingScope")
    def delta_sharing_scope(self) -> Optional[str]:
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        """
        return pulumi.get(self, "delta_sharing_scope")

    @delta_sharing_scope.setter
    def delta_sharing_scope(self, value: Optional[str]):
        pulumi.set(self, "delta_sharing_scope", value)

    @property
    @pulumi.getter(name="externalAccessEnabled")
    def external_access_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "external_access_enabled")

    @external_access_enabled.setter
    def external_access_enabled(self, value: Optional[bool]):
        pulumi.set(self, "external_access_enabled", value)

    @property
    @pulumi.getter(name="globalMetastoreId")
    def global_metastore_id(self) -> Optional[str]:
        return pulumi.get(self, "global_metastore_id")

    @global_metastore_id.setter
    def global_metastore_id(self, value: Optional[str]):
        pulumi.set(self, "global_metastore_id", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        ID of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the metastore
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Username/groupname/sp application_id of the metastore owner.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="privilegeModelVersion")
    def privilege_model_version(self) -> Optional[str]:
        return pulumi.get(self, "privilege_model_version")

    @privilege_model_version.setter
    def privilege_model_version(self, value: Optional[str]):
        pulumi.set(self, "privilege_model_version", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region of the metastore
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[str]:
        """
        Path on cloud storage account, where managed `Table` are stored.
        """
        return pulumi.get(self, "storage_root")

    @storage_root.setter
    def storage_root(self, value: Optional[str]):
        pulumi.set(self, "storage_root", value)

    @property
    @pulumi.getter(name="storageRootCredentialId")
    def storage_root_credential_id(self) -> Optional[str]:
        return pulumi.get(self, "storage_root_credential_id")

    @storage_root_credential_id.setter
    def storage_root_credential_id(self, value: Optional[str]):
        pulumi.set(self, "storage_root_credential_id", value)

    @property
    @pulumi.getter(name="storageRootCredentialName")
    def storage_root_credential_name(self) -> Optional[str]:
        return pulumi.get(self, "storage_root_credential_name")

    @storage_root_credential_name.setter
    def storage_root_credential_name(self, value: Optional[str]):
        pulumi.set(self, "storage_root_credential_name", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class GetMlflowExperimentTagArgsDict(TypedDict):
        key: NotRequired[str]
        value: NotRequired[str]
elif False:
    GetMlflowExperimentTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlflowExperimentTagArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetMlflowModelLatestVersionArgsDict(TypedDict):
        creation_timestamp: NotRequired[int]
        current_stage: NotRequired[str]
        description: NotRequired[str]
        """
        User-specified description for the object.
        """
        last_updated_timestamp: NotRequired[int]
        name: NotRequired[str]
        """
        Name of the registered model.
        """
        run_id: NotRequired[str]
        run_link: NotRequired[str]
        source: NotRequired[str]
        status: NotRequired[str]
        status_message: NotRequired[str]
        tags: NotRequired[Sequence['GetMlflowModelLatestVersionTagArgsDict']]
        """
        Array of tags associated with the model.
        """
        user_id: NotRequired[str]
        """
        The username of the user that created the object.
        """
        version: NotRequired[str]
elif False:
    GetMlflowModelLatestVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlflowModelLatestVersionArgs:
    def __init__(__self__, *,
                 creation_timestamp: Optional[int] = None,
                 current_stage: Optional[str] = None,
                 description: Optional[str] = None,
                 last_updated_timestamp: Optional[int] = None,
                 name: Optional[str] = None,
                 run_id: Optional[str] = None,
                 run_link: Optional[str] = None,
                 source: Optional[str] = None,
                 status: Optional[str] = None,
                 status_message: Optional[str] = None,
                 tags: Optional[Sequence['GetMlflowModelLatestVersionTagArgs']] = None,
                 user_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str description: User-specified description for the object.
        :param str name: Name of the registered model.
        :param Sequence['GetMlflowModelLatestVersionTagArgs'] tags: Array of tags associated with the model.
        :param str user_id: The username of the user that created the object.
        """
        if creation_timestamp is not None:
            pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        if current_stage is not None:
            pulumi.set(__self__, "current_stage", current_stage)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if last_updated_timestamp is not None:
            pulumi.set(__self__, "last_updated_timestamp", last_updated_timestamp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if run_id is not None:
            pulumi.set(__self__, "run_id", run_id)
        if run_link is not None:
            pulumi.set(__self__, "run_link", run_link)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "creation_timestamp")

    @creation_timestamp.setter
    def creation_timestamp(self, value: Optional[int]):
        pulumi.set(self, "creation_timestamp", value)

    @property
    @pulumi.getter(name="currentStage")
    def current_stage(self) -> Optional[str]:
        return pulumi.get(self, "current_stage")

    @current_stage.setter
    def current_stage(self, value: Optional[str]):
        pulumi.set(self, "current_stage", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-specified description for the object.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="lastUpdatedTimestamp")
    def last_updated_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "last_updated_timestamp")

    @last_updated_timestamp.setter
    def last_updated_timestamp(self, value: Optional[int]):
        pulumi.set(self, "last_updated_timestamp", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the registered model.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="runId")
    def run_id(self) -> Optional[str]:
        return pulumi.get(self, "run_id")

    @run_id.setter
    def run_id(self, value: Optional[str]):
        pulumi.set(self, "run_id", value)

    @property
    @pulumi.getter(name="runLink")
    def run_link(self) -> Optional[str]:
        return pulumi.get(self, "run_link")

    @run_link.setter
    def run_link(self, value: Optional[str]):
        pulumi.set(self, "run_link", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[str]:
        return pulumi.get(self, "status_message")

    @status_message.setter
    def status_message(self, value: Optional[str]):
        pulumi.set(self, "status_message", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['GetMlflowModelLatestVersionTagArgs']]:
        """
        Array of tags associated with the model.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Sequence['GetMlflowModelLatestVersionTagArgs']]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The username of the user that created the object.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[str]):
        pulumi.set(self, "user_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetMlflowModelLatestVersionTagArgsDict(TypedDict):
        key: NotRequired[str]
        value: NotRequired[str]
elif False:
    GetMlflowModelLatestVersionTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlflowModelLatestVersionTagArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetMlflowModelTagArgsDict(TypedDict):
        key: NotRequired[str]
        value: NotRequired[str]
elif False:
    GetMlflowModelTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetMlflowModelTagArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNotificationDestinationsNotificationDestinationArgsDict(TypedDict):
        destination_type: NotRequired[str]
        """
        The type of the notification destination. Possible values are `EMAIL`, `MICROSOFT_TEAMS`, `PAGERDUTY`, `SLACK`, or `WEBHOOK`.
        """
        display_name: NotRequired[str]
        """
        The display name of the Notification Destination.
        """
        id: NotRequired[str]
        """
        The unique ID of the Notification Destination.
        """
elif False:
    GetNotificationDestinationsNotificationDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNotificationDestinationsNotificationDestinationArgs:
    def __init__(__self__, *,
                 destination_type: Optional[str] = None,
                 display_name: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str destination_type: The type of the notification destination. Possible values are `EMAIL`, `MICROSOFT_TEAMS`, `PAGERDUTY`, `SLACK`, or `WEBHOOK`.
        :param str display_name: The display name of the Notification Destination.
        :param str id: The unique ID of the Notification Destination.
        """
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[str]:
        """
        The type of the notification destination. Possible values are `EMAIL`, `MICROSOFT_TEAMS`, `PAGERDUTY`, `SLACK`, or `WEBHOOK`.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[str]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The display name of the Notification Destination.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The unique ID of the Notification Destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetRegisteredModelModelInfoArgsDict(TypedDict):
        aliases: NotRequired[Sequence['GetRegisteredModelModelInfoAliasArgsDict']]
        """
        the list of aliases associated with this model. Each item is object consisting of following attributes:
        """
        browse_only: NotRequired[bool]
        catalog_name: NotRequired[str]
        """
        The name of the catalog where the schema and the registered model reside.
        """
        comment: NotRequired[str]
        """
        The comment attached to the registered model.
        """
        created_at: NotRequired[int]
        """
        the Unix timestamp at the model's creation
        """
        created_by: NotRequired[str]
        """
        the identifier of the user who created the model
        """
        full_name: NotRequired[str]
        """
        The fully-qualified name of the registered model (`catalog_name.schema_name.name`).
        """
        metastore_id: NotRequired[str]
        """
        the unique identifier of the metastore
        """
        name: NotRequired[str]
        """
        The name of the registered model.
        """
        owner: NotRequired[str]
        """
        Name of the registered model owner.
        """
        schema_name: NotRequired[str]
        """
        The name of the schema where the registered model resides.
        """
        storage_location: NotRequired[str]
        """
        The storage location under which model version data files are stored.
        """
        updated_at: NotRequired[int]
        """
        the timestamp of the last time changes were made to the model
        """
        updated_by: NotRequired[str]
        """
        the identifier of the user who updated the model last time
        """
elif False:
    GetRegisteredModelModelInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegisteredModelModelInfoArgs:
    def __init__(__self__, *,
                 aliases: Optional[Sequence['GetRegisteredModelModelInfoAliasArgs']] = None,
                 browse_only: Optional[bool] = None,
                 catalog_name: Optional[str] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 full_name: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 schema_name: Optional[str] = None,
                 storage_location: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param Sequence['GetRegisteredModelModelInfoAliasArgs'] aliases: the list of aliases associated with this model. Each item is object consisting of following attributes:
        :param str catalog_name: The name of the catalog where the schema and the registered model reside.
        :param str comment: The comment attached to the registered model.
        :param int created_at: the Unix timestamp at the model's creation
        :param str created_by: the identifier of the user who created the model
        :param str full_name: The fully-qualified name of the registered model (`catalog_name.schema_name.name`).
        :param str metastore_id: the unique identifier of the metastore
        :param str name: The name of the registered model.
        :param str owner: Name of the registered model owner.
        :param str schema_name: The name of the schema where the registered model resides.
        :param str storage_location: The storage location under which model version data files are stored.
        :param int updated_at: the timestamp of the last time changes were made to the model
        :param str updated_by: the identifier of the user who updated the model last time
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence['GetRegisteredModelModelInfoAliasArgs']]:
        """
        the list of aliases associated with this model. Each item is object consisting of following attributes:
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[Sequence['GetRegisteredModelModelInfoAliasArgs']]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[str]:
        """
        The name of the catalog where the schema and the registered model reside.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        The comment attached to the registered model.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        the Unix timestamp at the model's creation
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        the identifier of the user who created the model
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        The fully-qualified name of the registered model (`catalog_name.schema_name.name`).
        """
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the registered model.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Name of the registered model owner.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The name of the schema where the registered model resides.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[str]):
        pulumi.set(self, "schema_name", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        """
        The storage location under which model version data files are stored.
        """
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[str]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        the timestamp of the last time changes were made to the model
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        the identifier of the user who updated the model last time
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class GetRegisteredModelModelInfoAliasArgsDict(TypedDict):
        alias_name: NotRequired[str]
        """
        string with the name of alias
        """
        version_num: NotRequired[int]
        """
        associated model version
        """
elif False:
    GetRegisteredModelModelInfoAliasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegisteredModelModelInfoAliasArgs:
    def __init__(__self__, *,
                 alias_name: Optional[str] = None,
                 version_num: Optional[int] = None):
        """
        :param str alias_name: string with the name of alias
        :param int version_num: associated model version
        """
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)
        if version_num is not None:
            pulumi.set(__self__, "version_num", version_num)

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        """
        string with the name of alias
        """
        return pulumi.get(self, "alias_name")

    @alias_name.setter
    def alias_name(self, value: Optional[str]):
        pulumi.set(self, "alias_name", value)

    @property
    @pulumi.getter(name="versionNum")
    def version_num(self) -> Optional[int]:
        """
        associated model version
        """
        return pulumi.get(self, "version_num")

    @version_num.setter
    def version_num(self, value: Optional[int]):
        pulumi.set(self, "version_num", value)


if not MYPY:
    class GetSchemaSchemaInfoArgsDict(TypedDict):
        browse_only: NotRequired[bool]
        """
        indicates whether the principal is limited to retrieving metadata for the schema through the BROWSE privilege.
        """
        catalog_name: NotRequired[str]
        """
        the name of the catalog where the schema is.
        """
        catalog_type: NotRequired[str]
        """
        the type of the parent catalog.
        """
        comment: NotRequired[str]
        """
        the comment attached to the volume
        """
        created_at: NotRequired[int]
        """
        time at which this schema was created, in epoch milliseconds.
        """
        created_by: NotRequired[str]
        """
        username of schema creator.
        """
        effective_predictive_optimization_flag: NotRequired['GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgsDict']
        """
        information about actual state of predictive optimization.
        """
        enable_predictive_optimization: NotRequired[str]
        """
        whether predictive optimization should be enabled for this object and objects under it.
        """
        full_name: NotRequired[str]
        """
        the two-level (fully qualified) name of the schema
        """
        metastore_id: NotRequired[str]
        """
        the unique identifier of the metastore
        """
        name: NotRequired[str]
        """
        a fully qualified name of databricks_schema: *`catalog`.`schema`*
        """
        owner: NotRequired[str]
        """
        the identifier of the user who owns the schema
        """
        properties: NotRequired[Mapping[str, str]]
        """
        map of properties set on the schema
        """
        schema_id: NotRequired[str]
        """
        the unique identifier of the volume
        """
        storage_location: NotRequired[str]
        """
        the storage location on the cloud.
        """
        storage_root: NotRequired[str]
        """
        storage root URL for managed tables within schema.
        """
        updated_at: NotRequired[int]
        """
        the timestamp of the last time changes were made to the schema
        """
        updated_by: NotRequired[str]
        """
        the identifier of the user who updated the schema last time
        """
elif False:
    GetSchemaSchemaInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchemaSchemaInfoArgs:
    def __init__(__self__, *,
                 browse_only: Optional[bool] = None,
                 catalog_name: Optional[str] = None,
                 catalog_type: Optional[str] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 effective_predictive_optimization_flag: Optional['GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs'] = None,
                 enable_predictive_optimization: Optional[str] = None,
                 full_name: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 schema_id: Optional[str] = None,
                 storage_location: Optional[str] = None,
                 storage_root: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param bool browse_only: indicates whether the principal is limited to retrieving metadata for the schema through the BROWSE privilege.
        :param str catalog_name: the name of the catalog where the schema is.
        :param str catalog_type: the type of the parent catalog.
        :param str comment: the comment attached to the volume
        :param int created_at: time at which this schema was created, in epoch milliseconds.
        :param str created_by: username of schema creator.
        :param 'GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs' effective_predictive_optimization_flag: information about actual state of predictive optimization.
        :param str enable_predictive_optimization: whether predictive optimization should be enabled for this object and objects under it.
        :param str full_name: the two-level (fully qualified) name of the schema
        :param str metastore_id: the unique identifier of the metastore
        :param str name: a fully qualified name of databricks_schema: *`catalog`.`schema`*
        :param str owner: the identifier of the user who owns the schema
        :param Mapping[str, str] properties: map of properties set on the schema
        :param str schema_id: the unique identifier of the volume
        :param str storage_location: the storage location on the cloud.
        :param str storage_root: storage root URL for managed tables within schema.
        :param int updated_at: the timestamp of the last time changes were made to the schema
        :param str updated_by: the identifier of the user who updated the schema last time
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if catalog_type is not None:
            pulumi.set(__self__, "catalog_type", catalog_type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if effective_predictive_optimization_flag is not None:
            pulumi.set(__self__, "effective_predictive_optimization_flag", effective_predictive_optimization_flag)
        if enable_predictive_optimization is not None:
            pulumi.set(__self__, "enable_predictive_optimization", enable_predictive_optimization)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        """
        indicates whether the principal is limited to retrieving metadata for the schema through the BROWSE privilege.
        """
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[str]:
        """
        the name of the catalog where the schema is.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter(name="catalogType")
    def catalog_type(self) -> Optional[str]:
        """
        the type of the parent catalog.
        """
        return pulumi.get(self, "catalog_type")

    @catalog_type.setter
    def catalog_type(self, value: Optional[str]):
        pulumi.set(self, "catalog_type", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        the comment attached to the volume
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        time at which this schema was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        username of schema creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="effectivePredictiveOptimizationFlag")
    def effective_predictive_optimization_flag(self) -> Optional['GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs']:
        """
        information about actual state of predictive optimization.
        """
        return pulumi.get(self, "effective_predictive_optimization_flag")

    @effective_predictive_optimization_flag.setter
    def effective_predictive_optimization_flag(self, value: Optional['GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs']):
        pulumi.set(self, "effective_predictive_optimization_flag", value)

    @property
    @pulumi.getter(name="enablePredictiveOptimization")
    def enable_predictive_optimization(self) -> Optional[str]:
        """
        whether predictive optimization should be enabled for this object and objects under it.
        """
        return pulumi.get(self, "enable_predictive_optimization")

    @enable_predictive_optimization.setter
    def enable_predictive_optimization(self, value: Optional[str]):
        pulumi.set(self, "enable_predictive_optimization", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        the two-level (fully qualified) name of the schema
        """
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        a fully qualified name of databricks_schema: *`catalog`.`schema`*
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        the identifier of the user who owns the schema
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        """
        map of properties set on the schema
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[str]:
        """
        the unique identifier of the volume
        """
        return pulumi.get(self, "schema_id")

    @schema_id.setter
    def schema_id(self, value: Optional[str]):
        pulumi.set(self, "schema_id", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        """
        the storage location on the cloud.
        """
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[str]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[str]:
        """
        storage root URL for managed tables within schema.
        """
        return pulumi.get(self, "storage_root")

    @storage_root.setter
    def storage_root(self, value: Optional[str]):
        pulumi.set(self, "storage_root", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        the timestamp of the last time changes were made to the schema
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        the identifier of the user who updated the schema last time
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


if not MYPY:
    class GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgsDict(TypedDict):
        value: str
        inherited_from_name: NotRequired[str]
        inherited_from_type: NotRequired[str]
elif False:
    GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs:
    def __init__(__self__, *,
                 value: str,
                 inherited_from_name: Optional[str] = None,
                 inherited_from_type: Optional[str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[str]:
        return pulumi.get(self, "inherited_from_name")

    @inherited_from_name.setter
    def inherited_from_name(self, value: Optional[str]):
        pulumi.set(self, "inherited_from_name", value)

    @property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[str]:
        return pulumi.get(self, "inherited_from_type")

    @inherited_from_type.setter
    def inherited_from_type(self, value: Optional[str]):
        pulumi.set(self, "inherited_from_type", value)


if not MYPY:
    class GetShareObjectArgsDict(TypedDict):
        added_at: int
        added_by: str
        data_object_type: str
        """
        Type of the object.
        """
        name: str
        """
        The name of the share
        """
        status: str
        cdf_enabled: NotRequired[bool]
        comment: NotRequired[str]
        """
        Description about the object.
        """
        content: NotRequired[str]
        history_data_sharing_status: NotRequired[str]
        partitions: NotRequired[Sequence['GetShareObjectPartitionArgsDict']]
        shared_as: NotRequired[str]
        start_version: NotRequired[int]
        string_shared_as: NotRequired[str]
elif False:
    GetShareObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetShareObjectArgs:
    def __init__(__self__, *,
                 added_at: int,
                 added_by: str,
                 data_object_type: str,
                 name: str,
                 status: str,
                 cdf_enabled: Optional[bool] = None,
                 comment: Optional[str] = None,
                 content: Optional[str] = None,
                 history_data_sharing_status: Optional[str] = None,
                 partitions: Optional[Sequence['GetShareObjectPartitionArgs']] = None,
                 shared_as: Optional[str] = None,
                 start_version: Optional[int] = None,
                 string_shared_as: Optional[str] = None):
        """
        :param str data_object_type: Type of the object.
        :param str name: The name of the share
        :param str comment: Description about the object.
        """
        pulumi.set(__self__, "added_at", added_at)
        pulumi.set(__self__, "added_by", added_by)
        pulumi.set(__self__, "data_object_type", data_object_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        if cdf_enabled is not None:
            pulumi.set(__self__, "cdf_enabled", cdf_enabled)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if history_data_sharing_status is not None:
            pulumi.set(__self__, "history_data_sharing_status", history_data_sharing_status)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if shared_as is not None:
            pulumi.set(__self__, "shared_as", shared_as)
        if start_version is not None:
            pulumi.set(__self__, "start_version", start_version)
        if string_shared_as is not None:
            pulumi.set(__self__, "string_shared_as", string_shared_as)

    @property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> int:
        return pulumi.get(self, "added_at")

    @added_at.setter
    def added_at(self, value: int):
        pulumi.set(self, "added_at", value)

    @property
    @pulumi.getter(name="addedBy")
    def added_by(self) -> str:
        return pulumi.get(self, "added_by")

    @added_by.setter
    def added_by(self, value: str):
        pulumi.set(self, "added_by", value)

    @property
    @pulumi.getter(name="dataObjectType")
    def data_object_type(self) -> str:
        """
        Type of the object.
        """
        return pulumi.get(self, "data_object_type")

    @data_object_type.setter
    def data_object_type(self, value: str):
        pulumi.set(self, "data_object_type", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the share
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="cdfEnabled")
    def cdf_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "cdf_enabled")

    @cdf_enabled.setter
    def cdf_enabled(self, value: Optional[bool]):
        pulumi.set(self, "cdf_enabled", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Description about the object.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="historyDataSharingStatus")
    def history_data_sharing_status(self) -> Optional[str]:
        return pulumi.get(self, "history_data_sharing_status")

    @history_data_sharing_status.setter
    def history_data_sharing_status(self, value: Optional[str]):
        pulumi.set(self, "history_data_sharing_status", value)

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['GetShareObjectPartitionArgs']]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: Optional[Sequence['GetShareObjectPartitionArgs']]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="sharedAs")
    def shared_as(self) -> Optional[str]:
        return pulumi.get(self, "shared_as")

    @shared_as.setter
    def shared_as(self, value: Optional[str]):
        pulumi.set(self, "shared_as", value)

    @property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> Optional[int]:
        return pulumi.get(self, "start_version")

    @start_version.setter
    def start_version(self, value: Optional[int]):
        pulumi.set(self, "start_version", value)

    @property
    @pulumi.getter(name="stringSharedAs")
    def string_shared_as(self) -> Optional[str]:
        return pulumi.get(self, "string_shared_as")

    @string_shared_as.setter
    def string_shared_as(self, value: Optional[str]):
        pulumi.set(self, "string_shared_as", value)


if not MYPY:
    class GetShareObjectPartitionArgsDict(TypedDict):
        values: NotRequired[Sequence['GetShareObjectPartitionValueArgsDict']]
elif False:
    GetShareObjectPartitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetShareObjectPartitionArgs:
    def __init__(__self__, *,
                 values: Optional[Sequence['GetShareObjectPartitionValueArgs']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['GetShareObjectPartitionValueArgs']]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence['GetShareObjectPartitionValueArgs']]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetShareObjectPartitionValueArgsDict(TypedDict):
        name: str
        """
        The name of the share
        """
        op: str
        recipient_property_key: NotRequired[str]
        value: NotRequired[str]
elif False:
    GetShareObjectPartitionValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetShareObjectPartitionValueArgs:
    def __init__(__self__, *,
                 name: str,
                 op: str,
                 recipient_property_key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the share
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "op", op)
        if recipient_property_key is not None:
            pulumi.set(__self__, "recipient_property_key", recipient_property_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the share
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter(name="recipientPropertyKey")
    def recipient_property_key(self) -> Optional[str]:
        return pulumi.get(self, "recipient_property_key")

    @recipient_property_key.setter
    def recipient_property_key(self, value: Optional[str]):
        pulumi.set(self, "recipient_property_key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSqlWarehouseChannelArgsDict(TypedDict):
        dbsql_version: NotRequired[str]
        name: NotRequired[str]
        """
        Name of the SQL warehouse to search (case-sensitive).
        """
elif False:
    GetSqlWarehouseChannelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlWarehouseChannelArgs:
    def __init__(__self__, *,
                 dbsql_version: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str name: Name of the SQL warehouse to search (case-sensitive).
        """
        if dbsql_version is not None:
            pulumi.set(__self__, "dbsql_version", dbsql_version)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dbsqlVersion")
    def dbsql_version(self) -> Optional[str]:
        return pulumi.get(self, "dbsql_version")

    @dbsql_version.setter
    def dbsql_version(self, value: Optional[str]):
        pulumi.set(self, "dbsql_version", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the SQL warehouse to search (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetSqlWarehouseHealthArgsDict(TypedDict):
        details: NotRequired[str]
        failure_reason: NotRequired['GetSqlWarehouseHealthFailureReasonArgsDict']
        message: NotRequired[str]
        status: NotRequired[str]
        summary: NotRequired[str]
elif False:
    GetSqlWarehouseHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlWarehouseHealthArgs:
    def __init__(__self__, *,
                 details: Optional[str] = None,
                 failure_reason: Optional['GetSqlWarehouseHealthFailureReasonArgs'] = None,
                 message: Optional[str] = None,
                 status: Optional[str] = None,
                 summary: Optional[str] = None):
        if details is not None:
            pulumi.set(__self__, "details", details)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[str]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['GetSqlWarehouseHealthFailureReasonArgs']:
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional['GetSqlWarehouseHealthFailureReasonArgs']):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[str]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def summary(self) -> Optional[str]:
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: Optional[str]):
        pulumi.set(self, "summary", value)


if not MYPY:
    class GetSqlWarehouseHealthFailureReasonArgsDict(TypedDict):
        code: NotRequired[str]
        parameters: NotRequired[Mapping[str, str]]
        type: NotRequired[str]
elif False:
    GetSqlWarehouseHealthFailureReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlWarehouseHealthFailureReasonArgs:
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 parameters: Optional[Mapping[str, str]] = None,
                 type: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[str]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetSqlWarehouseOdbcParamsArgsDict(TypedDict):
        hostname: NotRequired[str]
        path: NotRequired[str]
        port: NotRequired[int]
        protocol: NotRequired[str]
elif False:
    GetSqlWarehouseOdbcParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlWarehouseOdbcParamsArgs:
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class GetSqlWarehouseTagsArgsDict(TypedDict):
        custom_tags: NotRequired[Sequence['GetSqlWarehouseTagsCustomTagArgsDict']]
elif False:
    GetSqlWarehouseTagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlWarehouseTagsArgs:
    def __init__(__self__, *,
                 custom_tags: Optional[Sequence['GetSqlWarehouseTagsCustomTagArgs']] = None):
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence['GetSqlWarehouseTagsCustomTagArgs']]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Sequence['GetSqlWarehouseTagsCustomTagArgs']]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GetSqlWarehouseTagsCustomTagArgsDict(TypedDict):
        key: NotRequired[str]
        value: NotRequired[str]
elif False:
    GetSqlWarehouseTagsCustomTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSqlWarehouseTagsCustomTagArgs:
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetStorageCredentialStorageCredentialInfoArgsDict(TypedDict):
        aws_iam_role: NotRequired['GetStorageCredentialStorageCredentialInfoAwsIamRoleArgsDict']
        """
        credential details for AWS:
        """
        azure_managed_identity: NotRequired['GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgsDict']
        """
        managed identity credential details for Azure
        """
        azure_service_principal: NotRequired['GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgsDict']
        """
        service principal credential details for Azure:
        """
        cloudflare_api_token: NotRequired['GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgsDict']
        comment: NotRequired[str]
        created_at: NotRequired[int]
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        created_by: NotRequired[str]
        """
        Username of catalog creator.
        """
        databricks_gcp_service_account: NotRequired['GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgsDict']
        """
        credential details for GCP:
        """
        full_name: NotRequired[str]
        id: NotRequired[str]
        """
        Unique ID of storage credential.
        """
        isolation_mode: NotRequired[str]
        metastore_id: NotRequired[str]
        """
        Unique identifier of the parent Metastore.
        """
        name: NotRequired[str]
        """
        The name of the storage credential
        """
        owner: NotRequired[str]
        """
        Username/groupname/sp application_id of the storage credential owner.
        """
        read_only: NotRequired[bool]
        """
        Indicates whether the storage credential is only usable for read operations.
        """
        updated_at: NotRequired[int]
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        updated_by: NotRequired[str]
        """
        Username of user who last modified catalog.
        """
        used_for_managed_storage: NotRequired[bool]
elif False:
    GetStorageCredentialStorageCredentialInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorageCredentialStorageCredentialInfoArgs:
    def __init__(__self__, *,
                 aws_iam_role: Optional['GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs'] = None,
                 azure_managed_identity: Optional['GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs'] = None,
                 azure_service_principal: Optional['GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs'] = None,
                 cloudflare_api_token: Optional['GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgs'] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 databricks_gcp_service_account: Optional['GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs'] = None,
                 full_name: Optional[str] = None,
                 id: Optional[str] = None,
                 isolation_mode: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None,
                 used_for_managed_storage: Optional[bool] = None):
        """
        :param 'GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs' aws_iam_role: credential details for AWS:
        :param 'GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs' azure_managed_identity: managed identity credential details for Azure
        :param 'GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs' azure_service_principal: service principal credential details for Azure:
        :param int created_at: Time at which this catalog was created, in epoch milliseconds.
        :param str created_by: Username of catalog creator.
        :param 'GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs' databricks_gcp_service_account: credential details for GCP:
        :param str id: Unique ID of storage credential.
        :param str metastore_id: Unique identifier of the parent Metastore.
        :param str name: The name of the storage credential
        :param str owner: Username/groupname/sp application_id of the storage credential owner.
        :param bool read_only: Indicates whether the storage credential is only usable for read operations.
        :param int updated_at: Time at which this catalog was last modified, in epoch milliseconds.
        :param str updated_by: Username of user who last modified catalog.
        """
        if aws_iam_role is not None:
            pulumi.set(__self__, "aws_iam_role", aws_iam_role)
        if azure_managed_identity is not None:
            pulumi.set(__self__, "azure_managed_identity", azure_managed_identity)
        if azure_service_principal is not None:
            pulumi.set(__self__, "azure_service_principal", azure_service_principal)
        if cloudflare_api_token is not None:
            pulumi.set(__self__, "cloudflare_api_token", cloudflare_api_token)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if databricks_gcp_service_account is not None:
            pulumi.set(__self__, "databricks_gcp_service_account", databricks_gcp_service_account)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if used_for_managed_storage is not None:
            pulumi.set(__self__, "used_for_managed_storage", used_for_managed_storage)

    @property
    @pulumi.getter(name="awsIamRole")
    def aws_iam_role(self) -> Optional['GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs']:
        """
        credential details for AWS:
        """
        return pulumi.get(self, "aws_iam_role")

    @aws_iam_role.setter
    def aws_iam_role(self, value: Optional['GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs']):
        pulumi.set(self, "aws_iam_role", value)

    @property
    @pulumi.getter(name="azureManagedIdentity")
    def azure_managed_identity(self) -> Optional['GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs']:
        """
        managed identity credential details for Azure
        """
        return pulumi.get(self, "azure_managed_identity")

    @azure_managed_identity.setter
    def azure_managed_identity(self, value: Optional['GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs']):
        pulumi.set(self, "azure_managed_identity", value)

    @property
    @pulumi.getter(name="azureServicePrincipal")
    def azure_service_principal(self) -> Optional['GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs']:
        """
        service principal credential details for Azure:
        """
        return pulumi.get(self, "azure_service_principal")

    @azure_service_principal.setter
    def azure_service_principal(self, value: Optional['GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs']):
        pulumi.set(self, "azure_service_principal", value)

    @property
    @pulumi.getter(name="cloudflareApiToken")
    def cloudflare_api_token(self) -> Optional['GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgs']:
        return pulumi.get(self, "cloudflare_api_token")

    @cloudflare_api_token.setter
    def cloudflare_api_token(self, value: Optional['GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgs']):
        pulumi.set(self, "cloudflare_api_token", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        Username of catalog creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="databricksGcpServiceAccount")
    def databricks_gcp_service_account(self) -> Optional['GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs']:
        """
        credential details for GCP:
        """
        return pulumi.get(self, "databricks_gcp_service_account")

    @databricks_gcp_service_account.setter
    def databricks_gcp_service_account(self, value: Optional['GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs']):
        pulumi.set(self, "databricks_gcp_service_account", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique ID of storage credential.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[str]:
        return pulumi.get(self, "isolation_mode")

    @isolation_mode.setter
    def isolation_mode(self, value: Optional[str]):
        pulumi.set(self, "isolation_mode", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        Unique identifier of the parent Metastore.
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the storage credential
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Username/groupname/sp application_id of the storage credential owner.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Indicates whether the storage credential is only usable for read operations.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[bool]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        Username of user who last modified catalog.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)

    @property
    @pulumi.getter(name="usedForManagedStorage")
    def used_for_managed_storage(self) -> Optional[bool]:
        return pulumi.get(self, "used_for_managed_storage")

    @used_for_managed_storage.setter
    def used_for_managed_storage(self, value: Optional[bool]):
        pulumi.set(self, "used_for_managed_storage", value)


if not MYPY:
    class GetStorageCredentialStorageCredentialInfoAwsIamRoleArgsDict(TypedDict):
        role_arn: str
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        external_id: NotRequired[str]
        """
        (output only) - The external ID used in role assumption to prevent confused deputy problem.
        """
        unity_catalog_iam_arn: NotRequired[str]
        """
        (output only) - The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
elif False:
    GetStorageCredentialStorageCredentialInfoAwsIamRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs:
    def __init__(__self__, *,
                 role_arn: str,
                 external_id: Optional[str] = None,
                 unity_catalog_iam_arn: Optional[str] = None):
        """
        :param str role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        :param str external_id: (output only) - The external ID used in role assumption to prevent confused deputy problem.
        :param str unity_catalog_iam_arn: (output only) - The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: str):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        (output only) - The external ID used in role assumption to prevent confused deputy problem.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[str]:
        """
        (output only) - The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
        return pulumi.get(self, "unity_catalog_iam_arn")

    @unity_catalog_iam_arn.setter
    def unity_catalog_iam_arn(self, value: Optional[str]):
        pulumi.set(self, "unity_catalog_iam_arn", value)


if not MYPY:
    class GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgsDict(TypedDict):
        access_connector_id: str
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        credential_id: NotRequired[str]
        managed_identity_id: NotRequired[str]
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
        """
elif False:
    GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs:
    def __init__(__self__, *,
                 access_connector_id: str,
                 credential_id: Optional[str] = None,
                 managed_identity_id: Optional[str] = None):
        """
        :param str access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param str managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> str:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @access_connector_id.setter
    def access_connector_id(self, value: str):
        pulumi.set(self, "access_connector_id", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[str]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[str]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[str]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
        """
        return pulumi.get(self, "managed_identity_id")

    @managed_identity_id.setter
    def managed_identity_id(self, value: Optional[str]):
        pulumi.set(self, "managed_identity_id", value)


if not MYPY:
    class GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgsDict(TypedDict):
        application_id: str
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        client_secret: str
        directory_id: str
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
elif False:
    GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs:
    def __init__(__self__, *,
                 application_id: str,
                 client_secret: str,
                 directory_id: str):
        """
        :param str application_id: The application ID of the application registration within the referenced AAD tenant
        :param str directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: str):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: str):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: str):
        pulumi.set(self, "directory_id", value)


if not MYPY:
    class GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgsDict(TypedDict):
        access_key_id: str
        account_id: str
        secret_access_key: str
elif False:
    GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorageCredentialStorageCredentialInfoCloudflareApiTokenArgs:
    def __init__(__self__, *,
                 access_key_id: str,
                 account_id: str,
                 secret_access_key: str):
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: str):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: str):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: str):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgsDict(TypedDict):
        credential_id: NotRequired[str]
        email: NotRequired[str]
        """
        The email of the GCP service account created, to be granted access to relevant buckets.
        """
elif False:
    GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs:
    def __init__(__self__, *,
                 credential_id: Optional[str] = None,
                 email: Optional[str] = None):
        """
        :param str email: The email of the GCP service account created, to be granted access to relevant buckets.
        """
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[str]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[str]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[str]):
        pulumi.set(self, "email", value)


if not MYPY:
    class GetTableTableInfoArgsDict(TypedDict):
        access_point: NotRequired[str]
        browse_only: NotRequired[bool]
        catalog_name: NotRequired[str]
        """
        Name of parent catalog.
        """
        columns: NotRequired[Sequence['GetTableTableInfoColumnArgsDict']]
        """
        Array of ColumnInfo objects of the table's columns
        """
        comment: NotRequired[str]
        """
        Free-form text description
        """
        created_at: NotRequired[int]
        created_by: NotRequired[str]
        data_access_configuration_id: NotRequired[str]
        data_source_format: NotRequired[str]
        """
        Table format, e.g. DELTA, CSV, JSON
        """
        deleted_at: NotRequired[int]
        delta_runtime_properties_kvpairs: NotRequired['GetTableTableInfoDeltaRuntimePropertiesKvpairsArgsDict']
        effective_predictive_optimization_flag: NotRequired['GetTableTableInfoEffectivePredictiveOptimizationFlagArgsDict']
        enable_predictive_optimization: NotRequired[str]
        encryption_details: NotRequired['GetTableTableInfoEncryptionDetailsArgsDict']
        full_name: NotRequired[str]
        metastore_id: NotRequired[str]
        name: NotRequired[str]
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        owner: NotRequired[str]
        """
        Current owner of the table
        """
        pipeline_id: NotRequired[str]
        properties: NotRequired[Mapping[str, str]]
        row_filter: NotRequired['GetTableTableInfoRowFilterArgsDict']
        schema_name: NotRequired[str]
        """
        Name of parent schema relative to its parent catalog.
        """
        sql_path: NotRequired[str]
        storage_credential_name: NotRequired[str]
        storage_location: NotRequired[str]
        table_constraints: NotRequired[Sequence['GetTableTableInfoTableConstraintArgsDict']]
        table_id: NotRequired[str]
        table_type: NotRequired[str]
        """
        Table type, e.g. MANAGED, EXTERNAL, VIEW
        """
        updated_at: NotRequired[int]
        updated_by: NotRequired[str]
        view_definition: NotRequired[str]
        """
        View definition SQL (when `table_type` is VIEW, MATERIALIZED_VIEW, or STREAMING_TABLE)
        """
        view_dependencies: NotRequired['GetTableTableInfoViewDependenciesArgsDict']
        """
        View dependencies (when `table_type` is VIEW or MATERIALIZED_VIEW, STREAMING_TABLE)
        """
elif False:
    GetTableTableInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoArgs:
    def __init__(__self__, *,
                 access_point: Optional[str] = None,
                 browse_only: Optional[bool] = None,
                 catalog_name: Optional[str] = None,
                 columns: Optional[Sequence['GetTableTableInfoColumnArgs']] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 data_access_configuration_id: Optional[str] = None,
                 data_source_format: Optional[str] = None,
                 deleted_at: Optional[int] = None,
                 delta_runtime_properties_kvpairs: Optional['GetTableTableInfoDeltaRuntimePropertiesKvpairsArgs'] = None,
                 effective_predictive_optimization_flag: Optional['GetTableTableInfoEffectivePredictiveOptimizationFlagArgs'] = None,
                 enable_predictive_optimization: Optional[str] = None,
                 encryption_details: Optional['GetTableTableInfoEncryptionDetailsArgs'] = None,
                 full_name: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 pipeline_id: Optional[str] = None,
                 properties: Optional[Mapping[str, str]] = None,
                 row_filter: Optional['GetTableTableInfoRowFilterArgs'] = None,
                 schema_name: Optional[str] = None,
                 sql_path: Optional[str] = None,
                 storage_credential_name: Optional[str] = None,
                 storage_location: Optional[str] = None,
                 table_constraints: Optional[Sequence['GetTableTableInfoTableConstraintArgs']] = None,
                 table_id: Optional[str] = None,
                 table_type: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None,
                 view_definition: Optional[str] = None,
                 view_dependencies: Optional['GetTableTableInfoViewDependenciesArgs'] = None):
        """
        :param str catalog_name: Name of parent catalog.
        :param Sequence['GetTableTableInfoColumnArgs'] columns: Array of ColumnInfo objects of the table's columns
        :param str comment: Free-form text description
        :param str data_source_format: Table format, e.g. DELTA, CSV, JSON
        :param str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        :param str owner: Current owner of the table
        :param str schema_name: Name of parent schema relative to its parent catalog.
        :param str table_type: Table type, e.g. MANAGED, EXTERNAL, VIEW
        :param str view_definition: View definition SQL (when `table_type` is VIEW, MATERIALIZED_VIEW, or STREAMING_TABLE)
        :param 'GetTableTableInfoViewDependenciesArgs' view_dependencies: View dependencies (when `table_type` is VIEW or MATERIALIZED_VIEW, STREAMING_TABLE)
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_access_configuration_id is not None:
            pulumi.set(__self__, "data_access_configuration_id", data_access_configuration_id)
        if data_source_format is not None:
            pulumi.set(__self__, "data_source_format", data_source_format)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if delta_runtime_properties_kvpairs is not None:
            pulumi.set(__self__, "delta_runtime_properties_kvpairs", delta_runtime_properties_kvpairs)
        if effective_predictive_optimization_flag is not None:
            pulumi.set(__self__, "effective_predictive_optimization_flag", effective_predictive_optimization_flag)
        if enable_predictive_optimization is not None:
            pulumi.set(__self__, "enable_predictive_optimization", enable_predictive_optimization)
        if encryption_details is not None:
            pulumi.set(__self__, "encryption_details", encryption_details)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if sql_path is not None:
            pulumi.set(__self__, "sql_path", sql_path)
        if storage_credential_name is not None:
            pulumi.set(__self__, "storage_credential_name", storage_credential_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if table_constraints is not None:
            pulumi.set(__self__, "table_constraints", table_constraints)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)
        if table_type is not None:
            pulumi.set(__self__, "table_type", table_type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if view_definition is not None:
            pulumi.set(__self__, "view_definition", view_definition)
        if view_dependencies is not None:
            pulumi.set(__self__, "view_dependencies", view_dependencies)

    @property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[str]:
        return pulumi.get(self, "access_point")

    @access_point.setter
    def access_point(self, value: Optional[str]):
        pulumi.set(self, "access_point", value)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[str]:
        """
        Name of parent catalog.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['GetTableTableInfoColumnArgs']]:
        """
        Array of ColumnInfo objects of the table's columns
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[Sequence['GetTableTableInfoColumnArgs']]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Free-form text description
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="dataAccessConfigurationId")
    def data_access_configuration_id(self) -> Optional[str]:
        return pulumi.get(self, "data_access_configuration_id")

    @data_access_configuration_id.setter
    def data_access_configuration_id(self, value: Optional[str]):
        pulumi.set(self, "data_access_configuration_id", value)

    @property
    @pulumi.getter(name="dataSourceFormat")
    def data_source_format(self) -> Optional[str]:
        """
        Table format, e.g. DELTA, CSV, JSON
        """
        return pulumi.get(self, "data_source_format")

    @data_source_format.setter
    def data_source_format(self, value: Optional[str]):
        pulumi.set(self, "data_source_format", value)

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[int]:
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[int]):
        pulumi.set(self, "deleted_at", value)

    @property
    @pulumi.getter(name="deltaRuntimePropertiesKvpairs")
    def delta_runtime_properties_kvpairs(self) -> Optional['GetTableTableInfoDeltaRuntimePropertiesKvpairsArgs']:
        return pulumi.get(self, "delta_runtime_properties_kvpairs")

    @delta_runtime_properties_kvpairs.setter
    def delta_runtime_properties_kvpairs(self, value: Optional['GetTableTableInfoDeltaRuntimePropertiesKvpairsArgs']):
        pulumi.set(self, "delta_runtime_properties_kvpairs", value)

    @property
    @pulumi.getter(name="effectivePredictiveOptimizationFlag")
    def effective_predictive_optimization_flag(self) -> Optional['GetTableTableInfoEffectivePredictiveOptimizationFlagArgs']:
        return pulumi.get(self, "effective_predictive_optimization_flag")

    @effective_predictive_optimization_flag.setter
    def effective_predictive_optimization_flag(self, value: Optional['GetTableTableInfoEffectivePredictiveOptimizationFlagArgs']):
        pulumi.set(self, "effective_predictive_optimization_flag", value)

    @property
    @pulumi.getter(name="enablePredictiveOptimization")
    def enable_predictive_optimization(self) -> Optional[str]:
        return pulumi.get(self, "enable_predictive_optimization")

    @enable_predictive_optimization.setter
    def enable_predictive_optimization(self, value: Optional[str]):
        pulumi.set(self, "enable_predictive_optimization", value)

    @property
    @pulumi.getter(name="encryptionDetails")
    def encryption_details(self) -> Optional['GetTableTableInfoEncryptionDetailsArgs']:
        return pulumi.get(self, "encryption_details")

    @encryption_details.setter
    def encryption_details(self, value: Optional['GetTableTableInfoEncryptionDetailsArgs']):
        pulumi.set(self, "encryption_details", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Current owner of the table
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[str]:
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[str]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional['GetTableTableInfoRowFilterArgs']:
        return pulumi.get(self, "row_filter")

    @row_filter.setter
    def row_filter(self, value: Optional['GetTableTableInfoRowFilterArgs']):
        pulumi.set(self, "row_filter", value)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        Name of parent schema relative to its parent catalog.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[str]):
        pulumi.set(self, "schema_name", value)

    @property
    @pulumi.getter(name="sqlPath")
    def sql_path(self) -> Optional[str]:
        return pulumi.get(self, "sql_path")

    @sql_path.setter
    def sql_path(self, value: Optional[str]):
        pulumi.set(self, "sql_path", value)

    @property
    @pulumi.getter(name="storageCredentialName")
    def storage_credential_name(self) -> Optional[str]:
        return pulumi.get(self, "storage_credential_name")

    @storage_credential_name.setter
    def storage_credential_name(self, value: Optional[str]):
        pulumi.set(self, "storage_credential_name", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[str]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter(name="tableConstraints")
    def table_constraints(self) -> Optional[Sequence['GetTableTableInfoTableConstraintArgs']]:
        return pulumi.get(self, "table_constraints")

    @table_constraints.setter
    def table_constraints(self, value: Optional[Sequence['GetTableTableInfoTableConstraintArgs']]):
        pulumi.set(self, "table_constraints", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[str]:
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: Optional[str]):
        pulumi.set(self, "table_id", value)

    @property
    @pulumi.getter(name="tableType")
    def table_type(self) -> Optional[str]:
        """
        Table type, e.g. MANAGED, EXTERNAL, VIEW
        """
        return pulumi.get(self, "table_type")

    @table_type.setter
    def table_type(self, value: Optional[str]):
        pulumi.set(self, "table_type", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)

    @property
    @pulumi.getter(name="viewDefinition")
    def view_definition(self) -> Optional[str]:
        """
        View definition SQL (when `table_type` is VIEW, MATERIALIZED_VIEW, or STREAMING_TABLE)
        """
        return pulumi.get(self, "view_definition")

    @view_definition.setter
    def view_definition(self, value: Optional[str]):
        pulumi.set(self, "view_definition", value)

    @property
    @pulumi.getter(name="viewDependencies")
    def view_dependencies(self) -> Optional['GetTableTableInfoViewDependenciesArgs']:
        """
        View dependencies (when `table_type` is VIEW or MATERIALIZED_VIEW, STREAMING_TABLE)
        """
        return pulumi.get(self, "view_dependencies")

    @view_dependencies.setter
    def view_dependencies(self, value: Optional['GetTableTableInfoViewDependenciesArgs']):
        pulumi.set(self, "view_dependencies", value)


if not MYPY:
    class GetTableTableInfoColumnArgsDict(TypedDict):
        comment: NotRequired[str]
        """
        Free-form text description
        """
        mask: NotRequired['GetTableTableInfoColumnMaskArgsDict']
        name: NotRequired[str]
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        nullable: NotRequired[bool]
        partition_index: NotRequired[int]
        position: NotRequired[int]
        type_interval_type: NotRequired[str]
        type_json: NotRequired[str]
        type_name: NotRequired[str]
        type_precision: NotRequired[int]
        type_scale: NotRequired[int]
        type_text: NotRequired[str]
elif False:
    GetTableTableInfoColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoColumnArgs:
    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 mask: Optional['GetTableTableInfoColumnMaskArgs'] = None,
                 name: Optional[str] = None,
                 nullable: Optional[bool] = None,
                 partition_index: Optional[int] = None,
                 position: Optional[int] = None,
                 type_interval_type: Optional[str] = None,
                 type_json: Optional[str] = None,
                 type_name: Optional[str] = None,
                 type_precision: Optional[int] = None,
                 type_scale: Optional[int] = None,
                 type_text: Optional[str] = None):
        """
        :param str comment: Free-form text description
        :param str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if partition_index is not None:
            pulumi.set(__self__, "partition_index", partition_index)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)
        if type_text is not None:
            pulumi.set(__self__, "type_text", type_text)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Free-form text description
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional['GetTableTableInfoColumnMaskArgs']:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional['GetTableTableInfoColumnMaskArgs']):
        pulumi.set(self, "mask", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[bool]:
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[bool]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="partitionIndex")
    def partition_index(self) -> Optional[int]:
        return pulumi.get(self, "partition_index")

    @partition_index.setter
    def partition_index(self, value: Optional[int]):
        pulumi.set(self, "partition_index", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[int]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[int]):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[str]:
        return pulumi.get(self, "type_interval_type")

    @type_interval_type.setter
    def type_interval_type(self, value: Optional[str]):
        pulumi.set(self, "type_interval_type", value)

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[str]:
        return pulumi.get(self, "type_json")

    @type_json.setter
    def type_json(self, value: Optional[str]):
        pulumi.set(self, "type_json", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: Optional[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[int]:
        return pulumi.get(self, "type_precision")

    @type_precision.setter
    def type_precision(self, value: Optional[int]):
        pulumi.set(self, "type_precision", value)

    @property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[int]:
        return pulumi.get(self, "type_scale")

    @type_scale.setter
    def type_scale(self, value: Optional[int]):
        pulumi.set(self, "type_scale", value)

    @property
    @pulumi.getter(name="typeText")
    def type_text(self) -> Optional[str]:
        return pulumi.get(self, "type_text")

    @type_text.setter
    def type_text(self, value: Optional[str]):
        pulumi.set(self, "type_text", value)


if not MYPY:
    class GetTableTableInfoColumnMaskArgsDict(TypedDict):
        function_name: NotRequired[str]
        using_column_names: NotRequired[Sequence[str]]
elif False:
    GetTableTableInfoColumnMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoColumnMaskArgs:
    def __init__(__self__, *,
                 function_name: Optional[str] = None,
                 using_column_names: Optional[Sequence[str]] = None):
        if function_name is not None:
            pulumi.set(__self__, "function_name", function_name)
        if using_column_names is not None:
            pulumi.set(__self__, "using_column_names", using_column_names)

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[str]:
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: Optional[str]):
        pulumi.set(self, "function_name", value)

    @property
    @pulumi.getter(name="usingColumnNames")
    def using_column_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "using_column_names")

    @using_column_names.setter
    def using_column_names(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "using_column_names", value)


if not MYPY:
    class GetTableTableInfoDeltaRuntimePropertiesKvpairsArgsDict(TypedDict):
        delta_runtime_properties: Mapping[str, str]
elif False:
    GetTableTableInfoDeltaRuntimePropertiesKvpairsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoDeltaRuntimePropertiesKvpairsArgs:
    def __init__(__self__, *,
                 delta_runtime_properties: Mapping[str, str]):
        pulumi.set(__self__, "delta_runtime_properties", delta_runtime_properties)

    @property
    @pulumi.getter(name="deltaRuntimeProperties")
    def delta_runtime_properties(self) -> Mapping[str, str]:
        return pulumi.get(self, "delta_runtime_properties")

    @delta_runtime_properties.setter
    def delta_runtime_properties(self, value: Mapping[str, str]):
        pulumi.set(self, "delta_runtime_properties", value)


if not MYPY:
    class GetTableTableInfoEffectivePredictiveOptimizationFlagArgsDict(TypedDict):
        value: str
        inherited_from_name: NotRequired[str]
        inherited_from_type: NotRequired[str]
elif False:
    GetTableTableInfoEffectivePredictiveOptimizationFlagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoEffectivePredictiveOptimizationFlagArgs:
    def __init__(__self__, *,
                 value: str,
                 inherited_from_name: Optional[str] = None,
                 inherited_from_type: Optional[str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[str]:
        return pulumi.get(self, "inherited_from_name")

    @inherited_from_name.setter
    def inherited_from_name(self, value: Optional[str]):
        pulumi.set(self, "inherited_from_name", value)

    @property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[str]:
        return pulumi.get(self, "inherited_from_type")

    @inherited_from_type.setter
    def inherited_from_type(self, value: Optional[str]):
        pulumi.set(self, "inherited_from_type", value)


if not MYPY:
    class GetTableTableInfoEncryptionDetailsArgsDict(TypedDict):
        sse_encryption_details: NotRequired['GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgsDict']
elif False:
    GetTableTableInfoEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoEncryptionDetailsArgs:
    def __init__(__self__, *,
                 sse_encryption_details: Optional['GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgs'] = None):
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgs']:
        return pulumi.get(self, "sse_encryption_details")

    @sse_encryption_details.setter
    def sse_encryption_details(self, value: Optional['GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgs']):
        pulumi.set(self, "sse_encryption_details", value)


if not MYPY:
    class GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgsDict(TypedDict):
        algorithm: NotRequired[str]
        aws_kms_key_arn: NotRequired[str]
elif False:
    GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoEncryptionDetailsSseEncryptionDetailsArgs:
    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 aws_kms_key_arn: Optional[str] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[str]:
        return pulumi.get(self, "aws_kms_key_arn")

    @aws_kms_key_arn.setter
    def aws_kms_key_arn(self, value: Optional[str]):
        pulumi.set(self, "aws_kms_key_arn", value)


if not MYPY:
    class GetTableTableInfoRowFilterArgsDict(TypedDict):
        function_name: str
        input_column_names: Sequence[str]
elif False:
    GetTableTableInfoRowFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoRowFilterArgs:
    def __init__(__self__, *,
                 function_name: str,
                 input_column_names: Sequence[str]):
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "input_column_names", input_column_names)

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        return pulumi.get(self, "function_name")

    @function_name.setter
    def function_name(self, value: str):
        pulumi.set(self, "function_name", value)

    @property
    @pulumi.getter(name="inputColumnNames")
    def input_column_names(self) -> Sequence[str]:
        return pulumi.get(self, "input_column_names")

    @input_column_names.setter
    def input_column_names(self, value: Sequence[str]):
        pulumi.set(self, "input_column_names", value)


if not MYPY:
    class GetTableTableInfoTableConstraintArgsDict(TypedDict):
        foreign_key_constraint: NotRequired['GetTableTableInfoTableConstraintForeignKeyConstraintArgsDict']
        named_table_constraint: NotRequired['GetTableTableInfoTableConstraintNamedTableConstraintArgsDict']
        primary_key_constraint: NotRequired['GetTableTableInfoTableConstraintPrimaryKeyConstraintArgsDict']
elif False:
    GetTableTableInfoTableConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoTableConstraintArgs:
    def __init__(__self__, *,
                 foreign_key_constraint: Optional['GetTableTableInfoTableConstraintForeignKeyConstraintArgs'] = None,
                 named_table_constraint: Optional['GetTableTableInfoTableConstraintNamedTableConstraintArgs'] = None,
                 primary_key_constraint: Optional['GetTableTableInfoTableConstraintPrimaryKeyConstraintArgs'] = None):
        if foreign_key_constraint is not None:
            pulumi.set(__self__, "foreign_key_constraint", foreign_key_constraint)
        if named_table_constraint is not None:
            pulumi.set(__self__, "named_table_constraint", named_table_constraint)
        if primary_key_constraint is not None:
            pulumi.set(__self__, "primary_key_constraint", primary_key_constraint)

    @property
    @pulumi.getter(name="foreignKeyConstraint")
    def foreign_key_constraint(self) -> Optional['GetTableTableInfoTableConstraintForeignKeyConstraintArgs']:
        return pulumi.get(self, "foreign_key_constraint")

    @foreign_key_constraint.setter
    def foreign_key_constraint(self, value: Optional['GetTableTableInfoTableConstraintForeignKeyConstraintArgs']):
        pulumi.set(self, "foreign_key_constraint", value)

    @property
    @pulumi.getter(name="namedTableConstraint")
    def named_table_constraint(self) -> Optional['GetTableTableInfoTableConstraintNamedTableConstraintArgs']:
        return pulumi.get(self, "named_table_constraint")

    @named_table_constraint.setter
    def named_table_constraint(self, value: Optional['GetTableTableInfoTableConstraintNamedTableConstraintArgs']):
        pulumi.set(self, "named_table_constraint", value)

    @property
    @pulumi.getter(name="primaryKeyConstraint")
    def primary_key_constraint(self) -> Optional['GetTableTableInfoTableConstraintPrimaryKeyConstraintArgs']:
        return pulumi.get(self, "primary_key_constraint")

    @primary_key_constraint.setter
    def primary_key_constraint(self, value: Optional['GetTableTableInfoTableConstraintPrimaryKeyConstraintArgs']):
        pulumi.set(self, "primary_key_constraint", value)


if not MYPY:
    class GetTableTableInfoTableConstraintForeignKeyConstraintArgsDict(TypedDict):
        child_columns: Sequence[str]
        name: str
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        parent_columns: Sequence[str]
        parent_table: str
elif False:
    GetTableTableInfoTableConstraintForeignKeyConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoTableConstraintForeignKeyConstraintArgs:
    def __init__(__self__, *,
                 child_columns: Sequence[str],
                 name: str,
                 parent_columns: Sequence[str],
                 parent_table: str):
        """
        :param str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        pulumi.set(__self__, "child_columns", child_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_columns", parent_columns)
        pulumi.set(__self__, "parent_table", parent_table)

    @property
    @pulumi.getter(name="childColumns")
    def child_columns(self) -> Sequence[str]:
        return pulumi.get(self, "child_columns")

    @child_columns.setter
    def child_columns(self, value: Sequence[str]):
        pulumi.set(self, "child_columns", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentColumns")
    def parent_columns(self) -> Sequence[str]:
        return pulumi.get(self, "parent_columns")

    @parent_columns.setter
    def parent_columns(self, value: Sequence[str]):
        pulumi.set(self, "parent_columns", value)

    @property
    @pulumi.getter(name="parentTable")
    def parent_table(self) -> str:
        return pulumi.get(self, "parent_table")

    @parent_table.setter
    def parent_table(self, value: str):
        pulumi.set(self, "parent_table", value)


if not MYPY:
    class GetTableTableInfoTableConstraintNamedTableConstraintArgsDict(TypedDict):
        name: str
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
elif False:
    GetTableTableInfoTableConstraintNamedTableConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoTableConstraintNamedTableConstraintArgs:
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetTableTableInfoTableConstraintPrimaryKeyConstraintArgsDict(TypedDict):
        child_columns: Sequence[str]
        name: str
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
elif False:
    GetTableTableInfoTableConstraintPrimaryKeyConstraintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoTableConstraintPrimaryKeyConstraintArgs:
    def __init__(__self__, *,
                 child_columns: Sequence[str],
                 name: str):
        """
        :param str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        pulumi.set(__self__, "child_columns", child_columns)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="childColumns")
    def child_columns(self) -> Sequence[str]:
        return pulumi.get(self, "child_columns")

    @child_columns.setter
    def child_columns(self, value: Sequence[str]):
        pulumi.set(self, "child_columns", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetTableTableInfoViewDependenciesArgsDict(TypedDict):
        dependencies: NotRequired[Sequence['GetTableTableInfoViewDependenciesDependencyArgsDict']]
elif False:
    GetTableTableInfoViewDependenciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoViewDependenciesArgs:
    def __init__(__self__, *,
                 dependencies: Optional[Sequence['GetTableTableInfoViewDependenciesDependencyArgs']] = None):
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['GetTableTableInfoViewDependenciesDependencyArgs']]:
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[Sequence['GetTableTableInfoViewDependenciesDependencyArgs']]):
        pulumi.set(self, "dependencies", value)


if not MYPY:
    class GetTableTableInfoViewDependenciesDependencyArgsDict(TypedDict):
        function: NotRequired['GetTableTableInfoViewDependenciesDependencyFunctionArgsDict']
        table: NotRequired['GetTableTableInfoViewDependenciesDependencyTableArgsDict']
elif False:
    GetTableTableInfoViewDependenciesDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoViewDependenciesDependencyArgs:
    def __init__(__self__, *,
                 function: Optional['GetTableTableInfoViewDependenciesDependencyFunctionArgs'] = None,
                 table: Optional['GetTableTableInfoViewDependenciesDependencyTableArgs'] = None):
        if function is not None:
            pulumi.set(__self__, "function", function)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def function(self) -> Optional['GetTableTableInfoViewDependenciesDependencyFunctionArgs']:
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional['GetTableTableInfoViewDependenciesDependencyFunctionArgs']):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def table(self) -> Optional['GetTableTableInfoViewDependenciesDependencyTableArgs']:
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: Optional['GetTableTableInfoViewDependenciesDependencyTableArgs']):
        pulumi.set(self, "table", value)


if not MYPY:
    class GetTableTableInfoViewDependenciesDependencyFunctionArgsDict(TypedDict):
        function_full_name: str
elif False:
    GetTableTableInfoViewDependenciesDependencyFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoViewDependenciesDependencyFunctionArgs:
    def __init__(__self__, *,
                 function_full_name: str):
        pulumi.set(__self__, "function_full_name", function_full_name)

    @property
    @pulumi.getter(name="functionFullName")
    def function_full_name(self) -> str:
        return pulumi.get(self, "function_full_name")

    @function_full_name.setter
    def function_full_name(self, value: str):
        pulumi.set(self, "function_full_name", value)


if not MYPY:
    class GetTableTableInfoViewDependenciesDependencyTableArgsDict(TypedDict):
        table_full_name: str
elif False:
    GetTableTableInfoViewDependenciesDependencyTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTableTableInfoViewDependenciesDependencyTableArgs:
    def __init__(__self__, *,
                 table_full_name: str):
        pulumi.set(__self__, "table_full_name", table_full_name)

    @property
    @pulumi.getter(name="tableFullName")
    def table_full_name(self) -> str:
        return pulumi.get(self, "table_full_name")

    @table_full_name.setter
    def table_full_name(self, value: str):
        pulumi.set(self, "table_full_name", value)


if not MYPY:
    class GetVolumeVolumeInfoArgsDict(TypedDict):
        access_point: NotRequired[str]
        """
        the AWS access point to use when accessing s3 bucket for this volume's external location
        """
        browse_only: NotRequired[bool]
        """
        indicates whether the principal is limited to retrieving metadata for the volume through the BROWSE privilege when include_browse is enabled in the request.
        """
        catalog_name: NotRequired[str]
        """
        the name of the catalog where the schema and the volume are
        """
        comment: NotRequired[str]
        """
        the comment attached to the volume
        """
        created_at: NotRequired[int]
        """
        the Unix timestamp at the volume's creation
        """
        created_by: NotRequired[str]
        """
        the identifier of the user who created the volume
        """
        encryption_details: NotRequired['GetVolumeVolumeInfoEncryptionDetailsArgsDict']
        """
        encryption options that apply to clients connecting to cloud storage
        """
        full_name: NotRequired[str]
        """
        the three-level (fully qualified) name of the volume
        """
        metastore_id: NotRequired[str]
        """
        the unique identifier of the metastore
        """
        name: NotRequired[str]
        """
        a fully qualified name of databricks_volume: *`catalog`.`schema`.`volume`*
        """
        owner: NotRequired[str]
        """
        the identifier of the user who owns the volume
        """
        schema_name: NotRequired[str]
        """
        the name of the schema where the volume is
        """
        storage_location: NotRequired[str]
        """
        the storage location on the cloud
        """
        updated_at: NotRequired[int]
        """
        the timestamp of the last time changes were made to the volume
        """
        updated_by: NotRequired[str]
        """
        the identifier of the user who updated the volume last time
        """
        volume_id: NotRequired[str]
        """
        the unique identifier of the volume
        """
        volume_type: NotRequired[str]
        """
        whether the volume is `MANAGED` or `EXTERNAL`
        """
elif False:
    GetVolumeVolumeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeVolumeInfoArgs:
    def __init__(__self__, *,
                 access_point: Optional[str] = None,
                 browse_only: Optional[bool] = None,
                 catalog_name: Optional[str] = None,
                 comment: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 encryption_details: Optional['GetVolumeVolumeInfoEncryptionDetailsArgs'] = None,
                 full_name: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 schema_name: Optional[str] = None,
                 storage_location: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        :param str access_point: the AWS access point to use when accessing s3 bucket for this volume's external location
        :param bool browse_only: indicates whether the principal is limited to retrieving metadata for the volume through the BROWSE privilege when include_browse is enabled in the request.
        :param str catalog_name: the name of the catalog where the schema and the volume are
        :param str comment: the comment attached to the volume
        :param int created_at: the Unix timestamp at the volume's creation
        :param str created_by: the identifier of the user who created the volume
        :param 'GetVolumeVolumeInfoEncryptionDetailsArgs' encryption_details: encryption options that apply to clients connecting to cloud storage
        :param str full_name: the three-level (fully qualified) name of the volume
        :param str metastore_id: the unique identifier of the metastore
        :param str name: a fully qualified name of databricks_volume: *`catalog`.`schema`.`volume`*
        :param str owner: the identifier of the user who owns the volume
        :param str schema_name: the name of the schema where the volume is
        :param str storage_location: the storage location on the cloud
        :param int updated_at: the timestamp of the last time changes were made to the volume
        :param str updated_by: the identifier of the user who updated the volume last time
        :param str volume_id: the unique identifier of the volume
        :param str volume_type: whether the volume is `MANAGED` or `EXTERNAL`
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if encryption_details is not None:
            pulumi.set(__self__, "encryption_details", encryption_details)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[str]:
        """
        the AWS access point to use when accessing s3 bucket for this volume's external location
        """
        return pulumi.get(self, "access_point")

    @access_point.setter
    def access_point(self, value: Optional[str]):
        pulumi.set(self, "access_point", value)

    @property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[bool]:
        """
        indicates whether the principal is limited to retrieving metadata for the volume through the BROWSE privilege when include_browse is enabled in the request.
        """
        return pulumi.get(self, "browse_only")

    @browse_only.setter
    def browse_only(self, value: Optional[bool]):
        pulumi.set(self, "browse_only", value)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[str]:
        """
        the name of the catalog where the schema and the volume are
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: Optional[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        the comment attached to the volume
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        """
        the Unix timestamp at the volume's creation
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        the identifier of the user who created the volume
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="encryptionDetails")
    def encryption_details(self) -> Optional['GetVolumeVolumeInfoEncryptionDetailsArgs']:
        """
        encryption options that apply to clients connecting to cloud storage
        """
        return pulumi.get(self, "encryption_details")

    @encryption_details.setter
    def encryption_details(self, value: Optional['GetVolumeVolumeInfoEncryptionDetailsArgs']):
        pulumi.set(self, "encryption_details", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        the three-level (fully qualified) name of the volume
        """
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[str]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        a fully qualified name of databricks_volume: *`catalog`.`schema`.`volume`*
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        the identifier of the user who owns the volume
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        the name of the schema where the volume is
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[str]):
        pulumi.set(self, "schema_name", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        """
        the storage location on the cloud
        """
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[str]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        """
        the timestamp of the last time changes were made to the volume
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        """
        the identifier of the user who updated the volume last time
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        the unique identifier of the volume
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[str]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        whether the volume is `MANAGED` or `EXTERNAL`
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class GetVolumeVolumeInfoEncryptionDetailsArgsDict(TypedDict):
        sse_encryption_details: NotRequired['GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgsDict']
elif False:
    GetVolumeVolumeInfoEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeVolumeInfoEncryptionDetailsArgs:
    def __init__(__self__, *,
                 sse_encryption_details: Optional['GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgs'] = None):
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgs']:
        return pulumi.get(self, "sse_encryption_details")

    @sse_encryption_details.setter
    def sse_encryption_details(self, value: Optional['GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgs']):
        pulumi.set(self, "sse_encryption_details", value)


if not MYPY:
    class GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgsDict(TypedDict):
        algorithm: NotRequired[str]
        aws_kms_key_arn: NotRequired[str]
elif False:
    GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsArgs:
    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 aws_kms_key_arn: Optional[str] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[str]:
        return pulumi.get(self, "aws_kms_key_arn")

    @aws_kms_key_arn.setter
    def aws_kms_key_arn(self, value: Optional[str]):
        pulumi.set(self, "aws_kms_key_arn", value)


