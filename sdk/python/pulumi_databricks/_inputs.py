# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AccessControlRuleSetGrantRuleArgs',
    'ArtifactAllowlistArtifactMatcherArgs',
    'ClusterAutoscaleArgs',
    'ClusterAwsAttributesArgs',
    'ClusterAzureAttributesArgs',
    'ClusterClusterLogConfArgs',
    'ClusterClusterLogConfDbfsArgs',
    'ClusterClusterLogConfS3Args',
    'ClusterClusterMountInfoArgs',
    'ClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'ClusterDockerImageArgs',
    'ClusterDockerImageBasicAuthArgs',
    'ClusterGcpAttributesArgs',
    'ClusterInitScriptArgs',
    'ClusterInitScriptAbfssArgs',
    'ClusterInitScriptDbfsArgs',
    'ClusterInitScriptFileArgs',
    'ClusterInitScriptGcsArgs',
    'ClusterInitScriptS3Args',
    'ClusterInitScriptVolumesArgs',
    'ClusterInitScriptWorkspaceArgs',
    'ClusterLibraryArgs',
    'ClusterLibraryCranArgs',
    'ClusterLibraryMavenArgs',
    'ClusterLibraryPypiArgs',
    'ClusterWorkloadTypeArgs',
    'ClusterWorkloadTypeClientsArgs',
    'ExternalLocationEncryptionDetailsArgs',
    'ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs',
    'GrantsGrantArgs',
    'InstancePoolAwsAttributesArgs',
    'InstancePoolAzureAttributesArgs',
    'InstancePoolDiskSpecArgs',
    'InstancePoolDiskSpecDiskTypeArgs',
    'InstancePoolGcpAttributesArgs',
    'InstancePoolInstancePoolFleetAttributesArgs',
    'InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs',
    'InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs',
    'InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs',
    'InstancePoolPreloadedDockerImageArgs',
    'InstancePoolPreloadedDockerImageBasicAuthArgs',
    'JobComputeArgs',
    'JobComputeSpecArgs',
    'JobContinuousArgs',
    'JobDbtTaskArgs',
    'JobDeploymentArgs',
    'JobEmailNotificationsArgs',
    'JobGitSourceArgs',
    'JobGitSourceJobSourceArgs',
    'JobHealthArgs',
    'JobHealthRuleArgs',
    'JobJobClusterArgs',
    'JobJobClusterNewClusterArgs',
    'JobJobClusterNewClusterAutoscaleArgs',
    'JobJobClusterNewClusterAwsAttributesArgs',
    'JobJobClusterNewClusterAzureAttributesArgs',
    'JobJobClusterNewClusterClusterLogConfArgs',
    'JobJobClusterNewClusterClusterLogConfDbfsArgs',
    'JobJobClusterNewClusterClusterLogConfS3Args',
    'JobJobClusterNewClusterClusterMountInfoArgs',
    'JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobJobClusterNewClusterDockerImageArgs',
    'JobJobClusterNewClusterDockerImageBasicAuthArgs',
    'JobJobClusterNewClusterGcpAttributesArgs',
    'JobJobClusterNewClusterInitScriptArgs',
    'JobJobClusterNewClusterInitScriptAbfssArgs',
    'JobJobClusterNewClusterInitScriptDbfsArgs',
    'JobJobClusterNewClusterInitScriptFileArgs',
    'JobJobClusterNewClusterInitScriptGcsArgs',
    'JobJobClusterNewClusterInitScriptS3Args',
    'JobJobClusterNewClusterInitScriptVolumesArgs',
    'JobJobClusterNewClusterInitScriptWorkspaceArgs',
    'JobJobClusterNewClusterWorkloadTypeArgs',
    'JobJobClusterNewClusterWorkloadTypeClientsArgs',
    'JobLibraryArgs',
    'JobLibraryCranArgs',
    'JobLibraryMavenArgs',
    'JobLibraryPypiArgs',
    'JobNewClusterArgs',
    'JobNewClusterAutoscaleArgs',
    'JobNewClusterAwsAttributesArgs',
    'JobNewClusterAzureAttributesArgs',
    'JobNewClusterClusterLogConfArgs',
    'JobNewClusterClusterLogConfDbfsArgs',
    'JobNewClusterClusterLogConfS3Args',
    'JobNewClusterClusterMountInfoArgs',
    'JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobNewClusterDockerImageArgs',
    'JobNewClusterDockerImageBasicAuthArgs',
    'JobNewClusterGcpAttributesArgs',
    'JobNewClusterInitScriptArgs',
    'JobNewClusterInitScriptAbfssArgs',
    'JobNewClusterInitScriptDbfsArgs',
    'JobNewClusterInitScriptFileArgs',
    'JobNewClusterInitScriptGcsArgs',
    'JobNewClusterInitScriptS3Args',
    'JobNewClusterInitScriptVolumesArgs',
    'JobNewClusterInitScriptWorkspaceArgs',
    'JobNewClusterWorkloadTypeArgs',
    'JobNewClusterWorkloadTypeClientsArgs',
    'JobNotebookTaskArgs',
    'JobNotificationSettingsArgs',
    'JobParameterArgs',
    'JobPipelineTaskArgs',
    'JobPythonWheelTaskArgs',
    'JobQueueArgs',
    'JobRunAsArgs',
    'JobRunJobTaskArgs',
    'JobScheduleArgs',
    'JobSparkJarTaskArgs',
    'JobSparkPythonTaskArgs',
    'JobSparkSubmitTaskArgs',
    'JobTaskArgs',
    'JobTaskConditionTaskArgs',
    'JobTaskDbtTaskArgs',
    'JobTaskDependsOnArgs',
    'JobTaskEmailNotificationsArgs',
    'JobTaskHealthArgs',
    'JobTaskHealthRuleArgs',
    'JobTaskLibraryArgs',
    'JobTaskLibraryCranArgs',
    'JobTaskLibraryMavenArgs',
    'JobTaskLibraryPypiArgs',
    'JobTaskNewClusterArgs',
    'JobTaskNewClusterAutoscaleArgs',
    'JobTaskNewClusterAwsAttributesArgs',
    'JobTaskNewClusterAzureAttributesArgs',
    'JobTaskNewClusterClusterLogConfArgs',
    'JobTaskNewClusterClusterLogConfDbfsArgs',
    'JobTaskNewClusterClusterLogConfS3Args',
    'JobTaskNewClusterClusterMountInfoArgs',
    'JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'JobTaskNewClusterDockerImageArgs',
    'JobTaskNewClusterDockerImageBasicAuthArgs',
    'JobTaskNewClusterGcpAttributesArgs',
    'JobTaskNewClusterInitScriptArgs',
    'JobTaskNewClusterInitScriptAbfssArgs',
    'JobTaskNewClusterInitScriptDbfsArgs',
    'JobTaskNewClusterInitScriptFileArgs',
    'JobTaskNewClusterInitScriptGcsArgs',
    'JobTaskNewClusterInitScriptS3Args',
    'JobTaskNewClusterInitScriptVolumesArgs',
    'JobTaskNewClusterInitScriptWorkspaceArgs',
    'JobTaskNewClusterWorkloadTypeArgs',
    'JobTaskNewClusterWorkloadTypeClientsArgs',
    'JobTaskNotebookTaskArgs',
    'JobTaskNotificationSettingsArgs',
    'JobTaskPipelineTaskArgs',
    'JobTaskPythonWheelTaskArgs',
    'JobTaskRunJobTaskArgs',
    'JobTaskSparkJarTaskArgs',
    'JobTaskSparkPythonTaskArgs',
    'JobTaskSparkSubmitTaskArgs',
    'JobTaskSqlTaskArgs',
    'JobTaskSqlTaskAlertArgs',
    'JobTaskSqlTaskAlertSubscriptionArgs',
    'JobTaskSqlTaskDashboardArgs',
    'JobTaskSqlTaskDashboardSubscriptionArgs',
    'JobTaskSqlTaskFileArgs',
    'JobTaskSqlTaskQueryArgs',
    'JobTriggerArgs',
    'JobTriggerFileArrivalArgs',
    'JobWebhookNotificationsArgs',
    'JobWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'JobWebhookNotificationsOnFailureArgs',
    'JobWebhookNotificationsOnStartArgs',
    'JobWebhookNotificationsOnSuccessArgs',
    'LibraryCranArgs',
    'LibraryMavenArgs',
    'LibraryPypiArgs',
    'MetastoreDataAccessAwsIamRoleArgs',
    'MetastoreDataAccessAzureManagedIdentityArgs',
    'MetastoreDataAccessAzureServicePrincipalArgs',
    'MetastoreDataAccessDatabricksGcpServiceAccountArgs',
    'MetastoreDataAccessGcpServiceAccountKeyArgs',
    'MlflowModelTagArgs',
    'MlflowWebhookHttpUrlSpecArgs',
    'MlflowWebhookJobSpecArgs',
    'ModelServingConfigArgs',
    'ModelServingConfigServedModelArgs',
    'ModelServingConfigTrafficConfigArgs',
    'ModelServingConfigTrafficConfigRouteArgs',
    'ModelServingTagArgs',
    'MountAbfsArgs',
    'MountAdlArgs',
    'MountGsArgs',
    'MountS3Args',
    'MountWasbArgs',
    'MwsCustomerManagedKeysAwsKeyInfoArgs',
    'MwsCustomerManagedKeysGcpKeyInfoArgs',
    'MwsNetworksErrorMessageArgs',
    'MwsNetworksGcpNetworkInfoArgs',
    'MwsNetworksVpcEndpointsArgs',
    'MwsVpcEndpointGcpVpcEndpointInfoArgs',
    'MwsWorkspacesCloudResourceContainerArgs',
    'MwsWorkspacesCloudResourceContainerGcpArgs',
    'MwsWorkspacesExternalCustomerInfoArgs',
    'MwsWorkspacesGcpManagedNetworkConfigArgs',
    'MwsWorkspacesGkeConfigArgs',
    'MwsWorkspacesTokenArgs',
    'PermissionsAccessControlArgs',
    'PipelineClusterArgs',
    'PipelineClusterAutoscaleArgs',
    'PipelineClusterAwsAttributesArgs',
    'PipelineClusterAzureAttributesArgs',
    'PipelineClusterClusterLogConfArgs',
    'PipelineClusterClusterLogConfDbfsArgs',
    'PipelineClusterClusterLogConfS3Args',
    'PipelineClusterGcpAttributesArgs',
    'PipelineClusterInitScriptArgs',
    'PipelineClusterInitScriptAbfssArgs',
    'PipelineClusterInitScriptDbfsArgs',
    'PipelineClusterInitScriptFileArgs',
    'PipelineClusterInitScriptGcsArgs',
    'PipelineClusterInitScriptS3Args',
    'PipelineClusterInitScriptVolumesArgs',
    'PipelineClusterInitScriptWorkspaceArgs',
    'PipelineFiltersArgs',
    'PipelineLibraryArgs',
    'PipelineLibraryFileArgs',
    'PipelineLibraryMavenArgs',
    'PipelineLibraryNotebookArgs',
    'PipelineNotificationArgs',
    'RecipientIpAccessListArgs',
    'RecipientTokenArgs',
    'RepoSparseCheckoutArgs',
    'SecretScopeKeyvaultMetadataArgs',
    'ShareObjectArgs',
    'ShareObjectPartitionArgs',
    'ShareObjectPartitionValueArgs',
    'SqlAlertOptionsArgs',
    'SqlEndpointChannelArgs',
    'SqlEndpointOdbcParamsArgs',
    'SqlEndpointTagsArgs',
    'SqlEndpointTagsCustomTagArgs',
    'SqlPermissionsPrivilegeAssignmentArgs',
    'SqlQueryParameterArgs',
    'SqlQueryParameterDateArgs',
    'SqlQueryParameterDateRangeArgs',
    'SqlQueryParameterDateRangeRangeArgs',
    'SqlQueryParameterDatetimeArgs',
    'SqlQueryParameterDatetimeRangeArgs',
    'SqlQueryParameterDatetimeRangeRangeArgs',
    'SqlQueryParameterDatetimesecArgs',
    'SqlQueryParameterDatetimesecRangeArgs',
    'SqlQueryParameterDatetimesecRangeRangeArgs',
    'SqlQueryParameterEnumArgs',
    'SqlQueryParameterEnumMultipleArgs',
    'SqlQueryParameterNumberArgs',
    'SqlQueryParameterQueryArgs',
    'SqlQueryParameterQueryMultipleArgs',
    'SqlQueryParameterTextArgs',
    'SqlQueryScheduleArgs',
    'SqlQueryScheduleContinuousArgs',
    'SqlQueryScheduleDailyArgs',
    'SqlQueryScheduleWeeklyArgs',
    'SqlTableColumnArgs',
    'SqlWidgetParameterArgs',
    'SqlWidgetPositionArgs',
    'StorageCredentialAwsIamRoleArgs',
    'StorageCredentialAzureManagedIdentityArgs',
    'StorageCredentialAzureServicePrincipalArgs',
    'StorageCredentialDatabricksGcpServiceAccountArgs',
    'StorageCredentialGcpServiceAccountKeyArgs',
    'TableColumnArgs',
    'GetClusterClusterInfoArgs',
    'GetClusterClusterInfoAutoscaleArgs',
    'GetClusterClusterInfoAwsAttributesArgs',
    'GetClusterClusterInfoAzureAttributesArgs',
    'GetClusterClusterInfoClusterLogConfArgs',
    'GetClusterClusterInfoClusterLogConfDbfsArgs',
    'GetClusterClusterInfoClusterLogConfS3Args',
    'GetClusterClusterInfoClusterLogStatusArgs',
    'GetClusterClusterInfoDockerImageArgs',
    'GetClusterClusterInfoDockerImageBasicAuthArgs',
    'GetClusterClusterInfoDriverArgs',
    'GetClusterClusterInfoDriverNodeAwsAttributesArgs',
    'GetClusterClusterInfoExecutorArgs',
    'GetClusterClusterInfoExecutorNodeAwsAttributesArgs',
    'GetClusterClusterInfoGcpAttributesArgs',
    'GetClusterClusterInfoInitScriptArgs',
    'GetClusterClusterInfoInitScriptAbfssArgs',
    'GetClusterClusterInfoInitScriptDbfsArgs',
    'GetClusterClusterInfoInitScriptFileArgs',
    'GetClusterClusterInfoInitScriptGcsArgs',
    'GetClusterClusterInfoInitScriptS3Args',
    'GetClusterClusterInfoInitScriptVolumesArgs',
    'GetClusterClusterInfoInitScriptWorkspaceArgs',
    'GetClusterClusterInfoTerminationReasonArgs',
    'GetInstancePoolPoolInfoArgs',
    'GetInstancePoolPoolInfoAwsAttributesArgs',
    'GetInstancePoolPoolInfoAzureAttributesArgs',
    'GetInstancePoolPoolInfoDiskSpecArgs',
    'GetInstancePoolPoolInfoDiskSpecDiskTypeArgs',
    'GetInstancePoolPoolInfoGcpAttributesArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs',
    'GetInstancePoolPoolInfoPreloadedDockerImageArgs',
    'GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs',
    'GetInstancePoolPoolInfoStatsArgs',
    'GetJobJobSettingsArgs',
    'GetJobJobSettingsSettingsArgs',
    'GetJobJobSettingsSettingsComputeArgs',
    'GetJobJobSettingsSettingsComputeSpecArgs',
    'GetJobJobSettingsSettingsContinuousArgs',
    'GetJobJobSettingsSettingsDbtTaskArgs',
    'GetJobJobSettingsSettingsDeploymentArgs',
    'GetJobJobSettingsSettingsEmailNotificationsArgs',
    'GetJobJobSettingsSettingsGitSourceArgs',
    'GetJobJobSettingsSettingsGitSourceJobSourceArgs',
    'GetJobJobSettingsSettingsHealthArgs',
    'GetJobJobSettingsSettingsHealthRuleArgs',
    'GetJobJobSettingsSettingsJobClusterArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsLibraryArgs',
    'GetJobJobSettingsSettingsLibraryCranArgs',
    'GetJobJobSettingsSettingsLibraryMavenArgs',
    'GetJobJobSettingsSettingsLibraryPypiArgs',
    'GetJobJobSettingsSettingsNewClusterArgs',
    'GetJobJobSettingsSettingsNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsNotebookTaskArgs',
    'GetJobJobSettingsSettingsNotificationSettingsArgs',
    'GetJobJobSettingsSettingsParameterArgs',
    'GetJobJobSettingsSettingsPipelineTaskArgs',
    'GetJobJobSettingsSettingsPythonWheelTaskArgs',
    'GetJobJobSettingsSettingsQueueArgs',
    'GetJobJobSettingsSettingsRunAsArgs',
    'GetJobJobSettingsSettingsRunJobTaskArgs',
    'GetJobJobSettingsSettingsScheduleArgs',
    'GetJobJobSettingsSettingsSparkJarTaskArgs',
    'GetJobJobSettingsSettingsSparkPythonTaskArgs',
    'GetJobJobSettingsSettingsSparkSubmitTaskArgs',
    'GetJobJobSettingsSettingsTaskArgs',
    'GetJobJobSettingsSettingsTaskConditionTaskArgs',
    'GetJobJobSettingsSettingsTaskDbtTaskArgs',
    'GetJobJobSettingsSettingsTaskDependsOnArgs',
    'GetJobJobSettingsSettingsTaskEmailNotificationsArgs',
    'GetJobJobSettingsSettingsTaskHealthArgs',
    'GetJobJobSettingsSettingsTaskHealthRuleArgs',
    'GetJobJobSettingsSettingsTaskLibraryArgs',
    'GetJobJobSettingsSettingsTaskLibraryCranArgs',
    'GetJobJobSettingsSettingsTaskLibraryMavenArgs',
    'GetJobJobSettingsSettingsTaskLibraryPypiArgs',
    'GetJobJobSettingsSettingsTaskNewClusterArgs',
    'GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs',
    'GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs',
    'GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs',
    'GetJobJobSettingsSettingsTaskNotebookTaskArgs',
    'GetJobJobSettingsSettingsTaskNotificationSettingsArgs',
    'GetJobJobSettingsSettingsTaskPipelineTaskArgs',
    'GetJobJobSettingsSettingsTaskPythonWheelTaskArgs',
    'GetJobJobSettingsSettingsTaskRunJobTaskArgs',
    'GetJobJobSettingsSettingsTaskSparkJarTaskArgs',
    'GetJobJobSettingsSettingsTaskSparkPythonTaskArgs',
    'GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskFileArgs',
    'GetJobJobSettingsSettingsTaskSqlTaskQueryArgs',
    'GetJobJobSettingsSettingsTriggerArgs',
    'GetJobJobSettingsSettingsTriggerFileArrivalArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs',
    'GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs',
    'GetMetastoreMetastoreInfoArgs',
    'GetShareObjectArgs',
    'GetShareObjectPartitionArgs',
    'GetShareObjectPartitionValueArgs',
    'GetSqlWarehouseChannelArgs',
    'GetSqlWarehouseOdbcParamsArgs',
    'GetSqlWarehouseTagsArgs',
    'GetSqlWarehouseTagsCustomTagArgs',
]

@pulumi.input_type
class AccessControlRuleSetGrantRuleArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[str],
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] role: Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page) or [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role).
               * `roles/servicePrincipal.manager` - Manager of a service principal.
               * `roles/servicePrincipal.user` - User of a service principal.
               * `roles/group.manager` - Manager of a group.
               * `roles/marketplace.admin` - Admin of marketplace.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] principals: a list of principals who are granted a role. The following format is supported:
               * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
               * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
               * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
        AccessControlRuleSetGrantRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role=role,
            principals=principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role: Optional[pulumi.Input[str]] = None,
             principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if role is None:
            raise TypeError("Missing 'role' argument")

        _setter("role", role)
        if principals is not None:
            _setter("principals", principals)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page) or [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role).
        * `roles/servicePrincipal.manager` - Manager of a service principal.
        * `roles/servicePrincipal.user` - User of a service principal.
        * `roles/group.manager` - Manager of a group.
        * `roles/marketplace.admin` - Admin of marketplace.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        a list of principals who are granted a role. The following format is supported:
        * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
        * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
        * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "principals", value)


@pulumi.input_type
class ArtifactAllowlistArtifactMatcherArgs:
    def __init__(__self__, *,
                 artifact: pulumi.Input[str],
                 match_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] artifact: The artifact path or maven coordinate.
        :param pulumi.Input[str] match_type: The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
        ArtifactAllowlistArtifactMatcherArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            artifact=artifact,
            match_type=match_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             artifact: Optional[pulumi.Input[str]] = None,
             match_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if artifact is None:
            raise TypeError("Missing 'artifact' argument")
        if match_type is None and 'matchType' in kwargs:
            match_type = kwargs['matchType']
        if match_type is None:
            raise TypeError("Missing 'match_type' argument")

        _setter("artifact", artifact)
        _setter("match_type", match_type)

    @property
    @pulumi.getter
    def artifact(self) -> pulumi.Input[str]:
        """
        The artifact path or maven coordinate.
        """
        return pulumi.get(self, "artifact")

    @artifact.setter
    def artifact(self, value: pulumi.Input[str]):
        pulumi.set(self, "artifact", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)


@pulumi.input_type
class ClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        ClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[pulumi.Input[int]] = None,
             min_workers: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class ClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        ClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             ebs_volume_count: Optional[pulumi.Input[int]] = None,
             ebs_volume_size: Optional[pulumi.Input[int]] = None,
             ebs_volume_type: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             instance_profile_arn: Optional[pulumi.Input[str]] = None,
             spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class ClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        ClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             spot_bid_max_price: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class ClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterClusterLogConfS3Args']] = None):
        ClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']] = None,
             s3: Optional[pulumi.Input['ClusterClusterLogConfS3Args']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['ClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class ClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        ClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        ClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class ClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        ClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[pulumi.Input[str]] = None,
             network_filesystem_info: Optional[pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs']] = None,
             remote_mount_dir_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['ClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class ClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        ClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[pulumi.Input[str]] = None,
             mount_options: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class ClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']] = None):
        ClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             basic_auth: Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['ClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class ClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        ClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        ClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             boot_disk_size: Optional[pulumi.Input[int]] = None,
             google_service_account: Optional[pulumi.Input[str]] = None,
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            warnings.warn("""Please use 'availability' instead.""", DeprecationWarning)
            pulumi.log.warn("""use_preemptible_executors is deprecated: Please use 'availability' instead.""")
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        warnings.warn("""Please use 'availability' instead.""", DeprecationWarning)
        pulumi.log.warn("""use_preemptible_executors is deprecated: Please use 'availability' instead.""")

        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class ClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['ClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['ClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['ClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['ClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['ClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']] = None):
        ClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional[pulumi.Input['ClusterInitScriptAbfssArgs']] = None,
             dbfs: Optional[pulumi.Input['ClusterInitScriptDbfsArgs']] = None,
             file: Optional[pulumi.Input['ClusterInitScriptFileArgs']] = None,
             gcs: Optional[pulumi.Input['ClusterInitScriptGcsArgs']] = None,
             s3: Optional[pulumi.Input['ClusterInitScriptS3Args']] = None,
             volumes: Optional[pulumi.Input['ClusterInitScriptVolumesArgs']] = None,
             workspace: Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['ClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['ClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['ClusterInitScriptDbfsArgs']]:
        warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
        pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")

        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['ClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['ClusterInitScriptFileArgs']]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['ClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['ClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['ClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['ClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['ClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['ClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class ClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        ClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        ClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        ClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        ClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        ClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class ClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        ClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        ClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class ClusterLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['ClusterLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['ClusterLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['ClusterLibraryPypiArgs']] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        ClusterLibraryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cran=cran,
            egg=egg,
            jar=jar,
            maven=maven,
            pypi=pypi,
            whl=whl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cran: Optional[pulumi.Input['ClusterLibraryCranArgs']] = None,
             egg: Optional[pulumi.Input[str]] = None,
             jar: Optional[pulumi.Input[str]] = None,
             maven: Optional[pulumi.Input['ClusterLibraryMavenArgs']] = None,
             pypi: Optional[pulumi.Input['ClusterLibraryPypiArgs']] = None,
             whl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cran is not None:
            _setter("cran", cran)
        if egg is not None:
            _setter("egg", egg)
        if jar is not None:
            _setter("jar", jar)
        if maven is not None:
            _setter("maven", maven)
        if pypi is not None:
            _setter("pypi", pypi)
        if whl is not None:
            _setter("whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['ClusterLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['ClusterLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['ClusterLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['ClusterLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['ClusterLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['ClusterLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


@pulumi.input_type
class ClusterLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        ClusterLibraryCranArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class ClusterLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        ClusterLibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class ClusterLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        ClusterLibraryPypiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class ClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['ClusterWorkloadTypeClientsArgs']):
        ClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional[pulumi.Input['ClusterWorkloadTypeClientsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['ClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['ClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class ClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        ClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[pulumi.Input[bool]] = None,
             notebooks: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class ExternalLocationEncryptionDetailsArgs:
    def __init__(__self__, *,
                 sse_encryption_details: Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']] = None):
        ExternalLocationEncryptionDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sse_encryption_details=sse_encryption_details,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sse_encryption_details: Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if sse_encryption_details is None and 'sseEncryptionDetails' in kwargs:
            sse_encryption_details = kwargs['sseEncryptionDetails']

        if sse_encryption_details is not None:
            _setter("sse_encryption_details", sse_encryption_details)

    @property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']]:
        return pulumi.get(self, "sse_encryption_details")

    @sse_encryption_details.setter
    def sse_encryption_details(self, value: Optional[pulumi.Input['ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs']]):
        pulumi.set(self, "sse_encryption_details", value)


@pulumi.input_type
class ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 aws_kms_key_arn: Optional[pulumi.Input[str]] = None):
        ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            aws_kms_key_arn=aws_kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[pulumi.Input[str]] = None,
             aws_kms_key_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if aws_kms_key_arn is None and 'awsKmsKeyArn' in kwargs:
            aws_kms_key_arn = kwargs['awsKmsKeyArn']

        if algorithm is not None:
            _setter("algorithm", algorithm)
        if aws_kms_key_arn is not None:
            _setter("aws_kms_key_arn", aws_kms_key_arn)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aws_kms_key_arn")

    @aws_kms_key_arn.setter
    def aws_kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_kms_key_arn", value)


@pulumi.input_type
class GrantsGrantArgs:
    def __init__(__self__, *,
                 principal: pulumi.Input[str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[str]]]):
        GrantsGrantArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal=principal,
            privileges=privileges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal: Optional[pulumi.Input[str]] = None,
             privileges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if principal is None:
            raise TypeError("Missing 'principal' argument")
        if privileges is None:
            raise TypeError("Missing 'privileges' argument")

        _setter("principal", principal)
        _setter("privileges", privileges)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[str]:
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "privileges", value)


@pulumi.input_type
class InstancePoolAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability: (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        :param pulumi.Input[int] spot_bid_price_percent: (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance types on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        :param pulumi.Input[str] zone_id: (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        InstancePoolAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance types on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        """
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class InstancePoolAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] availability: Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        :param pulumi.Input[float] spot_bid_max_price: The max price for Azure spot instances.  Use `-1` to specify the lowest price.
        """
        InstancePoolAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             spot_bid_max_price: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        """
        The max price for Azure spot instances.  Use `-1` to specify the lowest price.
        """
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class InstancePoolDiskSpecArgs:
    def __init__(__self__, *,
                 disk_count: Optional[pulumi.Input[int]] = None,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 disk_type: Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']] = None):
        """
        :param pulumi.Input[int] disk_count: (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        :param pulumi.Input[int] disk_size: (Integer) The size of each disk (in GiB) to attach.
        """
        InstancePoolDiskSpecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_count=disk_count,
            disk_size=disk_size,
            disk_type=disk_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_count: Optional[pulumi.Input[int]] = None,
             disk_size: Optional[pulumi.Input[int]] = None,
             disk_type: Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if disk_count is None and 'diskCount' in kwargs:
            disk_count = kwargs['diskCount']
        if disk_size is None and 'diskSize' in kwargs:
            disk_size = kwargs['diskSize']
        if disk_type is None and 'diskType' in kwargs:
            disk_type = kwargs['diskType']

        if disk_count is not None:
            _setter("disk_count", disk_count)
        if disk_size is not None:
            _setter("disk_size", disk_size)
        if disk_type is not None:
            _setter("disk_type", disk_type)

    @property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        """
        return pulumi.get(self, "disk_count")

    @disk_count.setter
    def disk_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_count", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) The size of each disk (in GiB) to attach.
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input['InstancePoolDiskSpecDiskTypeArgs']]):
        pulumi.set(self, "disk_type", value)


@pulumi.input_type
class InstancePoolDiskSpecDiskTypeArgs:
    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[pulumi.Input[str]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None):
        InstancePoolDiskSpecDiskTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_disk_volume_type=azure_disk_volume_type,
            ebs_volume_type=ebs_volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_disk_volume_type: Optional[pulumi.Input[str]] = None,
             ebs_volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if azure_disk_volume_type is None and 'azureDiskVolumeType' in kwargs:
            azure_disk_volume_type = kwargs['azureDiskVolumeType']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']

        if azure_disk_volume_type is not None:
            _setter("azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)

    @property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "azure_disk_volume_type")

    @azure_disk_volume_type.setter
    def azure_disk_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_disk_volume_type", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)


@pulumi.input_type
class InstancePoolGcpAttributesArgs:
    def __init__(__self__, *,
                 gcp_availability: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] gcp_availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param pulumi.Input[int] local_ssd_count: Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        InstancePoolGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gcp_availability=gcp_availability,
            local_ssd_count=local_ssd_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gcp_availability: Optional[pulumi.Input[str]] = None,
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if gcp_availability is None and 'gcpAvailability' in kwargs:
            gcp_availability = kwargs['gcpAvailability']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']

        if gcp_availability is not None:
            _setter("gcp_availability", gcp_availability)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)

    @property
    @pulumi.getter(name="gcpAvailability")
    def gcp_availability(self) -> Optional[pulumi.Input[str]]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "gcp_availability")

    @gcp_availability.setter
    def gcp_availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gcp_availability", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)


@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesArgs:
    def __init__(__self__, *,
                 launch_template_overrides: pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]],
                 fleet_on_demand_option: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']] = None,
                 fleet_spot_option: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']] = None):
        InstancePoolInstancePoolFleetAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            launch_template_overrides=launch_template_overrides,
            fleet_on_demand_option=fleet_on_demand_option,
            fleet_spot_option=fleet_spot_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             launch_template_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]]] = None,
             fleet_on_demand_option: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']] = None,
             fleet_spot_option: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if launch_template_overrides is None and 'launchTemplateOverrides' in kwargs:
            launch_template_overrides = kwargs['launchTemplateOverrides']
        if launch_template_overrides is None:
            raise TypeError("Missing 'launch_template_overrides' argument")
        if fleet_on_demand_option is None and 'fleetOnDemandOption' in kwargs:
            fleet_on_demand_option = kwargs['fleetOnDemandOption']
        if fleet_spot_option is None and 'fleetSpotOption' in kwargs:
            fleet_spot_option = kwargs['fleetSpotOption']

        _setter("launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            _setter("fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            _setter("fleet_spot_option", fleet_spot_option)

    @property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]]:
        return pulumi.get(self, "launch_template_overrides")

    @launch_template_overrides.setter
    def launch_template_overrides(self, value: pulumi.Input[Sequence[pulumi.Input['InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs']]]):
        pulumi.set(self, "launch_template_overrides", value)

    @property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']]:
        return pulumi.get(self, "fleet_on_demand_option")

    @fleet_on_demand_option.setter
    def fleet_on_demand_option(self, value: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs']]):
        pulumi.set(self, "fleet_on_demand_option", value)

    @property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']]:
        return pulumi.get(self, "fleet_spot_option")

    @fleet_spot_option.setter
    def fleet_spot_option(self, value: Optional[pulumi.Input['InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs']]):
        pulumi.set(self, "fleet_spot_option", value)


@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[str],
                 instance_pools_to_use_count: Optional[pulumi.Input[int]] = None):
        InstancePoolInstancePoolFleetAttributesFleetOnDemandOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
            instance_pools_to_use_count=instance_pools_to_use_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: Optional[pulumi.Input[str]] = None,
             instance_pools_to_use_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if allocation_strategy is None and 'allocationStrategy' in kwargs:
            allocation_strategy = kwargs['allocationStrategy']
        if allocation_strategy is None:
            raise TypeError("Missing 'allocation_strategy' argument")
        if instance_pools_to_use_count is None and 'instancePoolsToUseCount' in kwargs:
            instance_pools_to_use_count = kwargs['instancePoolsToUseCount']

        _setter("allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            _setter("instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)


@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: pulumi.Input[str],
                 instance_pools_to_use_count: Optional[pulumi.Input[int]] = None):
        InstancePoolInstancePoolFleetAttributesFleetSpotOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
            instance_pools_to_use_count=instance_pools_to_use_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: Optional[pulumi.Input[str]] = None,
             instance_pools_to_use_count: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if allocation_strategy is None and 'allocationStrategy' in kwargs:
            allocation_strategy = kwargs['allocationStrategy']
        if allocation_strategy is None:
            raise TypeError("Missing 'allocation_strategy' argument")
        if instance_pools_to_use_count is None and 'instancePoolsToUseCount' in kwargs:
            instance_pools_to_use_count = kwargs['instancePoolsToUseCount']

        _setter("allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            _setter("instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)


@pulumi.input_type
class InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: pulumi.Input[str],
                 instance_type: pulumi.Input[str]):
        InstancePoolInstancePoolFleetAttributesLaunchTemplateOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            instance_type=instance_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[pulumi.Input[str]] = None,
             instance_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")

        _setter("availability_zone", availability_zone)
        _setter("instance_type", instance_type)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)


@pulumi.input_type
class InstancePoolPreloadedDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']] = None):
        InstancePoolPreloadedDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             basic_auth: Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['InstancePoolPreloadedDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class InstancePoolPreloadedDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        InstancePoolPreloadedDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class JobComputeArgs:
    def __init__(__self__, *,
                 compute_key: Optional[pulumi.Input[str]] = None,
                 spec: Optional[pulumi.Input['JobComputeSpecArgs']] = None):
        JobComputeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_key=compute_key,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_key: Optional[pulumi.Input[str]] = None,
             spec: Optional[pulumi.Input['JobComputeSpecArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if compute_key is None and 'computeKey' in kwargs:
            compute_key = kwargs['computeKey']

        if compute_key is not None:
            _setter("compute_key", compute_key)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter(name="computeKey")
    def compute_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "compute_key")

    @compute_key.setter
    def compute_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_key", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['JobComputeSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['JobComputeSpecArgs']]):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class JobComputeSpecArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None):
        JobComputeSpecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class JobContinuousArgs:
    def __init__(__self__, *,
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pause_status: Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        JobContinuousArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pause_status=pause_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pause_status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pause_status is None and 'pauseStatus' in kwargs:
            pause_status = kwargs['pauseStatus']

        if pause_status is not None:
            _setter("pause_status", pause_status)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


@pulumi.input_type
class JobDbtTaskArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 catalog: Optional[pulumi.Input[str]] = None,
                 profiles_directory: Optional[pulumi.Input[str]] = None,
                 project_directory: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param pulumi.Input[str] catalog: The name of the catalog to use inside Unity Catalog.
        :param pulumi.Input[str] profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param pulumi.Input[str] project_directory: The relative path to the directory in the repository specified in `git_source` where dbt should look in for the `dbt_project.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--project-dir` to a dbt command.
        :param pulumi.Input[str] schema: The name of the schema dbt should run in. Defaults to `default`.
        :param pulumi.Input[str] warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        JobDbtTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            catalog=catalog,
            profiles_directory=profiles_directory,
            project_directory=project_directory,
            schema=schema,
            warehouse_id=warehouse_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             catalog: Optional[pulumi.Input[str]] = None,
             profiles_directory: Optional[pulumi.Input[str]] = None,
             project_directory: Optional[pulumi.Input[str]] = None,
             schema: Optional[pulumi.Input[str]] = None,
             warehouse_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if profiles_directory is None and 'profilesDirectory' in kwargs:
            profiles_directory = kwargs['profilesDirectory']
        if project_directory is None and 'projectDirectory' in kwargs:
            project_directory = kwargs['projectDirectory']
        if warehouse_id is None and 'warehouseId' in kwargs:
            warehouse_id = kwargs['warehouseId']

        _setter("commands", commands)
        if catalog is not None:
            _setter("catalog", catalog)
        if profiles_directory is not None:
            _setter("profiles_directory", profiles_directory)
        if project_directory is not None:
            _setter("project_directory", project_directory)
        if schema is not None:
            _setter("schema", schema)
        if warehouse_id is not None:
            _setter("warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified in `git_source` where dbt should look in for the `dbt_project.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--project-dir` to a dbt command.
        """
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


@pulumi.input_type
class JobDeploymentArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 metadata_file_path: Optional[pulumi.Input[str]] = None):
        JobDeploymentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            metadata_file_path=metadata_file_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             metadata_file_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if metadata_file_path is None and 'metadataFilePath' in kwargs:
            metadata_file_path = kwargs['metadataFilePath']

        _setter("kind", kind)
        if metadata_file_path is not None:
            _setter("metadata_file_path", metadata_file_path)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata_file_path")

    @metadata_file_path.setter
    def metadata_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_file_path", value)


@pulumi.input_type
class JobEmailNotificationsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_failures: (List) list of emails to notify when the run fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_starts: (List) list of emails to notify when the run starts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        JobEmailNotificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_on_last_attempt=alert_on_last_attempt,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
            on_duration_warning_threshold_exceededs=on_duration_warning_threshold_exceededs,
            on_failures=on_failures,
            on_starts=on_starts,
            on_successes=on_successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
             no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
             on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_on_last_attempt is None and 'alertOnLastAttempt' in kwargs:
            alert_on_last_attempt = kwargs['alertOnLastAttempt']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']
        if on_duration_warning_threshold_exceededs is None and 'onDurationWarningThresholdExceededs' in kwargs:
            on_duration_warning_threshold_exceededs = kwargs['onDurationWarningThresholdExceededs']
        if on_failures is None and 'onFailures' in kwargs:
            on_failures = kwargs['onFailures']
        if on_starts is None and 'onStarts' in kwargs:
            on_starts = kwargs['onStarts']
        if on_successes is None and 'onSuccesses' in kwargs:
            on_successes = kwargs['onSuccesses']

        if alert_on_last_attempt is not None:
            _setter("alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            _setter("on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            _setter("on_failures", on_failures)
        if on_starts is not None:
            _setter("on_starts", on_starts)
        if on_successes is not None:
            _setter("on_successes", on_successes)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_successes", value)


@pulumi.input_type
class JobGitSourceArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 branch: Optional[pulumi.Input[str]] = None,
                 commit: Optional[pulumi.Input[str]] = None,
                 job_source: Optional[pulumi.Input['JobGitSourceJobSourceArgs']] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: URL of the Git repository to use.
        :param pulumi.Input[str] branch: name of the Git branch to use. Conflicts with `tag` and `commit`.
        :param pulumi.Input[str] commit: hash of Git commit to use. Conflicts with `branch` and `tag`.
        :param pulumi.Input[str] provider: case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        :param pulumi.Input[str] tag: name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        JobGitSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            branch=branch,
            commit=commit,
            job_source=job_source,
            provider=provider,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             branch: Optional[pulumi.Input[str]] = None,
             commit: Optional[pulumi.Input[str]] = None,
             job_source: Optional[pulumi.Input['JobGitSourceJobSourceArgs']] = None,
             provider: Optional[pulumi.Input[str]] = None,
             tag: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if job_source is None and 'jobSource' in kwargs:
            job_source = kwargs['jobSource']

        _setter("url", url)
        if branch is not None:
            _setter("branch", branch)
        if commit is not None:
            _setter("commit", commit)
        if job_source is not None:
            _setter("job_source", job_source)
        if provider is not None:
            _setter("provider", provider)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the Git repository to use.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        name of the Git branch to use. Conflicts with `tag` and `commit`.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def commit(self) -> Optional[pulumi.Input[str]]:
        """
        hash of Git commit to use. Conflicts with `branch` and `tag`.
        """
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter(name="jobSource")
    def job_source(self) -> Optional[pulumi.Input['JobGitSourceJobSourceArgs']]:
        return pulumi.get(self, "job_source")

    @job_source.setter
    def job_source(self, value: Optional[pulumi.Input['JobGitSourceJobSourceArgs']]):
        pulumi.set(self, "job_source", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class JobGitSourceJobSourceArgs:
    def __init__(__self__, *,
                 import_from_git_branch: pulumi.Input[str],
                 job_config_path: pulumi.Input[str],
                 dirty_state: Optional[pulumi.Input[str]] = None):
        JobGitSourceJobSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            import_from_git_branch=import_from_git_branch,
            job_config_path=job_config_path,
            dirty_state=dirty_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             import_from_git_branch: Optional[pulumi.Input[str]] = None,
             job_config_path: Optional[pulumi.Input[str]] = None,
             dirty_state: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if import_from_git_branch is None and 'importFromGitBranch' in kwargs:
            import_from_git_branch = kwargs['importFromGitBranch']
        if import_from_git_branch is None:
            raise TypeError("Missing 'import_from_git_branch' argument")
        if job_config_path is None and 'jobConfigPath' in kwargs:
            job_config_path = kwargs['jobConfigPath']
        if job_config_path is None:
            raise TypeError("Missing 'job_config_path' argument")
        if dirty_state is None and 'dirtyState' in kwargs:
            dirty_state = kwargs['dirtyState']

        _setter("import_from_git_branch", import_from_git_branch)
        _setter("job_config_path", job_config_path)
        if dirty_state is not None:
            _setter("dirty_state", dirty_state)

    @property
    @pulumi.getter(name="importFromGitBranch")
    def import_from_git_branch(self) -> pulumi.Input[str]:
        return pulumi.get(self, "import_from_git_branch")

    @import_from_git_branch.setter
    def import_from_git_branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "import_from_git_branch", value)

    @property
    @pulumi.getter(name="jobConfigPath")
    def job_config_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "job_config_path")

    @job_config_path.setter
    def job_config_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_config_path", value)

    @property
    @pulumi.getter(name="dirtyState")
    def dirty_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dirty_state")

    @dirty_state.setter
    def dirty_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dirty_state", value)


@pulumi.input_type
class JobHealthArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]] rules: list of rules that are represented as objects with the following attributes:
        """
        JobHealthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['JobHealthRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class JobHealthRuleArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[str]] = None,
                 op: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] metric: string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        :param pulumi.Input[str] op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param pulumi.Input[int] value: integer value used to compare to the given metric.
        """
        JobHealthRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            op=op,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: Optional[pulumi.Input[str]] = None,
             op: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if metric is not None:
            _setter("metric", metric)
        if op is not None:
            _setter("op", op)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class JobJobClusterArgs:
    def __init__(__self__, *,
                 job_cluster_key: Optional[pulumi.Input[str]] = None,
                 new_cluster: Optional[pulumi.Input['JobJobClusterNewClusterArgs']] = None):
        """
        :param pulumi.Input[str] job_cluster_key: Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        :param pulumi.Input['JobJobClusterNewClusterArgs'] new_cluster: Same set of parameters as for Cluster resource.
        """
        JobJobClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_cluster_key=job_cluster_key,
            new_cluster=new_cluster,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_cluster_key: Optional[pulumi.Input[str]] = None,
             new_cluster: Optional[pulumi.Input['JobJobClusterNewClusterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if job_cluster_key is None and 'jobClusterKey' in kwargs:
            job_cluster_key = kwargs['jobClusterKey']
        if new_cluster is None and 'newCluster' in kwargs:
            new_cluster = kwargs['newCluster']

        if job_cluster_key is not None:
            _setter("job_cluster_key", job_cluster_key)
        if new_cluster is not None:
            _setter("new_cluster", new_cluster)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional[pulumi.Input['JobJobClusterNewClusterArgs']]:
        """
        Same set of parameters as for Cluster resource.
        """
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional[pulumi.Input['JobJobClusterNewClusterArgs']]):
        pulumi.set(self, "new_cluster", value)


@pulumi.input_type
class JobJobClusterNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']] = None,
                 autotermination_minutes: Optional[pulumi.Input[int]] = None,
                 aws_attributes: Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']] = None):
        JobJobClusterNewClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            spark_version=spark_version,
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_mount_infos=cluster_mount_infos,
            cluster_name=cluster_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            gcp_attributes=gcp_attributes,
            idempotency_token=idempotency_token,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            node_type_id=node_type_id,
            num_workers=num_workers,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             spark_version: Optional[pulumi.Input[str]] = None,
             apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
             autoscale: Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']] = None,
             autotermination_minutes: Optional[pulumi.Input[int]] = None,
             aws_attributes: Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']] = None,
             azure_attributes: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']] = None,
             cluster_id: Optional[pulumi.Input[str]] = None,
             cluster_log_conf: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']] = None,
             cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]] = None,
             cluster_name: Optional[pulumi.Input[str]] = None,
             custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             data_security_mode: Optional[pulumi.Input[str]] = None,
             docker_image: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']] = None,
             driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
             driver_node_type_id: Optional[pulumi.Input[str]] = None,
             enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
             enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
             gcp_attributes: Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']] = None,
             idempotency_token: Optional[pulumi.Input[str]] = None,
             init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]] = None,
             instance_pool_id: Optional[pulumi.Input[str]] = None,
             node_type_id: Optional[pulumi.Input[str]] = None,
             num_workers: Optional[pulumi.Input[int]] = None,
             policy_id: Optional[pulumi.Input[str]] = None,
             runtime_engine: Optional[pulumi.Input[str]] = None,
             single_user_name: Optional[pulumi.Input[str]] = None,
             spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             workload_type: Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_mount_infos is None and 'clusterMountInfos' in kwargs:
            cluster_mount_infos = kwargs['clusterMountInfos']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if idempotency_token is None and 'idempotencyToken' in kwargs:
            idempotency_token = kwargs['idempotencyToken']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("spark_version", spark_version)
        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            _setter("cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if driver_instance_pool_id is not None:
            _setter("driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            _setter("driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            _setter("enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            _setter("idempotency_token", idempotency_token)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if node_type_id is not None:
            _setter("node_type_id", node_type_id)
        if num_workers is not None:
            _setter("num_workers", num_workers)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobJobClusterNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']]:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class JobJobClusterNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        JobJobClusterNewClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[pulumi.Input[int]] = None,
             min_workers: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class JobJobClusterNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             ebs_volume_count: Optional[pulumi.Input[int]] = None,
             ebs_volume_size: Optional[pulumi.Input[int]] = None,
             ebs_volume_type: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             instance_profile_arn: Optional[pulumi.Input[str]] = None,
             spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class JobJobClusterNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        JobJobClusterNewClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             spot_bid_max_price: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class JobJobClusterNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']] = None):
        JobJobClusterNewClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']] = None,
             s3: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobJobClusterNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class JobJobClusterNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        JobJobClusterNewClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class JobJobClusterNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[pulumi.Input[str]] = None,
             network_filesystem_info: Optional[pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs']] = None,
             remote_mount_dir_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[pulumi.Input[str]] = None,
             mount_options: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class JobJobClusterNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        JobJobClusterNewClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             basic_auth: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobJobClusterNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class JobJobClusterNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        JobJobClusterNewClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class JobJobClusterNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             boot_disk_size: Optional[pulumi.Input[int]] = None,
             google_service_account: Optional[pulumi.Input[str]] = None,
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs'] file: block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
                   databricks.JobTaskArgs(
                       task_key="run_agg_query",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           query=databricks.JobTaskSqlTaskQueryArgs(
                               query_id=databricks_sql_query["agg_query"]["id"],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_dashboard",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                               dashboard_id=databricks_sql_dashboard["dash"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_alert",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           alert=databricks.JobTaskSqlTaskAlertArgs(
                               alert_id=databricks_sql_alert["alert"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
               ])
               ```
        """
        JobJobClusterNewClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']] = None,
             dbfs: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']] = None,
             file: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']] = None,
             gcs: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']] = None,
             s3: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']] = None,
             volumes: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']] = None,
             workspace: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']]:
        warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
        pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")

        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
            databricks.JobTaskArgs(
                task_key="run_agg_query",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    query=databricks.JobTaskSqlTaskQueryArgs(
                        query_id=databricks_sql_query["agg_query"]["id"],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_dashboard",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                        dashboard_id=databricks_sql_dashboard["dash"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_alert",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    alert=databricks.JobTaskSqlTaskAlertArgs(
                        alert_id=databricks_sql_alert["alert"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
        ])
        ```
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobJobClusterNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        JobJobClusterNewClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobJobClusterNewClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobJobClusterNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']):
        JobJobClusterNewClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional[pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobJobClusterNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class JobJobClusterNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        JobJobClusterNewClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[pulumi.Input[bool]] = None,
             notebooks: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class JobLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobLibraryPypiArgs']] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        JobLibraryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cran=cran,
            egg=egg,
            jar=jar,
            maven=maven,
            pypi=pypi,
            whl=whl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cran: Optional[pulumi.Input['JobLibraryCranArgs']] = None,
             egg: Optional[pulumi.Input[str]] = None,
             jar: Optional[pulumi.Input[str]] = None,
             maven: Optional[pulumi.Input['JobLibraryMavenArgs']] = None,
             pypi: Optional[pulumi.Input['JobLibraryPypiArgs']] = None,
             whl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cran is not None:
            _setter("cran", cran)
        if egg is not None:
            _setter("egg", egg)
        if jar is not None:
            _setter("jar", jar)
        if maven is not None:
            _setter("maven", maven)
        if pypi is not None:
            _setter("pypi", pypi)
        if whl is not None:
            _setter("whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


@pulumi.input_type
class JobLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        JobLibraryCranArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class JobLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        JobLibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class JobLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        JobLibraryPypiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class JobNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobNewClusterAutoscaleArgs']] = None,
                 autotermination_minutes: Optional[pulumi.Input[int]] = None,
                 aws_attributes: Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']] = None):
        JobNewClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            spark_version=spark_version,
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_mount_infos=cluster_mount_infos,
            cluster_name=cluster_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            gcp_attributes=gcp_attributes,
            idempotency_token=idempotency_token,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            node_type_id=node_type_id,
            num_workers=num_workers,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             spark_version: Optional[pulumi.Input[str]] = None,
             apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
             autoscale: Optional[pulumi.Input['JobNewClusterAutoscaleArgs']] = None,
             autotermination_minutes: Optional[pulumi.Input[int]] = None,
             aws_attributes: Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']] = None,
             azure_attributes: Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']] = None,
             cluster_id: Optional[pulumi.Input[str]] = None,
             cluster_log_conf: Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']] = None,
             cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]] = None,
             cluster_name: Optional[pulumi.Input[str]] = None,
             custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             data_security_mode: Optional[pulumi.Input[str]] = None,
             docker_image: Optional[pulumi.Input['JobNewClusterDockerImageArgs']] = None,
             driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
             driver_node_type_id: Optional[pulumi.Input[str]] = None,
             enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
             enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
             gcp_attributes: Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']] = None,
             idempotency_token: Optional[pulumi.Input[str]] = None,
             init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]] = None,
             instance_pool_id: Optional[pulumi.Input[str]] = None,
             node_type_id: Optional[pulumi.Input[str]] = None,
             num_workers: Optional[pulumi.Input[int]] = None,
             policy_id: Optional[pulumi.Input[str]] = None,
             runtime_engine: Optional[pulumi.Input[str]] = None,
             single_user_name: Optional[pulumi.Input[str]] = None,
             spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             workload_type: Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_mount_infos is None and 'clusterMountInfos' in kwargs:
            cluster_mount_infos = kwargs['clusterMountInfos']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if idempotency_token is None and 'idempotencyToken' in kwargs:
            idempotency_token = kwargs['idempotencyToken']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("spark_version", spark_version)
        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            _setter("cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if driver_instance_pool_id is not None:
            _setter("driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            _setter("driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            _setter("enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            _setter("idempotency_token", idempotency_token)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if node_type_id is not None:
            _setter("node_type_id", node_type_id)
        if num_workers is not None:
            _setter("num_workers", num_workers)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']]:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class JobNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        JobNewClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[pulumi.Input[int]] = None,
             min_workers: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class JobNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        JobNewClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             ebs_volume_count: Optional[pulumi.Input[int]] = None,
             ebs_volume_size: Optional[pulumi.Input[int]] = None,
             ebs_volume_type: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             instance_profile_arn: Optional[pulumi.Input[str]] = None,
             spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class JobNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        JobNewClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             spot_bid_max_price: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class JobNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']] = None):
        JobNewClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']] = None,
             s3: Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class JobNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        JobNewClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        JobNewClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class JobNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        JobNewClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[pulumi.Input[str]] = None,
             network_filesystem_info: Optional[pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs']] = None,
             remote_mount_dir_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        JobNewClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[pulumi.Input[str]] = None,
             mount_options: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class JobNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        JobNewClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             basic_auth: Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class JobNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        JobNewClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class JobNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        JobNewClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             boot_disk_size: Optional[pulumi.Input[int]] = None,
             google_service_account: Optional[pulumi.Input[str]] = None,
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class JobNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobNewClusterInitScriptFileArgs'] file: block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
                   databricks.JobTaskArgs(
                       task_key="run_agg_query",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           query=databricks.JobTaskSqlTaskQueryArgs(
                               query_id=databricks_sql_query["agg_query"]["id"],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_dashboard",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                               dashboard_id=databricks_sql_dashboard["dash"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_alert",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           alert=databricks.JobTaskSqlTaskAlertArgs(
                               alert_id=databricks_sql_alert["alert"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
               ])
               ```
        """
        JobNewClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']] = None,
             dbfs: Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']] = None,
             file: Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']] = None,
             gcs: Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']] = None,
             s3: Optional[pulumi.Input['JobNewClusterInitScriptS3Args']] = None,
             volumes: Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']] = None,
             workspace: Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']]:
        warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
        pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")

        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
            databricks.JobTaskArgs(
                task_key="run_agg_query",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    query=databricks.JobTaskSqlTaskQueryArgs(
                        query_id=databricks_sql_query["agg_query"]["id"],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_dashboard",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                        dashboard_id=databricks_sql_dashboard["dash"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_alert",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    alert=databricks.JobTaskSqlTaskAlertArgs(
                        alert_id=databricks_sql_alert["alert"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
        ])
        ```
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class JobNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobNewClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        JobNewClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobNewClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobNewClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        JobNewClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class JobNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobNewClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobNewClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']):
        JobNewClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional[pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class JobNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        JobNewClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[pulumi.Input[bool]] = None,
             notebooks: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class JobNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: pulumi.Input[str],
                 base_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Mapping[str, Any]] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the jobs base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param pulumi.Input[str] source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        JobNotebookTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notebook_path=notebook_path,
            base_parameters=base_parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notebook_path: Optional[pulumi.Input[str]] = None,
             base_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if notebook_path is None and 'notebookPath' in kwargs:
            notebook_path = kwargs['notebookPath']
        if notebook_path is None:
            raise TypeError("Missing 'notebook_path' argument")
        if base_parameters is None and 'baseParameters' in kwargs:
            base_parameters = kwargs['baseParameters']

        _setter("notebook_path", notebook_path)
        if base_parameters is not None:
            _setter("base_parameters", base_parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> pulumi.Input[str]:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the jobs base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class JobNotificationSettingsArgs:
    def __init__(__self__, *,
                 no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        JobNotificationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            no_alert_for_canceled_runs=no_alert_for_canceled_runs,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
             no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if no_alert_for_canceled_runs is None and 'noAlertForCanceledRuns' in kwargs:
            no_alert_for_canceled_runs = kwargs['noAlertForCanceledRuns']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']

        if no_alert_for_canceled_runs is not None:
            _setter("no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for cancelled runs.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


@pulumi.input_type
class JobParameterArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default: Default value of the parameter.
        :param pulumi.Input[str] name: An optional name for the job. The default value is Untitled.
        """
        JobParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default=default,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if default is not None:
            _setter("default", default)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        Default value of the parameter.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        An optional name for the job. The default value is Untitled.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class JobPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: pulumi.Input[str],
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline's unique ID.
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > **Note** The following configuration blocks are only supported inside a `task` block
        """
        JobPipelineTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_id=pipeline_id,
            full_refresh=full_refresh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_id: Optional[pulumi.Input[str]] = None,
             full_refresh: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if pipeline_id is None:
            raise TypeError("Missing 'pipeline_id' argument")
        if full_refresh is None and 'fullRefresh' in kwargs:
            full_refresh = kwargs['fullRefresh']

        _setter("pipeline_id", pipeline_id)
        if full_refresh is not None:
            _setter("full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> pulumi.Input[str]:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > **Note** The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


@pulumi.input_type
class JobPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 named_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 package_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entry_point: Python function as entry point for the task
        :param pulumi.Input[Mapping[str, Any]] named_parameters: Named parameters for the task
        :param pulumi.Input[str] package_name: Name of Python package
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: Parameters for the task
        """
        JobPythonWheelTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entry_point=entry_point,
            named_parameters=named_parameters,
            package_name=package_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entry_point: Optional[pulumi.Input[str]] = None,
             named_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             package_name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if entry_point is None and 'entryPoint' in kwargs:
            entry_point = kwargs['entryPoint']
        if named_parameters is None and 'namedParameters' in kwargs:
            named_parameters = kwargs['namedParameters']
        if package_name is None and 'packageName' in kwargs:
            package_name = kwargs['packageName']

        if entry_point is not None:
            _setter("entry_point", entry_point)
        if named_parameters is not None:
            _setter("named_parameters", named_parameters)
        if package_name is not None:
            _setter("package_name", package_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class JobQueueArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        JobQueueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class JobRunAsArgs:
    def __init__(__self__, *,
                 service_principal_name: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_principal_name: The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               this = databricks.Job("this", run_as=databricks.JobRunAsArgs(
                   service_principal_name="8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
               ))
               ```
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        JobRunAsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_principal_name=service_principal_name,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_principal_name: Optional[pulumi.Input[str]] = None,
             user_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if service_principal_name is None and 'servicePrincipalName' in kwargs:
            service_principal_name = kwargs['servicePrincipalName']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if service_principal_name is not None:
            _setter("service_principal_name", service_principal_name)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.

        Example:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        this = databricks.Job("this", run_as=databricks.JobRunAsArgs(
            service_principal_name="8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
        ))
        ```
        """
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class JobRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: pulumi.Input[int],
                 job_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[int] job_id: (String) ID of the job
        :param pulumi.Input[Mapping[str, Any]] job_parameters: (Map) Job parameters for the task
        """
        JobRunJobTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_id=job_id,
            job_parameters=job_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_id: Optional[pulumi.Input[int]] = None,
             job_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']
        if job_id is None:
            raise TypeError("Missing 'job_id' argument")
        if job_parameters is None and 'jobParameters' in kwargs:
            job_parameters = kwargs['jobParameters']

        _setter("job_id", job_id)
        if job_parameters is not None:
            _setter("job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[int]:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "job_parameters", value)


@pulumi.input_type
class JobScheduleArgs:
    def __init__(__self__, *,
                 quartz_cron_expression: pulumi.Input[str],
                 timezone_id: pulumi.Input[str],
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] quartz_cron_expression: A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        :param pulumi.Input[str] timezone_id: A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        :param pulumi.Input[str] pause_status: Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        JobScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            quartz_cron_expression=quartz_cron_expression,
            timezone_id=timezone_id,
            pause_status=pause_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             quartz_cron_expression: Optional[pulumi.Input[str]] = None,
             timezone_id: Optional[pulumi.Input[str]] = None,
             pause_status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if quartz_cron_expression is None and 'quartzCronExpression' in kwargs:
            quartz_cron_expression = kwargs['quartzCronExpression']
        if quartz_cron_expression is None:
            raise TypeError("Missing 'quartz_cron_expression' argument")
        if timezone_id is None and 'timezoneId' in kwargs:
            timezone_id = kwargs['timezoneId']
        if timezone_id is None:
            raise TypeError("Missing 'timezone_id' argument")
        if pause_status is None and 'pauseStatus' in kwargs:
            pause_status = kwargs['pauseStatus']

        _setter("quartz_cron_expression", quartz_cron_expression)
        _setter("timezone_id", timezone_id)
        if pause_status is not None:
            _setter("pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> pulumi.Input[str]:
        """
        A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @quartz_cron_expression.setter
    def quartz_cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "quartz_cron_expression", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> pulumi.Input[str]:
        """
        A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        """
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone_id", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


@pulumi.input_type
class JobSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[pulumi.Input[str]] = None,
                 main_class_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Parameters passed to the main method.
        """
        JobSparkJarTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jar_uri=jar_uri,
            main_class_name=main_class_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jar_uri: Optional[pulumi.Input[str]] = None,
             main_class_name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if jar_uri is None and 'jarUri' in kwargs:
            jar_uri = kwargs['jarUri']
        if main_class_name is None and 'mainClassName' in kwargs:
            main_class_name = kwargs['mainClassName']

        if jar_uri is not None:
            _setter("jar_uri", jar_uri)
        if main_class_name is not None:
            _setter("main_class_name", main_class_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class JobSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] python_file: The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command line parameters passed to the Python file.
        :param pulumi.Input[str] source: Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        JobSparkPythonTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            python_file=python_file,
            parameters=parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             python_file: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if python_file is None and 'pythonFile' in kwargs:
            python_file = kwargs['pythonFile']
        if python_file is None:
            raise TypeError("Missing 'python_file' argument")

        _setter("python_file", python_file)
        if parameters is not None:
            _setter("parameters", parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> pulumi.Input[str]:
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class JobSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command-line parameters passed to spark submit.
        """
        JobSparkSubmitTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class JobTaskArgs:
    def __init__(__self__, *,
                 compute_key: Optional[pulumi.Input[str]] = None,
                 condition_task: Optional[pulumi.Input['JobTaskConditionTaskArgs']] = None,
                 dbt_task: Optional[pulumi.Input['JobTaskDbtTaskArgs']] = None,
                 depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 email_notifications: Optional[pulumi.Input['JobTaskEmailNotificationsArgs']] = None,
                 existing_cluster_id: Optional[pulumi.Input[str]] = None,
                 health: Optional[pulumi.Input['JobTaskHealthArgs']] = None,
                 job_cluster_key: Optional[pulumi.Input[str]] = None,
                 libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 min_retry_interval_millis: Optional[pulumi.Input[int]] = None,
                 new_cluster: Optional[pulumi.Input['JobTaskNewClusterArgs']] = None,
                 notebook_task: Optional[pulumi.Input['JobTaskNotebookTaskArgs']] = None,
                 notification_settings: Optional[pulumi.Input['JobTaskNotificationSettingsArgs']] = None,
                 pipeline_task: Optional[pulumi.Input['JobTaskPipelineTaskArgs']] = None,
                 python_wheel_task: Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']] = None,
                 retry_on_timeout: Optional[pulumi.Input[bool]] = None,
                 run_if: Optional[pulumi.Input[str]] = None,
                 run_job_task: Optional[pulumi.Input['JobTaskRunJobTaskArgs']] = None,
                 spark_jar_task: Optional[pulumi.Input['JobTaskSparkJarTaskArgs']] = None,
                 spark_python_task: Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']] = None,
                 spark_submit_task: Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']] = None,
                 sql_task: Optional[pulumi.Input['JobTaskSqlTaskArgs']] = None,
                 task_key: Optional[pulumi.Input[str]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]] depends_ons: block specifying dependency(-ies) for a given task.
        :param pulumi.Input['JobTaskEmailNotificationsArgs'] email_notifications: (List) An optional set of email addresses notified when runs of this job begins, completes and fails. The default behavior is to not send any emails. This field is a block and is documented below.
        :param pulumi.Input['JobTaskHealthArgs'] health: block described below that specifies health conditions for a given task.
        :param pulumi.Input[str] job_cluster_key: Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]] libraries: (Set) An optional list of libraries to be installed on the cluster that will execute the job. Please consult libraries section for Cluster resource.
        :param pulumi.Input[int] max_retries: (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        :param pulumi.Input[int] min_retry_interval_millis: (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        :param pulumi.Input['JobTaskNewClusterArgs'] new_cluster: Same set of parameters as for Cluster resource.
        :param pulumi.Input['JobTaskNotificationSettingsArgs'] notification_settings: An optional block controlling the notification settings on the job level (described below).
        :param pulumi.Input[bool] retry_on_timeout: (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        :param pulumi.Input[str] run_if: An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. When omitted, defaults to `ALL_SUCCESS`.
        :param pulumi.Input[str] task_key: string specifying an unique key for a given task.
               * `*_task` - (Required) one of the specific task blocks described below:
        :param pulumi.Input[int] timeout_seconds: (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        JobTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_key=compute_key,
            condition_task=condition_task,
            dbt_task=dbt_task,
            depends_ons=depends_ons,
            description=description,
            email_notifications=email_notifications,
            existing_cluster_id=existing_cluster_id,
            health=health,
            job_cluster_key=job_cluster_key,
            libraries=libraries,
            max_retries=max_retries,
            min_retry_interval_millis=min_retry_interval_millis,
            new_cluster=new_cluster,
            notebook_task=notebook_task,
            notification_settings=notification_settings,
            pipeline_task=pipeline_task,
            python_wheel_task=python_wheel_task,
            retry_on_timeout=retry_on_timeout,
            run_if=run_if,
            run_job_task=run_job_task,
            spark_jar_task=spark_jar_task,
            spark_python_task=spark_python_task,
            spark_submit_task=spark_submit_task,
            sql_task=sql_task,
            task_key=task_key,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_key: Optional[pulumi.Input[str]] = None,
             condition_task: Optional[pulumi.Input['JobTaskConditionTaskArgs']] = None,
             dbt_task: Optional[pulumi.Input['JobTaskDbtTaskArgs']] = None,
             depends_ons: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]] = None,
             description: Optional[pulumi.Input[str]] = None,
             email_notifications: Optional[pulumi.Input['JobTaskEmailNotificationsArgs']] = None,
             existing_cluster_id: Optional[pulumi.Input[str]] = None,
             health: Optional[pulumi.Input['JobTaskHealthArgs']] = None,
             job_cluster_key: Optional[pulumi.Input[str]] = None,
             libraries: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]] = None,
             max_retries: Optional[pulumi.Input[int]] = None,
             min_retry_interval_millis: Optional[pulumi.Input[int]] = None,
             new_cluster: Optional[pulumi.Input['JobTaskNewClusterArgs']] = None,
             notebook_task: Optional[pulumi.Input['JobTaskNotebookTaskArgs']] = None,
             notification_settings: Optional[pulumi.Input['JobTaskNotificationSettingsArgs']] = None,
             pipeline_task: Optional[pulumi.Input['JobTaskPipelineTaskArgs']] = None,
             python_wheel_task: Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']] = None,
             retry_on_timeout: Optional[pulumi.Input[bool]] = None,
             run_if: Optional[pulumi.Input[str]] = None,
             run_job_task: Optional[pulumi.Input['JobTaskRunJobTaskArgs']] = None,
             spark_jar_task: Optional[pulumi.Input['JobTaskSparkJarTaskArgs']] = None,
             spark_python_task: Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']] = None,
             spark_submit_task: Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']] = None,
             sql_task: Optional[pulumi.Input['JobTaskSqlTaskArgs']] = None,
             task_key: Optional[pulumi.Input[str]] = None,
             timeout_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if compute_key is None and 'computeKey' in kwargs:
            compute_key = kwargs['computeKey']
        if condition_task is None and 'conditionTask' in kwargs:
            condition_task = kwargs['conditionTask']
        if dbt_task is None and 'dbtTask' in kwargs:
            dbt_task = kwargs['dbtTask']
        if depends_ons is None and 'dependsOns' in kwargs:
            depends_ons = kwargs['dependsOns']
        if email_notifications is None and 'emailNotifications' in kwargs:
            email_notifications = kwargs['emailNotifications']
        if existing_cluster_id is None and 'existingClusterId' in kwargs:
            existing_cluster_id = kwargs['existingClusterId']
        if job_cluster_key is None and 'jobClusterKey' in kwargs:
            job_cluster_key = kwargs['jobClusterKey']
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if min_retry_interval_millis is None and 'minRetryIntervalMillis' in kwargs:
            min_retry_interval_millis = kwargs['minRetryIntervalMillis']
        if new_cluster is None and 'newCluster' in kwargs:
            new_cluster = kwargs['newCluster']
        if notebook_task is None and 'notebookTask' in kwargs:
            notebook_task = kwargs['notebookTask']
        if notification_settings is None and 'notificationSettings' in kwargs:
            notification_settings = kwargs['notificationSettings']
        if pipeline_task is None and 'pipelineTask' in kwargs:
            pipeline_task = kwargs['pipelineTask']
        if python_wheel_task is None and 'pythonWheelTask' in kwargs:
            python_wheel_task = kwargs['pythonWheelTask']
        if retry_on_timeout is None and 'retryOnTimeout' in kwargs:
            retry_on_timeout = kwargs['retryOnTimeout']
        if run_if is None and 'runIf' in kwargs:
            run_if = kwargs['runIf']
        if run_job_task is None and 'runJobTask' in kwargs:
            run_job_task = kwargs['runJobTask']
        if spark_jar_task is None and 'sparkJarTask' in kwargs:
            spark_jar_task = kwargs['sparkJarTask']
        if spark_python_task is None and 'sparkPythonTask' in kwargs:
            spark_python_task = kwargs['sparkPythonTask']
        if spark_submit_task is None and 'sparkSubmitTask' in kwargs:
            spark_submit_task = kwargs['sparkSubmitTask']
        if sql_task is None and 'sqlTask' in kwargs:
            sql_task = kwargs['sqlTask']
        if task_key is None and 'taskKey' in kwargs:
            task_key = kwargs['taskKey']
        if timeout_seconds is None and 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if compute_key is not None:
            _setter("compute_key", compute_key)
        if condition_task is not None:
            _setter("condition_task", condition_task)
        if dbt_task is not None:
            _setter("dbt_task", dbt_task)
        if depends_ons is not None:
            _setter("depends_ons", depends_ons)
        if description is not None:
            _setter("description", description)
        if email_notifications is not None:
            _setter("email_notifications", email_notifications)
        if existing_cluster_id is not None:
            _setter("existing_cluster_id", existing_cluster_id)
        if health is not None:
            _setter("health", health)
        if job_cluster_key is not None:
            _setter("job_cluster_key", job_cluster_key)
        if libraries is not None:
            _setter("libraries", libraries)
        if max_retries is not None:
            _setter("max_retries", max_retries)
        if min_retry_interval_millis is not None:
            _setter("min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            _setter("new_cluster", new_cluster)
        if notebook_task is not None:
            _setter("notebook_task", notebook_task)
        if notification_settings is not None:
            _setter("notification_settings", notification_settings)
        if pipeline_task is not None:
            _setter("pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            _setter("python_wheel_task", python_wheel_task)
        if retry_on_timeout is not None:
            _setter("retry_on_timeout", retry_on_timeout)
        if run_if is not None:
            _setter("run_if", run_if)
        if run_job_task is not None:
            _setter("run_job_task", run_job_task)
        if spark_jar_task is not None:
            _setter("spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            _setter("spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            _setter("spark_submit_task", spark_submit_task)
        if sql_task is not None:
            _setter("sql_task", sql_task)
        if task_key is not None:
            _setter("task_key", task_key)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="computeKey")
    def compute_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "compute_key")

    @compute_key.setter
    def compute_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_key", value)

    @property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional[pulumi.Input['JobTaskConditionTaskArgs']]:
        return pulumi.get(self, "condition_task")

    @condition_task.setter
    def condition_task(self, value: Optional[pulumi.Input['JobTaskConditionTaskArgs']]):
        pulumi.set(self, "condition_task", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional[pulumi.Input['JobTaskDbtTaskArgs']]:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional[pulumi.Input['JobTaskDbtTaskArgs']]):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]]:
        """
        block specifying dependency(-ies) for a given task.
        """
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskDependsOnArgs']]]]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional[pulumi.Input['JobTaskEmailNotificationsArgs']]:
        """
        (List) An optional set of email addresses notified when runs of this job begins, completes and fails. The default behavior is to not send any emails. This field is a block and is documented below.
        """
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional[pulumi.Input['JobTaskEmailNotificationsArgs']]):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input['JobTaskHealthArgs']]:
        """
        block described below that specifies health conditions for a given task.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input['JobTaskHealthArgs']]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]]:
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job. Please consult libraries section for Cluster resource.
        """
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskLibraryArgs']]]]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional[pulumi.Input['JobTaskNewClusterArgs']]:
        """
        Same set of parameters as for Cluster resource.
        """
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional[pulumi.Input['JobTaskNewClusterArgs']]):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional[pulumi.Input['JobTaskNotebookTaskArgs']]:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional[pulumi.Input['JobTaskNotebookTaskArgs']]):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional[pulumi.Input['JobTaskNotificationSettingsArgs']]:
        """
        An optional block controlling the notification settings on the job level (described below).
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional[pulumi.Input['JobTaskNotificationSettingsArgs']]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional[pulumi.Input['JobTaskPipelineTaskArgs']]:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional[pulumi.Input['JobTaskPipelineTaskArgs']]):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']]:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional[pulumi.Input['JobTaskPythonWheelTaskArgs']]):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[pulumi.Input[str]]:
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. When omitted, defaults to `ALL_SUCCESS`.
        """
        return pulumi.get(self, "run_if")

    @run_if.setter
    def run_if(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_if", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional[pulumi.Input['JobTaskRunJobTaskArgs']]:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional[pulumi.Input['JobTaskRunJobTaskArgs']]):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional[pulumi.Input['JobTaskSparkJarTaskArgs']]:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional[pulumi.Input['JobTaskSparkJarTaskArgs']]):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']]:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional[pulumi.Input['JobTaskSparkPythonTaskArgs']]):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']]:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional[pulumi.Input['JobTaskSparkSubmitTaskArgs']]):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional[pulumi.Input['JobTaskSqlTaskArgs']]:
        return pulumi.get(self, "sql_task")

    @sql_task.setter
    def sql_task(self, value: Optional[pulumi.Input['JobTaskSqlTaskArgs']]):
        pulumi.set(self, "sql_task", value)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class JobTaskConditionTaskArgs:
    def __init__(__self__, *,
                 left: Optional[pulumi.Input[str]] = None,
                 op: Optional[pulumi.Input[str]] = None,
                 right: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        JobTaskConditionTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            left=left,
            op=op,
            right=right,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             left: Optional[pulumi.Input[str]] = None,
             op: Optional[pulumi.Input[str]] = None,
             right: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if left is not None:
            _setter("left", left)
        if op is not None:
            _setter("op", op)
        if right is not None:
            _setter("right", right)

    @property
    @pulumi.getter
    def left(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def right(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "right")

    @right.setter
    def right(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "right", value)


@pulumi.input_type
class JobTaskDbtTaskArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[str]]],
                 catalog: Optional[pulumi.Input[str]] = None,
                 profiles_directory: Optional[pulumi.Input[str]] = None,
                 project_directory: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param pulumi.Input[str] catalog: The name of the catalog to use inside Unity Catalog.
        :param pulumi.Input[str] profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param pulumi.Input[str] project_directory: The relative path to the directory in the repository specified in `git_source` where dbt should look in for the `dbt_project.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--project-dir` to a dbt command.
        :param pulumi.Input[str] schema: The name of the schema dbt should run in. Defaults to `default`.
        :param pulumi.Input[str] warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        JobTaskDbtTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            catalog=catalog,
            profiles_directory=profiles_directory,
            project_directory=project_directory,
            schema=schema,
            warehouse_id=warehouse_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             catalog: Optional[pulumi.Input[str]] = None,
             profiles_directory: Optional[pulumi.Input[str]] = None,
             project_directory: Optional[pulumi.Input[str]] = None,
             schema: Optional[pulumi.Input[str]] = None,
             warehouse_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if profiles_directory is None and 'profilesDirectory' in kwargs:
            profiles_directory = kwargs['profilesDirectory']
        if project_directory is None and 'projectDirectory' in kwargs:
            project_directory = kwargs['projectDirectory']
        if warehouse_id is None and 'warehouseId' in kwargs:
            warehouse_id = kwargs['warehouseId']

        _setter("commands", commands)
        if catalog is not None:
            _setter("catalog", catalog)
        if profiles_directory is not None:
            _setter("profiles_directory", profiles_directory)
        if project_directory is not None:
            _setter("project_directory", project_directory)
        if schema is not None:
            _setter("schema", schema)
        if warehouse_id is not None:
            _setter("warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[pulumi.Input[str]]:
        """
        The relative path to the directory in the repository specified in `git_source` where dbt should look in for the `dbt_project.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--project-dir` to a dbt command.
        """
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


@pulumi.input_type
class JobTaskDependsOnArgs:
    def __init__(__self__, *,
                 task_key: pulumi.Input[str],
                 outcome: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] task_key: The name of the task this task depends on.
        """
        JobTaskDependsOnArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_key=task_key,
            outcome=outcome,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_key: Optional[pulumi.Input[str]] = None,
             outcome: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if task_key is None and 'taskKey' in kwargs:
            task_key = kwargs['taskKey']
        if task_key is None:
            raise TypeError("Missing 'task_key' argument")

        _setter("task_key", task_key)
        if outcome is not None:
            _setter("outcome", outcome)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> pulumi.Input[str]:
        """
        The name of the task this task depends on.
        """
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter
    def outcome(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "outcome")

    @outcome.setter
    def outcome(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outcome", value)


@pulumi.input_type
class JobTaskEmailNotificationsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_failures: (List) list of emails to notify when the run fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_starts: (List) list of emails to notify when the run starts.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        JobTaskEmailNotificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_on_last_attempt=alert_on_last_attempt,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
            on_duration_warning_threshold_exceededs=on_duration_warning_threshold_exceededs,
            on_failures=on_failures,
            on_starts=on_starts,
            on_successes=on_successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
             no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
             on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             on_failures: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             on_starts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             on_successes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_on_last_attempt is None and 'alertOnLastAttempt' in kwargs:
            alert_on_last_attempt = kwargs['alertOnLastAttempt']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']
        if on_duration_warning_threshold_exceededs is None and 'onDurationWarningThresholdExceededs' in kwargs:
            on_duration_warning_threshold_exceededs = kwargs['onDurationWarningThresholdExceededs']
        if on_failures is None and 'onFailures' in kwargs:
            on_failures = kwargs['onFailures']
        if on_starts is None and 'onStarts' in kwargs:
            on_starts = kwargs['onStarts']
        if on_successes is None and 'onSuccesses' in kwargs:
            on_successes = kwargs['onSuccesses']

        if alert_on_last_attempt is not None:
            _setter("alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            _setter("on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            _setter("on_failures", on_failures)
        if on_starts is not None:
            _setter("on_starts", on_starts)
        if on_successes is not None:
            _setter("on_successes", on_successes)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "on_successes", value)


@pulumi.input_type
class JobTaskHealthArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]] rules: list of rules that are represented as objects with the following attributes:
        """
        JobTaskHealthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['JobTaskHealthRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class JobTaskHealthRuleArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[str]] = None,
                 op: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] metric: string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        :param pulumi.Input[str] op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param pulumi.Input[int] value: integer value used to compare to the given metric.
        """
        JobTaskHealthRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            op=op,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: Optional[pulumi.Input[str]] = None,
             op: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if metric is not None:
            _setter("metric", metric)
        if op is not None:
            _setter("op", op)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying the metric to check.  The only supported metric is `RUN_DURATION_SECONDS` (check [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class JobTaskLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional[pulumi.Input['JobTaskLibraryCranArgs']] = None,
                 egg: Optional[pulumi.Input[str]] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['JobTaskLibraryMavenArgs']] = None,
                 pypi: Optional[pulumi.Input['JobTaskLibraryPypiArgs']] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        JobTaskLibraryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cran=cran,
            egg=egg,
            jar=jar,
            maven=maven,
            pypi=pypi,
            whl=whl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cran: Optional[pulumi.Input['JobTaskLibraryCranArgs']] = None,
             egg: Optional[pulumi.Input[str]] = None,
             jar: Optional[pulumi.Input[str]] = None,
             maven: Optional[pulumi.Input['JobTaskLibraryMavenArgs']] = None,
             pypi: Optional[pulumi.Input['JobTaskLibraryPypiArgs']] = None,
             whl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cran is not None:
            _setter("cran", cran)
        if egg is not None:
            _setter("egg", egg)
        if jar is not None:
            _setter("jar", jar)
        if maven is not None:
            _setter("maven", maven)
        if pypi is not None:
            _setter("pypi", pypi)
        if whl is not None:
            _setter("whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional[pulumi.Input['JobTaskLibraryCranArgs']]:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional[pulumi.Input['JobTaskLibraryCranArgs']]):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['JobTaskLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['JobTaskLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional[pulumi.Input['JobTaskLibraryPypiArgs']]:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional[pulumi.Input['JobTaskLibraryPypiArgs']]):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


@pulumi.input_type
class JobTaskLibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        JobTaskLibraryCranArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class JobTaskLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        JobTaskLibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class JobTaskLibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        JobTaskLibraryPypiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class JobTaskNewClusterArgs:
    def __init__(__self__, *,
                 spark_version: pulumi.Input[str],
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']] = None,
                 autotermination_minutes: Optional[pulumi.Input[int]] = None,
                 aws_attributes: Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_log_conf: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']] = None,
                 cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 data_security_mode: Optional[pulumi.Input[str]] = None,
                 docker_image: Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']] = None,
                 idempotency_token: Optional[pulumi.Input[str]] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 runtime_engine: Optional[pulumi.Input[str]] = None,
                 single_user_name: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_type: Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']] = None):
        JobTaskNewClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            spark_version=spark_version,
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_mount_infos=cluster_mount_infos,
            cluster_name=cluster_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            gcp_attributes=gcp_attributes,
            idempotency_token=idempotency_token,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            node_type_id=node_type_id,
            num_workers=num_workers,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             spark_version: Optional[pulumi.Input[str]] = None,
             apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
             autoscale: Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']] = None,
             autotermination_minutes: Optional[pulumi.Input[int]] = None,
             aws_attributes: Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']] = None,
             azure_attributes: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']] = None,
             cluster_id: Optional[pulumi.Input[str]] = None,
             cluster_log_conf: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']] = None,
             cluster_mount_infos: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]] = None,
             cluster_name: Optional[pulumi.Input[str]] = None,
             custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             data_security_mode: Optional[pulumi.Input[str]] = None,
             docker_image: Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']] = None,
             driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
             driver_node_type_id: Optional[pulumi.Input[str]] = None,
             enable_elastic_disk: Optional[pulumi.Input[bool]] = None,
             enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
             gcp_attributes: Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']] = None,
             idempotency_token: Optional[pulumi.Input[str]] = None,
             init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]] = None,
             instance_pool_id: Optional[pulumi.Input[str]] = None,
             node_type_id: Optional[pulumi.Input[str]] = None,
             num_workers: Optional[pulumi.Input[int]] = None,
             policy_id: Optional[pulumi.Input[str]] = None,
             runtime_engine: Optional[pulumi.Input[str]] = None,
             single_user_name: Optional[pulumi.Input[str]] = None,
             spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             workload_type: Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_mount_infos is None and 'clusterMountInfos' in kwargs:
            cluster_mount_infos = kwargs['clusterMountInfos']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if idempotency_token is None and 'idempotencyToken' in kwargs:
            idempotency_token = kwargs['idempotencyToken']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("spark_version", spark_version)
        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            _setter("cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if driver_instance_pool_id is not None:
            _setter("driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            _setter("driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            _setter("enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            _setter("idempotency_token", idempotency_token)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if node_type_id is not None:
            _setter("node_type_id", node_type_id)
        if num_workers is not None:
            _setter("num_workers", num_workers)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['JobTaskNewClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['JobTaskNewClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['JobTaskNewClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterClusterMountInfoArgs']]]]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']]:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional[pulumi.Input['JobTaskNewClusterDockerImageArgs']]):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['JobTaskNewClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskNewClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']]:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeArgs']]):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class JobTaskNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None):
        JobTaskNewClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[pulumi.Input[int]] = None,
             min_workers: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class JobTaskNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             ebs_volume_count: Optional[pulumi.Input[int]] = None,
             ebs_volume_size: Optional[pulumi.Input[int]] = None,
             ebs_volume_type: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             instance_profile_arn: Optional[pulumi.Input[str]] = None,
             spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class JobTaskNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        JobTaskNewClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             spot_bid_max_price: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class JobTaskNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']] = None):
        JobTaskNewClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']] = None,
             s3: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobTaskNewClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class JobTaskNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        JobTaskNewClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class JobTaskNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: pulumi.Input[str],
                 network_filesystem_info: pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'],
                 remote_mount_dir_path: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[pulumi.Input[str]] = None,
             network_filesystem_info: Optional[pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']] = None,
             remote_mount_dir_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']:
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: pulumi.Input['JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs']):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: pulumi.Input[str],
                 mount_options: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[pulumi.Input[str]] = None,
             mount_options: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class JobTaskNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auth: Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        """
        JobTaskNewClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             basic_auth: Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']]:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional[pulumi.Input['JobTaskNewClusterDockerImageBasicAuthArgs']]):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class JobTaskNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        JobTaskNewClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class JobTaskNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 boot_disk_size: Optional[pulumi.Input[int]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             boot_disk_size: Optional[pulumi.Input[int]] = None,
             google_service_account: Optional[pulumi.Input[str]] = None,
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             use_preemptible_executors: Optional[pulumi.Input[bool]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']] = None):
        """
        :param pulumi.Input['JobTaskNewClusterInitScriptFileArgs'] file: block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
                   databricks.JobTaskArgs(
                       task_key="run_agg_query",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           query=databricks.JobTaskSqlTaskQueryArgs(
                               query_id=databricks_sql_query["agg_query"]["id"],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_dashboard",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                               dashboard_id=databricks_sql_dashboard["dash"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_alert",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           alert=databricks.JobTaskSqlTaskAlertArgs(
                               alert_id=databricks_sql_alert["alert"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
               ])
               ```
        """
        JobTaskNewClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']] = None,
             dbfs: Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']] = None,
             file: Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']] = None,
             gcs: Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']] = None,
             s3: Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']] = None,
             volumes: Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']] = None,
             workspace: Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']]:
        warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
        pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")

        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']]:
        """
        block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
            databricks.JobTaskArgs(
                task_key="run_agg_query",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    query=databricks.JobTaskSqlTaskQueryArgs(
                        query_id=databricks_sql_query["agg_query"]["id"],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_dashboard",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                        dashboard_id=databricks_sql_dashboard["dash"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_alert",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    alert=databricks.JobTaskSqlTaskAlertArgs(
                        alert_id=databricks_sql_alert["alert"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
        ])
        ```
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['JobTaskNewClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        JobTaskNewClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        JobTaskNewClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class JobTaskNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']):
        JobTaskNewClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional[pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']:
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: pulumi.Input['JobTaskNewClusterWorkloadTypeClientsArgs']):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class JobTaskNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[pulumi.Input[bool]] = None,
                 notebooks: Optional[pulumi.Input[bool]] = None):
        JobTaskNewClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[pulumi.Input[bool]] = None,
             notebooks: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class JobTaskNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: pulumi.Input[str],
                 base_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Mapping[str, Any]] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the jobs base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param pulumi.Input[str] source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        JobTaskNotebookTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notebook_path=notebook_path,
            base_parameters=base_parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notebook_path: Optional[pulumi.Input[str]] = None,
             base_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if notebook_path is None and 'notebookPath' in kwargs:
            notebook_path = kwargs['notebookPath']
        if notebook_path is None:
            raise TypeError("Missing 'notebook_path' argument")
        if base_parameters is None and 'baseParameters' in kwargs:
            base_parameters = kwargs['baseParameters']

        _setter("notebook_path", notebook_path)
        if base_parameters is not None:
            _setter("base_parameters", base_parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> pulumi.Input[str]:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the jobs base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class JobTaskNotificationSettingsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
                 no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param pulumi.Input[bool] no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
        :param pulumi.Input[bool] no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        JobTaskNotificationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_on_last_attempt=alert_on_last_attempt,
            no_alert_for_canceled_runs=no_alert_for_canceled_runs,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_on_last_attempt: Optional[pulumi.Input[bool]] = None,
             no_alert_for_canceled_runs: Optional[pulumi.Input[bool]] = None,
             no_alert_for_skipped_runs: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_on_last_attempt is None and 'alertOnLastAttempt' in kwargs:
            alert_on_last_attempt = kwargs['alertOnLastAttempt']
        if no_alert_for_canceled_runs is None and 'noAlertForCanceledRuns' in kwargs:
            no_alert_for_canceled_runs = kwargs['noAlertForCanceledRuns']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']

        if alert_on_last_attempt is not None:
            _setter("alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            _setter("no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for cancelled runs.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


@pulumi.input_type
class JobTaskPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: pulumi.Input[str],
                 full_refresh: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] pipeline_id: The pipeline's unique ID.
        :param pulumi.Input[bool] full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > **Note** The following configuration blocks are only supported inside a `task` block
        """
        JobTaskPipelineTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_id=pipeline_id,
            full_refresh=full_refresh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_id: Optional[pulumi.Input[str]] = None,
             full_refresh: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if pipeline_id is None:
            raise TypeError("Missing 'pipeline_id' argument")
        if full_refresh is None and 'fullRefresh' in kwargs:
            full_refresh = kwargs['fullRefresh']

        _setter("pipeline_id", pipeline_id)
        if full_refresh is not None:
            _setter("full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> pulumi.Input[str]:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > **Note** The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "full_refresh", value)


@pulumi.input_type
class JobTaskPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[pulumi.Input[str]] = None,
                 named_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 package_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entry_point: Python function as entry point for the task
        :param pulumi.Input[Mapping[str, Any]] named_parameters: Named parameters for the task
        :param pulumi.Input[str] package_name: Name of Python package
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: Parameters for the task
        """
        JobTaskPythonWheelTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entry_point=entry_point,
            named_parameters=named_parameters,
            package_name=package_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entry_point: Optional[pulumi.Input[str]] = None,
             named_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             package_name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if entry_point is None and 'entryPoint' in kwargs:
            entry_point = kwargs['entryPoint']
        if named_parameters is None and 'namedParameters' in kwargs:
            named_parameters = kwargs['namedParameters']
        if package_name is None and 'packageName' in kwargs:
            package_name = kwargs['packageName']

        if entry_point is not None:
            _setter("entry_point", entry_point)
        if named_parameters is not None:
            _setter("named_parameters", named_parameters)
        if package_name is not None:
            _setter("package_name", package_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[pulumi.Input[str]]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class JobTaskRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: pulumi.Input[int],
                 job_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[int] job_id: (String) ID of the job
        :param pulumi.Input[Mapping[str, Any]] job_parameters: (Map) Job parameters for the task
        """
        JobTaskRunJobTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_id=job_id,
            job_parameters=job_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_id: Optional[pulumi.Input[int]] = None,
             job_parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']
        if job_id is None:
            raise TypeError("Missing 'job_id' argument")
        if job_parameters is None and 'jobParameters' in kwargs:
            job_parameters = kwargs['jobParameters']

        _setter("job_id", job_id)
        if job_parameters is not None:
            _setter("job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[int]:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "job_parameters", value)


@pulumi.input_type
class JobTaskSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[pulumi.Input[str]] = None,
                 main_class_name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Parameters passed to the main method.
        """
        JobTaskSparkJarTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jar_uri=jar_uri,
            main_class_name=main_class_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jar_uri: Optional[pulumi.Input[str]] = None,
             main_class_name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if jar_uri is None and 'jarUri' in kwargs:
            jar_uri = kwargs['jarUri']
        if main_class_name is None and 'mainClassName' in kwargs:
            main_class_name = kwargs['mainClassName']

        if jar_uri is not None:
            _setter("jar_uri", jar_uri)
        if main_class_name is not None:
            _setter("main_class_name", main_class_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class JobTaskSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] python_file: The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command line parameters passed to the Python file.
        :param pulumi.Input[str] source: Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        JobTaskSparkPythonTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            python_file=python_file,
            parameters=parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             python_file: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if python_file is None and 'pythonFile' in kwargs:
            python_file = kwargs['pythonFile']
        if python_file is None:
            raise TypeError("Missing 'python_file' argument")

        _setter("python_file", python_file)
        if parameters is not None:
            _setter("parameters", parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> pulumi.Input[str]:
        """
        The URI of the Python file to be executed. databricks_dbfs_file, cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/Repos`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Location type of the Python file, can only be `GIT`. When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class JobTaskSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] parameters: (List) Command-line parameters passed to spark submit.
        """
        JobTaskSparkSubmitTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class JobTaskSqlTaskArgs:
    def __init__(__self__, *,
                 alert: Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']] = None,
                 dashboard: Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']] = None,
                 file: Optional[pulumi.Input['JobTaskSqlTaskFileArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 query: Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']] = None,
                 warehouse_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['JobTaskSqlTaskAlertArgs'] alert: block consisting of following fields:
        :param pulumi.Input['JobTaskSqlTaskDashboardArgs'] dashboard: block consisting of following fields:
        :param pulumi.Input['JobTaskSqlTaskFileArgs'] file: block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
                   databricks.JobTaskArgs(
                       task_key="run_agg_query",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           query=databricks.JobTaskSqlTaskQueryArgs(
                               query_id=databricks_sql_query["agg_query"]["id"],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_dashboard",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                               dashboard_id=databricks_sql_dashboard["dash"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
                   databricks.JobTaskArgs(
                       task_key="run_alert",
                       sql_task=databricks.JobTaskSqlTaskArgs(
                           warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                           alert=databricks.JobTaskSqlTaskAlertArgs(
                               alert_id=databricks_sql_alert["alert"]["id"],
                               subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                                   user_name="user@domain.com",
                               )],
                           ),
                       ),
                   ),
               ])
               ```
        :param pulumi.Input[Mapping[str, Any]] parameters: (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        :param pulumi.Input['JobTaskSqlTaskQueryArgs'] query: block consisting of single string field: `query_id` - identifier of the Databricks SQL Query (databricks_sql_query).
        :param pulumi.Input[str] warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        JobTaskSqlTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert=alert,
            dashboard=dashboard,
            file=file,
            parameters=parameters,
            query=query,
            warehouse_id=warehouse_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert: Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']] = None,
             dashboard: Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']] = None,
             file: Optional[pulumi.Input['JobTaskSqlTaskFileArgs']] = None,
             parameters: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             query: Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']] = None,
             warehouse_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if warehouse_id is None and 'warehouseId' in kwargs:
            warehouse_id = kwargs['warehouseId']

        if alert is not None:
            _setter("alert", alert)
        if dashboard is not None:
            _setter("dashboard", dashboard)
        if file is not None:
            _setter("file", file)
        if parameters is not None:
            _setter("parameters", parameters)
        if query is not None:
            _setter("query", query)
        if warehouse_id is not None:
            _setter("warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def alert(self) -> Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']]:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional[pulumi.Input['JobTaskSqlTaskAlertArgs']]):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']]:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input['JobTaskSqlTaskDashboardArgs']]):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['JobTaskSqlTaskFileArgs']]:
        """
        block consisting of single string field: `path` - a relative path to the file (inside the Git repository) with SQL commands to execute.  *Requires `git_source` configuration block*.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sqlAggregationJob", tasks=[
            databricks.JobTaskArgs(
                task_key="run_agg_query",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    query=databricks.JobTaskSqlTaskQueryArgs(
                        query_id=databricks_sql_query["agg_query"]["id"],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_dashboard",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    dashboard=databricks.JobTaskSqlTaskDashboardArgs(
                        dashboard_id=databricks_sql_dashboard["dash"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskDashboardSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
            databricks.JobTaskArgs(
                task_key="run_alert",
                sql_task=databricks.JobTaskSqlTaskArgs(
                    warehouse_id=databricks_sql_endpoint["sql_job_warehouse"]["id"],
                    alert=databricks.JobTaskSqlTaskAlertArgs(
                        alert_id=databricks_sql_alert["alert"]["id"],
                        subscriptions=[databricks.JobTaskSqlTaskAlertSubscriptionArgs(
                            user_name="user@domain.com",
                        )],
                    ),
                ),
            ),
        ])
        ```
        """
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['JobTaskSqlTaskFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']]:
        """
        block consisting of single string field: `query_id` - identifier of the Databricks SQL Query (databricks_sql_query).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['JobTaskSqlTaskQueryArgs']]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warehouse_id", value)


@pulumi.input_type
class JobTaskSqlTaskAlertArgs:
    def __init__(__self__, *,
                 alert_id: pulumi.Input[str],
                 subscriptions: pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]],
                 pause_subscriptions: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] alert_id: (String) identifier of the Databricks SQL Alert.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        :param pulumi.Input[bool] pause_subscriptions: flag that specifies if subscriptions are paused or not.
        """
        JobTaskSqlTaskAlertArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            subscriptions=subscriptions,
            pause_subscriptions=pause_subscriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: Optional[pulumi.Input[str]] = None,
             subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]]] = None,
             pause_subscriptions: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_id is None and 'alertId' in kwargs:
            alert_id = kwargs['alertId']
        if alert_id is None:
            raise TypeError("Missing 'alert_id' argument")
        if subscriptions is None:
            raise TypeError("Missing 'subscriptions' argument")
        if pause_subscriptions is None and 'pauseSubscriptions' in kwargs:
            pause_subscriptions = kwargs['pauseSubscriptions']

        _setter("alert_id", alert_id)
        _setter("subscriptions", subscriptions)
        if pause_subscriptions is not None:
            _setter("pause_subscriptions", pause_subscriptions)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> pulumi.Input[str]:
        """
        (String) identifier of the Databricks SQL Alert.
        """
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskAlertSubscriptionArgs']]]):
        pulumi.set(self, "subscriptions", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[pulumi.Input[bool]]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pause_subscriptions", value)


@pulumi.input_type
class JobTaskSqlTaskAlertSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        JobTaskSqlTaskAlertSubscriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_id=destination_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_id: Optional[pulumi.Input[str]] = None,
             user_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination_id is None and 'destinationId' in kwargs:
            destination_id = kwargs['destinationId']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if destination_id is not None:
            _setter("destination_id", destination_id)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class JobTaskSqlTaskDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: pulumi.Input[str],
                 custom_subject: Optional[pulumi.Input[str]] = None,
                 pause_subscriptions: Optional[pulumi.Input[bool]] = None,
                 subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]] = None):
        """
        :param pulumi.Input[str] dashboard_id: (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        :param pulumi.Input[str] custom_subject: string specifying a custom subject of email sent.
        :param pulumi.Input[bool] pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        JobTaskSqlTaskDashboardArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard_id=dashboard_id,
            custom_subject=custom_subject,
            pause_subscriptions=pause_subscriptions,
            subscriptions=subscriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard_id: Optional[pulumi.Input[str]] = None,
             custom_subject: Optional[pulumi.Input[str]] = None,
             pause_subscriptions: Optional[pulumi.Input[bool]] = None,
             subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if dashboard_id is None and 'dashboardId' in kwargs:
            dashboard_id = kwargs['dashboardId']
        if dashboard_id is None:
            raise TypeError("Missing 'dashboard_id' argument")
        if custom_subject is None and 'customSubject' in kwargs:
            custom_subject = kwargs['customSubject']
        if pause_subscriptions is None and 'pauseSubscriptions' in kwargs:
            pause_subscriptions = kwargs['pauseSubscriptions']

        _setter("dashboard_id", dashboard_id)
        if custom_subject is not None:
            _setter("custom_subject", custom_subject)
        if pause_subscriptions is not None:
            _setter("pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            _setter("subscriptions", subscriptions)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> pulumi.Input[str]:
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[pulumi.Input[str]]:
        """
        string specifying a custom subject of email sent.
        """
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[pulumi.Input[bool]]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTaskSqlTaskDashboardSubscriptionArgs']]]]):
        pulumi.set(self, "subscriptions", value)


@pulumi.input_type
class JobTaskSqlTaskDashboardSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        JobTaskSqlTaskDashboardSubscriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_id=destination_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_id: Optional[pulumi.Input[str]] = None,
             user_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination_id is None and 'destinationId' in kwargs:
            destination_id = kwargs['destinationId']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if destination_id is not None:
            _setter("destination_id", destination_id)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class JobTaskSqlTaskFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        JobTaskSqlTaskFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class JobTaskSqlTaskQueryArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str]):
        JobTaskSqlTaskQueryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_id=query_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_id is None:
            raise TypeError("Missing 'query_id' argument")

        _setter("query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)


@pulumi.input_type
class JobTriggerArgs:
    def __init__(__self__, *,
                 file_arrival: pulumi.Input['JobTriggerFileArrivalArgs'],
                 pause_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['JobTriggerFileArrivalArgs'] file_arrival: configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        :param pulumi.Input[str] pause_status: Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        JobTriggerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_arrival=file_arrival,
            pause_status=pause_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_arrival: Optional[pulumi.Input['JobTriggerFileArrivalArgs']] = None,
             pause_status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if file_arrival is None and 'fileArrival' in kwargs:
            file_arrival = kwargs['fileArrival']
        if file_arrival is None:
            raise TypeError("Missing 'file_arrival' argument")
        if pause_status is None and 'pauseStatus' in kwargs:
            pause_status = kwargs['pauseStatus']

        _setter("file_arrival", file_arrival)
        if pause_status is not None:
            _setter("pause_status", pause_status)

    @property
    @pulumi.getter(name="fileArrival")
    def file_arrival(self) -> pulumi.Input['JobTriggerFileArrivalArgs']:
        """
        configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        """
        return pulumi.get(self, "file_arrival")

    @file_arrival.setter
    def file_arrival(self, value: pulumi.Input['JobTriggerFileArrivalArgs']):
        pulumi.set(self, "file_arrival", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[pulumi.Input[str]]:
        """
        Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pause_status", value)


@pulumi.input_type
class JobTriggerFileArrivalArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 min_time_between_triggers_seconds: Optional[pulumi.Input[int]] = None,
                 wait_after_last_change_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] url: URL of the job on the given workspace
        :param pulumi.Input[int] min_time_between_triggers_seconds: If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        :param pulumi.Input[int] wait_after_last_change_seconds: If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        JobTriggerFileArrivalArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            min_time_between_triggers_seconds=min_time_between_triggers_seconds,
            wait_after_last_change_seconds=wait_after_last_change_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             min_time_between_triggers_seconds: Optional[pulumi.Input[int]] = None,
             wait_after_last_change_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if min_time_between_triggers_seconds is None and 'minTimeBetweenTriggersSeconds' in kwargs:
            min_time_between_triggers_seconds = kwargs['minTimeBetweenTriggersSeconds']
        if wait_after_last_change_seconds is None and 'waitAfterLastChangeSeconds' in kwargs:
            wait_after_last_change_seconds = kwargs['waitAfterLastChangeSeconds']

        _setter("url", url)
        if min_time_between_triggers_seconds is not None:
            _setter("min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            _setter("wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


@pulumi.input_type
class JobWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]] = None,
                 on_failures: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]] = None,
                 on_starts: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]] = None,
                 on_successes: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
               
               ```python
               import pulumi
               ```
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        JobWebhookNotificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_duration_warning_threshold_exceededs=on_duration_warning_threshold_exceededs,
            on_failures=on_failures,
            on_starts=on_starts,
            on_successes=on_successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_duration_warning_threshold_exceededs: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]] = None,
             on_failures: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]] = None,
             on_starts: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]] = None,
             on_successes: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if on_duration_warning_threshold_exceededs is None and 'onDurationWarningThresholdExceededs' in kwargs:
            on_duration_warning_threshold_exceededs = kwargs['onDurationWarningThresholdExceededs']
        if on_failures is None and 'onFailures' in kwargs:
            on_failures = kwargs['onFailures']
        if on_starts is None and 'onStarts' in kwargs:
            on_starts = kwargs['onStarts']
        if on_successes is None and 'onSuccesses' in kwargs:
            on_successes = kwargs['onSuccesses']

        if on_duration_warning_threshold_exceededs is not None:
            _setter("on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            _setter("on_failures", on_failures)
        if on_starts is not None:
            _setter("on_starts", on_starts)
        if on_successes is not None:
            _setter("on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs']]]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnFailureArgs']]]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnStartArgs']]]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobWebhookNotificationsOnSuccessArgs']]]]):
        pulumi.set(self, "on_successes", value)


@pulumi.input_type
class JobWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        JobWebhookNotificationsOnDurationWarningThresholdExceededArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class JobWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        JobWebhookNotificationsOnFailureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class JobWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        JobWebhookNotificationsOnStartArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class JobWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: ID of the job
        """
        JobWebhookNotificationsOnSuccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the job
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class LibraryCranArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        LibraryCranArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class LibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        LibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class LibraryPypiArgs:
    def __init__(__self__, *,
                 package: pulumi.Input[str],
                 repo: Optional[pulumi.Input[str]] = None):
        LibraryPypiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[pulumi.Input[str]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: pulumi.Input[str]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class MetastoreDataAccessAwsIamRoleArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
               
               `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (Recommended):
        """
        MetastoreDataAccessAwsIamRoleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")

        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`

        `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (Recommended):
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


@pulumi.input_type
class MetastoreDataAccessAzureManagedIdentityArgs:
    def __init__(__self__, *,
                 access_connector_id: pulumi.Input[str],
                 credential_id: Optional[pulumi.Input[str]] = None,
                 managed_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param pulumi.Input[str] managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
               
               `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        MetastoreDataAccessAzureManagedIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_connector_id=access_connector_id,
            credential_id=credential_id,
            managed_identity_id=managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_connector_id: Optional[pulumi.Input[str]] = None,
             credential_id: Optional[pulumi.Input[str]] = None,
             managed_identity_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_connector_id is None and 'accessConnectorId' in kwargs:
            access_connector_id = kwargs['accessConnectorId']
        if access_connector_id is None:
            raise TypeError("Missing 'access_connector_id' argument")
        if credential_id is None and 'credentialId' in kwargs:
            credential_id = kwargs['credentialId']
        if managed_identity_id is None and 'managedIdentityId' in kwargs:
            managed_identity_id = kwargs['managedIdentityId']

        _setter("access_connector_id", access_connector_id)
        if credential_id is not None:
            _setter("credential_id", credential_id)
        if managed_identity_id is not None:
            _setter("managed_identity_id", managed_identity_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> pulumi.Input[str]:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @access_connector_id.setter
    def access_connector_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_connector_id", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.

        `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        return pulumi.get(self, "managed_identity_id")

    @managed_identity_id.setter
    def managed_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_identity_id", value)


@pulumi.input_type
class MetastoreDataAccessAzureServicePrincipalArgs:
    def __init__(__self__, *,
                 application_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 directory_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] application_id: The application ID of the application registration within the referenced AAD tenant
        :param pulumi.Input[str] client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
        :param pulumi.Input[str] directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        MetastoreDataAccessAzureServicePrincipalArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            client_secret=client_secret,
            directory_id=directory_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             directory_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_id is None and 'applicationId' in kwargs:
            application_id = kwargs['applicationId']
        if application_id is None:
            raise TypeError("Missing 'application_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if directory_id is None and 'directoryId' in kwargs:
            directory_id = kwargs['directoryId']
        if directory_id is None:
            raise TypeError("Missing 'directory_id' argument")

        _setter("application_id", application_id)
        _setter("client_secret", client_secret)
        _setter("directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> pulumi.Input[str]:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> pulumi.Input[str]:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "directory_id", value)


@pulumi.input_type
class MetastoreDataAccessDatabricksGcpServiceAccountArgs:
    def __init__(__self__, *,
                 credential_id: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: The email of the GCP service account created, to be granted access to relevant buckets.
               
               `azure_service_principal` optional configuration block for credential details for Azure (Legacy):
        """
        MetastoreDataAccessDatabricksGcpServiceAccountArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credential_id=credential_id,
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credential_id: Optional[pulumi.Input[str]] = None,
             email: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if credential_id is None and 'credentialId' in kwargs:
            credential_id = kwargs['credentialId']

        if credential_id is not None:
            _setter("credential_id", credential_id)
        if email is not None:
            _setter("email", email)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `azure_service_principal` optional configuration block for credential details for Azure (Legacy):
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class MetastoreDataAccessGcpServiceAccountKeyArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 private_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the GCP service account created, to be granted access to relevant buckets.
               
               `azure_service_principal` optional configuration block for credential details for Azure (Legacy):
        """
        MetastoreDataAccessGcpServiceAccountKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            private_key=private_key,
            private_key_id=private_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             private_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if email is None:
            raise TypeError("Missing 'email' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")
        if private_key_id is None and 'privateKeyId' in kwargs:
            private_key_id = kwargs['privateKeyId']
        if private_key_id is None:
            raise TypeError("Missing 'private_key_id' argument")

        _setter("email", email)
        _setter("private_key", private_key)
        _setter("private_key_id", private_key_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `azure_service_principal` optional configuration block for credential details for Azure (Legacy):
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_id", value)


@pulumi.input_type
class MlflowModelTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        MlflowModelTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MlflowWebhookHttpUrlSpecArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 authorization: Optional[pulumi.Input[str]] = None,
                 enable_ssl_verification: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        :param pulumi.Input[str] authorization: Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        :param pulumi.Input[bool] enable_ssl_verification: Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        :param pulumi.Input[str] secret: Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
        MlflowWebhookHttpUrlSpecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            authorization=authorization,
            enable_ssl_verification=enable_ssl_verification,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             authorization: Optional[pulumi.Input[str]] = None,
             enable_ssl_verification: Optional[pulumi.Input[bool]] = None,
             secret: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if enable_ssl_verification is None and 'enableSslVerification' in kwargs:
            enable_ssl_verification = kwargs['enableSslVerification']

        _setter("url", url)
        if authorization is not None:
            _setter("authorization", authorization)
        if enable_ssl_verification is not None:
            _setter("enable_ssl_verification", enable_ssl_verification)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="enableSslVerification")
    def enable_ssl_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        """
        return pulumi.get(self, "enable_ssl_verification")

    @enable_ssl_verification.setter
    def enable_ssl_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ssl_verification", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class MlflowWebhookJobSpecArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 job_id: pulumi.Input[str],
                 workspace_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The personal access token used to authorize webhook's job runs.
        :param pulumi.Input[str] job_id: ID of the Databricks job that the webhook runs.
        :param pulumi.Input[str] workspace_url: URL of the workspace containing the job that this webhook runs. If not specified, the jobs workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        MlflowWebhookJobSpecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_token=access_token,
            job_id=job_id,
            workspace_url=workspace_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_token: Optional[pulumi.Input[str]] = None,
             job_id: Optional[pulumi.Input[str]] = None,
             workspace_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_token is None and 'accessToken' in kwargs:
            access_token = kwargs['accessToken']
        if access_token is None:
            raise TypeError("Missing 'access_token' argument")
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']
        if job_id is None:
            raise TypeError("Missing 'job_id' argument")
        if workspace_url is None and 'workspaceUrl' in kwargs:
            workspace_url = kwargs['workspaceUrl']

        _setter("access_token", access_token)
        _setter("job_id", job_id)
        if workspace_url is not None:
            _setter("workspace_url", workspace_url)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The personal access token used to authorize webhook's job runs.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> pulumi.Input[str]:
        """
        ID of the Databricks job that the webhook runs.
        """
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="workspaceUrl")
    def workspace_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of the workspace containing the job that this webhook runs. If not specified, the jobs workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        return pulumi.get(self, "workspace_url")

    @workspace_url.setter
    def workspace_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_url", value)


@pulumi.input_type
class ModelServingConfigArgs:
    def __init__(__self__, *,
                 served_models: pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]],
                 traffic_config: Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]] served_models: Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        :param pulumi.Input['ModelServingConfigTrafficConfigArgs'] traffic_config: A single block represents the traffic split configuration amongst the served models.
        """
        ModelServingConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            served_models=served_models,
            traffic_config=traffic_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             served_models: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]]] = None,
             traffic_config: Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if served_models is None and 'servedModels' in kwargs:
            served_models = kwargs['servedModels']
        if served_models is None:
            raise TypeError("Missing 'served_models' argument")
        if traffic_config is None and 'trafficConfig' in kwargs:
            traffic_config = kwargs['trafficConfig']

        _setter("served_models", served_models)
        if traffic_config is not None:
            _setter("traffic_config", traffic_config)

    @property
    @pulumi.getter(name="servedModels")
    def served_models(self) -> pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]]:
        """
        Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        """
        return pulumi.get(self, "served_models")

    @served_models.setter
    def served_models(self, value: pulumi.Input[Sequence[pulumi.Input['ModelServingConfigServedModelArgs']]]):
        pulumi.set(self, "served_models", value)

    @property
    @pulumi.getter(name="trafficConfig")
    def traffic_config(self) -> Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']]:
        """
        A single block represents the traffic split configuration amongst the served models.
        """
        return pulumi.get(self, "traffic_config")

    @traffic_config.setter
    def traffic_config(self, value: Optional[pulumi.Input['ModelServingConfigTrafficConfigArgs']]):
        pulumi.set(self, "traffic_config", value)


@pulumi.input_type
class ModelServingConfigServedModelArgs:
    def __init__(__self__, *,
                 model_name: pulumi.Input[str],
                 model_version: pulumi.Input[str],
                 workload_size: pulumi.Input[str],
                 environment_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 scale_to_zero_enabled: Optional[pulumi.Input[bool]] = None,
                 workload_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] model_name: The name of the model in Databricks Model Registry to be served.
        :param pulumi.Input[str] model_version: The version of the model in Databricks Model Registry to be served.
        :param pulumi.Input[str] workload_size: The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are "Small" (4 - 4 provisioned concurrency), "Medium" (8 - 16 provisioned concurrency), and "Large" (16 - 64 provisioned concurrency).
        :param pulumi.Input[Mapping[str, Any]] environment_vars: a map of environment variable name/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        :param pulumi.Input[str] instance_profile_arn: ARN of the instance profile that the served model will use to access AWS resources.
        :param pulumi.Input[str] name: The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        :param pulumi.Input[bool] scale_to_zero_enabled: Whether the compute resources for the served model should scale down to zero. If scale-to-zero is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        :param pulumi.Input[str] workload_type: The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See documentation for all options. The default value is `CPU`.
        """
        ModelServingConfigServedModelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            model_name=model_name,
            model_version=model_version,
            workload_size=workload_size,
            environment_vars=environment_vars,
            instance_profile_arn=instance_profile_arn,
            name=name,
            scale_to_zero_enabled=scale_to_zero_enabled,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             model_name: Optional[pulumi.Input[str]] = None,
             model_version: Optional[pulumi.Input[str]] = None,
             workload_size: Optional[pulumi.Input[str]] = None,
             environment_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             instance_profile_arn: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             scale_to_zero_enabled: Optional[pulumi.Input[bool]] = None,
             workload_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if model_name is None and 'modelName' in kwargs:
            model_name = kwargs['modelName']
        if model_name is None:
            raise TypeError("Missing 'model_name' argument")
        if model_version is None and 'modelVersion' in kwargs:
            model_version = kwargs['modelVersion']
        if model_version is None:
            raise TypeError("Missing 'model_version' argument")
        if workload_size is None and 'workloadSize' in kwargs:
            workload_size = kwargs['workloadSize']
        if workload_size is None:
            raise TypeError("Missing 'workload_size' argument")
        if environment_vars is None and 'environmentVars' in kwargs:
            environment_vars = kwargs['environmentVars']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if scale_to_zero_enabled is None and 'scaleToZeroEnabled' in kwargs:
            scale_to_zero_enabled = kwargs['scaleToZeroEnabled']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("model_name", model_name)
        _setter("model_version", model_version)
        _setter("workload_size", workload_size)
        if environment_vars is not None:
            _setter("environment_vars", environment_vars)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if name is not None:
            _setter("name", name)
        if scale_to_zero_enabled is not None:
            _setter("scale_to_zero_enabled", scale_to_zero_enabled)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> pulumi.Input[str]:
        """
        The name of the model in Databricks Model Registry to be served.
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_name", value)

    @property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> pulumi.Input[str]:
        """
        The version of the model in Databricks Model Registry to be served.
        """
        return pulumi.get(self, "model_version")

    @model_version.setter
    def model_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_version", value)

    @property
    @pulumi.getter(name="workloadSize")
    def workload_size(self) -> pulumi.Input[str]:
        """
        The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are "Small" (4 - 4 provisioned concurrency), "Medium" (8 - 16 provisioned concurrency), and "Large" (16 - 64 provisioned concurrency).
        """
        return pulumi.get(self, "workload_size")

    @workload_size.setter
    def workload_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "workload_size", value)

    @property
    @pulumi.getter(name="environmentVars")
    def environment_vars(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        a map of environment variable name/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        """
        return pulumi.get(self, "environment_vars")

    @environment_vars.setter
    def environment_vars(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "environment_vars", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of the instance profile that the served model will use to access AWS resources.
        """
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="scaleToZeroEnabled")
    def scale_to_zero_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the compute resources for the served model should scale down to zero. If scale-to-zero is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        """
        return pulumi.get(self, "scale_to_zero_enabled")

    @scale_to_zero_enabled.setter
    def scale_to_zero_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scale_to_zero_enabled", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input[str]]:
        """
        The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See documentation for all options. The default value is `CPU`.
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class ModelServingConfigTrafficConfigArgs:
    def __init__(__self__, *,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]] routes: Each block represents a route that defines traffic to each served model. Each `served_models` block needs to have a corresponding `routes` block
        """
        ModelServingConfigTrafficConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            routes=routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             routes: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if routes is not None:
            _setter("routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]]:
        """
        Each block represents a route that defines traffic to each served model. Each `served_models` block needs to have a corresponding `routes` block
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelServingConfigTrafficConfigRouteArgs']]]]):
        pulumi.set(self, "routes", value)


@pulumi.input_type
class ModelServingConfigTrafficConfigRouteArgs:
    def __init__(__self__, *,
                 served_model_name: pulumi.Input[str],
                 traffic_percentage: pulumi.Input[int]):
        """
        :param pulumi.Input[str] served_model_name: The name of the served model this route configures traffic for. This needs to match the name of a `served_models` block
        :param pulumi.Input[int] traffic_percentage: The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
        ModelServingConfigTrafficConfigRouteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            served_model_name=served_model_name,
            traffic_percentage=traffic_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             served_model_name: Optional[pulumi.Input[str]] = None,
             traffic_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if served_model_name is None and 'servedModelName' in kwargs:
            served_model_name = kwargs['servedModelName']
        if served_model_name is None:
            raise TypeError("Missing 'served_model_name' argument")
        if traffic_percentage is None and 'trafficPercentage' in kwargs:
            traffic_percentage = kwargs['trafficPercentage']
        if traffic_percentage is None:
            raise TypeError("Missing 'traffic_percentage' argument")

        _setter("served_model_name", served_model_name)
        _setter("traffic_percentage", traffic_percentage)

    @property
    @pulumi.getter(name="servedModelName")
    def served_model_name(self) -> pulumi.Input[str]:
        """
        The name of the served model this route configures traffic for. This needs to match the name of a `served_models` block
        """
        return pulumi.get(self, "served_model_name")

    @served_model_name.setter
    def served_model_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "served_model_name", value)

    @property
    @pulumi.getter(name="trafficPercentage")
    def traffic_percentage(self) -> pulumi.Input[int]:
        """
        The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
        return pulumi.get(self, "traffic_percentage")

    @traffic_percentage.setter
    def traffic_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "traffic_percentage", value)


@pulumi.input_type
class ModelServingTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        ModelServingTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")

        _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MountAbfsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_key: pulumi.Input[str],
                 client_secret_scope: pulumi.Input[str],
                 initialize_file_system: pulumi.Input[bool],
                 container_name: Optional[pulumi.Input[str]] = None,
                 directory: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        MountAbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_key=client_secret_key,
            client_secret_scope=client_secret_scope,
            initialize_file_system=initialize_file_system,
            container_name=container_name,
            directory=directory,
            storage_account_name=storage_account_name,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_key: Optional[pulumi.Input[str]] = None,
             client_secret_scope: Optional[pulumi.Input[str]] = None,
             initialize_file_system: Optional[pulumi.Input[bool]] = None,
             container_name: Optional[pulumi.Input[str]] = None,
             directory: Optional[pulumi.Input[str]] = None,
             storage_account_name: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret_key is None and 'clientSecretKey' in kwargs:
            client_secret_key = kwargs['clientSecretKey']
        if client_secret_key is None:
            raise TypeError("Missing 'client_secret_key' argument")
        if client_secret_scope is None and 'clientSecretScope' in kwargs:
            client_secret_scope = kwargs['clientSecretScope']
        if client_secret_scope is None:
            raise TypeError("Missing 'client_secret_scope' argument")
        if initialize_file_system is None and 'initializeFileSystem' in kwargs:
            initialize_file_system = kwargs['initializeFileSystem']
        if initialize_file_system is None:
            raise TypeError("Missing 'initialize_file_system' argument")
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if storage_account_name is None and 'storageAccountName' in kwargs:
            storage_account_name = kwargs['storageAccountName']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        _setter("client_id", client_id)
        _setter("client_secret_key", client_secret_key)
        _setter("client_secret_scope", client_secret_scope)
        _setter("initialize_file_system", initialize_file_system)
        if container_name is not None:
            _setter("container_name", container_name)
        if directory is not None:
            _setter("directory", directory)
        if storage_account_name is not None:
            _setter("storage_account_name", storage_account_name)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_key")

    @client_secret_key.setter
    def client_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_key", value)

    @property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_scope")

    @client_secret_scope.setter
    def client_secret_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_scope", value)

    @property
    @pulumi.getter(name="initializeFileSystem")
    def initialize_file_system(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "initialize_file_system")

    @initialize_file_system.setter
    def initialize_file_system(self, value: pulumi.Input[bool]):
        pulumi.set(self, "initialize_file_system", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class MountAdlArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret_key: pulumi.Input[str],
                 client_secret_scope: pulumi.Input[str],
                 directory: Optional[pulumi.Input[str]] = None,
                 spark_conf_prefix: Optional[pulumi.Input[str]] = None,
                 storage_resource_name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        MountAdlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_key=client_secret_key,
            client_secret_scope=client_secret_scope,
            directory=directory,
            spark_conf_prefix=spark_conf_prefix,
            storage_resource_name=storage_resource_name,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_key: Optional[pulumi.Input[str]] = None,
             client_secret_scope: Optional[pulumi.Input[str]] = None,
             directory: Optional[pulumi.Input[str]] = None,
             spark_conf_prefix: Optional[pulumi.Input[str]] = None,
             storage_resource_name: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if client_secret_key is None and 'clientSecretKey' in kwargs:
            client_secret_key = kwargs['clientSecretKey']
        if client_secret_key is None:
            raise TypeError("Missing 'client_secret_key' argument")
        if client_secret_scope is None and 'clientSecretScope' in kwargs:
            client_secret_scope = kwargs['clientSecretScope']
        if client_secret_scope is None:
            raise TypeError("Missing 'client_secret_scope' argument")
        if spark_conf_prefix is None and 'sparkConfPrefix' in kwargs:
            spark_conf_prefix = kwargs['sparkConfPrefix']
        if storage_resource_name is None and 'storageResourceName' in kwargs:
            storage_resource_name = kwargs['storageResourceName']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        _setter("client_id", client_id)
        _setter("client_secret_key", client_secret_key)
        _setter("client_secret_scope", client_secret_scope)
        if directory is not None:
            _setter("directory", directory)
        if spark_conf_prefix is not None:
            _setter("spark_conf_prefix", spark_conf_prefix)
        if storage_resource_name is not None:
            _setter("storage_resource_name", storage_resource_name)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_key")

    @client_secret_key.setter
    def client_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_key", value)

    @property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret_scope")

    @client_secret_scope.setter
    def client_secret_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret_scope", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter(name="sparkConfPrefix")
    def spark_conf_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "spark_conf_prefix")

    @spark_conf_prefix.setter
    def spark_conf_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_conf_prefix", value)

    @property
    @pulumi.getter(name="storageResourceName")
    def storage_resource_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_resource_name")

    @storage_resource_name.setter
    def storage_resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_resource_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class MountGsArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 service_account: Optional[pulumi.Input[str]] = None):
        MountGsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            service_account=service_account,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[pulumi.Input[str]] = None,
             service_account: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if service_account is None and 'serviceAccount' in kwargs:
            service_account = kwargs['serviceAccount']

        _setter("bucket_name", bucket_name)
        if service_account is not None:
            _setter("service_account", service_account)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)


@pulumi.input_type
class MountS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 instance_profile: Optional[pulumi.Input[str]] = None):
        MountS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            instance_profile=instance_profile,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: Optional[pulumi.Input[str]] = None,
             instance_profile: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if bucket_name is None and 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if bucket_name is None:
            raise TypeError("Missing 'bucket_name' argument")
        if instance_profile is None and 'instanceProfile' in kwargs:
            instance_profile = kwargs['instanceProfile']

        _setter("bucket_name", bucket_name)
        if instance_profile is not None:
            _setter("instance_profile", instance_profile)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="instanceProfile")
    def instance_profile(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile")

    @instance_profile.setter
    def instance_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile", value)


@pulumi.input_type
class MountWasbArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[str],
                 token_secret_key: pulumi.Input[str],
                 token_secret_scope: pulumi.Input[str],
                 container_name: Optional[pulumi.Input[str]] = None,
                 directory: Optional[pulumi.Input[str]] = None,
                 storage_account_name: Optional[pulumi.Input[str]] = None):
        MountWasbArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_type=auth_type,
            token_secret_key=token_secret_key,
            token_secret_scope=token_secret_scope,
            container_name=container_name,
            directory=directory,
            storage_account_name=storage_account_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_type: Optional[pulumi.Input[str]] = None,
             token_secret_key: Optional[pulumi.Input[str]] = None,
             token_secret_scope: Optional[pulumi.Input[str]] = None,
             container_name: Optional[pulumi.Input[str]] = None,
             directory: Optional[pulumi.Input[str]] = None,
             storage_account_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if auth_type is None and 'authType' in kwargs:
            auth_type = kwargs['authType']
        if auth_type is None:
            raise TypeError("Missing 'auth_type' argument")
        if token_secret_key is None and 'tokenSecretKey' in kwargs:
            token_secret_key = kwargs['tokenSecretKey']
        if token_secret_key is None:
            raise TypeError("Missing 'token_secret_key' argument")
        if token_secret_scope is None and 'tokenSecretScope' in kwargs:
            token_secret_scope = kwargs['tokenSecretScope']
        if token_secret_scope is None:
            raise TypeError("Missing 'token_secret_scope' argument")
        if container_name is None and 'containerName' in kwargs:
            container_name = kwargs['containerName']
        if storage_account_name is None and 'storageAccountName' in kwargs:
            storage_account_name = kwargs['storageAccountName']

        _setter("auth_type", auth_type)
        _setter("token_secret_key", token_secret_key)
        _setter("token_secret_scope", token_secret_scope)
        if container_name is not None:
            _setter("container_name", container_name)
        if directory is not None:
            _setter("directory", directory)
        if storage_account_name is not None:
            _setter("storage_account_name", storage_account_name)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="tokenSecretKey")
    def token_secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token_secret_key")

    @token_secret_key.setter
    def token_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_secret_key", value)

    @property
    @pulumi.getter(name="tokenSecretScope")
    def token_secret_scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token_secret_scope")

    @token_secret_scope.setter
    def token_secret_scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_secret_scope", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account_name", value)


@pulumi.input_type
class MwsCustomerManagedKeysAwsKeyInfoArgs:
    def __init__(__self__, *,
                 key_alias: pulumi.Input[str],
                 key_arn: pulumi.Input[str],
                 key_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_alias: The AWS KMS key alias.
        :param pulumi.Input[str] key_arn: The AWS KMS key's Amazon Resource Name (ARN).
        :param pulumi.Input[str] key_region: (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        MwsCustomerManagedKeysAwsKeyInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_alias=key_alias,
            key_arn=key_arn,
            key_region=key_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_alias: Optional[pulumi.Input[str]] = None,
             key_arn: Optional[pulumi.Input[str]] = None,
             key_region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if key_alias is None and 'keyAlias' in kwargs:
            key_alias = kwargs['keyAlias']
        if key_alias is None:
            raise TypeError("Missing 'key_alias' argument")
        if key_arn is None and 'keyArn' in kwargs:
            key_arn = kwargs['keyArn']
        if key_arn is None:
            raise TypeError("Missing 'key_arn' argument")
        if key_region is None and 'keyRegion' in kwargs:
            key_region = kwargs['keyRegion']

        _setter("key_alias", key_alias)
        _setter("key_arn", key_arn)
        if key_region is not None:
            _setter("key_region", key_region)

    @property
    @pulumi.getter(name="keyAlias")
    def key_alias(self) -> pulumi.Input[str]:
        """
        The AWS KMS key alias.
        """
        return pulumi.get(self, "key_alias")

    @key_alias.setter
    def key_alias(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_alias", value)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> pulumi.Input[str]:
        """
        The AWS KMS key's Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_arn", value)

    @property
    @pulumi.getter(name="keyRegion")
    def key_region(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        return pulumi.get(self, "key_region")

    @key_region.setter
    def key_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_region", value)


@pulumi.input_type
class MwsCustomerManagedKeysGcpKeyInfoArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_key_id: The GCP KMS key's resource name.
        """
        MwsCustomerManagedKeysGcpKeyInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kms_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if kms_key_id is None and 'kmsKeyId' in kwargs:
            kms_key_id = kwargs['kmsKeyId']
        if kms_key_id is None:
            raise TypeError("Missing 'kms_key_id' argument")

        _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[str]:
        """
        The GCP KMS key's resource name.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class MwsNetworksErrorMessageArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[str]] = None,
                 error_type: Optional[pulumi.Input[str]] = None):
        MwsNetworksErrorMessageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_message=error_message,
            error_type=error_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_message: Optional[pulumi.Input[str]] = None,
             error_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_type is None and 'errorType' in kwargs:
            error_type = kwargs['errorType']

        if error_message is not None:
            _setter("error_message", error_message)
        if error_type is not None:
            _setter("error_type", error_type)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter(name="errorType")
    def error_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_type")

    @error_type.setter
    def error_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_type", value)


@pulumi.input_type
class MwsNetworksGcpNetworkInfoArgs:
    def __init__(__self__, *,
                 network_project_id: pulumi.Input[str],
                 pod_ip_range_name: pulumi.Input[str],
                 service_ip_range_name: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 subnet_region: pulumi.Input[str],
                 vpc_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] network_project_id: The Google Cloud project ID of the VPC network.
        :param pulumi.Input[str] pod_ip_range_name: The name of the secondary IP range for pods. A Databricks-managed GKE cluster uses this IP range for its pods. This secondary IP range can only be used by one workspace.
        :param pulumi.Input[str] service_ip_range_name: The name of the secondary IP range for services. A Databricks-managed GKE cluster uses this IP range for its services. This secondary IP range can only be used by one workspace.
        :param pulumi.Input[str] subnet_id: The ID of the subnet associated with this network.
        :param pulumi.Input[str] subnet_region: The Google Cloud region of the workspace data plane. For example, `us-east4`.
        :param pulumi.Input[str] vpc_id: The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
        MwsNetworksGcpNetworkInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_project_id=network_project_id,
            pod_ip_range_name=pod_ip_range_name,
            service_ip_range_name=service_ip_range_name,
            subnet_id=subnet_id,
            subnet_region=subnet_region,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_project_id: Optional[pulumi.Input[str]] = None,
             pod_ip_range_name: Optional[pulumi.Input[str]] = None,
             service_ip_range_name: Optional[pulumi.Input[str]] = None,
             subnet_id: Optional[pulumi.Input[str]] = None,
             subnet_region: Optional[pulumi.Input[str]] = None,
             vpc_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if network_project_id is None and 'networkProjectId' in kwargs:
            network_project_id = kwargs['networkProjectId']
        if network_project_id is None:
            raise TypeError("Missing 'network_project_id' argument")
        if pod_ip_range_name is None and 'podIpRangeName' in kwargs:
            pod_ip_range_name = kwargs['podIpRangeName']
        if pod_ip_range_name is None:
            raise TypeError("Missing 'pod_ip_range_name' argument")
        if service_ip_range_name is None and 'serviceIpRangeName' in kwargs:
            service_ip_range_name = kwargs['serviceIpRangeName']
        if service_ip_range_name is None:
            raise TypeError("Missing 'service_ip_range_name' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if subnet_region is None and 'subnetRegion' in kwargs:
            subnet_region = kwargs['subnetRegion']
        if subnet_region is None:
            raise TypeError("Missing 'subnet_region' argument")
        if vpc_id is None and 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if vpc_id is None:
            raise TypeError("Missing 'vpc_id' argument")

        _setter("network_project_id", network_project_id)
        _setter("pod_ip_range_name", pod_ip_range_name)
        _setter("service_ip_range_name", service_ip_range_name)
        _setter("subnet_id", subnet_id)
        _setter("subnet_region", subnet_region)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="networkProjectId")
    def network_project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud project ID of the VPC network.
        """
        return pulumi.get(self, "network_project_id")

    @network_project_id.setter
    def network_project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_project_id", value)

    @property
    @pulumi.getter(name="podIpRangeName")
    def pod_ip_range_name(self) -> pulumi.Input[str]:
        """
        The name of the secondary IP range for pods. A Databricks-managed GKE cluster uses this IP range for its pods. This secondary IP range can only be used by one workspace.
        """
        return pulumi.get(self, "pod_ip_range_name")

    @pod_ip_range_name.setter
    def pod_ip_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "pod_ip_range_name", value)

    @property
    @pulumi.getter(name="serviceIpRangeName")
    def service_ip_range_name(self) -> pulumi.Input[str]:
        """
        The name of the secondary IP range for services. A Databricks-managed GKE cluster uses this IP range for its services. This secondary IP range can only be used by one workspace.
        """
        return pulumi.get(self, "service_ip_range_name")

    @service_ip_range_name.setter
    def service_ip_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_ip_range_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The ID of the subnet associated with this network.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="subnetRegion")
    def subnet_region(self) -> pulumi.Input[str]:
        """
        The Google Cloud region of the workspace data plane. For example, `us-east4`.
        """
        return pulumi.get(self, "subnet_region")

    @subnet_region.setter
    def subnet_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_region", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        """
        The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)


@pulumi.input_type
class MwsNetworksVpcEndpointsArgs:
    def __init__(__self__, *,
                 dataplane_relays: pulumi.Input[Sequence[pulumi.Input[str]]],
                 rest_apis: pulumi.Input[Sequence[pulumi.Input[str]]]):
        MwsNetworksVpcEndpointsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dataplane_relays=dataplane_relays,
            rest_apis=rest_apis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dataplane_relays: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             rest_apis: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if dataplane_relays is None and 'dataplaneRelays' in kwargs:
            dataplane_relays = kwargs['dataplaneRelays']
        if dataplane_relays is None:
            raise TypeError("Missing 'dataplane_relays' argument")
        if rest_apis is None and 'restApis' in kwargs:
            rest_apis = kwargs['restApis']
        if rest_apis is None:
            raise TypeError("Missing 'rest_apis' argument")

        _setter("dataplane_relays", dataplane_relays)
        _setter("rest_apis", rest_apis)

    @property
    @pulumi.getter(name="dataplaneRelays")
    def dataplane_relays(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "dataplane_relays")

    @dataplane_relays.setter
    def dataplane_relays(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dataplane_relays", value)

    @property
    @pulumi.getter(name="restApis")
    def rest_apis(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "rest_apis")

    @rest_apis.setter
    def rest_apis(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "rest_apis", value)


@pulumi.input_type
class MwsVpcEndpointGcpVpcEndpointInfoArgs:
    def __init__(__self__, *,
                 endpoint_region: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 psc_endpoint_name: pulumi.Input[str],
                 psc_connection_id: Optional[pulumi.Input[str]] = None,
                 service_attachment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_region: Region of the PSC endpoint.
        :param pulumi.Input[str] project_id: The Google Cloud project ID of the VPC network where the PSC connection resides.
        :param pulumi.Input[str] psc_endpoint_name: The name of the PSC endpoint in the Google Cloud project.
        :param pulumi.Input[str] psc_connection_id: The unique ID of this PSC connection.
        :param pulumi.Input[str] service_attachment_id: The service attachment this PSC connection connects to.
        """
        MwsVpcEndpointGcpVpcEndpointInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_region=endpoint_region,
            project_id=project_id,
            psc_endpoint_name=psc_endpoint_name,
            psc_connection_id=psc_connection_id,
            service_attachment_id=service_attachment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_region: Optional[pulumi.Input[str]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             psc_endpoint_name: Optional[pulumi.Input[str]] = None,
             psc_connection_id: Optional[pulumi.Input[str]] = None,
             service_attachment_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if endpoint_region is None and 'endpointRegion' in kwargs:
            endpoint_region = kwargs['endpointRegion']
        if endpoint_region is None:
            raise TypeError("Missing 'endpoint_region' argument")
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_id is None:
            raise TypeError("Missing 'project_id' argument")
        if psc_endpoint_name is None and 'pscEndpointName' in kwargs:
            psc_endpoint_name = kwargs['pscEndpointName']
        if psc_endpoint_name is None:
            raise TypeError("Missing 'psc_endpoint_name' argument")
        if psc_connection_id is None and 'pscConnectionId' in kwargs:
            psc_connection_id = kwargs['pscConnectionId']
        if service_attachment_id is None and 'serviceAttachmentId' in kwargs:
            service_attachment_id = kwargs['serviceAttachmentId']

        _setter("endpoint_region", endpoint_region)
        _setter("project_id", project_id)
        _setter("psc_endpoint_name", psc_endpoint_name)
        if psc_connection_id is not None:
            _setter("psc_connection_id", psc_connection_id)
        if service_attachment_id is not None:
            _setter("service_attachment_id", service_attachment_id)

    @property
    @pulumi.getter(name="endpointRegion")
    def endpoint_region(self) -> pulumi.Input[str]:
        """
        Region of the PSC endpoint.
        """
        return pulumi.get(self, "endpoint_region")

    @endpoint_region.setter
    def endpoint_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_region", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud project ID of the VPC network where the PSC connection resides.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="pscEndpointName")
    def psc_endpoint_name(self) -> pulumi.Input[str]:
        """
        The name of the PSC endpoint in the Google Cloud project.
        """
        return pulumi.get(self, "psc_endpoint_name")

    @psc_endpoint_name.setter
    def psc_endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "psc_endpoint_name", value)

    @property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID of this PSC connection.
        """
        return pulumi.get(self, "psc_connection_id")

    @psc_connection_id.setter
    def psc_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psc_connection_id", value)

    @property
    @pulumi.getter(name="serviceAttachmentId")
    def service_attachment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The service attachment this PSC connection connects to.
        """
        return pulumi.get(self, "service_attachment_id")

    @service_attachment_id.setter
    def service_attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_attachment_id", value)


@pulumi.input_type
class MwsWorkspacesCloudResourceContainerArgs:
    def __init__(__self__, *,
                 gcp: pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']):
        """
        :param pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs'] gcp: A block that consists of the following field:
        """
        MwsWorkspacesCloudResourceContainerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gcp=gcp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gcp: Optional[pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if gcp is None:
            raise TypeError("Missing 'gcp' argument")

        _setter("gcp", gcp)

    @property
    @pulumi.getter
    def gcp(self) -> pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']:
        """
        A block that consists of the following field:
        """
        return pulumi.get(self, "gcp")

    @gcp.setter
    def gcp(self, value: pulumi.Input['MwsWorkspacesCloudResourceContainerGcpArgs']):
        pulumi.set(self, "gcp", value)


@pulumi.input_type
class MwsWorkspacesCloudResourceContainerGcpArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] project_id: The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
        MwsWorkspacesCloudResourceContainerGcpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_id is None:
            raise TypeError("Missing 'project_id' argument")

        _setter("project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


@pulumi.input_type
class MwsWorkspacesExternalCustomerInfoArgs:
    def __init__(__self__, *,
                 authoritative_user_email: pulumi.Input[str],
                 authoritative_user_full_name: pulumi.Input[str],
                 customer_name: pulumi.Input[str]):
        MwsWorkspacesExternalCustomerInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authoritative_user_email=authoritative_user_email,
            authoritative_user_full_name=authoritative_user_full_name,
            customer_name=customer_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authoritative_user_email: Optional[pulumi.Input[str]] = None,
             authoritative_user_full_name: Optional[pulumi.Input[str]] = None,
             customer_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if authoritative_user_email is None and 'authoritativeUserEmail' in kwargs:
            authoritative_user_email = kwargs['authoritativeUserEmail']
        if authoritative_user_email is None:
            raise TypeError("Missing 'authoritative_user_email' argument")
        if authoritative_user_full_name is None and 'authoritativeUserFullName' in kwargs:
            authoritative_user_full_name = kwargs['authoritativeUserFullName']
        if authoritative_user_full_name is None:
            raise TypeError("Missing 'authoritative_user_full_name' argument")
        if customer_name is None and 'customerName' in kwargs:
            customer_name = kwargs['customerName']
        if customer_name is None:
            raise TypeError("Missing 'customer_name' argument")

        _setter("authoritative_user_email", authoritative_user_email)
        _setter("authoritative_user_full_name", authoritative_user_full_name)
        _setter("customer_name", customer_name)

    @property
    @pulumi.getter(name="authoritativeUserEmail")
    def authoritative_user_email(self) -> pulumi.Input[str]:
        return pulumi.get(self, "authoritative_user_email")

    @authoritative_user_email.setter
    def authoritative_user_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "authoritative_user_email", value)

    @property
    @pulumi.getter(name="authoritativeUserFullName")
    def authoritative_user_full_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "authoritative_user_full_name")

    @authoritative_user_full_name.setter
    def authoritative_user_full_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "authoritative_user_full_name", value)

    @property
    @pulumi.getter(name="customerName")
    def customer_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "customer_name")

    @customer_name.setter
    def customer_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "customer_name", value)


@pulumi.input_type
class MwsWorkspacesGcpManagedNetworkConfigArgs:
    def __init__(__self__, *,
                 gke_cluster_pod_ip_range: pulumi.Input[str],
                 gke_cluster_service_ip_range: pulumi.Input[str],
                 subnet_cidr: pulumi.Input[str]):
        MwsWorkspacesGcpManagedNetworkConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gke_cluster_pod_ip_range=gke_cluster_pod_ip_range,
            gke_cluster_service_ip_range=gke_cluster_service_ip_range,
            subnet_cidr=subnet_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gke_cluster_pod_ip_range: Optional[pulumi.Input[str]] = None,
             gke_cluster_service_ip_range: Optional[pulumi.Input[str]] = None,
             subnet_cidr: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if gke_cluster_pod_ip_range is None and 'gkeClusterPodIpRange' in kwargs:
            gke_cluster_pod_ip_range = kwargs['gkeClusterPodIpRange']
        if gke_cluster_pod_ip_range is None:
            raise TypeError("Missing 'gke_cluster_pod_ip_range' argument")
        if gke_cluster_service_ip_range is None and 'gkeClusterServiceIpRange' in kwargs:
            gke_cluster_service_ip_range = kwargs['gkeClusterServiceIpRange']
        if gke_cluster_service_ip_range is None:
            raise TypeError("Missing 'gke_cluster_service_ip_range' argument")
        if subnet_cidr is None and 'subnetCidr' in kwargs:
            subnet_cidr = kwargs['subnetCidr']
        if subnet_cidr is None:
            raise TypeError("Missing 'subnet_cidr' argument")

        _setter("gke_cluster_pod_ip_range", gke_cluster_pod_ip_range)
        _setter("gke_cluster_service_ip_range", gke_cluster_service_ip_range)
        _setter("subnet_cidr", subnet_cidr)

    @property
    @pulumi.getter(name="gkeClusterPodIpRange")
    def gke_cluster_pod_ip_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gke_cluster_pod_ip_range")

    @gke_cluster_pod_ip_range.setter
    def gke_cluster_pod_ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "gke_cluster_pod_ip_range", value)

    @property
    @pulumi.getter(name="gkeClusterServiceIpRange")
    def gke_cluster_service_ip_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gke_cluster_service_ip_range")

    @gke_cluster_service_ip_range.setter
    def gke_cluster_service_ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "gke_cluster_service_ip_range", value)

    @property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subnet_cidr")

    @subnet_cidr.setter
    def subnet_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_cidr", value)


@pulumi.input_type
class MwsWorkspacesGkeConfigArgs:
    def __init__(__self__, *,
                 connectivity_type: pulumi.Input[str],
                 master_ip_range: pulumi.Input[str]):
        """
        :param pulumi.Input[str] connectivity_type: Specifies the network connectivity types for the GKE nodes and the GKE master network. Possible values are: `PRIVATE_NODE_PUBLIC_MASTER`, `PUBLIC_NODE_PUBLIC_MASTER`.
        :param pulumi.Input[str] master_ip_range: The IP range from which to allocate GKE cluster master resources. This field will be ignored if GKE private cluster is not enabled. It must be exactly as big as `/28`.
        """
        MwsWorkspacesGkeConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connectivity_type=connectivity_type,
            master_ip_range=master_ip_range,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connectivity_type: Optional[pulumi.Input[str]] = None,
             master_ip_range: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if connectivity_type is None and 'connectivityType' in kwargs:
            connectivity_type = kwargs['connectivityType']
        if connectivity_type is None:
            raise TypeError("Missing 'connectivity_type' argument")
        if master_ip_range is None and 'masterIpRange' in kwargs:
            master_ip_range = kwargs['masterIpRange']
        if master_ip_range is None:
            raise TypeError("Missing 'master_ip_range' argument")

        _setter("connectivity_type", connectivity_type)
        _setter("master_ip_range", master_ip_range)

    @property
    @pulumi.getter(name="connectivityType")
    def connectivity_type(self) -> pulumi.Input[str]:
        """
        Specifies the network connectivity types for the GKE nodes and the GKE master network. Possible values are: `PRIVATE_NODE_PUBLIC_MASTER`, `PUBLIC_NODE_PUBLIC_MASTER`.
        """
        return pulumi.get(self, "connectivity_type")

    @connectivity_type.setter
    def connectivity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connectivity_type", value)

    @property
    @pulumi.getter(name="masterIpRange")
    def master_ip_range(self) -> pulumi.Input[str]:
        """
        The IP range from which to allocate GKE cluster master resources. This field will be ignored if GKE private cluster is not enabled. It must be exactly as big as `/28`.
        """
        return pulumi.get(self, "master_ip_range")

    @master_ip_range.setter
    def master_ip_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_ip_range", value)


@pulumi.input_type
class MwsWorkspacesTokenArgs:
    def __init__(__self__, *,
                 comment: Optional[pulumi.Input[str]] = None,
                 lifetime_seconds: Optional[pulumi.Input[int]] = None,
                 token_id: Optional[pulumi.Input[str]] = None,
                 token_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] lifetime_seconds: Token expiry lifetime. By default its 2592000 (30 days).
        """
        MwsWorkspacesTokenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            lifetime_seconds=lifetime_seconds,
            token_id=token_id,
            token_value=token_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: Optional[pulumi.Input[str]] = None,
             lifetime_seconds: Optional[pulumi.Input[int]] = None,
             token_id: Optional[pulumi.Input[str]] = None,
             token_value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if lifetime_seconds is None and 'lifetimeSeconds' in kwargs:
            lifetime_seconds = kwargs['lifetimeSeconds']
        if token_id is None and 'tokenId' in kwargs:
            token_id = kwargs['tokenId']
        if token_value is None and 'tokenValue' in kwargs:
            token_value = kwargs['tokenValue']

        if comment is not None:
            _setter("comment", comment)
        if lifetime_seconds is not None:
            _setter("lifetime_seconds", lifetime_seconds)
        if token_id is not None:
            _setter("token_id", token_id)
        if token_value is not None:
            _setter("token_value", token_value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Token expiry lifetime. By default its 2592000 (30 days).
        """
        return pulumi.get(self, "lifetime_seconds")

    @lifetime_seconds.setter
    def lifetime_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lifetime_seconds", value)

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_id")

    @token_id.setter
    def token_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_id", value)

    @property
    @pulumi.getter(name="tokenValue")
    def token_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_value")

    @token_value.setter
    def token_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_value", value)


@pulumi.input_type
class PermissionsAccessControlArgs:
    def __init__(__self__, *,
                 permission_level: pulumi.Input[str],
                 group_name: Optional[pulumi.Input[str]] = None,
                 service_principal_name: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission_level: permission level according to specific resource. See examples above for the reference.
               
               Exactly one of the below arguments is required:
        :param pulumi.Input[str] group_name: name of the group. We recommend setting permissions on groups.
        :param pulumi.Input[str] service_principal_name: Application ID of the service_principal.
        :param pulumi.Input[str] user_name: name of the user.
        """
        PermissionsAccessControlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permission_level=permission_level,
            group_name=group_name,
            service_principal_name=service_principal_name,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permission_level: Optional[pulumi.Input[str]] = None,
             group_name: Optional[pulumi.Input[str]] = None,
             service_principal_name: Optional[pulumi.Input[str]] = None,
             user_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if permission_level is None and 'permissionLevel' in kwargs:
            permission_level = kwargs['permissionLevel']
        if permission_level is None:
            raise TypeError("Missing 'permission_level' argument")
        if group_name is None and 'groupName' in kwargs:
            group_name = kwargs['groupName']
        if service_principal_name is None and 'servicePrincipalName' in kwargs:
            service_principal_name = kwargs['servicePrincipalName']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        _setter("permission_level", permission_level)
        if group_name is not None:
            _setter("group_name", group_name)
        if service_principal_name is not None:
            _setter("service_principal_name", service_principal_name)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> pulumi.Input[str]:
        """
        permission level according to specific resource. See examples above for the reference.

        Exactly one of the below arguments is required:
        """
        return pulumi.get(self, "permission_level")

    @permission_level.setter
    def permission_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission_level", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the group. We recommend setting permissions on groups.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        Application ID of the service_principal.
        """
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the user.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class PipelineClusterArgs:
    def __init__(__self__, *,
                 apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
                 autoscale: Optional[pulumi.Input['PipelineClusterAutoscaleArgs']] = None,
                 aws_attributes: Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']] = None,
                 azure_attributes: Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']] = None,
                 cluster_log_conf: Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
                 driver_node_type_id: Optional[pulumi.Input[str]] = None,
                 enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
                 gcp_attributes: Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']] = None,
                 init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 node_type_id: Optional[pulumi.Input[str]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        PipelineClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_log_conf=cluster_log_conf,
            custom_tags=custom_tags,
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_local_disk_encryption=enable_local_disk_encryption,
            gcp_attributes=gcp_attributes,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            label=label,
            node_type_id=node_type_id,
            num_workers=num_workers,
            policy_id=policy_id,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apply_policy_default_values: Optional[pulumi.Input[bool]] = None,
             autoscale: Optional[pulumi.Input['PipelineClusterAutoscaleArgs']] = None,
             aws_attributes: Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']] = None,
             azure_attributes: Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']] = None,
             cluster_log_conf: Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']] = None,
             custom_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             driver_instance_pool_id: Optional[pulumi.Input[str]] = None,
             driver_node_type_id: Optional[pulumi.Input[str]] = None,
             enable_local_disk_encryption: Optional[pulumi.Input[bool]] = None,
             gcp_attributes: Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']] = None,
             init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]] = None,
             instance_pool_id: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             node_type_id: Optional[pulumi.Input[str]] = None,
             num_workers: Optional[pulumi.Input[int]] = None,
             policy_id: Optional[pulumi.Input[str]] = None,
             spark_conf: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             spark_env_vars: Optional[pulumi.Input[Mapping[str, Any]]] = None,
             ssh_public_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']

        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if driver_instance_pool_id is not None:
            _setter("driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            _setter("driver_node_type_id", driver_node_type_id)
        if enable_local_disk_encryption is not None:
            _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if label is not None:
            _setter("label", label)
        if node_type_id is not None:
            _setter("node_type_id", node_type_id)
        if num_workers is not None:
            _setter("num_workers", num_workers)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[pulumi.Input['PipelineClusterAutoscaleArgs']]:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional[pulumi.Input['PipelineClusterAutoscaleArgs']]):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']]:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional[pulumi.Input['PipelineClusterAwsAttributesArgs']]):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']]:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional[pulumi.Input['PipelineClusterAzureAttributesArgs']]):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']]:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional[pulumi.Input['PipelineClusterClusterLogConfArgs']]):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']]:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional[pulumi.Input['PipelineClusterGcpAttributesArgs']]):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PipelineClusterInitScriptArgs']]]]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssh_public_keys", value)


@pulumi.input_type
class PipelineClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[pulumi.Input[int]] = None,
                 min_workers: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        PipelineClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[pulumi.Input[int]] = None,
             min_workers: Optional[pulumi.Input[int]] = None,
             mode: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_workers", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class PipelineClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 ebs_volume_count: Optional[pulumi.Input[int]] = None,
                 ebs_volume_size: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 instance_profile_arn: Optional[pulumi.Input[str]] = None,
                 spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        PipelineClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             ebs_volume_count: Optional[pulumi.Input[int]] = None,
             ebs_volume_size: Optional[pulumi.Input[int]] = None,
             ebs_volume_type: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             instance_profile_arn: Optional[pulumi.Input[str]] = None,
             spot_bid_price_percent: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class PipelineClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 first_on_demand: Optional[pulumi.Input[int]] = None,
                 spot_bid_max_price: Optional[pulumi.Input[float]] = None):
        PipelineClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             first_on_demand: Optional[pulumi.Input[int]] = None,
             spot_bid_max_price: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class PipelineClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']] = None,
                 s3: Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']] = None):
        PipelineClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']] = None,
             s3: Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']]:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['PipelineClusterClusterLogConfDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['PipelineClusterClusterLogConfS3Args']]):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class PipelineClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        PipelineClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        PipelineClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class PipelineClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[pulumi.Input[str]] = None,
                 google_service_account: Optional[pulumi.Input[str]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 zone_id: Optional[pulumi.Input[str]] = None):
        PipelineClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[pulumi.Input[str]] = None,
             google_service_account: Optional[pulumi.Input[str]] = None,
             local_ssd_count: Optional[pulumi.Input[int]] = None,
             zone_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class PipelineClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']] = None,
                 dbfs: Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']] = None,
                 file: Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']] = None,
                 gcs: Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']] = None,
                 s3: Optional[pulumi.Input['PipelineClusterInitScriptS3Args']] = None,
                 volumes: Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']] = None,
                 workspace: Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']] = None):
        PipelineClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']] = None,
             dbfs: Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']] = None,
             file: Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']] = None,
             gcs: Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']] = None,
             s3: Optional[pulumi.Input['PipelineClusterInitScriptS3Args']] = None,
             volumes: Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']] = None,
             workspace: Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
            pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']]:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional[pulumi.Input['PipelineClusterInitScriptAbfssArgs']]):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']]:
        warnings.warn("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""", DeprecationWarning)
        pulumi.log.warn("""dbfs is deprecated: For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")

        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional[pulumi.Input['PipelineClusterInitScriptDbfsArgs']]):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['PipelineClusterInitScriptFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']]:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional[pulumi.Input['PipelineClusterInitScriptGcsArgs']]):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['PipelineClusterInitScriptS3Args']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['PipelineClusterInitScriptS3Args']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']]:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input['PipelineClusterInitScriptVolumesArgs']]):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']]:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional[pulumi.Input['PipelineClusterInitScriptWorkspaceArgs']]):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class PipelineClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        PipelineClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str]):
        PipelineClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        PipelineClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        PipelineClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 enable_encryption: Optional[pulumi.Input[bool]] = None,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        PipelineClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             canned_acl: Optional[pulumi.Input[str]] = None,
             enable_encryption: Optional[pulumi.Input[bool]] = None,
             encryption_type: Optional[pulumi.Input[str]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             kms_key: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class PipelineClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        PipelineClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None):
        PipelineClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class PipelineFiltersArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        PipelineFiltersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excludes=excludes,
            includes=includes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excludes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if excludes is not None:
            _setter("excludes", excludes)
        if includes is not None:
            _setter("includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes", value)


@pulumi.input_type
class PipelineLibraryArgs:
    def __init__(__self__, *,
                 file: Optional[pulumi.Input['PipelineLibraryFileArgs']] = None,
                 jar: Optional[pulumi.Input[str]] = None,
                 maven: Optional[pulumi.Input['PipelineLibraryMavenArgs']] = None,
                 notebook: Optional[pulumi.Input['PipelineLibraryNotebookArgs']] = None,
                 whl: Optional[pulumi.Input[str]] = None):
        PipelineLibraryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            jar=jar,
            maven=maven,
            notebook=notebook,
            whl=whl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: Optional[pulumi.Input['PipelineLibraryFileArgs']] = None,
             jar: Optional[pulumi.Input[str]] = None,
             maven: Optional[pulumi.Input['PipelineLibraryMavenArgs']] = None,
             notebook: Optional[pulumi.Input['PipelineLibraryNotebookArgs']] = None,
             whl: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if file is not None:
            _setter("file", file)
        if jar is not None:
            _setter("jar", jar)
        if maven is not None:
            _setter("maven", maven)
        if notebook is not None:
            _setter("notebook", notebook)
        if whl is not None:
            _setter("whl", whl)

    @property
    @pulumi.getter
    def file(self) -> Optional[pulumi.Input['PipelineLibraryFileArgs']]:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional[pulumi.Input['PipelineLibraryFileArgs']]):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional[pulumi.Input['PipelineLibraryMavenArgs']]:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional[pulumi.Input['PipelineLibraryMavenArgs']]):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def notebook(self) -> Optional[pulumi.Input['PipelineLibraryNotebookArgs']]:
        return pulumi.get(self, "notebook")

    @notebook.setter
    def notebook(self, value: Optional[pulumi.Input['PipelineLibraryNotebookArgs']]):
        pulumi.set(self, "notebook", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "whl", value)


@pulumi.input_type
class PipelineLibraryFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        PipelineLibraryFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class PipelineLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        PipelineLibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             repo: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> pulumi.Input[str]:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: pulumi.Input[str]):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class PipelineLibraryNotebookArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        PipelineLibraryNotebookArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class PipelineNotificationArgs:
    def __init__(__self__, *,
                 alerts: pulumi.Input[Sequence[pulumi.Input[str]]],
                 email_recipients: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alerts: non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
               * `on-update-success` - a pipeline update completes successfully.
               * `on-update-failure` - a pipeline update fails with a retryable error.
               * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
               * `on-flow-failure` - a single data flow fails.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_recipients: non-empty list of emails to notify.
        """
        PipelineNotificationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alerts=alerts,
            email_recipients=email_recipients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alerts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             email_recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alerts is None:
            raise TypeError("Missing 'alerts' argument")
        if email_recipients is None and 'emailRecipients' in kwargs:
            email_recipients = kwargs['emailRecipients']
        if email_recipients is None:
            raise TypeError("Missing 'email_recipients' argument")

        _setter("alerts", alerts)
        _setter("email_recipients", email_recipients)

    @property
    @pulumi.getter
    def alerts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
        * `on-update-success` - a pipeline update completes successfully.
        * `on-update-failure` - a pipeline update fails with a retryable error.
        * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
        * `on-flow-failure` - a single data flow fails.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="emailRecipients")
    def email_recipients(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        non-empty list of emails to notify.
        """
        return pulumi.get(self, "email_recipients")

    @email_recipients.setter
    def email_recipients(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "email_recipients", value)


@pulumi.input_type
class RecipientIpAccessListArgs:
    def __init__(__self__, *,
                 allowed_ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_ip_addresses: Allowed IP Addresses in CIDR notation. Limit of 100.
        """
        RecipientIpAccessListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_ip_addresses=allowed_ip_addresses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if allowed_ip_addresses is None and 'allowedIpAddresses' in kwargs:
            allowed_ip_addresses = kwargs['allowedIpAddresses']
        if allowed_ip_addresses is None:
            raise TypeError("Missing 'allowed_ip_addresses' argument")

        _setter("allowed_ip_addresses", allowed_ip_addresses)

    @property
    @pulumi.getter(name="allowedIpAddresses")
    def allowed_ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Allowed IP Addresses in CIDR notation. Limit of 100.
        """
        return pulumi.get(self, "allowed_ip_addresses")

    @allowed_ip_addresses.setter
    def allowed_ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_ip_addresses", value)


@pulumi.input_type
class RecipientTokenArgs:
    def __init__(__self__, *,
                 activation_url: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[int]] = None,
                 created_by: Optional[pulumi.Input[str]] = None,
                 expiration_time: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[int]] = None,
                 updated_by: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] activation_url: Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        :param pulumi.Input[int] created_at: Time at which this recipient Token was created, in epoch milliseconds.
        :param pulumi.Input[str] created_by: Username of recipient token creator.
        :param pulumi.Input[int] expiration_time: Expiration timestamp of the token in epoch milliseconds.
        :param pulumi.Input[str] id: ID of this recipient - same as the `name`.
        :param pulumi.Input[int] updated_at: Time at which this recipient Token was updated, in epoch milliseconds.
        :param pulumi.Input[str] updated_by: Username of recipient Token updater.
        """
        RecipientTokenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            activation_url=activation_url,
            created_at=created_at,
            created_by=created_by,
            expiration_time=expiration_time,
            id=id,
            updated_at=updated_at,
            updated_by=updated_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             activation_url: Optional[pulumi.Input[str]] = None,
             created_at: Optional[pulumi.Input[int]] = None,
             created_by: Optional[pulumi.Input[str]] = None,
             expiration_time: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[str]] = None,
             updated_at: Optional[pulumi.Input[int]] = None,
             updated_by: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if activation_url is None and 'activationUrl' in kwargs:
            activation_url = kwargs['activationUrl']
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if expiration_time is None and 'expirationTime' in kwargs:
            expiration_time = kwargs['expirationTime']
        if updated_at is None and 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']
        if updated_by is None and 'updatedBy' in kwargs:
            updated_by = kwargs['updatedBy']

        if activation_url is not None:
            _setter("activation_url", activation_url)
        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if expiration_time is not None:
            _setter("expiration_time", expiration_time)
        if id is not None:
            _setter("id", id)
        if updated_at is not None:
            _setter("updated_at", updated_at)
        if updated_by is not None:
            _setter("updated_by", updated_by)

    @property
    @pulumi.getter(name="activationUrl")
    def activation_url(self) -> Optional[pulumi.Input[str]]:
        """
        Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        """
        return pulumi.get(self, "activation_url")

    @activation_url.setter
    def activation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "activation_url", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[int]]:
        """
        Time at which this recipient Token was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[str]]:
        """
        Username of recipient token creator.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[int]]:
        """
        Expiration timestamp of the token in epoch milliseconds.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of this recipient - same as the `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[int]]:
        """
        Time at which this recipient Token was updated, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[pulumi.Input[str]]:
        """
        Username of recipient Token updater.
        """
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_by", value)


@pulumi.input_type
class RepoSparseCheckoutArgs:
    def __init__(__self__, *,
                 patterns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        RepoSparseCheckoutArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            patterns=patterns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if patterns is None:
            raise TypeError("Missing 'patterns' argument")

        _setter("patterns", patterns)

    @property
    @pulumi.getter
    def patterns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "patterns", value)


@pulumi.input_type
class SecretScopeKeyvaultMetadataArgs:
    def __init__(__self__, *,
                 dns_name: pulumi.Input[str],
                 resource_id: pulumi.Input[str]):
        SecretScopeKeyvaultMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_name=dns_name,
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_name: Optional[pulumi.Input[str]] = None,
             resource_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if dns_name is None and 'dnsName' in kwargs:
            dns_name = kwargs['dnsName']
        if dns_name is None:
            raise TypeError("Missing 'dns_name' argument")
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']
        if resource_id is None:
            raise TypeError("Missing 'resource_id' argument")

        _setter("dns_name", dns_name)
        _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)


@pulumi.input_type
class ShareObjectArgs:
    def __init__(__self__, *,
                 data_object_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 added_at: Optional[pulumi.Input[int]] = None,
                 added_by: Optional[pulumi.Input[str]] = None,
                 cdf_enabled: Optional[pulumi.Input[bool]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 history_data_sharing_status: Optional[pulumi.Input[str]] = None,
                 partitions: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]] = None,
                 shared_as: Optional[pulumi.Input[str]] = None,
                 start_version: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_object_type: Type of the object, currently only `TABLE` is allowed.
        :param pulumi.Input[str] name: Full name of the object, e.g. `catalog.schema.name` for a table.
        :param pulumi.Input[bool] cdf_enabled: Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        :param pulumi.Input[str] comment: Description about the object.
        :param pulumi.Input[str] history_data_sharing_status: Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.
               
               To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        :param pulumi.Input[str] shared_as: A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        :param pulumi.Input[int] start_version: The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        :param pulumi.Input[str] status: Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        ShareObjectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_object_type=data_object_type,
            name=name,
            added_at=added_at,
            added_by=added_by,
            cdf_enabled=cdf_enabled,
            comment=comment,
            history_data_sharing_status=history_data_sharing_status,
            partitions=partitions,
            shared_as=shared_as,
            start_version=start_version,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_object_type: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             added_at: Optional[pulumi.Input[int]] = None,
             added_by: Optional[pulumi.Input[str]] = None,
             cdf_enabled: Optional[pulumi.Input[bool]] = None,
             comment: Optional[pulumi.Input[str]] = None,
             history_data_sharing_status: Optional[pulumi.Input[str]] = None,
             partitions: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]] = None,
             shared_as: Optional[pulumi.Input[str]] = None,
             start_version: Optional[pulumi.Input[int]] = None,
             status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if data_object_type is None and 'dataObjectType' in kwargs:
            data_object_type = kwargs['dataObjectType']
        if data_object_type is None:
            raise TypeError("Missing 'data_object_type' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if added_at is None and 'addedAt' in kwargs:
            added_at = kwargs['addedAt']
        if added_by is None and 'addedBy' in kwargs:
            added_by = kwargs['addedBy']
        if cdf_enabled is None and 'cdfEnabled' in kwargs:
            cdf_enabled = kwargs['cdfEnabled']
        if history_data_sharing_status is None and 'historyDataSharingStatus' in kwargs:
            history_data_sharing_status = kwargs['historyDataSharingStatus']
        if shared_as is None and 'sharedAs' in kwargs:
            shared_as = kwargs['sharedAs']
        if start_version is None and 'startVersion' in kwargs:
            start_version = kwargs['startVersion']

        _setter("data_object_type", data_object_type)
        _setter("name", name)
        if added_at is not None:
            _setter("added_at", added_at)
        if added_by is not None:
            _setter("added_by", added_by)
        if cdf_enabled is not None:
            _setter("cdf_enabled", cdf_enabled)
        if comment is not None:
            _setter("comment", comment)
        if history_data_sharing_status is not None:
            _setter("history_data_sharing_status", history_data_sharing_status)
        if partitions is not None:
            _setter("partitions", partitions)
        if shared_as is not None:
            _setter("shared_as", shared_as)
        if start_version is not None:
            _setter("start_version", start_version)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="dataObjectType")
    def data_object_type(self) -> pulumi.Input[str]:
        """
        Type of the object, currently only `TABLE` is allowed.
        """
        return pulumi.get(self, "data_object_type")

    @data_object_type.setter
    def data_object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_object_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Full name of the object, e.g. `catalog.schema.name` for a table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "added_at")

    @added_at.setter
    def added_at(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "added_at", value)

    @property
    @pulumi.getter(name="addedBy")
    def added_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "added_by")

    @added_by.setter
    def added_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "added_by", value)

    @property
    @pulumi.getter(name="cdfEnabled")
    def cdf_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        """
        return pulumi.get(self, "cdf_enabled")

    @cdf_enabled.setter
    def cdf_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cdf_enabled", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Description about the object.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="historyDataSharingStatus")
    def history_data_sharing_status(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.

        To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        """
        return pulumi.get(self, "history_data_sharing_status")

    @history_data_sharing_status.setter
    def history_data_sharing_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "history_data_sharing_status", value)

    @property
    @pulumi.getter
    def partitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionArgs']]]]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="sharedAs")
    def shared_as(self) -> Optional[pulumi.Input[str]]:
        """
        A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        """
        return pulumi.get(self, "shared_as")

    @shared_as.setter
    def shared_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_as", value)

    @property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> Optional[pulumi.Input[int]]:
        """
        The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        """
        return pulumi.get(self, "start_version")

    @start_version.setter
    def start_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_version", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class ShareObjectPartitionArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]] values: The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        ShareObjectPartitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]:
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['ShareObjectPartitionValueArgs']]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ShareObjectPartitionValueArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 op: pulumi.Input[str],
                 recipient_property_key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the partition column.
        :param pulumi.Input[str] op: The operator to apply for the value, one of: `EQUAL`, `LIKE`
        :param pulumi.Input[str] recipient_property_key: The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        :param pulumi.Input[str] value: The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        ShareObjectPartitionValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            op=op,
            recipient_property_key=recipient_property_key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             op: Optional[pulumi.Input[str]] = None,
             recipient_property_key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if op is None:
            raise TypeError("Missing 'op' argument")
        if recipient_property_key is None and 'recipientPropertyKey' in kwargs:
            recipient_property_key = kwargs['recipientPropertyKey']

        _setter("name", name)
        _setter("op", op)
        if recipient_property_key is not None:
            _setter("recipient_property_key", recipient_property_key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the partition column.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        The operator to apply for the value, one of: `EQUAL`, `LIKE`
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter(name="recipientPropertyKey")
    def recipient_property_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        """
        return pulumi.get(self, "recipient_property_key")

    @recipient_property_key.setter
    def recipient_property_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recipient_property_key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlAlertOptionsArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[str],
                 op: pulumi.Input[str],
                 value: pulumi.Input[str],
                 custom_body: Optional[pulumi.Input[str]] = None,
                 custom_subject: Optional[pulumi.Input[str]] = None,
                 empty_result_state: Optional[pulumi.Input[str]] = None,
                 muted: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] column: Name of column in the query result to compare in alert evaluation.
        :param pulumi.Input[str] op: Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        :param pulumi.Input[str] value: Value used to compare in alert evaluation.
        :param pulumi.Input[str] custom_body: Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        :param pulumi.Input[str] custom_subject: Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        :param pulumi.Input[str] empty_result_state: State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        :param pulumi.Input[bool] muted: Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
        SqlAlertOptionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            op=op,
            value=value,
            custom_body=custom_body,
            custom_subject=custom_subject,
            empty_result_state=empty_result_state,
            muted=muted,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: Optional[pulumi.Input[str]] = None,
             op: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             custom_body: Optional[pulumi.Input[str]] = None,
             custom_subject: Optional[pulumi.Input[str]] = None,
             empty_result_state: Optional[pulumi.Input[str]] = None,
             muted: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if column is None:
            raise TypeError("Missing 'column' argument")
        if op is None:
            raise TypeError("Missing 'op' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")
        if custom_body is None and 'customBody' in kwargs:
            custom_body = kwargs['customBody']
        if custom_subject is None and 'customSubject' in kwargs:
            custom_subject = kwargs['customSubject']
        if empty_result_state is None and 'emptyResultState' in kwargs:
            empty_result_state = kwargs['emptyResultState']

        _setter("column", column)
        _setter("op", op)
        _setter("value", value)
        if custom_body is not None:
            _setter("custom_body", custom_body)
        if custom_subject is not None:
            _setter("custom_subject", custom_subject)
        if empty_result_state is not None:
            _setter("empty_result_state", empty_result_state)
        if muted is not None:
            _setter("muted", muted)

    @property
    @pulumi.getter
    def column(self) -> pulumi.Input[str]:
        """
        Name of column in the query result to compare in alert evaluation.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value used to compare in alert evaluation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="customBody")
    def custom_body(self) -> Optional[pulumi.Input[str]]:
        """
        Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        return pulumi.get(self, "custom_body")

    @custom_body.setter
    def custom_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_body", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[pulumi.Input[str]]:
        """
        Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[pulumi.Input[str]]:
        """
        State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        """
        return pulumi.get(self, "empty_result_state")

    @empty_result_state.setter
    def empty_result_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "empty_result_state", value)

    @property
    @pulumi.getter
    def muted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
        return pulumi.get(self, "muted")

    @muted.setter
    def muted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "muted", value)


@pulumi.input_type
class SqlEndpointChannelArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        SqlEndpointChannelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SqlEndpointOdbcParamsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 host: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None):
        SqlEndpointOdbcParamsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            port=port,
            protocol=protocol,
            host=host,
            hostname=hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             host: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("path", path)
        _setter("port", port)
        _setter("protocol", protocol)
        if host is not None:
            _setter("host", host)
        if hostname is not None:
            _setter("hostname", hostname)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


@pulumi.input_type
class SqlEndpointTagsArgs:
    def __init__(__self__, *,
                 custom_tags: pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]):
        SqlEndpointTagsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_tags: Optional[pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if custom_tags is None:
            raise TypeError("Missing 'custom_tags' argument")

        _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: pulumi.Input[Sequence[pulumi.Input['SqlEndpointTagsCustomTagArgs']]]):
        pulumi.set(self, "custom_tags", value)


@pulumi.input_type
class SqlEndpointTagsCustomTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        SqlEndpointTagsCustomTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlPermissionsPrivilegeAssignmentArgs:
    def __init__(__self__, *,
                 principal: pulumi.Input[str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] principal: `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] privileges: set of available privilege names in upper case.
               
               [Available](https://docs.databricks.com/security/access-control/table-acls/object-privileges.html) privilege names are:
        """
        SqlPermissionsPrivilegeAssignmentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal=principal,
            privileges=privileges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal: Optional[pulumi.Input[str]] = None,
             privileges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if principal is None:
            raise TypeError("Missing 'principal' argument")
        if privileges is None:
            raise TypeError("Missing 'privileges' argument")

        _setter("principal", principal)
        _setter("privileges", privileges)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[str]:
        """
        `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[str]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        set of available privilege names in upper case.

        [Available](https://docs.databricks.com/security/access-control/table-acls/object-privileges.html) privilege names are:
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "privileges", value)


@pulumi.input_type
class SqlQueryParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 date: Optional[pulumi.Input['SqlQueryParameterDateArgs']] = None,
                 date_range: Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']] = None,
                 datetime: Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']] = None,
                 datetime_range: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']] = None,
                 datetimesec: Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']] = None,
                 datetimesec_range: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']] = None,
                 enum: Optional[pulumi.Input['SqlQueryParameterEnumArgs']] = None,
                 number: Optional[pulumi.Input['SqlQueryParameterNumberArgs']] = None,
                 query: Optional[pulumi.Input['SqlQueryParameterQueryArgs']] = None,
                 text: Optional[pulumi.Input['SqlQueryParameterTextArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The literal parameter marker that appears between double curly braces in the query text.
               Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.
               
               For `text`, `number`, `date`, `datetime`, `datetimesec` block
        :param pulumi.Input['SqlQueryParameterQueryArgs'] query: The text of the query to be run.
        :param pulumi.Input[str] title: The text displayed in a parameter picking widget.
        """
        SqlQueryParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            date=date,
            date_range=date_range,
            datetime=datetime,
            datetime_range=datetime_range,
            datetimesec=datetimesec,
            datetimesec_range=datetimesec_range,
            enum=enum,
            number=number,
            query=query,
            text=text,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             date: Optional[pulumi.Input['SqlQueryParameterDateArgs']] = None,
             date_range: Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']] = None,
             datetime: Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']] = None,
             datetime_range: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']] = None,
             datetimesec: Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']] = None,
             datetimesec_range: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']] = None,
             enum: Optional[pulumi.Input['SqlQueryParameterEnumArgs']] = None,
             number: Optional[pulumi.Input['SqlQueryParameterNumberArgs']] = None,
             query: Optional[pulumi.Input['SqlQueryParameterQueryArgs']] = None,
             text: Optional[pulumi.Input['SqlQueryParameterTextArgs']] = None,
             title: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if date_range is None and 'dateRange' in kwargs:
            date_range = kwargs['dateRange']
        if datetime_range is None and 'datetimeRange' in kwargs:
            datetime_range = kwargs['datetimeRange']
        if datetimesec_range is None and 'datetimesecRange' in kwargs:
            datetimesec_range = kwargs['datetimesecRange']

        _setter("name", name)
        if date is not None:
            _setter("date", date)
        if date_range is not None:
            _setter("date_range", date_range)
        if datetime is not None:
            _setter("datetime", datetime)
        if datetime_range is not None:
            _setter("datetime_range", datetime_range)
        if datetimesec is not None:
            _setter("datetimesec", datetimesec)
        if datetimesec_range is not None:
            _setter("datetimesec_range", datetimesec_range)
        if enum is not None:
            _setter("enum", enum)
        if number is not None:
            _setter("number", number)
        if query is not None:
            _setter("query", query)
        if text is not None:
            _setter("text", text)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The literal parameter marker that appears between double curly braces in the query text.
        Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.

        For `text`, `number`, `date`, `datetime`, `datetimesec` block
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input['SqlQueryParameterDateArgs']]:
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input['SqlQueryParameterDateArgs']]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']]:
        return pulumi.get(self, "date_range")

    @date_range.setter
    def date_range(self, value: Optional[pulumi.Input['SqlQueryParameterDateRangeArgs']]):
        pulumi.set(self, "date_range", value)

    @property
    @pulumi.getter
    def datetime(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']]:
        return pulumi.get(self, "datetime")

    @datetime.setter
    def datetime(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimeArgs']]):
        pulumi.set(self, "datetime", value)

    @property
    @pulumi.getter(name="datetimeRange")
    def datetime_range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']]:
        return pulumi.get(self, "datetime_range")

    @datetime_range.setter
    def datetime_range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeArgs']]):
        pulumi.set(self, "datetime_range", value)

    @property
    @pulumi.getter
    def datetimesec(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']]:
        return pulumi.get(self, "datetimesec")

    @datetimesec.setter
    def datetimesec(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimesecArgs']]):
        pulumi.set(self, "datetimesec", value)

    @property
    @pulumi.getter(name="datetimesecRange")
    def datetimesec_range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']]:
        return pulumi.get(self, "datetimesec_range")

    @datetimesec_range.setter
    def datetimesec_range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeArgs']]):
        pulumi.set(self, "datetimesec_range", value)

    @property
    @pulumi.getter
    def enum(self) -> Optional[pulumi.Input['SqlQueryParameterEnumArgs']]:
        return pulumi.get(self, "enum")

    @enum.setter
    def enum(self, value: Optional[pulumi.Input['SqlQueryParameterEnumArgs']]):
        pulumi.set(self, "enum", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input['SqlQueryParameterNumberArgs']]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input['SqlQueryParameterNumberArgs']]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input['SqlQueryParameterQueryArgs']]:
        """
        The text of the query to be run.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input['SqlQueryParameterQueryArgs']]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['SqlQueryParameterTextArgs']]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['SqlQueryParameterTextArgs']]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The text displayed in a parameter picking widget.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class SqlQueryParameterDateArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterDateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterDateRangeArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterDateRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if range is not None:
            _setter("range", range)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['SqlQueryParameterDateRangeRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterDateRangeRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        SqlQueryParameterDateRangeRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[pulumi.Input[str]] = None,
             start: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class SqlQueryParameterDatetimeArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterDatetimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterDatetimeRangeArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterDatetimeRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if range is not None:
            _setter("range", range)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimeRangeRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterDatetimeRangeRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        SqlQueryParameterDatetimeRangeRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[pulumi.Input[str]] = None,
             start: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class SqlQueryParameterDatetimesecArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterDatetimesecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterDatetimesecRangeArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterDatetimesecRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            range=range,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             range: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if range is not None:
            _setter("range", range)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['SqlQueryParameterDatetimesecRangeRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterDatetimesecRangeRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[str],
                 start: pulumi.Input[str]):
        SqlQueryParameterDatetimesecRangeRangeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[pulumi.Input[str]] = None,
             start: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if end is None:
            raise TypeError("Missing 'end' argument")
        if start is None:
            raise TypeError("Missing 'start' argument")

        _setter("end", end)
        _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class SqlQueryParameterEnumArgs:
    def __init__(__self__, *,
                 options: pulumi.Input[Sequence[pulumi.Input[str]]],
                 multiple: Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterEnumArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            options=options,
            multiple=multiple,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             multiple: Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']] = None,
             value: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if options is None:
            raise TypeError("Missing 'options' argument")

        _setter("options", options)
        if multiple is not None:
            _setter("multiple", multiple)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def multiple(self) -> Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']]:
        return pulumi.get(self, "multiple")

    @multiple.setter
    def multiple(self, value: Optional[pulumi.Input['SqlQueryParameterEnumMultipleArgs']]):
        pulumi.set(self, "multiple", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class SqlQueryParameterEnumMultipleArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[str],
                 separator: pulumi.Input[str],
                 suffix: pulumi.Input[str]):
        SqlQueryParameterEnumMultipleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            separator=separator,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[pulumi.Input[str]] = None,
             separator: Optional[pulumi.Input[str]] = None,
             suffix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if separator is None:
            raise TypeError("Missing 'separator' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("prefix", prefix)
        _setter("separator", separator)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def separator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: pulumi.Input[str]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[str]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[str]):
        pulumi.set(self, "suffix", value)


@pulumi.input_type
class SqlQueryParameterNumberArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        """
        :param pulumi.Input[float] value: The default value for this parameter.
        """
        SqlQueryParameterNumberArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryParameterQueryArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str],
                 multiple: Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterQueryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_id=query_id,
            multiple=multiple,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_id: Optional[pulumi.Input[str]] = None,
             multiple: Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']] = None,
             value: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_id is None:
            raise TypeError("Missing 'query_id' argument")

        _setter("query_id", query_id)
        if multiple is not None:
            _setter("multiple", multiple)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)

    @property
    @pulumi.getter
    def multiple(self) -> Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']]:
        return pulumi.get(self, "multiple")

    @multiple.setter
    def multiple(self, value: Optional[pulumi.Input['SqlQueryParameterQueryMultipleArgs']]):
        pulumi.set(self, "multiple", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class SqlQueryParameterQueryMultipleArgs:
    def __init__(__self__, *,
                 prefix: pulumi.Input[str],
                 separator: pulumi.Input[str],
                 suffix: pulumi.Input[str]):
        SqlQueryParameterQueryMultipleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            separator=separator,
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[pulumi.Input[str]] = None,
             separator: Optional[pulumi.Input[str]] = None,
             suffix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if prefix is None:
            raise TypeError("Missing 'prefix' argument")
        if separator is None:
            raise TypeError("Missing 'separator' argument")
        if suffix is None:
            raise TypeError("Missing 'suffix' argument")

        _setter("prefix", prefix)
        _setter("separator", separator)
        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[str]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def separator(self) -> pulumi.Input[str]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: pulumi.Input[str]):
        pulumi.set(self, "separator", value)

    @property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[str]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[str]):
        pulumi.set(self, "suffix", value)


@pulumi.input_type
class SqlQueryParameterTextArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The default value for this parameter.
        """
        SqlQueryParameterTextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SqlQueryScheduleArgs:
    def __init__(__self__, *,
                 continuous: Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']] = None,
                 daily: Optional[pulumi.Input['SqlQueryScheduleDailyArgs']] = None,
                 weekly: Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']] = None):
        SqlQueryScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            continuous=continuous,
            daily=daily,
            weekly=weekly,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             continuous: Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']] = None,
             daily: Optional[pulumi.Input['SqlQueryScheduleDailyArgs']] = None,
             weekly: Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if continuous is not None:
            _setter("continuous", continuous)
        if daily is not None:
            _setter("daily", daily)
        if weekly is not None:
            _setter("weekly", weekly)

    @property
    @pulumi.getter
    def continuous(self) -> Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']]:
        return pulumi.get(self, "continuous")

    @continuous.setter
    def continuous(self, value: Optional[pulumi.Input['SqlQueryScheduleContinuousArgs']]):
        pulumi.set(self, "continuous", value)

    @property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['SqlQueryScheduleDailyArgs']]:
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['SqlQueryScheduleDailyArgs']]):
        pulumi.set(self, "daily", value)

    @property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']]:
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['SqlQueryScheduleWeeklyArgs']]):
        pulumi.set(self, "weekly", value)


@pulumi.input_type
class SqlQueryScheduleContinuousArgs:
    def __init__(__self__, *,
                 interval_seconds: pulumi.Input[int],
                 until_date: Optional[pulumi.Input[str]] = None):
        SqlQueryScheduleContinuousArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval_seconds=interval_seconds,
            until_date=until_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval_seconds: Optional[pulumi.Input[int]] = None,
             until_date: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if interval_seconds is None and 'intervalSeconds' in kwargs:
            interval_seconds = kwargs['intervalSeconds']
        if interval_seconds is None:
            raise TypeError("Missing 'interval_seconds' argument")
        if until_date is None and 'untilDate' in kwargs:
            until_date = kwargs['untilDate']

        _setter("interval_seconds", interval_seconds)
        if until_date is not None:
            _setter("until_date", until_date)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> pulumi.Input[int]:
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_seconds", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "until_date", value)


@pulumi.input_type
class SqlQueryScheduleDailyArgs:
    def __init__(__self__, *,
                 interval_days: pulumi.Input[int],
                 time_of_day: pulumi.Input[str],
                 until_date: Optional[pulumi.Input[str]] = None):
        SqlQueryScheduleDailyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval_days=interval_days,
            time_of_day=time_of_day,
            until_date=until_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval_days: Optional[pulumi.Input[int]] = None,
             time_of_day: Optional[pulumi.Input[str]] = None,
             until_date: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if interval_days is None and 'intervalDays' in kwargs:
            interval_days = kwargs['intervalDays']
        if interval_days is None:
            raise TypeError("Missing 'interval_days' argument")
        if time_of_day is None and 'timeOfDay' in kwargs:
            time_of_day = kwargs['timeOfDay']
        if time_of_day is None:
            raise TypeError("Missing 'time_of_day' argument")
        if until_date is None and 'untilDate' in kwargs:
            until_date = kwargs['untilDate']

        _setter("interval_days", interval_days)
        _setter("time_of_day", time_of_day)
        if until_date is not None:
            _setter("until_date", until_date)

    @property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> pulumi.Input[int]:
        return pulumi.get(self, "interval_days")

    @interval_days.setter
    def interval_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_days", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_of_day", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "until_date", value)


@pulumi.input_type
class SqlQueryScheduleWeeklyArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[str],
                 interval_weeks: pulumi.Input[int],
                 time_of_day: pulumi.Input[str],
                 until_date: Optional[pulumi.Input[str]] = None):
        SqlQueryScheduleWeeklyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_week=day_of_week,
            interval_weeks=interval_weeks,
            time_of_day=time_of_day,
            until_date=until_date,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_week: Optional[pulumi.Input[str]] = None,
             interval_weeks: Optional[pulumi.Input[int]] = None,
             time_of_day: Optional[pulumi.Input[str]] = None,
             until_date: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if day_of_week is None and 'dayOfWeek' in kwargs:
            day_of_week = kwargs['dayOfWeek']
        if day_of_week is None:
            raise TypeError("Missing 'day_of_week' argument")
        if interval_weeks is None and 'intervalWeeks' in kwargs:
            interval_weeks = kwargs['intervalWeeks']
        if interval_weeks is None:
            raise TypeError("Missing 'interval_weeks' argument")
        if time_of_day is None and 'timeOfDay' in kwargs:
            time_of_day = kwargs['timeOfDay']
        if time_of_day is None:
            raise TypeError("Missing 'time_of_day' argument")
        if until_date is None and 'untilDate' in kwargs:
            until_date = kwargs['untilDate']

        _setter("day_of_week", day_of_week)
        _setter("interval_weeks", interval_weeks)
        _setter("time_of_day", time_of_day)
        if until_date is not None:
            _setter("until_date", until_date)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[str]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="intervalWeeks")
    def interval_weeks(self) -> pulumi.Input[int]:
        return pulumi.get(self, "interval_weeks")

    @interval_weeks.setter
    def interval_weeks(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval_weeks", value)

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_of_day", value)

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "until_date")

    @until_date.setter
    def until_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "until_date", value)


@pulumi.input_type
class SqlTableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 comment: Optional[pulumi.Input[str]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: User-visible name of column
        :param pulumi.Input[str] comment: User-supplied free-form text.
        :param pulumi.Input[bool] nullable: Whether field is nullable (Default: `true`)
        :param pulumi.Input[str] type: Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        SqlTableColumnArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            comment=comment,
            nullable=nullable,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             comment: Optional[pulumi.Input[str]] = None,
             nullable: Optional[pulumi.Input[bool]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("name", name)
        if comment is not None:
            _setter("comment", comment)
        if nullable is not None:
            _setter("nullable", nullable)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        User-visible name of column
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        User-supplied free-form text.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether field is nullable (Default: `true`)
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SqlWidgetParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 map_to: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        SqlWidgetParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            map_to=map_to,
            title=title,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             map_to: Optional[pulumi.Input[str]] = None,
             title: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if map_to is None and 'mapTo' in kwargs:
            map_to = kwargs['mapTo']

        _setter("name", name)
        _setter("type", type)
        if map_to is not None:
            _setter("map_to", map_to)
        if title is not None:
            _setter("title", title)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mapTo")
    def map_to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "map_to")

    @map_to.setter
    def map_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "map_to", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class SqlWidgetPositionArgs:
    def __init__(__self__, *,
                 size_x: pulumi.Input[int],
                 size_y: pulumi.Input[int],
                 auto_height: Optional[pulumi.Input[bool]] = None,
                 pos_x: Optional[pulumi.Input[int]] = None,
                 pos_y: Optional[pulumi.Input[int]] = None):
        SqlWidgetPositionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_x=size_x,
            size_y=size_y,
            auto_height=auto_height,
            pos_x=pos_x,
            pos_y=pos_y,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_x: Optional[pulumi.Input[int]] = None,
             size_y: Optional[pulumi.Input[int]] = None,
             auto_height: Optional[pulumi.Input[bool]] = None,
             pos_x: Optional[pulumi.Input[int]] = None,
             pos_y: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if size_x is None and 'sizeX' in kwargs:
            size_x = kwargs['sizeX']
        if size_x is None:
            raise TypeError("Missing 'size_x' argument")
        if size_y is None and 'sizeY' in kwargs:
            size_y = kwargs['sizeY']
        if size_y is None:
            raise TypeError("Missing 'size_y' argument")
        if auto_height is None and 'autoHeight' in kwargs:
            auto_height = kwargs['autoHeight']
        if pos_x is None and 'posX' in kwargs:
            pos_x = kwargs['posX']
        if pos_y is None and 'posY' in kwargs:
            pos_y = kwargs['posY']

        _setter("size_x", size_x)
        _setter("size_y", size_y)
        if auto_height is not None:
            _setter("auto_height", auto_height)
        if pos_x is not None:
            _setter("pos_x", pos_x)
        if pos_y is not None:
            _setter("pos_y", pos_y)

    @property
    @pulumi.getter(name="sizeX")
    def size_x(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_x")

    @size_x.setter
    def size_x(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_x", value)

    @property
    @pulumi.getter(name="sizeY")
    def size_y(self) -> pulumi.Input[int]:
        return pulumi.get(self, "size_y")

    @size_y.setter
    def size_y(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_y", value)

    @property
    @pulumi.getter(name="autoHeight")
    def auto_height(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "auto_height")

    @auto_height.setter
    def auto_height(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_height", value)

    @property
    @pulumi.getter(name="posX")
    def pos_x(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pos_x")

    @pos_x.setter
    def pos_x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pos_x", value)

    @property
    @pulumi.getter(name="posY")
    def pos_y(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "pos_y")

    @pos_y.setter
    def pos_y(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pos_y", value)


@pulumi.input_type
class StorageCredentialAwsIamRoleArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
               
               `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        """
        StorageCredentialAwsIamRoleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if role_arn is None:
            raise TypeError("Missing 'role_arn' argument")

        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`

        `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


@pulumi.input_type
class StorageCredentialAzureManagedIdentityArgs:
    def __init__(__self__, *,
                 access_connector_id: pulumi.Input[str],
                 credential_id: Optional[pulumi.Input[str]] = None,
                 managed_identity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param pulumi.Input[str] managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
               
               `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        StorageCredentialAzureManagedIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_connector_id=access_connector_id,
            credential_id=credential_id,
            managed_identity_id=managed_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_connector_id: Optional[pulumi.Input[str]] = None,
             credential_id: Optional[pulumi.Input[str]] = None,
             managed_identity_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if access_connector_id is None and 'accessConnectorId' in kwargs:
            access_connector_id = kwargs['accessConnectorId']
        if access_connector_id is None:
            raise TypeError("Missing 'access_connector_id' argument")
        if credential_id is None and 'credentialId' in kwargs:
            credential_id = kwargs['credentialId']
        if managed_identity_id is None and 'managedIdentityId' in kwargs:
            managed_identity_id = kwargs['managedIdentityId']

        _setter("access_connector_id", access_connector_id)
        if credential_id is not None:
            _setter("credential_id", credential_id)
        if managed_identity_id is not None:
            _setter("managed_identity_id", managed_identity_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> pulumi.Input[str]:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @access_connector_id.setter
    def access_connector_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_connector_id", value)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.

        `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        return pulumi.get(self, "managed_identity_id")

    @managed_identity_id.setter
    def managed_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_identity_id", value)


@pulumi.input_type
class StorageCredentialAzureServicePrincipalArgs:
    def __init__(__self__, *,
                 application_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 directory_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] application_id: The application ID of the application registration within the referenced AAD tenant
        :param pulumi.Input[str] client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
        :param pulumi.Input[str] directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        StorageCredentialAzureServicePrincipalArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            client_secret=client_secret,
            directory_id=directory_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             directory_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if application_id is None and 'applicationId' in kwargs:
            application_id = kwargs['applicationId']
        if application_id is None:
            raise TypeError("Missing 'application_id' argument")
        if client_secret is None and 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if client_secret is None:
            raise TypeError("Missing 'client_secret' argument")
        if directory_id is None and 'directoryId' in kwargs:
            directory_id = kwargs['directoryId']
        if directory_id is None:
            raise TypeError("Missing 'directory_id' argument")

        _setter("application_id", application_id)
        _setter("client_secret", client_secret)
        _setter("directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> pulumi.Input[str]:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> pulumi.Input[str]:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "directory_id", value)


@pulumi.input_type
class StorageCredentialDatabricksGcpServiceAccountArgs:
    def __init__(__self__, *,
                 credential_id: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: The email of the GCP service account created, to be granted access to relevant buckets.
        """
        StorageCredentialDatabricksGcpServiceAccountArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credential_id=credential_id,
            email=email,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credential_id: Optional[pulumi.Input[str]] = None,
             email: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if credential_id is None and 'credentialId' in kwargs:
            credential_id = kwargs['credentialId']

        if credential_id is not None:
            _setter("credential_id", credential_id)
        if email is not None:
            _setter("email", email)

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_id")

    @credential_id.setter
    def credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_id", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class StorageCredentialGcpServiceAccountKeyArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 private_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the GCP service account created, to be granted access to relevant buckets.
        """
        StorageCredentialGcpServiceAccountKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            private_key=private_key,
            private_key_id=private_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[pulumi.Input[str]] = None,
             private_key: Optional[pulumi.Input[str]] = None,
             private_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if email is None:
            raise TypeError("Missing 'email' argument")
        if private_key is None and 'privateKey' in kwargs:
            private_key = kwargs['privateKey']
        if private_key is None:
            raise TypeError("Missing 'private_key' argument")
        if private_key_id is None and 'privateKeyId' in kwargs:
            private_key_id = kwargs['privateKeyId']
        if private_key_id is None:
            raise TypeError("Missing 'private_key_id' argument")

        _setter("email", email)
        _setter("private_key", private_key)
        _setter("private_key_id", private_key_id)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_id", value)


@pulumi.input_type
class TableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 position: pulumi.Input[int],
                 type_name: pulumi.Input[str],
                 type_text: pulumi.Input[str],
                 comment: Optional[pulumi.Input[str]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 partition_index: Optional[pulumi.Input[int]] = None,
                 type_interval_type: Optional[pulumi.Input[str]] = None,
                 type_json: Optional[pulumi.Input[str]] = None,
                 type_precision: Optional[pulumi.Input[int]] = None,
                 type_scale: Optional[pulumi.Input[int]] = None):
        TableColumnArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            position=position,
            type_name=type_name,
            type_text=type_text,
            comment=comment,
            nullable=nullable,
            partition_index=partition_index,
            type_interval_type=type_interval_type,
            type_json=type_json,
            type_precision=type_precision,
            type_scale=type_scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             position: Optional[pulumi.Input[int]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             type_text: Optional[pulumi.Input[str]] = None,
             comment: Optional[pulumi.Input[str]] = None,
             nullable: Optional[pulumi.Input[bool]] = None,
             partition_index: Optional[pulumi.Input[int]] = None,
             type_interval_type: Optional[pulumi.Input[str]] = None,
             type_json: Optional[pulumi.Input[str]] = None,
             type_precision: Optional[pulumi.Input[int]] = None,
             type_scale: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if position is None:
            raise TypeError("Missing 'position' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if type_text is None and 'typeText' in kwargs:
            type_text = kwargs['typeText']
        if type_text is None:
            raise TypeError("Missing 'type_text' argument")
        if partition_index is None and 'partitionIndex' in kwargs:
            partition_index = kwargs['partitionIndex']
        if type_interval_type is None and 'typeIntervalType' in kwargs:
            type_interval_type = kwargs['typeIntervalType']
        if type_json is None and 'typeJson' in kwargs:
            type_json = kwargs['typeJson']
        if type_precision is None and 'typePrecision' in kwargs:
            type_precision = kwargs['typePrecision']
        if type_scale is None and 'typeScale' in kwargs:
            type_scale = kwargs['typeScale']

        _setter("name", name)
        _setter("position", position)
        _setter("type_name", type_name)
        _setter("type_text", type_text)
        if comment is not None:
            _setter("comment", comment)
        if nullable is not None:
            _setter("nullable", nullable)
        if partition_index is not None:
            _setter("partition_index", partition_index)
        if type_interval_type is not None:
            _setter("type_interval_type", type_interval_type)
        if type_json is not None:
            _setter("type_json", type_json)
        if type_precision is not None:
            _setter("type_precision", type_precision)
        if type_scale is not None:
            _setter("type_scale", type_scale)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def position(self) -> pulumi.Input[int]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: pulumi.Input[int]):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="typeText")
    def type_text(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_text")

    @type_text.setter
    def type_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_text", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="partitionIndex")
    def partition_index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "partition_index")

    @partition_index.setter
    def partition_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_index", value)

    @property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type_interval_type")

    @type_interval_type.setter
    def type_interval_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_interval_type", value)

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type_json")

    @type_json.setter
    def type_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_json", value)

    @property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "type_precision")

    @type_precision.setter
    def type_precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type_precision", value)

    @property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "type_scale")

    @type_scale.setter
    def type_scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type_scale", value)


@pulumi.input_type
class GetClusterClusterInfoArgs:
    def __init__(__self__, *,
                 default_tags: Mapping[str, Any],
                 driver_instance_pool_id: str,
                 spark_version: str,
                 state: str,
                 autoscale: Optional['GetClusterClusterInfoAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetClusterClusterInfoAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetClusterClusterInfoAzureAttributesArgs'] = None,
                 cluster_cores: Optional[float] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetClusterClusterInfoClusterLogConfArgs'] = None,
                 cluster_log_status: Optional['GetClusterClusterInfoClusterLogStatusArgs'] = None,
                 cluster_memory_mb: Optional[int] = None,
                 cluster_name: Optional[str] = None,
                 cluster_source: Optional[str] = None,
                 creator_user_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetClusterClusterInfoDockerImageArgs'] = None,
                 driver: Optional['GetClusterClusterInfoDriverArgs'] = None,
                 driver_node_type_id: Optional[str] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 enable_local_disk_encryption: Optional[bool] = None,
                 executors: Optional[Sequence['GetClusterClusterInfoExecutorArgs']] = None,
                 gcp_attributes: Optional['GetClusterClusterInfoGcpAttributesArgs'] = None,
                 init_scripts: Optional[Sequence['GetClusterClusterInfoInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 jdbc_port: Optional[int] = None,
                 last_activity_time: Optional[int] = None,
                 last_state_loss_time: Optional[int] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_context_id: Optional[int] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 start_time: Optional[int] = None,
                 state_message: Optional[str] = None,
                 terminate_time: Optional[int] = None,
                 termination_reason: Optional['GetClusterClusterInfoTerminationReasonArgs'] = None):
        """
        :param str driver_instance_pool_id: similar to `instance_pool_id`, but for driver node.
        :param str spark_version: [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        :param int autotermination_minutes: Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        :param str cluster_id: The id of the cluster
        :param str cluster_name: The exact name of the cluster to search
        :param Mapping[str, Any] custom_tags: Additional tags for cluster resources.
        :param str data_security_mode: Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        :param str driver_node_type_id: The node type of the Spark driver.
        :param bool enable_elastic_disk: Use autoscaling local storage.
        :param bool enable_local_disk_encryption: Enable local disk encryption.
        :param str instance_pool_id: The pool of idle instances the cluster is attached to.
        :param str node_type_id: Any supported get_node_type id.
        :param str policy_id: Identifier of Cluster Policy to validate cluster and preset certain defaults.
        :param str runtime_engine: The type of runtime of the cluster
        :param str single_user_name: The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        :param Mapping[str, Any] spark_conf: Map with key-value pairs to fine-tune Spark clusters.
        :param Mapping[str, Any] spark_env_vars: Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        :param Sequence[str] ssh_public_keys: SSH public key contents that will be added to each Spark node in this cluster.
        """
        GetClusterClusterInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_tags=default_tags,
            driver_instance_pool_id=driver_instance_pool_id,
            spark_version=spark_version,
            state=state,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_cores=cluster_cores,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_log_status=cluster_log_status,
            cluster_memory_mb=cluster_memory_mb,
            cluster_name=cluster_name,
            cluster_source=cluster_source,
            creator_user_name=creator_user_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            driver=driver,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            executors=executors,
            gcp_attributes=gcp_attributes,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            jdbc_port=jdbc_port,
            last_activity_time=last_activity_time,
            last_state_loss_time=last_state_loss_time,
            node_type_id=node_type_id,
            num_workers=num_workers,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_context_id=spark_context_id,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            start_time=start_time,
            state_message=state_message,
            terminate_time=terminate_time,
            termination_reason=termination_reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_tags: Optional[Mapping[str, Any]] = None,
             driver_instance_pool_id: Optional[str] = None,
             spark_version: Optional[str] = None,
             state: Optional[str] = None,
             autoscale: Optional['GetClusterClusterInfoAutoscaleArgs'] = None,
             autotermination_minutes: Optional[int] = None,
             aws_attributes: Optional['GetClusterClusterInfoAwsAttributesArgs'] = None,
             azure_attributes: Optional['GetClusterClusterInfoAzureAttributesArgs'] = None,
             cluster_cores: Optional[float] = None,
             cluster_id: Optional[str] = None,
             cluster_log_conf: Optional['GetClusterClusterInfoClusterLogConfArgs'] = None,
             cluster_log_status: Optional['GetClusterClusterInfoClusterLogStatusArgs'] = None,
             cluster_memory_mb: Optional[int] = None,
             cluster_name: Optional[str] = None,
             cluster_source: Optional[str] = None,
             creator_user_name: Optional[str] = None,
             custom_tags: Optional[Mapping[str, Any]] = None,
             data_security_mode: Optional[str] = None,
             docker_image: Optional['GetClusterClusterInfoDockerImageArgs'] = None,
             driver: Optional['GetClusterClusterInfoDriverArgs'] = None,
             driver_node_type_id: Optional[str] = None,
             enable_elastic_disk: Optional[bool] = None,
             enable_local_disk_encryption: Optional[bool] = None,
             executors: Optional[Sequence['GetClusterClusterInfoExecutorArgs']] = None,
             gcp_attributes: Optional['GetClusterClusterInfoGcpAttributesArgs'] = None,
             init_scripts: Optional[Sequence['GetClusterClusterInfoInitScriptArgs']] = None,
             instance_pool_id: Optional[str] = None,
             jdbc_port: Optional[int] = None,
             last_activity_time: Optional[int] = None,
             last_state_loss_time: Optional[int] = None,
             node_type_id: Optional[str] = None,
             num_workers: Optional[int] = None,
             policy_id: Optional[str] = None,
             runtime_engine: Optional[str] = None,
             single_user_name: Optional[str] = None,
             spark_conf: Optional[Mapping[str, Any]] = None,
             spark_context_id: Optional[int] = None,
             spark_env_vars: Optional[Mapping[str, Any]] = None,
             ssh_public_keys: Optional[Sequence[str]] = None,
             start_time: Optional[int] = None,
             state_message: Optional[str] = None,
             terminate_time: Optional[int] = None,
             termination_reason: Optional['GetClusterClusterInfoTerminationReasonArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if default_tags is None and 'defaultTags' in kwargs:
            default_tags = kwargs['defaultTags']
        if default_tags is None:
            raise TypeError("Missing 'default_tags' argument")
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_instance_pool_id is None:
            raise TypeError("Missing 'driver_instance_pool_id' argument")
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_cores is None and 'clusterCores' in kwargs:
            cluster_cores = kwargs['clusterCores']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_log_status is None and 'clusterLogStatus' in kwargs:
            cluster_log_status = kwargs['clusterLogStatus']
        if cluster_memory_mb is None and 'clusterMemoryMb' in kwargs:
            cluster_memory_mb = kwargs['clusterMemoryMb']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if cluster_source is None and 'clusterSource' in kwargs:
            cluster_source = kwargs['clusterSource']
        if creator_user_name is None and 'creatorUserName' in kwargs:
            creator_user_name = kwargs['creatorUserName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if jdbc_port is None and 'jdbcPort' in kwargs:
            jdbc_port = kwargs['jdbcPort']
        if last_activity_time is None and 'lastActivityTime' in kwargs:
            last_activity_time = kwargs['lastActivityTime']
        if last_state_loss_time is None and 'lastStateLossTime' in kwargs:
            last_state_loss_time = kwargs['lastStateLossTime']
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_context_id is None and 'sparkContextId' in kwargs:
            spark_context_id = kwargs['sparkContextId']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']
        if state_message is None and 'stateMessage' in kwargs:
            state_message = kwargs['stateMessage']
        if terminate_time is None and 'terminateTime' in kwargs:
            terminate_time = kwargs['terminateTime']
        if termination_reason is None and 'terminationReason' in kwargs:
            termination_reason = kwargs['terminationReason']

        _setter("default_tags", default_tags)
        _setter("driver_instance_pool_id", driver_instance_pool_id)
        _setter("spark_version", spark_version)
        _setter("state", state)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_cores is not None:
            _setter("cluster_cores", cluster_cores)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_log_status is not None:
            _setter("cluster_log_status", cluster_log_status)
        if cluster_memory_mb is not None:
            _setter("cluster_memory_mb", cluster_memory_mb)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if cluster_source is not None:
            _setter("cluster_source", cluster_source)
        if creator_user_name is not None:
            _setter("creator_user_name", creator_user_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if driver is not None:
            _setter("driver", driver)
        if driver_node_type_id is not None:
            _setter("driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            _setter("enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        if executors is not None:
            _setter("executors", executors)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if jdbc_port is not None:
            _setter("jdbc_port", jdbc_port)
        if last_activity_time is not None:
            _setter("last_activity_time", last_activity_time)
        if last_state_loss_time is not None:
            _setter("last_state_loss_time", last_state_loss_time)
        if node_type_id is not None:
            _setter("node_type_id", node_type_id)
        if num_workers is not None:
            _setter("num_workers", num_workers)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_context_id is not None:
            _setter("spark_context_id", spark_context_id)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if start_time is not None:
            _setter("start_time", start_time)
        if state_message is not None:
            _setter("state_message", state_message)
        if terminate_time is not None:
            _setter("terminate_time", terminate_time)
        if termination_reason is not None:
            _setter("termination_reason", termination_reason)

    @property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "default_tags")

    @default_tags.setter
    def default_tags(self, value: Mapping[str, Any]):
        pulumi.set(self, "default_tags", value)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        """
        similar to `instance_pool_id`, but for driver node.
        """
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: str):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetClusterClusterInfoAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetClusterClusterInfoAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        """
        Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        """
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetClusterClusterInfoAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetClusterClusterInfoAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetClusterClusterInfoAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetClusterClusterInfoAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterCores")
    def cluster_cores(self) -> Optional[float]:
        return pulumi.get(self, "cluster_cores")

    @cluster_cores.setter
    def cluster_cores(self, value: Optional[float]):
        pulumi.set(self, "cluster_cores", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The id of the cluster
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetClusterClusterInfoClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetClusterClusterInfoClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterLogStatus")
    def cluster_log_status(self) -> Optional['GetClusterClusterInfoClusterLogStatusArgs']:
        return pulumi.get(self, "cluster_log_status")

    @cluster_log_status.setter
    def cluster_log_status(self, value: Optional['GetClusterClusterInfoClusterLogStatusArgs']):
        pulumi.set(self, "cluster_log_status", value)

    @property
    @pulumi.getter(name="clusterMemoryMb")
    def cluster_memory_mb(self) -> Optional[int]:
        return pulumi.get(self, "cluster_memory_mb")

    @cluster_memory_mb.setter
    def cluster_memory_mb(self, value: Optional[int]):
        pulumi.set(self, "cluster_memory_mb", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        The exact name of the cluster to search
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterSource")
    def cluster_source(self) -> Optional[str]:
        return pulumi.get(self, "cluster_source")

    @cluster_source.setter
    def cluster_source(self, value: Optional[str]):
        pulumi.set(self, "cluster_source", value)

    @property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[str]:
        return pulumi.get(self, "creator_user_name")

    @creator_user_name.setter
    def creator_user_name(self, value: Optional[str]):
        pulumi.set(self, "creator_user_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        """
        Additional tags for cluster resources.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetClusterClusterInfoDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetClusterClusterInfoDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter
    def driver(self) -> Optional['GetClusterClusterInfoDriverArgs']:
        return pulumi.get(self, "driver")

    @driver.setter
    def driver(self, value: Optional['GetClusterClusterInfoDriverArgs']):
        pulumi.set(self, "driver", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        """
        The node type of the Spark driver.
        """
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: Optional[str]):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        """
        Use autoscaling local storage.
        """
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[bool]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[bool]:
        """
        Enable local disk encryption.
        """
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter
    def executors(self) -> Optional[Sequence['GetClusterClusterInfoExecutorArgs']]:
        return pulumi.get(self, "executors")

    @executors.setter
    def executors(self, value: Optional[Sequence['GetClusterClusterInfoExecutorArgs']]):
        pulumi.set(self, "executors", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetClusterClusterInfoGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetClusterClusterInfoGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetClusterClusterInfoInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetClusterClusterInfoInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        """
        The pool of idle instances the cluster is attached to.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="jdbcPort")
    def jdbc_port(self) -> Optional[int]:
        return pulumi.get(self, "jdbc_port")

    @jdbc_port.setter
    def jdbc_port(self, value: Optional[int]):
        pulumi.set(self, "jdbc_port", value)

    @property
    @pulumi.getter(name="lastActivityTime")
    def last_activity_time(self) -> Optional[int]:
        return pulumi.get(self, "last_activity_time")

    @last_activity_time.setter
    def last_activity_time(self, value: Optional[int]):
        pulumi.set(self, "last_activity_time", value)

    @property
    @pulumi.getter(name="lastStateLossTime")
    def last_state_loss_time(self) -> Optional[int]:
        return pulumi.get(self, "last_state_loss_time")

    @last_state_loss_time.setter
    def last_state_loss_time(self, value: Optional[int]):
        pulumi.set(self, "last_state_loss_time", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        """
        Any supported get_node_type id.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[int]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        """
        The type of runtime of the cluster
        """
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkContextId")
    def spark_context_id(self) -> Optional[int]:
        return pulumi.get(self, "spark_context_id")

    @spark_context_id.setter
    def spark_context_id(self, value: Optional[int]):
        pulumi.set(self, "spark_context_id", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[int]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[str]:
        return pulumi.get(self, "state_message")

    @state_message.setter
    def state_message(self, value: Optional[str]):
        pulumi.set(self, "state_message", value)

    @property
    @pulumi.getter(name="terminateTime")
    def terminate_time(self) -> Optional[int]:
        return pulumi.get(self, "terminate_time")

    @terminate_time.setter
    def terminate_time(self, value: Optional[int]):
        pulumi.set(self, "terminate_time", value)

    @property
    @pulumi.getter(name="terminationReason")
    def termination_reason(self) -> Optional['GetClusterClusterInfoTerminationReasonArgs']:
        return pulumi.get(self, "termination_reason")

    @termination_reason.setter
    def termination_reason(self, value: Optional['GetClusterClusterInfoTerminationReasonArgs']):
        pulumi.set(self, "termination_reason", value)


@pulumi.input_type
class GetClusterClusterInfoAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        GetClusterClusterInfoAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[int] = None,
             min_workers: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class GetClusterClusterInfoAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        GetClusterClusterInfoAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             ebs_volume_count: Optional[int] = None,
             ebs_volume_size: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             instance_profile_arn: Optional[str] = None,
             spot_bid_price_percent: Optional[int] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetClusterClusterInfoAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        GetClusterClusterInfoAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             spot_bid_max_price: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class GetClusterClusterInfoClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetClusterClusterInfoClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetClusterClusterInfoClusterLogConfS3Args'] = None):
        GetClusterClusterInfoClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional['GetClusterClusterInfoClusterLogConfDbfsArgs'] = None,
             s3: Optional['GetClusterClusterInfoClusterLogConfS3Args'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetClusterClusterInfoClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetClusterClusterInfoClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetClusterClusterInfoClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetClusterClusterInfoClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class GetClusterClusterInfoClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetClusterClusterInfoClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetClusterClusterInfoClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetClusterClusterInfoClusterLogStatusArgs:
    def __init__(__self__, *,
                 last_attempted: Optional[int] = None,
                 last_exception: Optional[str] = None):
        GetClusterClusterInfoClusterLogStatusArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_attempted=last_attempted,
            last_exception=last_exception,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_attempted: Optional[int] = None,
             last_exception: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if last_attempted is None and 'lastAttempted' in kwargs:
            last_attempted = kwargs['lastAttempted']
        if last_exception is None and 'lastException' in kwargs:
            last_exception = kwargs['lastException']

        if last_attempted is not None:
            _setter("last_attempted", last_attempted)
        if last_exception is not None:
            _setter("last_exception", last_exception)

    @property
    @pulumi.getter(name="lastAttempted")
    def last_attempted(self) -> Optional[int]:
        return pulumi.get(self, "last_attempted")

    @last_attempted.setter
    def last_attempted(self, value: Optional[int]):
        pulumi.set(self, "last_attempted", value)

    @property
    @pulumi.getter(name="lastException")
    def last_exception(self) -> Optional[str]:
        return pulumi.get(self, "last_exception")

    @last_exception.setter
    def last_exception(self, value: Optional[str]):
        pulumi.set(self, "last_exception", value)


@pulumi.input_type
class GetClusterClusterInfoDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetClusterClusterInfoDockerImageBasicAuthArgs'] = None):
        GetClusterClusterInfoDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             basic_auth: Optional['GetClusterClusterInfoDockerImageBasicAuthArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetClusterClusterInfoDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetClusterClusterInfoDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class GetClusterClusterInfoDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        GetClusterClusterInfoDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetClusterClusterInfoDriverArgs:
    def __init__(__self__, *,
                 host_private_ip: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 node_aws_attributes: Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs'] = None,
                 node_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_dns: Optional[str] = None,
                 start_timestamp: Optional[int] = None):
        GetClusterClusterInfoDriverArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_private_ip=host_private_ip,
            instance_id=instance_id,
            node_aws_attributes=node_aws_attributes,
            node_id=node_id,
            private_ip=private_ip,
            public_dns=public_dns,
            start_timestamp=start_timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_private_ip: Optional[str] = None,
             instance_id: Optional[str] = None,
             node_aws_attributes: Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs'] = None,
             node_id: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_dns: Optional[str] = None,
             start_timestamp: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if host_private_ip is None and 'hostPrivateIp' in kwargs:
            host_private_ip = kwargs['hostPrivateIp']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if node_aws_attributes is None and 'nodeAwsAttributes' in kwargs:
            node_aws_attributes = kwargs['nodeAwsAttributes']
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if public_dns is None and 'publicDns' in kwargs:
            public_dns = kwargs['publicDns']
        if start_timestamp is None and 'startTimestamp' in kwargs:
            start_timestamp = kwargs['startTimestamp']

        if host_private_ip is not None:
            _setter("host_private_ip", host_private_ip)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if node_aws_attributes is not None:
            _setter("node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            _setter("node_id", node_id)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if public_dns is not None:
            _setter("public_dns", public_dns)
        if start_timestamp is not None:
            _setter("start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[str]:
        return pulumi.get(self, "host_private_ip")

    @host_private_ip.setter
    def host_private_ip(self, value: Optional[str]):
        pulumi.set(self, "host_private_ip", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs']:
        return pulumi.get(self, "node_aws_attributes")

    @node_aws_attributes.setter
    def node_aws_attributes(self, value: Optional['GetClusterClusterInfoDriverNodeAwsAttributesArgs']):
        pulumi.set(self, "node_aws_attributes", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[str]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[str]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[str]:
        return pulumi.get(self, "public_dns")

    @public_dns.setter
    def public_dns(self, value: Optional[str]):
        pulumi.set(self, "public_dns", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[int]):
        pulumi.set(self, "start_timestamp", value)


@pulumi.input_type
class GetClusterClusterInfoDriverNodeAwsAttributesArgs:
    def __init__(__self__, *,
                 is_spot: Optional[bool] = None):
        GetClusterClusterInfoDriverNodeAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_spot=is_spot,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_spot: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if is_spot is None and 'isSpot' in kwargs:
            is_spot = kwargs['isSpot']

        if is_spot is not None:
            _setter("is_spot", is_spot)

    @property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[bool]:
        return pulumi.get(self, "is_spot")

    @is_spot.setter
    def is_spot(self, value: Optional[bool]):
        pulumi.set(self, "is_spot", value)


@pulumi.input_type
class GetClusterClusterInfoExecutorArgs:
    def __init__(__self__, *,
                 host_private_ip: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 node_aws_attributes: Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs'] = None,
                 node_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_dns: Optional[str] = None,
                 start_timestamp: Optional[int] = None):
        GetClusterClusterInfoExecutorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_private_ip=host_private_ip,
            instance_id=instance_id,
            node_aws_attributes=node_aws_attributes,
            node_id=node_id,
            private_ip=private_ip,
            public_dns=public_dns,
            start_timestamp=start_timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_private_ip: Optional[str] = None,
             instance_id: Optional[str] = None,
             node_aws_attributes: Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs'] = None,
             node_id: Optional[str] = None,
             private_ip: Optional[str] = None,
             public_dns: Optional[str] = None,
             start_timestamp: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if host_private_ip is None and 'hostPrivateIp' in kwargs:
            host_private_ip = kwargs['hostPrivateIp']
        if instance_id is None and 'instanceId' in kwargs:
            instance_id = kwargs['instanceId']
        if node_aws_attributes is None and 'nodeAwsAttributes' in kwargs:
            node_aws_attributes = kwargs['nodeAwsAttributes']
        if node_id is None and 'nodeId' in kwargs:
            node_id = kwargs['nodeId']
        if private_ip is None and 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if public_dns is None and 'publicDns' in kwargs:
            public_dns = kwargs['publicDns']
        if start_timestamp is None and 'startTimestamp' in kwargs:
            start_timestamp = kwargs['startTimestamp']

        if host_private_ip is not None:
            _setter("host_private_ip", host_private_ip)
        if instance_id is not None:
            _setter("instance_id", instance_id)
        if node_aws_attributes is not None:
            _setter("node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            _setter("node_id", node_id)
        if private_ip is not None:
            _setter("private_ip", private_ip)
        if public_dns is not None:
            _setter("public_dns", public_dns)
        if start_timestamp is not None:
            _setter("start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[str]:
        return pulumi.get(self, "host_private_ip")

    @host_private_ip.setter
    def host_private_ip(self, value: Optional[str]):
        pulumi.set(self, "host_private_ip", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs']:
        return pulumi.get(self, "node_aws_attributes")

    @node_aws_attributes.setter
    def node_aws_attributes(self, value: Optional['GetClusterClusterInfoExecutorNodeAwsAttributesArgs']):
        pulumi.set(self, "node_aws_attributes", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[str]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[str]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[str]:
        return pulumi.get(self, "public_dns")

    @public_dns.setter
    def public_dns(self, value: Optional[str]):
        pulumi.set(self, "public_dns", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[int]):
        pulumi.set(self, "start_timestamp", value)


@pulumi.input_type
class GetClusterClusterInfoExecutorNodeAwsAttributesArgs:
    def __init__(__self__, *,
                 is_spot: Optional[bool] = None):
        GetClusterClusterInfoExecutorNodeAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_spot=is_spot,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_spot: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if is_spot is None and 'isSpot' in kwargs:
            is_spot = kwargs['isSpot']

        if is_spot is not None:
            _setter("is_spot", is_spot)

    @property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[bool]:
        return pulumi.get(self, "is_spot")

    @is_spot.setter
    def is_spot(self, value: Optional[bool]):
        pulumi.set(self, "is_spot", value)


@pulumi.input_type
class GetClusterClusterInfoGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        GetClusterClusterInfoGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             boot_disk_size: Optional[int] = None,
             google_service_account: Optional[str] = None,
             local_ssd_count: Optional[int] = None,
             use_preemptible_executors: Optional[bool] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetClusterClusterInfoInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetClusterClusterInfoInitScriptDbfsArgs'] = None,
                 file: Optional['GetClusterClusterInfoInitScriptFileArgs'] = None,
                 gcs: Optional['GetClusterClusterInfoInitScriptGcsArgs'] = None,
                 s3: Optional['GetClusterClusterInfoInitScriptS3Args'] = None,
                 volumes: Optional['GetClusterClusterInfoInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetClusterClusterInfoInitScriptWorkspaceArgs'] = None):
        GetClusterClusterInfoInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional['GetClusterClusterInfoInitScriptAbfssArgs'] = None,
             dbfs: Optional['GetClusterClusterInfoInitScriptDbfsArgs'] = None,
             file: Optional['GetClusterClusterInfoInitScriptFileArgs'] = None,
             gcs: Optional['GetClusterClusterInfoInitScriptGcsArgs'] = None,
             s3: Optional['GetClusterClusterInfoInitScriptS3Args'] = None,
             volumes: Optional['GetClusterClusterInfoInitScriptVolumesArgs'] = None,
             workspace: Optional['GetClusterClusterInfoInitScriptWorkspaceArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetClusterClusterInfoInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetClusterClusterInfoInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetClusterClusterInfoInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetClusterClusterInfoInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetClusterClusterInfoInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetClusterClusterInfoInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetClusterClusterInfoInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetClusterClusterInfoInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetClusterClusterInfoInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetClusterClusterInfoInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetClusterClusterInfoInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetClusterClusterInfoInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetClusterClusterInfoInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetClusterClusterInfoInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetClusterClusterInfoInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetClusterClusterInfoInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetClusterClusterInfoInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetClusterClusterInfoInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetClusterClusterInfoInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetClusterClusterInfoInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetClusterClusterInfoInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetClusterClusterInfoTerminationReasonArgs:
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 parameters: Optional[Mapping[str, Any]] = None,
                 type: Optional[str] = None):
        GetClusterClusterInfoTerminationReasonArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            parameters=parameters,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             parameters: Optional[Mapping[str, Any]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if parameters is not None:
            _setter("parameters", parameters)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[str]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetInstancePoolPoolInfoArgs:
    def __init__(__self__, *,
                 default_tags: Mapping[str, Any],
                 idle_instance_autotermination_minutes: int,
                 instance_pool_id: str,
                 instance_pool_name: str,
                 aws_attributes: Optional['GetInstancePoolPoolInfoAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetInstancePoolPoolInfoAzureAttributesArgs'] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 disk_spec: Optional['GetInstancePoolPoolInfoDiskSpecArgs'] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 gcp_attributes: Optional['GetInstancePoolPoolInfoGcpAttributesArgs'] = None,
                 instance_pool_fleet_attributes: Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']] = None,
                 max_capacity: Optional[int] = None,
                 min_idle_instances: Optional[int] = None,
                 node_type_id: Optional[str] = None,
                 preloaded_docker_images: Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']] = None,
                 preloaded_spark_versions: Optional[Sequence[str]] = None,
                 state: Optional[str] = None,
                 stats: Optional['GetInstancePoolPoolInfoStatsArgs'] = None):
        GetInstancePoolPoolInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_tags=default_tags,
            idle_instance_autotermination_minutes=idle_instance_autotermination_minutes,
            instance_pool_id=instance_pool_id,
            instance_pool_name=instance_pool_name,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            custom_tags=custom_tags,
            disk_spec=disk_spec,
            enable_elastic_disk=enable_elastic_disk,
            gcp_attributes=gcp_attributes,
            instance_pool_fleet_attributes=instance_pool_fleet_attributes,
            max_capacity=max_capacity,
            min_idle_instances=min_idle_instances,
            node_type_id=node_type_id,
            preloaded_docker_images=preloaded_docker_images,
            preloaded_spark_versions=preloaded_spark_versions,
            state=state,
            stats=stats,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_tags: Optional[Mapping[str, Any]] = None,
             idle_instance_autotermination_minutes: Optional[int] = None,
             instance_pool_id: Optional[str] = None,
             instance_pool_name: Optional[str] = None,
             aws_attributes: Optional['GetInstancePoolPoolInfoAwsAttributesArgs'] = None,
             azure_attributes: Optional['GetInstancePoolPoolInfoAzureAttributesArgs'] = None,
             custom_tags: Optional[Mapping[str, Any]] = None,
             disk_spec: Optional['GetInstancePoolPoolInfoDiskSpecArgs'] = None,
             enable_elastic_disk: Optional[bool] = None,
             gcp_attributes: Optional['GetInstancePoolPoolInfoGcpAttributesArgs'] = None,
             instance_pool_fleet_attributes: Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']] = None,
             max_capacity: Optional[int] = None,
             min_idle_instances: Optional[int] = None,
             node_type_id: Optional[str] = None,
             preloaded_docker_images: Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']] = None,
             preloaded_spark_versions: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             stats: Optional['GetInstancePoolPoolInfoStatsArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if default_tags is None and 'defaultTags' in kwargs:
            default_tags = kwargs['defaultTags']
        if default_tags is None:
            raise TypeError("Missing 'default_tags' argument")
        if idle_instance_autotermination_minutes is None and 'idleInstanceAutoterminationMinutes' in kwargs:
            idle_instance_autotermination_minutes = kwargs['idleInstanceAutoterminationMinutes']
        if idle_instance_autotermination_minutes is None:
            raise TypeError("Missing 'idle_instance_autotermination_minutes' argument")
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if instance_pool_id is None:
            raise TypeError("Missing 'instance_pool_id' argument")
        if instance_pool_name is None and 'instancePoolName' in kwargs:
            instance_pool_name = kwargs['instancePoolName']
        if instance_pool_name is None:
            raise TypeError("Missing 'instance_pool_name' argument")
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if disk_spec is None and 'diskSpec' in kwargs:
            disk_spec = kwargs['diskSpec']
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if instance_pool_fleet_attributes is None and 'instancePoolFleetAttributes' in kwargs:
            instance_pool_fleet_attributes = kwargs['instancePoolFleetAttributes']
        if max_capacity is None and 'maxCapacity' in kwargs:
            max_capacity = kwargs['maxCapacity']
        if min_idle_instances is None and 'minIdleInstances' in kwargs:
            min_idle_instances = kwargs['minIdleInstances']
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if preloaded_docker_images is None and 'preloadedDockerImages' in kwargs:
            preloaded_docker_images = kwargs['preloadedDockerImages']
        if preloaded_spark_versions is None and 'preloadedSparkVersions' in kwargs:
            preloaded_spark_versions = kwargs['preloadedSparkVersions']

        _setter("default_tags", default_tags)
        _setter("idle_instance_autotermination_minutes", idle_instance_autotermination_minutes)
        _setter("instance_pool_id", instance_pool_id)
        _setter("instance_pool_name", instance_pool_name)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if disk_spec is not None:
            _setter("disk_spec", disk_spec)
        if enable_elastic_disk is not None:
            _setter("enable_elastic_disk", enable_elastic_disk)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if instance_pool_fleet_attributes is not None:
            _setter("instance_pool_fleet_attributes", instance_pool_fleet_attributes)
        if max_capacity is not None:
            _setter("max_capacity", max_capacity)
        if min_idle_instances is not None:
            _setter("min_idle_instances", min_idle_instances)
        if node_type_id is not None:
            _setter("node_type_id", node_type_id)
        if preloaded_docker_images is not None:
            _setter("preloaded_docker_images", preloaded_docker_images)
        if preloaded_spark_versions is not None:
            _setter("preloaded_spark_versions", preloaded_spark_versions)
        if state is not None:
            _setter("state", state)
        if stats is not None:
            _setter("stats", stats)

    @property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "default_tags")

    @default_tags.setter
    def default_tags(self, value: Mapping[str, Any]):
        pulumi.set(self, "default_tags", value)

    @property
    @pulumi.getter(name="idleInstanceAutoterminationMinutes")
    def idle_instance_autotermination_minutes(self) -> int:
        return pulumi.get(self, "idle_instance_autotermination_minutes")

    @idle_instance_autotermination_minutes.setter
    def idle_instance_autotermination_minutes(self, value: int):
        pulumi.set(self, "idle_instance_autotermination_minutes", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: str):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="instancePoolName")
    def instance_pool_name(self) -> str:
        return pulumi.get(self, "instance_pool_name")

    @instance_pool_name.setter
    def instance_pool_name(self, value: str):
        pulumi.set(self, "instance_pool_name", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetInstancePoolPoolInfoAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetInstancePoolPoolInfoAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetInstancePoolPoolInfoAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetInstancePoolPoolInfoAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="diskSpec")
    def disk_spec(self) -> Optional['GetInstancePoolPoolInfoDiskSpecArgs']:
        return pulumi.get(self, "disk_spec")

    @disk_spec.setter
    def disk_spec(self, value: Optional['GetInstancePoolPoolInfoDiskSpecArgs']):
        pulumi.set(self, "disk_spec", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: Optional[bool]):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetInstancePoolPoolInfoGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetInstancePoolPoolInfoGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="instancePoolFleetAttributes")
    def instance_pool_fleet_attributes(self) -> Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']]:
        return pulumi.get(self, "instance_pool_fleet_attributes")

    @instance_pool_fleet_attributes.setter
    def instance_pool_fleet_attributes(self, value: Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs']]):
        pulumi.set(self, "instance_pool_fleet_attributes", value)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[int]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minIdleInstances")
    def min_idle_instances(self) -> Optional[int]:
        return pulumi.get(self, "min_idle_instances")

    @min_idle_instances.setter
    def min_idle_instances(self, value: Optional[int]):
        pulumi.set(self, "min_idle_instances", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: Optional[str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="preloadedDockerImages")
    def preloaded_docker_images(self) -> Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']]:
        return pulumi.get(self, "preloaded_docker_images")

    @preloaded_docker_images.setter
    def preloaded_docker_images(self, value: Optional[Sequence['GetInstancePoolPoolInfoPreloadedDockerImageArgs']]):
        pulumi.set(self, "preloaded_docker_images", value)

    @property
    @pulumi.getter(name="preloadedSparkVersions")
    def preloaded_spark_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preloaded_spark_versions")

    @preloaded_spark_versions.setter
    def preloaded_spark_versions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "preloaded_spark_versions", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[str]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def stats(self) -> Optional['GetInstancePoolPoolInfoStatsArgs']:
        return pulumi.get(self, "stats")

    @stats.setter
    def stats(self, value: Optional['GetInstancePoolPoolInfoStatsArgs']):
        pulumi.set(self, "stats", value)


@pulumi.input_type
class GetInstancePoolPoolInfoAwsAttributesArgs:
    def __init__(__self__, *,
                 zone_id: str,
                 availability: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None):
        GetInstancePoolPoolInfoAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            zone_id=zone_id,
            availability=availability,
            spot_bid_price_percent=spot_bid_price_percent,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             zone_id: Optional[str] = None,
             availability: Optional[str] = None,
             spot_bid_price_percent: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']
        if zone_id is None:
            raise TypeError("Missing 'zone_id' argument")
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']

        _setter("zone_id", zone_id)
        if availability is not None:
            _setter("availability", availability)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: str):
        pulumi.set(self, "zone_id", value)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)


@pulumi.input_type
class GetInstancePoolPoolInfoAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 spot_bid_max_price: Optional[float] = None):
        GetInstancePoolPoolInfoAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             spot_bid_max_price: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class GetInstancePoolPoolInfoDiskSpecArgs:
    def __init__(__self__, *,
                 disk_count: Optional[int] = None,
                 disk_size: Optional[int] = None,
                 disk_type: Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs'] = None):
        GetInstancePoolPoolInfoDiskSpecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disk_count=disk_count,
            disk_size=disk_size,
            disk_type=disk_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disk_count: Optional[int] = None,
             disk_size: Optional[int] = None,
             disk_type: Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if disk_count is None and 'diskCount' in kwargs:
            disk_count = kwargs['diskCount']
        if disk_size is None and 'diskSize' in kwargs:
            disk_size = kwargs['diskSize']
        if disk_type is None and 'diskType' in kwargs:
            disk_type = kwargs['diskType']

        if disk_count is not None:
            _setter("disk_count", disk_count)
        if disk_size is not None:
            _setter("disk_size", disk_size)
        if disk_type is not None:
            _setter("disk_type", disk_type)

    @property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[int]:
        return pulumi.get(self, "disk_count")

    @disk_count.setter
    def disk_count(self, value: Optional[int]):
        pulumi.set(self, "disk_count", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[int]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs']:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional['GetInstancePoolPoolInfoDiskSpecDiskTypeArgs']):
        pulumi.set(self, "disk_type", value)


@pulumi.input_type
class GetInstancePoolPoolInfoDiskSpecDiskTypeArgs:
    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[str] = None,
                 ebs_volume_type: Optional[str] = None):
        GetInstancePoolPoolInfoDiskSpecDiskTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_disk_volume_type=azure_disk_volume_type,
            ebs_volume_type=ebs_volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_disk_volume_type: Optional[str] = None,
             ebs_volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if azure_disk_volume_type is None and 'azureDiskVolumeType' in kwargs:
            azure_disk_volume_type = kwargs['azureDiskVolumeType']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']

        if azure_disk_volume_type is not None:
            _setter("azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)

    @property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "azure_disk_volume_type")

    @azure_disk_volume_type.setter
    def azure_disk_volume_type(self, value: Optional[str]):
        pulumi.set(self, "azure_disk_volume_type", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)


@pulumi.input_type
class GetInstancePoolPoolInfoGcpAttributesArgs:
    def __init__(__self__, *,
                 gcp_availability: Optional[str] = None,
                 local_ssd_count: Optional[int] = None):
        GetInstancePoolPoolInfoGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gcp_availability=gcp_availability,
            local_ssd_count=local_ssd_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gcp_availability: Optional[str] = None,
             local_ssd_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if gcp_availability is None and 'gcpAvailability' in kwargs:
            gcp_availability = kwargs['gcpAvailability']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']

        if gcp_availability is not None:
            _setter("gcp_availability", gcp_availability)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)

    @property
    @pulumi.getter(name="gcpAvailability")
    def gcp_availability(self) -> Optional[str]:
        return pulumi.get(self, "gcp_availability")

    @gcp_availability.setter
    def gcp_availability(self, value: Optional[str]):
        pulumi.set(self, "gcp_availability", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)


@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs:
    def __init__(__self__, *,
                 launch_template_overrides: Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs'],
                 fleet_on_demand_option: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs'] = None,
                 fleet_spot_option: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs'] = None):
        GetInstancePoolPoolInfoInstancePoolFleetAttributeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            launch_template_overrides=launch_template_overrides,
            fleet_on_demand_option=fleet_on_demand_option,
            fleet_spot_option=fleet_spot_option,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             launch_template_overrides: Optional[Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs']] = None,
             fleet_on_demand_option: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs'] = None,
             fleet_spot_option: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if launch_template_overrides is None and 'launchTemplateOverrides' in kwargs:
            launch_template_overrides = kwargs['launchTemplateOverrides']
        if launch_template_overrides is None:
            raise TypeError("Missing 'launch_template_overrides' argument")
        if fleet_on_demand_option is None and 'fleetOnDemandOption' in kwargs:
            fleet_on_demand_option = kwargs['fleetOnDemandOption']
        if fleet_spot_option is None and 'fleetSpotOption' in kwargs:
            fleet_spot_option = kwargs['fleetSpotOption']

        _setter("launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            _setter("fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            _setter("fleet_spot_option", fleet_spot_option)

    @property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs']:
        return pulumi.get(self, "launch_template_overrides")

    @launch_template_overrides.setter
    def launch_template_overrides(self, value: Sequence['GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs']):
        pulumi.set(self, "launch_template_overrides", value)

    @property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs']:
        return pulumi.get(self, "fleet_on_demand_option")

    @fleet_on_demand_option.setter
    def fleet_on_demand_option(self, value: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs']):
        pulumi.set(self, "fleet_on_demand_option", value)

    @property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs']:
        return pulumi.get(self, "fleet_spot_option")

    @fleet_spot_option.setter
    def fleet_spot_option(self, value: Optional['GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs']):
        pulumi.set(self, "fleet_spot_option", value)


@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: str,
                 instance_pools_to_use_count: Optional[int] = None):
        GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
            instance_pools_to_use_count=instance_pools_to_use_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: Optional[str] = None,
             instance_pools_to_use_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if allocation_strategy is None and 'allocationStrategy' in kwargs:
            allocation_strategy = kwargs['allocationStrategy']
        if allocation_strategy is None:
            raise TypeError("Missing 'allocation_strategy' argument")
        if instance_pools_to_use_count is None and 'instancePoolsToUseCount' in kwargs:
            instance_pools_to_use_count = kwargs['instancePoolsToUseCount']

        _setter("allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            _setter("instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: str):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[int]):
        pulumi.set(self, "instance_pools_to_use_count", value)


@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs:
    def __init__(__self__, *,
                 allocation_strategy: str,
                 instance_pools_to_use_count: Optional[int] = None):
        GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
            instance_pools_to_use_count=instance_pools_to_use_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: Optional[str] = None,
             instance_pools_to_use_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if allocation_strategy is None and 'allocationStrategy' in kwargs:
            allocation_strategy = kwargs['allocationStrategy']
        if allocation_strategy is None:
            raise TypeError("Missing 'allocation_strategy' argument")
        if instance_pools_to_use_count is None and 'instancePoolsToUseCount' in kwargs:
            instance_pools_to_use_count = kwargs['instancePoolsToUseCount']

        _setter("allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            _setter("instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: str):
        pulumi.set(self, "allocation_strategy", value)

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[int]):
        pulumi.set(self, "instance_pools_to_use_count", value)


@pulumi.input_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs:
    def __init__(__self__, *,
                 availability_zone: str,
                 instance_type: str):
        GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            instance_type=instance_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             instance_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if availability_zone is None and 'availabilityZone' in kwargs:
            availability_zone = kwargs['availabilityZone']
        if availability_zone is None:
            raise TypeError("Missing 'availability_zone' argument")
        if instance_type is None and 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if instance_type is None:
            raise TypeError("Missing 'instance_type' argument")

        _setter("availability_zone", availability_zone)
        _setter("instance_type", instance_type)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: str):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: str):
        pulumi.set(self, "instance_type", value)


@pulumi.input_type
class GetInstancePoolPoolInfoPreloadedDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs'] = None):
        GetInstancePoolPoolInfoPreloadedDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             basic_auth: Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetInstancePoolPoolInfoStatsArgs:
    def __init__(__self__, *,
                 idle_count: Optional[int] = None,
                 pending_idle_count: Optional[int] = None,
                 pending_used_count: Optional[int] = None,
                 used_count: Optional[int] = None):
        GetInstancePoolPoolInfoStatsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle_count=idle_count,
            pending_idle_count=pending_idle_count,
            pending_used_count=pending_used_count,
            used_count=used_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle_count: Optional[int] = None,
             pending_idle_count: Optional[int] = None,
             pending_used_count: Optional[int] = None,
             used_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if idle_count is None and 'idleCount' in kwargs:
            idle_count = kwargs['idleCount']
        if pending_idle_count is None and 'pendingIdleCount' in kwargs:
            pending_idle_count = kwargs['pendingIdleCount']
        if pending_used_count is None and 'pendingUsedCount' in kwargs:
            pending_used_count = kwargs['pendingUsedCount']
        if used_count is None and 'usedCount' in kwargs:
            used_count = kwargs['usedCount']

        if idle_count is not None:
            _setter("idle_count", idle_count)
        if pending_idle_count is not None:
            _setter("pending_idle_count", pending_idle_count)
        if pending_used_count is not None:
            _setter("pending_used_count", pending_used_count)
        if used_count is not None:
            _setter("used_count", used_count)

    @property
    @pulumi.getter(name="idleCount")
    def idle_count(self) -> Optional[int]:
        return pulumi.get(self, "idle_count")

    @idle_count.setter
    def idle_count(self, value: Optional[int]):
        pulumi.set(self, "idle_count", value)

    @property
    @pulumi.getter(name="pendingIdleCount")
    def pending_idle_count(self) -> Optional[int]:
        return pulumi.get(self, "pending_idle_count")

    @pending_idle_count.setter
    def pending_idle_count(self, value: Optional[int]):
        pulumi.set(self, "pending_idle_count", value)

    @property
    @pulumi.getter(name="pendingUsedCount")
    def pending_used_count(self) -> Optional[int]:
        return pulumi.get(self, "pending_used_count")

    @pending_used_count.setter
    def pending_used_count(self, value: Optional[int]):
        pulumi.set(self, "pending_used_count", value)

    @property
    @pulumi.getter(name="usedCount")
    def used_count(self) -> Optional[int]:
        return pulumi.get(self, "used_count")

    @used_count.setter
    def used_count(self, value: Optional[int]):
        pulumi.set(self, "used_count", value)


@pulumi.input_type
class GetJobJobSettingsArgs:
    def __init__(__self__, *,
                 run_as_user_name: str,
                 created_time: Optional[int] = None,
                 creator_user_name: Optional[str] = None,
                 job_id: Optional[int] = None,
                 settings: Optional['GetJobJobSettingsSettingsArgs'] = None):
        GetJobJobSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            run_as_user_name=run_as_user_name,
            created_time=created_time,
            creator_user_name=creator_user_name,
            job_id=job_id,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             run_as_user_name: Optional[str] = None,
             created_time: Optional[int] = None,
             creator_user_name: Optional[str] = None,
             job_id: Optional[int] = None,
             settings: Optional['GetJobJobSettingsSettingsArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if run_as_user_name is None and 'runAsUserName' in kwargs:
            run_as_user_name = kwargs['runAsUserName']
        if run_as_user_name is None:
            raise TypeError("Missing 'run_as_user_name' argument")
        if created_time is None and 'createdTime' in kwargs:
            created_time = kwargs['createdTime']
        if creator_user_name is None and 'creatorUserName' in kwargs:
            creator_user_name = kwargs['creatorUserName']
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']

        _setter("run_as_user_name", run_as_user_name)
        if created_time is not None:
            _setter("created_time", created_time)
        if creator_user_name is not None:
            _setter("creator_user_name", creator_user_name)
        if job_id is not None:
            _setter("job_id", job_id)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> str:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: str):
        pulumi.set(self, "run_as_user_name", value)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[int]:
        return pulumi.get(self, "created_time")

    @created_time.setter
    def created_time(self, value: Optional[int]):
        pulumi.set(self, "created_time", value)

    @property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[str]:
        return pulumi.get(self, "creator_user_name")

    @creator_user_name.setter
    def creator_user_name(self, value: Optional[str]):
        pulumi.set(self, "creator_user_name", value)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[int]:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: Optional[int]):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional['GetJobJobSettingsSettingsArgs']:
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional['GetJobJobSettingsSettingsArgs']):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class GetJobJobSettingsSettingsArgs:
    def __init__(__self__, *,
                 format: str,
                 computes: Optional[Sequence['GetJobJobSettingsSettingsComputeArgs']] = None,
                 continuous: Optional['GetJobJobSettingsSettingsContinuousArgs'] = None,
                 dbt_task: Optional['GetJobJobSettingsSettingsDbtTaskArgs'] = None,
                 deployment: Optional['GetJobJobSettingsSettingsDeploymentArgs'] = None,
                 email_notifications: Optional['GetJobJobSettingsSettingsEmailNotificationsArgs'] = None,
                 existing_cluster_id: Optional[str] = None,
                 git_source: Optional['GetJobJobSettingsSettingsGitSourceArgs'] = None,
                 health: Optional['GetJobJobSettingsSettingsHealthArgs'] = None,
                 job_clusters: Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']] = None,
                 libraries: Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']] = None,
                 max_concurrent_runs: Optional[int] = None,
                 max_retries: Optional[int] = None,
                 min_retry_interval_millis: Optional[int] = None,
                 name: Optional[str] = None,
                 new_cluster: Optional['GetJobJobSettingsSettingsNewClusterArgs'] = None,
                 notebook_task: Optional['GetJobJobSettingsSettingsNotebookTaskArgs'] = None,
                 notification_settings: Optional['GetJobJobSettingsSettingsNotificationSettingsArgs'] = None,
                 parameters: Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']] = None,
                 pipeline_task: Optional['GetJobJobSettingsSettingsPipelineTaskArgs'] = None,
                 python_wheel_task: Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs'] = None,
                 queue: Optional['GetJobJobSettingsSettingsQueueArgs'] = None,
                 retry_on_timeout: Optional[bool] = None,
                 run_as: Optional['GetJobJobSettingsSettingsRunAsArgs'] = None,
                 run_job_task: Optional['GetJobJobSettingsSettingsRunJobTaskArgs'] = None,
                 schedule: Optional['GetJobJobSettingsSettingsScheduleArgs'] = None,
                 spark_jar_task: Optional['GetJobJobSettingsSettingsSparkJarTaskArgs'] = None,
                 spark_python_task: Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs'] = None,
                 spark_submit_task: Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs'] = None,
                 tags: Optional[Mapping[str, Any]] = None,
                 tasks: Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']] = None,
                 timeout_seconds: Optional[int] = None,
                 trigger: Optional['GetJobJobSettingsSettingsTriggerArgs'] = None,
                 webhook_notifications: Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs'] = None):
        """
        :param str name: the job name of Job if the resource was matched by id.
        """
        GetJobJobSettingsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            format=format,
            computes=computes,
            continuous=continuous,
            dbt_task=dbt_task,
            deployment=deployment,
            email_notifications=email_notifications,
            existing_cluster_id=existing_cluster_id,
            git_source=git_source,
            health=health,
            job_clusters=job_clusters,
            libraries=libraries,
            max_concurrent_runs=max_concurrent_runs,
            max_retries=max_retries,
            min_retry_interval_millis=min_retry_interval_millis,
            name=name,
            new_cluster=new_cluster,
            notebook_task=notebook_task,
            notification_settings=notification_settings,
            parameters=parameters,
            pipeline_task=pipeline_task,
            python_wheel_task=python_wheel_task,
            queue=queue,
            retry_on_timeout=retry_on_timeout,
            run_as=run_as,
            run_job_task=run_job_task,
            schedule=schedule,
            spark_jar_task=spark_jar_task,
            spark_python_task=spark_python_task,
            spark_submit_task=spark_submit_task,
            tags=tags,
            tasks=tasks,
            timeout_seconds=timeout_seconds,
            trigger=trigger,
            webhook_notifications=webhook_notifications,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             format: Optional[str] = None,
             computes: Optional[Sequence['GetJobJobSettingsSettingsComputeArgs']] = None,
             continuous: Optional['GetJobJobSettingsSettingsContinuousArgs'] = None,
             dbt_task: Optional['GetJobJobSettingsSettingsDbtTaskArgs'] = None,
             deployment: Optional['GetJobJobSettingsSettingsDeploymentArgs'] = None,
             email_notifications: Optional['GetJobJobSettingsSettingsEmailNotificationsArgs'] = None,
             existing_cluster_id: Optional[str] = None,
             git_source: Optional['GetJobJobSettingsSettingsGitSourceArgs'] = None,
             health: Optional['GetJobJobSettingsSettingsHealthArgs'] = None,
             job_clusters: Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']] = None,
             libraries: Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']] = None,
             max_concurrent_runs: Optional[int] = None,
             max_retries: Optional[int] = None,
             min_retry_interval_millis: Optional[int] = None,
             name: Optional[str] = None,
             new_cluster: Optional['GetJobJobSettingsSettingsNewClusterArgs'] = None,
             notebook_task: Optional['GetJobJobSettingsSettingsNotebookTaskArgs'] = None,
             notification_settings: Optional['GetJobJobSettingsSettingsNotificationSettingsArgs'] = None,
             parameters: Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']] = None,
             pipeline_task: Optional['GetJobJobSettingsSettingsPipelineTaskArgs'] = None,
             python_wheel_task: Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs'] = None,
             queue: Optional['GetJobJobSettingsSettingsQueueArgs'] = None,
             retry_on_timeout: Optional[bool] = None,
             run_as: Optional['GetJobJobSettingsSettingsRunAsArgs'] = None,
             run_job_task: Optional['GetJobJobSettingsSettingsRunJobTaskArgs'] = None,
             schedule: Optional['GetJobJobSettingsSettingsScheduleArgs'] = None,
             spark_jar_task: Optional['GetJobJobSettingsSettingsSparkJarTaskArgs'] = None,
             spark_python_task: Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs'] = None,
             spark_submit_task: Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs'] = None,
             tags: Optional[Mapping[str, Any]] = None,
             tasks: Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']] = None,
             timeout_seconds: Optional[int] = None,
             trigger: Optional['GetJobJobSettingsSettingsTriggerArgs'] = None,
             webhook_notifications: Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if format is None:
            raise TypeError("Missing 'format' argument")
        if dbt_task is None and 'dbtTask' in kwargs:
            dbt_task = kwargs['dbtTask']
        if email_notifications is None and 'emailNotifications' in kwargs:
            email_notifications = kwargs['emailNotifications']
        if existing_cluster_id is None and 'existingClusterId' in kwargs:
            existing_cluster_id = kwargs['existingClusterId']
        if git_source is None and 'gitSource' in kwargs:
            git_source = kwargs['gitSource']
        if job_clusters is None and 'jobClusters' in kwargs:
            job_clusters = kwargs['jobClusters']
        if max_concurrent_runs is None and 'maxConcurrentRuns' in kwargs:
            max_concurrent_runs = kwargs['maxConcurrentRuns']
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if min_retry_interval_millis is None and 'minRetryIntervalMillis' in kwargs:
            min_retry_interval_millis = kwargs['minRetryIntervalMillis']
        if new_cluster is None and 'newCluster' in kwargs:
            new_cluster = kwargs['newCluster']
        if notebook_task is None and 'notebookTask' in kwargs:
            notebook_task = kwargs['notebookTask']
        if notification_settings is None and 'notificationSettings' in kwargs:
            notification_settings = kwargs['notificationSettings']
        if pipeline_task is None and 'pipelineTask' in kwargs:
            pipeline_task = kwargs['pipelineTask']
        if python_wheel_task is None and 'pythonWheelTask' in kwargs:
            python_wheel_task = kwargs['pythonWheelTask']
        if retry_on_timeout is None and 'retryOnTimeout' in kwargs:
            retry_on_timeout = kwargs['retryOnTimeout']
        if run_as is None and 'runAs' in kwargs:
            run_as = kwargs['runAs']
        if run_job_task is None and 'runJobTask' in kwargs:
            run_job_task = kwargs['runJobTask']
        if spark_jar_task is None and 'sparkJarTask' in kwargs:
            spark_jar_task = kwargs['sparkJarTask']
        if spark_python_task is None and 'sparkPythonTask' in kwargs:
            spark_python_task = kwargs['sparkPythonTask']
        if spark_submit_task is None and 'sparkSubmitTask' in kwargs:
            spark_submit_task = kwargs['sparkSubmitTask']
        if timeout_seconds is None and 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']
        if webhook_notifications is None and 'webhookNotifications' in kwargs:
            webhook_notifications = kwargs['webhookNotifications']

        _setter("format", format)
        if computes is not None:
            _setter("computes", computes)
        if continuous is not None:
            _setter("continuous", continuous)
        if dbt_task is not None:
            _setter("dbt_task", dbt_task)
        if deployment is not None:
            _setter("deployment", deployment)
        if email_notifications is not None:
            _setter("email_notifications", email_notifications)
        if existing_cluster_id is not None:
            _setter("existing_cluster_id", existing_cluster_id)
        if git_source is not None:
            _setter("git_source", git_source)
        if health is not None:
            _setter("health", health)
        if job_clusters is not None:
            _setter("job_clusters", job_clusters)
        if libraries is not None:
            _setter("libraries", libraries)
        if max_concurrent_runs is not None:
            _setter("max_concurrent_runs", max_concurrent_runs)
        if max_retries is not None:
            _setter("max_retries", max_retries)
        if min_retry_interval_millis is not None:
            _setter("min_retry_interval_millis", min_retry_interval_millis)
        if name is not None:
            _setter("name", name)
        if new_cluster is not None:
            _setter("new_cluster", new_cluster)
        if notebook_task is not None:
            _setter("notebook_task", notebook_task)
        if notification_settings is not None:
            _setter("notification_settings", notification_settings)
        if parameters is not None:
            _setter("parameters", parameters)
        if pipeline_task is not None:
            _setter("pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            _setter("python_wheel_task", python_wheel_task)
        if queue is not None:
            _setter("queue", queue)
        if retry_on_timeout is not None:
            _setter("retry_on_timeout", retry_on_timeout)
        if run_as is not None:
            _setter("run_as", run_as)
        if run_job_task is not None:
            _setter("run_job_task", run_job_task)
        if schedule is not None:
            _setter("schedule", schedule)
        if spark_jar_task is not None:
            _setter("spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            _setter("spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            _setter("spark_submit_task", spark_submit_task)
        if tags is not None:
            _setter("tags", tags)
        if tasks is not None:
            _setter("tasks", tasks)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)
        if trigger is not None:
            _setter("trigger", trigger)
        if webhook_notifications is not None:
            _setter("webhook_notifications", webhook_notifications)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: str):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def computes(self) -> Optional[Sequence['GetJobJobSettingsSettingsComputeArgs']]:
        return pulumi.get(self, "computes")

    @computes.setter
    def computes(self, value: Optional[Sequence['GetJobJobSettingsSettingsComputeArgs']]):
        pulumi.set(self, "computes", value)

    @property
    @pulumi.getter
    def continuous(self) -> Optional['GetJobJobSettingsSettingsContinuousArgs']:
        return pulumi.get(self, "continuous")

    @continuous.setter
    def continuous(self, value: Optional['GetJobJobSettingsSettingsContinuousArgs']):
        pulumi.set(self, "continuous", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['GetJobJobSettingsSettingsDbtTaskArgs']:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional['GetJobJobSettingsSettingsDbtTaskArgs']):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional['GetJobJobSettingsSettingsDeploymentArgs']:
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional['GetJobJobSettingsSettingsDeploymentArgs']):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['GetJobJobSettingsSettingsEmailNotificationsArgs']:
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional['GetJobJobSettingsSettingsEmailNotificationsArgs']):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[str]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter(name="gitSource")
    def git_source(self) -> Optional['GetJobJobSettingsSettingsGitSourceArgs']:
        return pulumi.get(self, "git_source")

    @git_source.setter
    def git_source(self, value: Optional['GetJobJobSettingsSettingsGitSourceArgs']):
        pulumi.set(self, "git_source", value)

    @property
    @pulumi.getter
    def health(self) -> Optional['GetJobJobSettingsSettingsHealthArgs']:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional['GetJobJobSettingsSettingsHealthArgs']):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusters")
    def job_clusters(self) -> Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']]:
        return pulumi.get(self, "job_clusters")

    @job_clusters.setter
    def job_clusters(self, value: Optional[Sequence['GetJobJobSettingsSettingsJobClusterArgs']]):
        pulumi.set(self, "job_clusters", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']]:
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[Sequence['GetJobJobSettingsSettingsLibraryArgs']]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrent_runs")

    @max_concurrent_runs.setter
    def max_concurrent_runs(self, value: Optional[int]):
        pulumi.set(self, "max_concurrent_runs", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[int]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['GetJobJobSettingsSettingsNewClusterArgs']:
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional['GetJobJobSettingsSettingsNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['GetJobJobSettingsSettingsNotebookTaskArgs']:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional['GetJobJobSettingsSettingsNotebookTaskArgs']):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['GetJobJobSettingsSettingsNotificationSettingsArgs']:
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional['GetJobJobSettingsSettingsNotificationSettingsArgs']):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence['GetJobJobSettingsSettingsParameterArgs']]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['GetJobJobSettingsSettingsPipelineTaskArgs']:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional['GetJobJobSettingsSettingsPipelineTaskArgs']):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs']:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional['GetJobJobSettingsSettingsPythonWheelTaskArgs']):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter
    def queue(self) -> Optional['GetJobJobSettingsSettingsQueueArgs']:
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: Optional['GetJobJobSettingsSettingsQueueArgs']):
        pulumi.set(self, "queue", value)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[bool]:
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: Optional[bool]):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="runAs")
    def run_as(self) -> Optional['GetJobJobSettingsSettingsRunAsArgs']:
        return pulumi.get(self, "run_as")

    @run_as.setter
    def run_as(self, value: Optional['GetJobJobSettingsSettingsRunAsArgs']):
        pulumi.set(self, "run_as", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['GetJobJobSettingsSettingsRunJobTaskArgs']:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional['GetJobJobSettingsSettingsRunJobTaskArgs']):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional['GetJobJobSettingsSettingsScheduleArgs']:
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional['GetJobJobSettingsSettingsScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['GetJobJobSettingsSettingsSparkJarTaskArgs']:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional['GetJobJobSettingsSettingsSparkJarTaskArgs']):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs']:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional['GetJobJobSettingsSettingsSparkPythonTaskArgs']):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs']:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional['GetJobJobSettingsSettingsSparkSubmitTaskArgs']):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']]:
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskArgs']]):
        pulumi.set(self, "tasks", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[int]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter
    def trigger(self) -> Optional['GetJobJobSettingsSettingsTriggerArgs']:
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: Optional['GetJobJobSettingsSettingsTriggerArgs']):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs']:
        return pulumi.get(self, "webhook_notifications")

    @webhook_notifications.setter
    def webhook_notifications(self, value: Optional['GetJobJobSettingsSettingsWebhookNotificationsArgs']):
        pulumi.set(self, "webhook_notifications", value)


@pulumi.input_type
class GetJobJobSettingsSettingsComputeArgs:
    def __init__(__self__, *,
                 compute_key: Optional[str] = None,
                 spec: Optional['GetJobJobSettingsSettingsComputeSpecArgs'] = None):
        GetJobJobSettingsSettingsComputeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_key=compute_key,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_key: Optional[str] = None,
             spec: Optional['GetJobJobSettingsSettingsComputeSpecArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if compute_key is None and 'computeKey' in kwargs:
            compute_key = kwargs['computeKey']

        if compute_key is not None:
            _setter("compute_key", compute_key)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter(name="computeKey")
    def compute_key(self) -> Optional[str]:
        return pulumi.get(self, "compute_key")

    @compute_key.setter
    def compute_key(self, value: Optional[str]):
        pulumi.set(self, "compute_key", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional['GetJobJobSettingsSettingsComputeSpecArgs']:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional['GetJobJobSettingsSettingsComputeSpecArgs']):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class GetJobJobSettingsSettingsComputeSpecArgs:
    def __init__(__self__, *,
                 kind: Optional[str] = None):
        GetJobJobSettingsSettingsComputeSpecArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[str]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class GetJobJobSettingsSettingsContinuousArgs:
    def __init__(__self__, *,
                 pause_status: Optional[str] = None):
        GetJobJobSettingsSettingsContinuousArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pause_status=pause_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pause_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pause_status is None and 'pauseStatus' in kwargs:
            pause_status = kwargs['pauseStatus']

        if pause_status is not None:
            _setter("pause_status", pause_status)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[str]):
        pulumi.set(self, "pause_status", value)


@pulumi.input_type
class GetJobJobSettingsSettingsDbtTaskArgs:
    def __init__(__self__, *,
                 commands: Sequence[str],
                 catalog: Optional[str] = None,
                 profiles_directory: Optional[str] = None,
                 project_directory: Optional[str] = None,
                 schema: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        GetJobJobSettingsSettingsDbtTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            catalog=catalog,
            profiles_directory=profiles_directory,
            project_directory=project_directory,
            schema=schema,
            warehouse_id=warehouse_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[str]] = None,
             catalog: Optional[str] = None,
             profiles_directory: Optional[str] = None,
             project_directory: Optional[str] = None,
             schema: Optional[str] = None,
             warehouse_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if profiles_directory is None and 'profilesDirectory' in kwargs:
            profiles_directory = kwargs['profilesDirectory']
        if project_directory is None and 'projectDirectory' in kwargs:
            project_directory = kwargs['projectDirectory']
        if warehouse_id is None and 'warehouseId' in kwargs:
            warehouse_id = kwargs['warehouseId']

        _setter("commands", commands)
        if catalog is not None:
            _setter("catalog", catalog)
        if profiles_directory is not None:
            _setter("profiles_directory", profiles_directory)
        if project_directory is not None:
            _setter("project_directory", project_directory)
        if schema is not None:
            _setter("schema", schema)
        if warehouse_id is not None:
            _setter("warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[str]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[str]:
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[str]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[str]:
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[str]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsDeploymentArgs:
    def __init__(__self__, *,
                 kind: str,
                 metadata_file_path: Optional[str] = None):
        GetJobJobSettingsSettingsDeploymentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            metadata_file_path=metadata_file_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[str] = None,
             metadata_file_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if metadata_file_path is None and 'metadataFilePath' in kwargs:
            metadata_file_path = kwargs['metadataFilePath']

        _setter("kind", kind)
        if metadata_file_path is not None:
            _setter("metadata_file_path", metadata_file_path)

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[str]:
        return pulumi.get(self, "metadata_file_path")

    @metadata_file_path.setter
    def metadata_file_path(self, value: Optional[str]):
        pulumi.set(self, "metadata_file_path", value)


@pulumi.input_type
class GetJobJobSettingsSettingsEmailNotificationsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsEmailNotificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_on_last_attempt=alert_on_last_attempt,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
            on_duration_warning_threshold_exceededs=on_duration_warning_threshold_exceededs,
            on_failures=on_failures,
            on_starts=on_starts,
            on_successes=on_successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_on_last_attempt: Optional[bool] = None,
             no_alert_for_skipped_runs: Optional[bool] = None,
             on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
             on_failures: Optional[Sequence[str]] = None,
             on_starts: Optional[Sequence[str]] = None,
             on_successes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_on_last_attempt is None and 'alertOnLastAttempt' in kwargs:
            alert_on_last_attempt = kwargs['alertOnLastAttempt']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']
        if on_duration_warning_threshold_exceededs is None and 'onDurationWarningThresholdExceededs' in kwargs:
            on_duration_warning_threshold_exceededs = kwargs['onDurationWarningThresholdExceededs']
        if on_failures is None and 'onFailures' in kwargs:
            on_failures = kwargs['onFailures']
        if on_starts is None and 'onStarts' in kwargs:
            on_starts = kwargs['onStarts']
        if on_successes is None and 'onSuccesses' in kwargs:
            on_successes = kwargs['onSuccesses']

        if alert_on_last_attempt is not None:
            _setter("alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            _setter("on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            _setter("on_failures", on_failures)
        if on_starts is not None:
            _setter("on_starts", on_starts)
        if on_successes is not None:
            _setter("on_successes", on_successes)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[bool]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_successes", value)


@pulumi.input_type
class GetJobJobSettingsSettingsGitSourceArgs:
    def __init__(__self__, *,
                 url: str,
                 branch: Optional[str] = None,
                 commit: Optional[str] = None,
                 job_source: Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs'] = None,
                 provider: Optional[str] = None,
                 tag: Optional[str] = None):
        GetJobJobSettingsSettingsGitSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            branch=branch,
            commit=commit,
            job_source=job_source,
            provider=provider,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             branch: Optional[str] = None,
             commit: Optional[str] = None,
             job_source: Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs'] = None,
             provider: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if job_source is None and 'jobSource' in kwargs:
            job_source = kwargs['jobSource']

        _setter("url", url)
        if branch is not None:
            _setter("branch", branch)
        if commit is not None:
            _setter("commit", commit)
        if job_source is not None:
            _setter("job_source", job_source)
        if provider is not None:
            _setter("provider", provider)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[str]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def commit(self) -> Optional[str]:
        return pulumi.get(self, "commit")

    @commit.setter
    def commit(self, value: Optional[str]):
        pulumi.set(self, "commit", value)

    @property
    @pulumi.getter(name="jobSource")
    def job_source(self) -> Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs']:
        return pulumi.get(self, "job_source")

    @job_source.setter
    def job_source(self, value: Optional['GetJobJobSettingsSettingsGitSourceJobSourceArgs']):
        pulumi.set(self, "job_source", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[str]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class GetJobJobSettingsSettingsGitSourceJobSourceArgs:
    def __init__(__self__, *,
                 import_from_git_branch: str,
                 job_config_path: str,
                 dirty_state: Optional[str] = None):
        GetJobJobSettingsSettingsGitSourceJobSourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            import_from_git_branch=import_from_git_branch,
            job_config_path=job_config_path,
            dirty_state=dirty_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             import_from_git_branch: Optional[str] = None,
             job_config_path: Optional[str] = None,
             dirty_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if import_from_git_branch is None and 'importFromGitBranch' in kwargs:
            import_from_git_branch = kwargs['importFromGitBranch']
        if import_from_git_branch is None:
            raise TypeError("Missing 'import_from_git_branch' argument")
        if job_config_path is None and 'jobConfigPath' in kwargs:
            job_config_path = kwargs['jobConfigPath']
        if job_config_path is None:
            raise TypeError("Missing 'job_config_path' argument")
        if dirty_state is None and 'dirtyState' in kwargs:
            dirty_state = kwargs['dirtyState']

        _setter("import_from_git_branch", import_from_git_branch)
        _setter("job_config_path", job_config_path)
        if dirty_state is not None:
            _setter("dirty_state", dirty_state)

    @property
    @pulumi.getter(name="importFromGitBranch")
    def import_from_git_branch(self) -> str:
        return pulumi.get(self, "import_from_git_branch")

    @import_from_git_branch.setter
    def import_from_git_branch(self, value: str):
        pulumi.set(self, "import_from_git_branch", value)

    @property
    @pulumi.getter(name="jobConfigPath")
    def job_config_path(self) -> str:
        return pulumi.get(self, "job_config_path")

    @job_config_path.setter
    def job_config_path(self, value: str):
        pulumi.set(self, "job_config_path", value)

    @property
    @pulumi.getter(name="dirtyState")
    def dirty_state(self) -> Optional[str]:
        return pulumi.get(self, "dirty_state")

    @dirty_state.setter
    def dirty_state(self, value: Optional[str]):
        pulumi.set(self, "dirty_state", value)


@pulumi.input_type
class GetJobJobSettingsSettingsHealthArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetJobJobSettingsSettingsHealthRuleArgs']):
        GetJobJobSettingsSettingsHealthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['GetJobJobSettingsSettingsHealthRuleArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetJobJobSettingsSettingsHealthRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetJobJobSettingsSettingsHealthRuleArgs']):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class GetJobJobSettingsSettingsHealthRuleArgs:
    def __init__(__self__, *,
                 metric: Optional[str] = None,
                 op: Optional[str] = None,
                 value: Optional[int] = None):
        GetJobJobSettingsSettingsHealthRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            op=op,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: Optional[str] = None,
             op: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if metric is not None:
            _setter("metric", metric)
        if op is not None:
            _setter("op", op)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterArgs:
    def __init__(__self__, *,
                 job_cluster_key: Optional[str] = None,
                 new_cluster: Optional['GetJobJobSettingsSettingsJobClusterNewClusterArgs'] = None):
        GetJobJobSettingsSettingsJobClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_cluster_key=job_cluster_key,
            new_cluster=new_cluster,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_cluster_key: Optional[str] = None,
             new_cluster: Optional['GetJobJobSettingsSettingsJobClusterNewClusterArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if job_cluster_key is None and 'jobClusterKey' in kwargs:
            job_cluster_key = kwargs['jobClusterKey']
        if new_cluster is None and 'newCluster' in kwargs:
            new_cluster = kwargs['newCluster']

        if job_cluster_key is not None:
            _setter("job_cluster_key", job_cluster_key)
        if new_cluster is not None:
            _setter("new_cluster", new_cluster)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[str]:
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[str]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterArgs']:
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs'] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            node_type_id=node_type_id,
            num_workers=num_workers,
            spark_version=spark_version,
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_mount_infos=cluster_mount_infos,
            cluster_name=cluster_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            gcp_attributes=gcp_attributes,
            idempotency_token=idempotency_token,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             driver_instance_pool_id: Optional[str] = None,
             driver_node_type_id: Optional[str] = None,
             enable_elastic_disk: Optional[bool] = None,
             enable_local_disk_encryption: Optional[bool] = None,
             node_type_id: Optional[str] = None,
             num_workers: Optional[int] = None,
             spark_version: Optional[str] = None,
             apply_policy_default_values: Optional[bool] = None,
             autoscale: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs'] = None,
             autotermination_minutes: Optional[int] = None,
             aws_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs'] = None,
             azure_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs'] = None,
             cluster_id: Optional[str] = None,
             cluster_log_conf: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs'] = None,
             cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']] = None,
             cluster_name: Optional[str] = None,
             custom_tags: Optional[Mapping[str, Any]] = None,
             data_security_mode: Optional[str] = None,
             docker_image: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs'] = None,
             gcp_attributes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs'] = None,
             idempotency_token: Optional[str] = None,
             init_scripts: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']] = None,
             instance_pool_id: Optional[str] = None,
             policy_id: Optional[str] = None,
             runtime_engine: Optional[str] = None,
             single_user_name: Optional[str] = None,
             spark_conf: Optional[Mapping[str, Any]] = None,
             spark_env_vars: Optional[Mapping[str, Any]] = None,
             ssh_public_keys: Optional[Sequence[str]] = None,
             workload_type: Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_instance_pool_id is None:
            raise TypeError("Missing 'driver_instance_pool_id' argument")
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if driver_node_type_id is None:
            raise TypeError("Missing 'driver_node_type_id' argument")
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_elastic_disk is None:
            raise TypeError("Missing 'enable_elastic_disk' argument")
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if enable_local_disk_encryption is None:
            raise TypeError("Missing 'enable_local_disk_encryption' argument")
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if node_type_id is None:
            raise TypeError("Missing 'node_type_id' argument")
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if num_workers is None:
            raise TypeError("Missing 'num_workers' argument")
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_mount_infos is None and 'clusterMountInfos' in kwargs:
            cluster_mount_infos = kwargs['clusterMountInfos']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if idempotency_token is None and 'idempotencyToken' in kwargs:
            idempotency_token = kwargs['idempotencyToken']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("driver_instance_pool_id", driver_instance_pool_id)
        _setter("driver_node_type_id", driver_node_type_id)
        _setter("enable_elastic_disk", enable_elastic_disk)
        _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        _setter("node_type_id", node_type_id)
        _setter("num_workers", num_workers)
        _setter("spark_version", spark_version)
        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            _setter("cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            _setter("idempotency_token", idempotency_token)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[int] = None,
             min_workers: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             ebs_volume_count: Optional[int] = None,
             ebs_volume_size: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             instance_profile_arn: Optional[str] = None,
             spot_bid_price_percent: Optional[int] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             spot_bid_max_price: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args'] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs'] = None,
             s3: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[str] = None,
             network_filesystem_info: Optional['GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs'] = None,
             remote_mount_dir_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[str] = None,
             mount_options: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs'] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             basic_auth: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             boot_disk_size: Optional[int] = None,
             google_service_account: Optional[str] = None,
             local_ssd_count: Optional[int] = None,
             use_preemptible_executors: Optional[bool] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs'] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs'] = None,
             dbfs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs'] = None,
             file: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs'] = None,
             gcs: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs'] = None,
             s3: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args'] = None,
             volumes: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs'] = None,
             workspace: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs'):
        GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional['GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[bool] = None,
             notebooks: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class GetJobJobSettingsSettingsLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional['GetJobJobSettingsSettingsLibraryCranArgs'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['GetJobJobSettingsSettingsLibraryMavenArgs'] = None,
                 pypi: Optional['GetJobJobSettingsSettingsLibraryPypiArgs'] = None,
                 whl: Optional[str] = None):
        GetJobJobSettingsSettingsLibraryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cran=cran,
            egg=egg,
            jar=jar,
            maven=maven,
            pypi=pypi,
            whl=whl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cran: Optional['GetJobJobSettingsSettingsLibraryCranArgs'] = None,
             egg: Optional[str] = None,
             jar: Optional[str] = None,
             maven: Optional['GetJobJobSettingsSettingsLibraryMavenArgs'] = None,
             pypi: Optional['GetJobJobSettingsSettingsLibraryPypiArgs'] = None,
             whl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cran is not None:
            _setter("cran", cran)
        if egg is not None:
            _setter("egg", egg)
        if jar is not None:
            _setter("jar", jar)
        if maven is not None:
            _setter("maven", maven)
        if pypi is not None:
            _setter("pypi", pypi)
        if whl is not None:
            _setter("whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['GetJobJobSettingsSettingsLibraryCranArgs']:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional['GetJobJobSettingsSettingsLibraryCranArgs']):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[str]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[str]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional['GetJobJobSettingsSettingsLibraryMavenArgs']:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional['GetJobJobSettingsSettingsLibraryMavenArgs']):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional['GetJobJobSettingsSettingsLibraryPypiArgs']:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional['GetJobJobSettingsSettingsLibraryPypiArgs']):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[str]):
        pulumi.set(self, "whl", value)


@pulumi.input_type
class GetJobJobSettingsSettingsLibraryCranArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        GetJobJobSettingsSettingsLibraryCranArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[str] = None,
             repo: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class GetJobJobSettingsSettingsLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        GetJobJobSettingsSettingsLibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             repo: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: str):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class GetJobJobSettingsSettingsLibraryPypiArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        GetJobJobSettingsSettingsLibraryPypiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[str] = None,
             repo: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs'] = None):
        GetJobJobSettingsSettingsNewClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            node_type_id=node_type_id,
            num_workers=num_workers,
            spark_version=spark_version,
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_mount_infos=cluster_mount_infos,
            cluster_name=cluster_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            gcp_attributes=gcp_attributes,
            idempotency_token=idempotency_token,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             driver_instance_pool_id: Optional[str] = None,
             driver_node_type_id: Optional[str] = None,
             enable_elastic_disk: Optional[bool] = None,
             enable_local_disk_encryption: Optional[bool] = None,
             node_type_id: Optional[str] = None,
             num_workers: Optional[int] = None,
             spark_version: Optional[str] = None,
             apply_policy_default_values: Optional[bool] = None,
             autoscale: Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs'] = None,
             autotermination_minutes: Optional[int] = None,
             aws_attributes: Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs'] = None,
             azure_attributes: Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs'] = None,
             cluster_id: Optional[str] = None,
             cluster_log_conf: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs'] = None,
             cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']] = None,
             cluster_name: Optional[str] = None,
             custom_tags: Optional[Mapping[str, Any]] = None,
             data_security_mode: Optional[str] = None,
             docker_image: Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs'] = None,
             gcp_attributes: Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs'] = None,
             idempotency_token: Optional[str] = None,
             init_scripts: Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']] = None,
             instance_pool_id: Optional[str] = None,
             policy_id: Optional[str] = None,
             runtime_engine: Optional[str] = None,
             single_user_name: Optional[str] = None,
             spark_conf: Optional[Mapping[str, Any]] = None,
             spark_env_vars: Optional[Mapping[str, Any]] = None,
             ssh_public_keys: Optional[Sequence[str]] = None,
             workload_type: Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_instance_pool_id is None:
            raise TypeError("Missing 'driver_instance_pool_id' argument")
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if driver_node_type_id is None:
            raise TypeError("Missing 'driver_node_type_id' argument")
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_elastic_disk is None:
            raise TypeError("Missing 'enable_elastic_disk' argument")
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if enable_local_disk_encryption is None:
            raise TypeError("Missing 'enable_local_disk_encryption' argument")
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if node_type_id is None:
            raise TypeError("Missing 'node_type_id' argument")
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if num_workers is None:
            raise TypeError("Missing 'num_workers' argument")
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_mount_infos is None and 'clusterMountInfos' in kwargs:
            cluster_mount_infos = kwargs['clusterMountInfos']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if idempotency_token is None and 'idempotencyToken' in kwargs:
            idempotency_token = kwargs['idempotencyToken']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("driver_instance_pool_id", driver_instance_pool_id)
        _setter("driver_node_type_id", driver_node_type_id)
        _setter("enable_elastic_disk", enable_elastic_disk)
        _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        _setter("node_type_id", node_type_id)
        _setter("num_workers", num_workers)
        _setter("spark_version", spark_version)
        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            _setter("cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            _setter("idempotency_token", idempotency_token)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        GetJobJobSettingsSettingsNewClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[int] = None,
             min_workers: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             ebs_volume_count: Optional[int] = None,
             ebs_volume_size: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             instance_profile_arn: Optional[str] = None,
             spot_bid_price_percent: Optional[int] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        GetJobJobSettingsSettingsNewClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             spot_bid_max_price: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args'] = None):
        GetJobJobSettingsSettingsNewClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs'] = None,
             s3: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[str] = None,
             network_filesystem_info: Optional['GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs'] = None,
             remote_mount_dir_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[str] = None,
             mount_options: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs'] = None):
        GetJobJobSettingsSettingsNewClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             basic_auth: Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             boot_disk_size: Optional[int] = None,
             google_service_account: Optional[str] = None,
             local_ssd_count: Optional[int] = None,
             use_preemptible_executors: Optional[bool] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs'] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs'] = None,
             dbfs: Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs'] = None,
             file: Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs'] = None,
             gcs: Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs'] = None,
             s3: Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args'] = None,
             volumes: Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs'] = None,
             workspace: Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetJobJobSettingsSettingsNewClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs'):
        GetJobJobSettingsSettingsNewClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional['GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[bool] = None,
             notebooks: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, Any]] = None,
                 source: Optional[str] = None):
        GetJobJobSettingsSettingsNotebookTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notebook_path=notebook_path,
            base_parameters=base_parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notebook_path: Optional[str] = None,
             base_parameters: Optional[Mapping[str, Any]] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if notebook_path is None and 'notebookPath' in kwargs:
            notebook_path = kwargs['notebookPath']
        if notebook_path is None:
            raise TypeError("Missing 'notebook_path' argument")
        if base_parameters is None and 'baseParameters' in kwargs:
            base_parameters = kwargs['baseParameters']

        _setter("notebook_path", notebook_path)
        if base_parameters is not None:
            _setter("base_parameters", base_parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: str):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class GetJobJobSettingsSettingsNotificationSettingsArgs:
    def __init__(__self__, *,
                 no_alert_for_canceled_runs: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None):
        GetJobJobSettingsSettingsNotificationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            no_alert_for_canceled_runs=no_alert_for_canceled_runs,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             no_alert_for_canceled_runs: Optional[bool] = None,
             no_alert_for_skipped_runs: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if no_alert_for_canceled_runs is None and 'noAlertForCanceledRuns' in kwargs:
            no_alert_for_canceled_runs = kwargs['noAlertForCanceledRuns']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']

        if no_alert_for_canceled_runs is not None:
            _setter("no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


@pulumi.input_type
class GetJobJobSettingsSettingsParameterArgs:
    def __init__(__self__, *,
                 default: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str name: the job name of Job if the resource was matched by id.
        """
        GetJobJobSettingsSettingsParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default=default,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if default is not None:
            _setter("default", default)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[str]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetJobJobSettingsSettingsPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: str,
                 full_refresh: Optional[bool] = None):
        GetJobJobSettingsSettingsPipelineTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_id=pipeline_id,
            full_refresh=full_refresh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_id: Optional[str] = None,
             full_refresh: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if pipeline_id is None:
            raise TypeError("Missing 'pipeline_id' argument")
        if full_refresh is None and 'fullRefresh' in kwargs:
            full_refresh = kwargs['fullRefresh']

        _setter("pipeline_id", pipeline_id)
        if full_refresh is not None:
            _setter("full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: str):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[bool]:
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[bool]):
        pulumi.set(self, "full_refresh", value)


@pulumi.input_type
class GetJobJobSettingsSettingsPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, Any]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsPythonWheelTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entry_point=entry_point,
            named_parameters=named_parameters,
            package_name=package_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entry_point: Optional[str] = None,
             named_parameters: Optional[Mapping[str, Any]] = None,
             package_name: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if entry_point is None and 'entryPoint' in kwargs:
            entry_point = kwargs['entryPoint']
        if named_parameters is None and 'namedParameters' in kwargs:
            named_parameters = kwargs['namedParameters']
        if package_name is None and 'packageName' in kwargs:
            package_name = kwargs['packageName']

        if entry_point is not None:
            _setter("entry_point", entry_point)
        if named_parameters is not None:
            _setter("named_parameters", named_parameters)
        if package_name is not None:
            _setter("package_name", package_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[str]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsQueueArgs:
    def __init__(__self__, *,
                 enabled: bool):
        GetJobJobSettingsSettingsQueueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class GetJobJobSettingsSettingsRunAsArgs:
    def __init__(__self__, *,
                 service_principal_name: Optional[str] = None,
                 user_name: Optional[str] = None):
        GetJobJobSettingsSettingsRunAsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            service_principal_name=service_principal_name,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             service_principal_name: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if service_principal_name is None and 'servicePrincipalName' in kwargs:
            service_principal_name = kwargs['servicePrincipalName']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if service_principal_name is not None:
            _setter("service_principal_name", service_principal_name)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[str]:
        return pulumi.get(self, "service_principal_name")

    @service_principal_name.setter
    def service_principal_name(self, value: Optional[str]):
        pulumi.set(self, "service_principal_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class GetJobJobSettingsSettingsRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: int,
                 job_parameters: Optional[Mapping[str, Any]] = None):
        GetJobJobSettingsSettingsRunJobTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_id=job_id,
            job_parameters=job_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_id: Optional[int] = None,
             job_parameters: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']
        if job_id is None:
            raise TypeError("Missing 'job_id' argument")
        if job_parameters is None and 'jobParameters' in kwargs:
            job_parameters = kwargs['jobParameters']

        _setter("job_id", job_id)
        if job_parameters is not None:
            _setter("job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: int):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "job_parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsScheduleArgs:
    def __init__(__self__, *,
                 quartz_cron_expression: str,
                 timezone_id: str,
                 pause_status: Optional[str] = None):
        GetJobJobSettingsSettingsScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            quartz_cron_expression=quartz_cron_expression,
            timezone_id=timezone_id,
            pause_status=pause_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             quartz_cron_expression: Optional[str] = None,
             timezone_id: Optional[str] = None,
             pause_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if quartz_cron_expression is None and 'quartzCronExpression' in kwargs:
            quartz_cron_expression = kwargs['quartzCronExpression']
        if quartz_cron_expression is None:
            raise TypeError("Missing 'quartz_cron_expression' argument")
        if timezone_id is None and 'timezoneId' in kwargs:
            timezone_id = kwargs['timezoneId']
        if timezone_id is None:
            raise TypeError("Missing 'timezone_id' argument")
        if pause_status is None and 'pauseStatus' in kwargs:
            pause_status = kwargs['pauseStatus']

        _setter("quartz_cron_expression", quartz_cron_expression)
        _setter("timezone_id", timezone_id)
        if pause_status is not None:
            _setter("pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> str:
        return pulumi.get(self, "quartz_cron_expression")

    @quartz_cron_expression.setter
    def quartz_cron_expression(self, value: str):
        pulumi.set(self, "quartz_cron_expression", value)

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> str:
        return pulumi.get(self, "timezone_id")

    @timezone_id.setter
    def timezone_id(self, value: str):
        pulumi.set(self, "timezone_id", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[str]):
        pulumi.set(self, "pause_status", value)


@pulumi.input_type
class GetJobJobSettingsSettingsSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsSparkJarTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jar_uri=jar_uri,
            main_class_name=main_class_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jar_uri: Optional[str] = None,
             main_class_name: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if jar_uri is None and 'jarUri' in kwargs:
            jar_uri = kwargs['jarUri']
        if main_class_name is None and 'mainClassName' in kwargs:
            main_class_name = kwargs['mainClassName']

        if jar_uri is not None:
            _setter("jar_uri", jar_uri)
        if main_class_name is not None:
            _setter("main_class_name", main_class_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[str]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[str]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None,
                 source: Optional[str] = None):
        GetJobJobSettingsSettingsSparkPythonTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            python_file=python_file,
            parameters=parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             python_file: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if python_file is None and 'pythonFile' in kwargs:
            python_file = kwargs['pythonFile']
        if python_file is None:
            raise TypeError("Missing 'python_file' argument")

        _setter("python_file", python_file)
        if parameters is not None:
            _setter("parameters", parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: str):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class GetJobJobSettingsSettingsSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsSparkSubmitTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskArgs:
    def __init__(__self__, *,
                 retry_on_timeout: bool,
                 compute_key: Optional[str] = None,
                 condition_task: Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs'] = None,
                 dbt_task: Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs'] = None,
                 depends_ons: Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']] = None,
                 description: Optional[str] = None,
                 email_notifications: Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs'] = None,
                 existing_cluster_id: Optional[str] = None,
                 health: Optional['GetJobJobSettingsSettingsTaskHealthArgs'] = None,
                 job_cluster_key: Optional[str] = None,
                 libraries: Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']] = None,
                 max_retries: Optional[int] = None,
                 min_retry_interval_millis: Optional[int] = None,
                 new_cluster: Optional['GetJobJobSettingsSettingsTaskNewClusterArgs'] = None,
                 notebook_task: Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs'] = None,
                 notification_settings: Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs'] = None,
                 pipeline_task: Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs'] = None,
                 python_wheel_task: Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs'] = None,
                 run_if: Optional[str] = None,
                 run_job_task: Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs'] = None,
                 spark_jar_task: Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs'] = None,
                 spark_python_task: Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs'] = None,
                 spark_submit_task: Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs'] = None,
                 sql_task: Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs'] = None,
                 task_key: Optional[str] = None,
                 timeout_seconds: Optional[int] = None):
        GetJobJobSettingsSettingsTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            retry_on_timeout=retry_on_timeout,
            compute_key=compute_key,
            condition_task=condition_task,
            dbt_task=dbt_task,
            depends_ons=depends_ons,
            description=description,
            email_notifications=email_notifications,
            existing_cluster_id=existing_cluster_id,
            health=health,
            job_cluster_key=job_cluster_key,
            libraries=libraries,
            max_retries=max_retries,
            min_retry_interval_millis=min_retry_interval_millis,
            new_cluster=new_cluster,
            notebook_task=notebook_task,
            notification_settings=notification_settings,
            pipeline_task=pipeline_task,
            python_wheel_task=python_wheel_task,
            run_if=run_if,
            run_job_task=run_job_task,
            spark_jar_task=spark_jar_task,
            spark_python_task=spark_python_task,
            spark_submit_task=spark_submit_task,
            sql_task=sql_task,
            task_key=task_key,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             retry_on_timeout: Optional[bool] = None,
             compute_key: Optional[str] = None,
             condition_task: Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs'] = None,
             dbt_task: Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs'] = None,
             depends_ons: Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']] = None,
             description: Optional[str] = None,
             email_notifications: Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs'] = None,
             existing_cluster_id: Optional[str] = None,
             health: Optional['GetJobJobSettingsSettingsTaskHealthArgs'] = None,
             job_cluster_key: Optional[str] = None,
             libraries: Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']] = None,
             max_retries: Optional[int] = None,
             min_retry_interval_millis: Optional[int] = None,
             new_cluster: Optional['GetJobJobSettingsSettingsTaskNewClusterArgs'] = None,
             notebook_task: Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs'] = None,
             notification_settings: Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs'] = None,
             pipeline_task: Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs'] = None,
             python_wheel_task: Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs'] = None,
             run_if: Optional[str] = None,
             run_job_task: Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs'] = None,
             spark_jar_task: Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs'] = None,
             spark_python_task: Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs'] = None,
             spark_submit_task: Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs'] = None,
             sql_task: Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs'] = None,
             task_key: Optional[str] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if retry_on_timeout is None and 'retryOnTimeout' in kwargs:
            retry_on_timeout = kwargs['retryOnTimeout']
        if retry_on_timeout is None:
            raise TypeError("Missing 'retry_on_timeout' argument")
        if compute_key is None and 'computeKey' in kwargs:
            compute_key = kwargs['computeKey']
        if condition_task is None and 'conditionTask' in kwargs:
            condition_task = kwargs['conditionTask']
        if dbt_task is None and 'dbtTask' in kwargs:
            dbt_task = kwargs['dbtTask']
        if depends_ons is None and 'dependsOns' in kwargs:
            depends_ons = kwargs['dependsOns']
        if email_notifications is None and 'emailNotifications' in kwargs:
            email_notifications = kwargs['emailNotifications']
        if existing_cluster_id is None and 'existingClusterId' in kwargs:
            existing_cluster_id = kwargs['existingClusterId']
        if job_cluster_key is None and 'jobClusterKey' in kwargs:
            job_cluster_key = kwargs['jobClusterKey']
        if max_retries is None and 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if min_retry_interval_millis is None and 'minRetryIntervalMillis' in kwargs:
            min_retry_interval_millis = kwargs['minRetryIntervalMillis']
        if new_cluster is None and 'newCluster' in kwargs:
            new_cluster = kwargs['newCluster']
        if notebook_task is None and 'notebookTask' in kwargs:
            notebook_task = kwargs['notebookTask']
        if notification_settings is None and 'notificationSettings' in kwargs:
            notification_settings = kwargs['notificationSettings']
        if pipeline_task is None and 'pipelineTask' in kwargs:
            pipeline_task = kwargs['pipelineTask']
        if python_wheel_task is None and 'pythonWheelTask' in kwargs:
            python_wheel_task = kwargs['pythonWheelTask']
        if run_if is None and 'runIf' in kwargs:
            run_if = kwargs['runIf']
        if run_job_task is None and 'runJobTask' in kwargs:
            run_job_task = kwargs['runJobTask']
        if spark_jar_task is None and 'sparkJarTask' in kwargs:
            spark_jar_task = kwargs['sparkJarTask']
        if spark_python_task is None and 'sparkPythonTask' in kwargs:
            spark_python_task = kwargs['sparkPythonTask']
        if spark_submit_task is None and 'sparkSubmitTask' in kwargs:
            spark_submit_task = kwargs['sparkSubmitTask']
        if sql_task is None and 'sqlTask' in kwargs:
            sql_task = kwargs['sqlTask']
        if task_key is None and 'taskKey' in kwargs:
            task_key = kwargs['taskKey']
        if timeout_seconds is None and 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        _setter("retry_on_timeout", retry_on_timeout)
        if compute_key is not None:
            _setter("compute_key", compute_key)
        if condition_task is not None:
            _setter("condition_task", condition_task)
        if dbt_task is not None:
            _setter("dbt_task", dbt_task)
        if depends_ons is not None:
            _setter("depends_ons", depends_ons)
        if description is not None:
            _setter("description", description)
        if email_notifications is not None:
            _setter("email_notifications", email_notifications)
        if existing_cluster_id is not None:
            _setter("existing_cluster_id", existing_cluster_id)
        if health is not None:
            _setter("health", health)
        if job_cluster_key is not None:
            _setter("job_cluster_key", job_cluster_key)
        if libraries is not None:
            _setter("libraries", libraries)
        if max_retries is not None:
            _setter("max_retries", max_retries)
        if min_retry_interval_millis is not None:
            _setter("min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            _setter("new_cluster", new_cluster)
        if notebook_task is not None:
            _setter("notebook_task", notebook_task)
        if notification_settings is not None:
            _setter("notification_settings", notification_settings)
        if pipeline_task is not None:
            _setter("pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            _setter("python_wheel_task", python_wheel_task)
        if run_if is not None:
            _setter("run_if", run_if)
        if run_job_task is not None:
            _setter("run_job_task", run_job_task)
        if spark_jar_task is not None:
            _setter("spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            _setter("spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            _setter("spark_submit_task", spark_submit_task)
        if sql_task is not None:
            _setter("sql_task", sql_task)
        if task_key is not None:
            _setter("task_key", task_key)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> bool:
        return pulumi.get(self, "retry_on_timeout")

    @retry_on_timeout.setter
    def retry_on_timeout(self, value: bool):
        pulumi.set(self, "retry_on_timeout", value)

    @property
    @pulumi.getter(name="computeKey")
    def compute_key(self) -> Optional[str]:
        return pulumi.get(self, "compute_key")

    @compute_key.setter
    def compute_key(self, value: Optional[str]):
        pulumi.set(self, "compute_key", value)

    @property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs']:
        return pulumi.get(self, "condition_task")

    @condition_task.setter
    def condition_task(self, value: Optional['GetJobJobSettingsSettingsTaskConditionTaskArgs']):
        pulumi.set(self, "condition_task", value)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs']:
        return pulumi.get(self, "dbt_task")

    @dbt_task.setter
    def dbt_task(self, value: Optional['GetJobJobSettingsSettingsTaskDbtTaskArgs']):
        pulumi.set(self, "dbt_task", value)

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']]:
        return pulumi.get(self, "depends_ons")

    @depends_ons.setter
    def depends_ons(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskDependsOnArgs']]):
        pulumi.set(self, "depends_ons", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs']:
        return pulumi.get(self, "email_notifications")

    @email_notifications.setter
    def email_notifications(self, value: Optional['GetJobJobSettingsSettingsTaskEmailNotificationsArgs']):
        pulumi.set(self, "email_notifications", value)

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "existing_cluster_id")

    @existing_cluster_id.setter
    def existing_cluster_id(self, value: Optional[str]):
        pulumi.set(self, "existing_cluster_id", value)

    @property
    @pulumi.getter
    def health(self) -> Optional['GetJobJobSettingsSettingsTaskHealthArgs']:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional['GetJobJobSettingsSettingsTaskHealthArgs']):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[str]:
        return pulumi.get(self, "job_cluster_key")

    @job_cluster_key.setter
    def job_cluster_key(self, value: Optional[str]):
        pulumi.set(self, "job_cluster_key", value)

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']]:
        return pulumi.get(self, "libraries")

    @libraries.setter
    def libraries(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskLibraryArgs']]):
        pulumi.set(self, "libraries", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @min_retry_interval_millis.setter
    def min_retry_interval_millis(self, value: Optional[int]):
        pulumi.set(self, "min_retry_interval_millis", value)

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterArgs']:
        return pulumi.get(self, "new_cluster")

    @new_cluster.setter
    def new_cluster(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterArgs']):
        pulumi.set(self, "new_cluster", value)

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs']:
        return pulumi.get(self, "notebook_task")

    @notebook_task.setter
    def notebook_task(self, value: Optional['GetJobJobSettingsSettingsTaskNotebookTaskArgs']):
        pulumi.set(self, "notebook_task", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs']:
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: Optional['GetJobJobSettingsSettingsTaskNotificationSettingsArgs']):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs']:
        return pulumi.get(self, "pipeline_task")

    @pipeline_task.setter
    def pipeline_task(self, value: Optional['GetJobJobSettingsSettingsTaskPipelineTaskArgs']):
        pulumi.set(self, "pipeline_task", value)

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs']:
        return pulumi.get(self, "python_wheel_task")

    @python_wheel_task.setter
    def python_wheel_task(self, value: Optional['GetJobJobSettingsSettingsTaskPythonWheelTaskArgs']):
        pulumi.set(self, "python_wheel_task", value)

    @property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[str]:
        return pulumi.get(self, "run_if")

    @run_if.setter
    def run_if(self, value: Optional[str]):
        pulumi.set(self, "run_if", value)

    @property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs']:
        return pulumi.get(self, "run_job_task")

    @run_job_task.setter
    def run_job_task(self, value: Optional['GetJobJobSettingsSettingsTaskRunJobTaskArgs']):
        pulumi.set(self, "run_job_task", value)

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs']:
        return pulumi.get(self, "spark_jar_task")

    @spark_jar_task.setter
    def spark_jar_task(self, value: Optional['GetJobJobSettingsSettingsTaskSparkJarTaskArgs']):
        pulumi.set(self, "spark_jar_task", value)

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs']:
        return pulumi.get(self, "spark_python_task")

    @spark_python_task.setter
    def spark_python_task(self, value: Optional['GetJobJobSettingsSettingsTaskSparkPythonTaskArgs']):
        pulumi.set(self, "spark_python_task", value)

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs']:
        return pulumi.get(self, "spark_submit_task")

    @spark_submit_task.setter
    def spark_submit_task(self, value: Optional['GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs']):
        pulumi.set(self, "spark_submit_task", value)

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs']:
        return pulumi.get(self, "sql_task")

    @sql_task.setter
    def sql_task(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskArgs']):
        pulumi.set(self, "sql_task", value)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> Optional[str]:
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: Optional[str]):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[int]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskConditionTaskArgs:
    def __init__(__self__, *,
                 left: Optional[str] = None,
                 op: Optional[str] = None,
                 right: Optional[str] = None):
        GetJobJobSettingsSettingsTaskConditionTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            left=left,
            op=op,
            right=right,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             left: Optional[str] = None,
             op: Optional[str] = None,
             right: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if left is not None:
            _setter("left", left)
        if op is not None:
            _setter("op", op)
        if right is not None:
            _setter("right", right)

    @property
    @pulumi.getter
    def left(self) -> Optional[str]:
        return pulumi.get(self, "left")

    @left.setter
    def left(self, value: Optional[str]):
        pulumi.set(self, "left", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def right(self) -> Optional[str]:
        return pulumi.get(self, "right")

    @right.setter
    def right(self, value: Optional[str]):
        pulumi.set(self, "right", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskDbtTaskArgs:
    def __init__(__self__, *,
                 commands: Sequence[str],
                 catalog: Optional[str] = None,
                 profiles_directory: Optional[str] = None,
                 project_directory: Optional[str] = None,
                 schema: Optional[str] = None,
                 warehouse_id: Optional[str] = None):
        GetJobJobSettingsSettingsTaskDbtTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            catalog=catalog,
            profiles_directory=profiles_directory,
            project_directory=project_directory,
            schema=schema,
            warehouse_id=warehouse_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence[str]] = None,
             catalog: Optional[str] = None,
             profiles_directory: Optional[str] = None,
             project_directory: Optional[str] = None,
             schema: Optional[str] = None,
             warehouse_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if profiles_directory is None and 'profilesDirectory' in kwargs:
            profiles_directory = kwargs['profilesDirectory']
        if project_directory is None and 'projectDirectory' in kwargs:
            project_directory = kwargs['projectDirectory']
        if warehouse_id is None and 'warehouseId' in kwargs:
            warehouse_id = kwargs['warehouseId']

        _setter("commands", commands)
        if catalog is not None:
            _setter("catalog", catalog)
        if profiles_directory is not None:
            _setter("profiles_directory", profiles_directory)
        if project_directory is not None:
            _setter("project_directory", project_directory)
        if schema is not None:
            _setter("schema", schema)
        if warehouse_id is not None:
            _setter("warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[str]):
        pulumi.set(self, "commands", value)

    @property
    @pulumi.getter
    def catalog(self) -> Optional[str]:
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: Optional[str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[str]:
        return pulumi.get(self, "profiles_directory")

    @profiles_directory.setter
    def profiles_directory(self, value: Optional[str]):
        pulumi.set(self, "profiles_directory", value)

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[str]:
        return pulumi.get(self, "project_directory")

    @project_directory.setter
    def project_directory(self, value: Optional[str]):
        pulumi.set(self, "project_directory", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskDependsOnArgs:
    def __init__(__self__, *,
                 task_key: str,
                 outcome: Optional[str] = None):
        GetJobJobSettingsSettingsTaskDependsOnArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            task_key=task_key,
            outcome=outcome,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             task_key: Optional[str] = None,
             outcome: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if task_key is None and 'taskKey' in kwargs:
            task_key = kwargs['taskKey']
        if task_key is None:
            raise TypeError("Missing 'task_key' argument")

        _setter("task_key", task_key)
        if outcome is not None:
            _setter("outcome", outcome)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> str:
        return pulumi.get(self, "task_key")

    @task_key.setter
    def task_key(self, value: str):
        pulumi.set(self, "task_key", value)

    @property
    @pulumi.getter
    def outcome(self) -> Optional[str]:
        return pulumi.get(self, "outcome")

    @outcome.setter
    def outcome(self, value: Optional[str]):
        pulumi.set(self, "outcome", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskEmailNotificationsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsTaskEmailNotificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_on_last_attempt=alert_on_last_attempt,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
            on_duration_warning_threshold_exceededs=on_duration_warning_threshold_exceededs,
            on_failures=on_failures,
            on_starts=on_starts,
            on_successes=on_successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_on_last_attempt: Optional[bool] = None,
             no_alert_for_skipped_runs: Optional[bool] = None,
             on_duration_warning_threshold_exceededs: Optional[Sequence[str]] = None,
             on_failures: Optional[Sequence[str]] = None,
             on_starts: Optional[Sequence[str]] = None,
             on_successes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_on_last_attempt is None and 'alertOnLastAttempt' in kwargs:
            alert_on_last_attempt = kwargs['alertOnLastAttempt']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']
        if on_duration_warning_threshold_exceededs is None and 'onDurationWarningThresholdExceededs' in kwargs:
            on_duration_warning_threshold_exceededs = kwargs['onDurationWarningThresholdExceededs']
        if on_failures is None and 'onFailures' in kwargs:
            on_failures = kwargs['onFailures']
        if on_starts is None and 'onStarts' in kwargs:
            on_starts = kwargs['onStarts']
        if on_successes is None and 'onSuccesses' in kwargs:
            on_successes = kwargs['onSuccesses']

        if alert_on_last_attempt is not None:
            _setter("alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            _setter("on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            _setter("on_failures", on_failures)
        if on_starts is not None:
            _setter("on_starts", on_starts)
        if on_successes is not None:
            _setter("on_successes", on_successes)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[bool]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "on_successes", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskHealthArgs:
    def __init__(__self__, *,
                 rules: Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']):
        GetJobJobSettingsSettingsTaskHealthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Sequence['GetJobJobSettingsSettingsTaskHealthRuleArgs']):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskHealthRuleArgs:
    def __init__(__self__, *,
                 metric: Optional[str] = None,
                 op: Optional[str] = None,
                 value: Optional[int] = None):
        GetJobJobSettingsSettingsTaskHealthRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            op=op,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: Optional[str] = None,
             op: Optional[str] = None,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if metric is not None:
            _setter("metric", metric)
        if op is not None:
            _setter("op", op)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryArgs:
    def __init__(__self__, *,
                 cran: Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs'] = None,
                 pypi: Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs'] = None,
                 whl: Optional[str] = None):
        GetJobJobSettingsSettingsTaskLibraryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cran=cran,
            egg=egg,
            jar=jar,
            maven=maven,
            pypi=pypi,
            whl=whl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cran: Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs'] = None,
             egg: Optional[str] = None,
             jar: Optional[str] = None,
             maven: Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs'] = None,
             pypi: Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs'] = None,
             whl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cran is not None:
            _setter("cran", cran)
        if egg is not None:
            _setter("egg", egg)
        if jar is not None:
            _setter("jar", jar)
        if maven is not None:
            _setter("maven", maven)
        if pypi is not None:
            _setter("pypi", pypi)
        if whl is not None:
            _setter("whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs']:
        return pulumi.get(self, "cran")

    @cran.setter
    def cran(self, value: Optional['GetJobJobSettingsSettingsTaskLibraryCranArgs']):
        pulumi.set(self, "cran", value)

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @egg.setter
    def egg(self, value: Optional[str]):
        pulumi.set(self, "egg", value)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @jar.setter
    def jar(self, value: Optional[str]):
        pulumi.set(self, "jar", value)

    @property
    @pulumi.getter
    def maven(self) -> Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs']:
        return pulumi.get(self, "maven")

    @maven.setter
    def maven(self, value: Optional['GetJobJobSettingsSettingsTaskLibraryMavenArgs']):
        pulumi.set(self, "maven", value)

    @property
    @pulumi.getter
    def pypi(self) -> Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs']:
        return pulumi.get(self, "pypi")

    @pypi.setter
    def pypi(self, value: Optional['GetJobJobSettingsSettingsTaskLibraryPypiArgs']):
        pulumi.set(self, "pypi", value)

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")

    @whl.setter
    def whl(self, value: Optional[str]):
        pulumi.set(self, "whl", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryCranArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        GetJobJobSettingsSettingsTaskLibraryCranArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[str] = None,
             repo: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryMavenArgs:
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        GetJobJobSettingsSettingsTaskLibraryMavenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            coordinates=coordinates,
            exclusions=exclusions,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             coordinates: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             repo: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if coordinates is None:
            raise TypeError("Missing 'coordinates' argument")

        _setter("coordinates", coordinates)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @coordinates.setter
    def coordinates(self, value: str):
        pulumi.set(self, "coordinates", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskLibraryPypiArgs:
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        GetJobJobSettingsSettingsTaskLibraryPypiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package=package,
            repo=repo,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package: Optional[str] = None,
             repo: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if package is None:
            raise TypeError("Missing 'package' argument")

        _setter("package", package)
        if repo is not None:
            _setter("repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: str):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[str]):
        pulumi.set(self, "repo", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterArgs:
    def __init__(__self__, *,
                 driver_instance_pool_id: str,
                 driver_node_type_id: str,
                 enable_elastic_disk: bool,
                 enable_local_disk_encryption: bool,
                 node_type_id: str,
                 num_workers: int,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs'] = None,
                 azure_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs'] = None,
                 cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs'] = None,
                 gcp_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']] = None,
                 instance_pool_id: Optional[str] = None,
                 policy_id: Optional[str] = None,
                 runtime_engine: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs'] = None):
        GetJobJobSettingsSettingsTaskNewClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            driver_instance_pool_id=driver_instance_pool_id,
            driver_node_type_id=driver_node_type_id,
            enable_elastic_disk=enable_elastic_disk,
            enable_local_disk_encryption=enable_local_disk_encryption,
            node_type_id=node_type_id,
            num_workers=num_workers,
            spark_version=spark_version,
            apply_policy_default_values=apply_policy_default_values,
            autoscale=autoscale,
            autotermination_minutes=autotermination_minutes,
            aws_attributes=aws_attributes,
            azure_attributes=azure_attributes,
            cluster_id=cluster_id,
            cluster_log_conf=cluster_log_conf,
            cluster_mount_infos=cluster_mount_infos,
            cluster_name=cluster_name,
            custom_tags=custom_tags,
            data_security_mode=data_security_mode,
            docker_image=docker_image,
            gcp_attributes=gcp_attributes,
            idempotency_token=idempotency_token,
            init_scripts=init_scripts,
            instance_pool_id=instance_pool_id,
            policy_id=policy_id,
            runtime_engine=runtime_engine,
            single_user_name=single_user_name,
            spark_conf=spark_conf,
            spark_env_vars=spark_env_vars,
            ssh_public_keys=ssh_public_keys,
            workload_type=workload_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             driver_instance_pool_id: Optional[str] = None,
             driver_node_type_id: Optional[str] = None,
             enable_elastic_disk: Optional[bool] = None,
             enable_local_disk_encryption: Optional[bool] = None,
             node_type_id: Optional[str] = None,
             num_workers: Optional[int] = None,
             spark_version: Optional[str] = None,
             apply_policy_default_values: Optional[bool] = None,
             autoscale: Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs'] = None,
             autotermination_minutes: Optional[int] = None,
             aws_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs'] = None,
             azure_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs'] = None,
             cluster_id: Optional[str] = None,
             cluster_log_conf: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs'] = None,
             cluster_mount_infos: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']] = None,
             cluster_name: Optional[str] = None,
             custom_tags: Optional[Mapping[str, Any]] = None,
             data_security_mode: Optional[str] = None,
             docker_image: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs'] = None,
             gcp_attributes: Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs'] = None,
             idempotency_token: Optional[str] = None,
             init_scripts: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']] = None,
             instance_pool_id: Optional[str] = None,
             policy_id: Optional[str] = None,
             runtime_engine: Optional[str] = None,
             single_user_name: Optional[str] = None,
             spark_conf: Optional[Mapping[str, Any]] = None,
             spark_env_vars: Optional[Mapping[str, Any]] = None,
             ssh_public_keys: Optional[Sequence[str]] = None,
             workload_type: Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if driver_instance_pool_id is None and 'driverInstancePoolId' in kwargs:
            driver_instance_pool_id = kwargs['driverInstancePoolId']
        if driver_instance_pool_id is None:
            raise TypeError("Missing 'driver_instance_pool_id' argument")
        if driver_node_type_id is None and 'driverNodeTypeId' in kwargs:
            driver_node_type_id = kwargs['driverNodeTypeId']
        if driver_node_type_id is None:
            raise TypeError("Missing 'driver_node_type_id' argument")
        if enable_elastic_disk is None and 'enableElasticDisk' in kwargs:
            enable_elastic_disk = kwargs['enableElasticDisk']
        if enable_elastic_disk is None:
            raise TypeError("Missing 'enable_elastic_disk' argument")
        if enable_local_disk_encryption is None and 'enableLocalDiskEncryption' in kwargs:
            enable_local_disk_encryption = kwargs['enableLocalDiskEncryption']
        if enable_local_disk_encryption is None:
            raise TypeError("Missing 'enable_local_disk_encryption' argument")
        if node_type_id is None and 'nodeTypeId' in kwargs:
            node_type_id = kwargs['nodeTypeId']
        if node_type_id is None:
            raise TypeError("Missing 'node_type_id' argument")
        if num_workers is None and 'numWorkers' in kwargs:
            num_workers = kwargs['numWorkers']
        if num_workers is None:
            raise TypeError("Missing 'num_workers' argument")
        if spark_version is None and 'sparkVersion' in kwargs:
            spark_version = kwargs['sparkVersion']
        if spark_version is None:
            raise TypeError("Missing 'spark_version' argument")
        if apply_policy_default_values is None and 'applyPolicyDefaultValues' in kwargs:
            apply_policy_default_values = kwargs['applyPolicyDefaultValues']
        if autotermination_minutes is None and 'autoterminationMinutes' in kwargs:
            autotermination_minutes = kwargs['autoterminationMinutes']
        if aws_attributes is None and 'awsAttributes' in kwargs:
            aws_attributes = kwargs['awsAttributes']
        if azure_attributes is None and 'azureAttributes' in kwargs:
            azure_attributes = kwargs['azureAttributes']
        if cluster_id is None and 'clusterId' in kwargs:
            cluster_id = kwargs['clusterId']
        if cluster_log_conf is None and 'clusterLogConf' in kwargs:
            cluster_log_conf = kwargs['clusterLogConf']
        if cluster_mount_infos is None and 'clusterMountInfos' in kwargs:
            cluster_mount_infos = kwargs['clusterMountInfos']
        if cluster_name is None and 'clusterName' in kwargs:
            cluster_name = kwargs['clusterName']
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if data_security_mode is None and 'dataSecurityMode' in kwargs:
            data_security_mode = kwargs['dataSecurityMode']
        if docker_image is None and 'dockerImage' in kwargs:
            docker_image = kwargs['dockerImage']
        if gcp_attributes is None and 'gcpAttributes' in kwargs:
            gcp_attributes = kwargs['gcpAttributes']
        if idempotency_token is None and 'idempotencyToken' in kwargs:
            idempotency_token = kwargs['idempotencyToken']
        if init_scripts is None and 'initScripts' in kwargs:
            init_scripts = kwargs['initScripts']
        if instance_pool_id is None and 'instancePoolId' in kwargs:
            instance_pool_id = kwargs['instancePoolId']
        if policy_id is None and 'policyId' in kwargs:
            policy_id = kwargs['policyId']
        if runtime_engine is None and 'runtimeEngine' in kwargs:
            runtime_engine = kwargs['runtimeEngine']
        if single_user_name is None and 'singleUserName' in kwargs:
            single_user_name = kwargs['singleUserName']
        if spark_conf is None and 'sparkConf' in kwargs:
            spark_conf = kwargs['sparkConf']
        if spark_env_vars is None and 'sparkEnvVars' in kwargs:
            spark_env_vars = kwargs['sparkEnvVars']
        if ssh_public_keys is None and 'sshPublicKeys' in kwargs:
            ssh_public_keys = kwargs['sshPublicKeys']
        if workload_type is None and 'workloadType' in kwargs:
            workload_type = kwargs['workloadType']

        _setter("driver_instance_pool_id", driver_instance_pool_id)
        _setter("driver_node_type_id", driver_node_type_id)
        _setter("enable_elastic_disk", enable_elastic_disk)
        _setter("enable_local_disk_encryption", enable_local_disk_encryption)
        _setter("node_type_id", node_type_id)
        _setter("num_workers", num_workers)
        _setter("spark_version", spark_version)
        if apply_policy_default_values is not None:
            _setter("apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if autotermination_minutes is not None:
            _setter("autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            _setter("aws_attributes", aws_attributes)
        if azure_attributes is not None:
            _setter("azure_attributes", azure_attributes)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_log_conf is not None:
            _setter("cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            _setter("cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)
        if data_security_mode is not None:
            _setter("data_security_mode", data_security_mode)
        if docker_image is not None:
            _setter("docker_image", docker_image)
        if gcp_attributes is not None:
            _setter("gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            _setter("idempotency_token", idempotency_token)
        if init_scripts is not None:
            _setter("init_scripts", init_scripts)
        if instance_pool_id is not None:
            _setter("instance_pool_id", instance_pool_id)
        if policy_id is not None:
            _setter("policy_id", policy_id)
        if runtime_engine is not None:
            _setter("runtime_engine", runtime_engine)
        if single_user_name is not None:
            _setter("single_user_name", single_user_name)
        if spark_conf is not None:
            _setter("spark_conf", spark_conf)
        if spark_env_vars is not None:
            _setter("spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            _setter("ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            _setter("workload_type", workload_type)

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        return pulumi.get(self, "driver_instance_pool_id")

    @driver_instance_pool_id.setter
    def driver_instance_pool_id(self, value: str):
        pulumi.set(self, "driver_instance_pool_id", value)

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> str:
        return pulumi.get(self, "driver_node_type_id")

    @driver_node_type_id.setter
    def driver_node_type_id(self, value: str):
        pulumi.set(self, "driver_node_type_id", value)

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> bool:
        return pulumi.get(self, "enable_elastic_disk")

    @enable_elastic_disk.setter
    def enable_elastic_disk(self, value: bool):
        pulumi.set(self, "enable_elastic_disk", value)

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @enable_local_disk_encryption.setter
    def enable_local_disk_encryption(self, value: bool):
        pulumi.set(self, "enable_local_disk_encryption", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> str:
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: str):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> int:
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: int):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @spark_version.setter
    def spark_version(self, value: str):
        pulumi.set(self, "spark_version", value)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @apply_policy_default_values.setter
    def apply_policy_default_values(self, value: Optional[bool]):
        pulumi.set(self, "apply_policy_default_values", value)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs']:
        return pulumi.get(self, "autoscale")

    @autoscale.setter
    def autoscale(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs']):
        pulumi.set(self, "autoscale", value)

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @autotermination_minutes.setter
    def autotermination_minutes(self, value: Optional[int]):
        pulumi.set(self, "autotermination_minutes", value)

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs']:
        return pulumi.get(self, "aws_attributes")

    @aws_attributes.setter
    def aws_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs']):
        pulumi.set(self, "aws_attributes", value)

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs']:
        return pulumi.get(self, "azure_attributes")

    @azure_attributes.setter
    def azure_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs']):
        pulumi.set(self, "azure_attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs']:
        return pulumi.get(self, "cluster_log_conf")

    @cluster_log_conf.setter
    def cluster_log_conf(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs']):
        pulumi.set(self, "cluster_log_conf", value)

    @property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']]:
        return pulumi.get(self, "cluster_mount_infos")

    @cluster_mount_infos.setter
    def cluster_mount_infos(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs']]):
        pulumi.set(self, "cluster_mount_infos", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @data_security_mode.setter
    def data_security_mode(self, value: Optional[str]):
        pulumi.set(self, "data_security_mode", value)

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs']:
        return pulumi.get(self, "docker_image")

    @docker_image.setter
    def docker_image(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs']):
        pulumi.set(self, "docker_image", value)

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs']:
        return pulumi.get(self, "gcp_attributes")

    @gcp_attributes.setter
    def gcp_attributes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs']):
        pulumi.set(self, "gcp_attributes", value)

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @idempotency_token.setter
    def idempotency_token(self, value: Optional[str]):
        pulumi.set(self, "idempotency_token", value)

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']]:
        return pulumi.get(self, "init_scripts")

    @init_scripts.setter
    def init_scripts(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs']]):
        pulumi.set(self, "init_scripts", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[str]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[str]:
        return pulumi.get(self, "runtime_engine")

    @runtime_engine.setter
    def runtime_engine(self, value: Optional[str]):
        pulumi.set(self, "runtime_engine", value)

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @single_user_name.setter
    def single_user_name(self, value: Optional[str]):
        pulumi.set(self, "single_user_name", value)

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @spark_conf.setter
    def spark_conf(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_conf", value)

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @spark_env_vars.setter
    def spark_env_vars(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "spark_env_vars", value)

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @ssh_public_keys.setter
    def ssh_public_keys(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "ssh_public_keys", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs']:
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs']):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs:
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        GetJobJobSettingsSettingsTaskNewClusterAutoscaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_workers=max_workers,
            min_workers=min_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_workers: Optional[int] = None,
             min_workers: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if max_workers is None and 'maxWorkers' in kwargs:
            max_workers = kwargs['maxWorkers']
        if min_workers is None and 'minWorkers' in kwargs:
            min_workers = kwargs['minWorkers']

        if max_workers is not None:
            _setter("max_workers", max_workers)
        if min_workers is not None:
            _setter("min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @max_workers.setter
    def max_workers(self, value: Optional[int]):
        pulumi.set(self, "max_workers", value)

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")

    @min_workers.setter
    def min_workers(self, value: Optional[int]):
        pulumi.set(self, "min_workers", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterAwsAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            ebs_volume_count=ebs_volume_count,
            ebs_volume_size=ebs_volume_size,
            ebs_volume_type=ebs_volume_type,
            first_on_demand=first_on_demand,
            instance_profile_arn=instance_profile_arn,
            spot_bid_price_percent=spot_bid_price_percent,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             ebs_volume_count: Optional[int] = None,
             ebs_volume_size: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             instance_profile_arn: Optional[str] = None,
             spot_bid_price_percent: Optional[int] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if ebs_volume_count is None and 'ebsVolumeCount' in kwargs:
            ebs_volume_count = kwargs['ebsVolumeCount']
        if ebs_volume_size is None and 'ebsVolumeSize' in kwargs:
            ebs_volume_size = kwargs['ebsVolumeSize']
        if ebs_volume_type is None and 'ebsVolumeType' in kwargs:
            ebs_volume_type = kwargs['ebsVolumeType']
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if instance_profile_arn is None and 'instanceProfileArn' in kwargs:
            instance_profile_arn = kwargs['instanceProfileArn']
        if spot_bid_price_percent is None and 'spotBidPricePercent' in kwargs:
            spot_bid_price_percent = kwargs['spotBidPricePercent']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if ebs_volume_count is not None:
            _setter("ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            _setter("ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            _setter("instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            _setter("spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @ebs_volume_count.setter
    def ebs_volume_count(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_count", value)

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @ebs_volume_size.setter
    def ebs_volume_size(self, value: Optional[int]):
        pulumi.set(self, "ebs_volume_size", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[str]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @instance_profile_arn.setter
    def instance_profile_arn(self, value: Optional[str]):
        pulumi.set(self, "instance_profile_arn", value)

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @spot_bid_price_percent.setter
    def spot_bid_price_percent(self, value: Optional[int]):
        pulumi.set(self, "spot_bid_price_percent", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        GetJobJobSettingsSettingsTaskNewClusterAzureAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            first_on_demand=first_on_demand,
            spot_bid_max_price=spot_bid_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             first_on_demand: Optional[int] = None,
             spot_bid_max_price: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if first_on_demand is None and 'firstOnDemand' in kwargs:
            first_on_demand = kwargs['firstOnDemand']
        if spot_bid_max_price is None and 'spotBidMaxPrice' in kwargs:
            spot_bid_max_price = kwargs['spotBidMaxPrice']

        if availability is not None:
            _setter("availability", availability)
        if first_on_demand is not None:
            _setter("first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            _setter("spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @first_on_demand.setter
    def first_on_demand(self, value: Optional[int]):
        pulumi.set(self, "first_on_demand", value)

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")

    @spot_bid_max_price.setter
    def spot_bid_max_price(self, value: Optional[float]):
        pulumi.set(self, "spot_bid_max_price", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs:
    def __init__(__self__, *,
                 dbfs: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args'] = None):
        GetJobJobSettingsSettingsTaskNewClusterClusterLogConfArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbfs=dbfs,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbfs: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs'] = None,
             s3: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dbfs is not None:
            _setter("dbfs", dbfs)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args']):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs:
    def __init__(__self__, *,
                 local_mount_dir_path: str,
                 network_filesystem_info: 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs',
                 remote_mount_dir_path: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            local_mount_dir_path=local_mount_dir_path,
            network_filesystem_info=network_filesystem_info,
            remote_mount_dir_path=remote_mount_dir_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             local_mount_dir_path: Optional[str] = None,
             network_filesystem_info: Optional['GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'] = None,
             remote_mount_dir_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if local_mount_dir_path is None and 'localMountDirPath' in kwargs:
            local_mount_dir_path = kwargs['localMountDirPath']
        if local_mount_dir_path is None:
            raise TypeError("Missing 'local_mount_dir_path' argument")
        if network_filesystem_info is None and 'networkFilesystemInfo' in kwargs:
            network_filesystem_info = kwargs['networkFilesystemInfo']
        if network_filesystem_info is None:
            raise TypeError("Missing 'network_filesystem_info' argument")
        if remote_mount_dir_path is None and 'remoteMountDirPath' in kwargs:
            remote_mount_dir_path = kwargs['remoteMountDirPath']

        _setter("local_mount_dir_path", local_mount_dir_path)
        _setter("network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            _setter("remote_mount_dir_path", remote_mount_dir_path)

    @property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> str:
        return pulumi.get(self, "local_mount_dir_path")

    @local_mount_dir_path.setter
    def local_mount_dir_path(self, value: str):
        pulumi.set(self, "local_mount_dir_path", value)

    @property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs':
        return pulumi.get(self, "network_filesystem_info")

    @network_filesystem_info.setter
    def network_filesystem_info(self, value: 'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs'):
        pulumi.set(self, "network_filesystem_info", value)

    @property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[str]:
        return pulumi.get(self, "remote_mount_dir_path")

    @remote_mount_dir_path.setter
    def remote_mount_dir_path(self, value: Optional[str]):
        pulumi.set(self, "remote_mount_dir_path", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs:
    def __init__(__self__, *,
                 server_address: str,
                 mount_options: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_address=server_address,
            mount_options=mount_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_address: Optional[str] = None,
             mount_options: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if server_address is None and 'serverAddress' in kwargs:
            server_address = kwargs['serverAddress']
        if server_address is None:
            raise TypeError("Missing 'server_address' argument")
        if mount_options is None and 'mountOptions' in kwargs:
            mount_options = kwargs['mountOptions']

        _setter("server_address", server_address)
        if mount_options is not None:
            _setter("mount_options", mount_options)

    @property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> str:
        return pulumi.get(self, "server_address")

    @server_address.setter
    def server_address(self, value: str):
        pulumi.set(self, "server_address", value)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[str]):
        pulumi.set(self, "mount_options", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs:
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs'] = None):
        GetJobJobSettingsSettingsTaskNewClusterDockerImageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            basic_auth=basic_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             basic_auth: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if basic_auth is None and 'basicAuth' in kwargs:
            basic_auth = kwargs['basicAuth']

        _setter("url", url)
        if basic_auth is not None:
            _setter("basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs']:
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs:
    def __init__(__self__, *,
                 password: str,
                 username: str):
        GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if password is None:
            raise TypeError("Missing 'password' argument")
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("password", password)
        _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: str):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs:
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 local_ssd_count: Optional[int] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterGcpAttributesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            boot_disk_size=boot_disk_size,
            google_service_account=google_service_account,
            local_ssd_count=local_ssd_count,
            use_preemptible_executors=use_preemptible_executors,
            zone_id=zone_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional[str] = None,
             boot_disk_size: Optional[int] = None,
             google_service_account: Optional[str] = None,
             local_ssd_count: Optional[int] = None,
             use_preemptible_executors: Optional[bool] = None,
             zone_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if boot_disk_size is None and 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if google_service_account is None and 'googleServiceAccount' in kwargs:
            google_service_account = kwargs['googleServiceAccount']
        if local_ssd_count is None and 'localSsdCount' in kwargs:
            local_ssd_count = kwargs['localSsdCount']
        if use_preemptible_executors is None and 'usePreemptibleExecutors' in kwargs:
            use_preemptible_executors = kwargs['usePreemptibleExecutors']
        if zone_id is None and 'zoneId' in kwargs:
            zone_id = kwargs['zoneId']

        if availability is not None:
            _setter("availability", availability)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            _setter("google_service_account", google_service_account)
        if local_ssd_count is not None:
            _setter("local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            _setter("use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            _setter("zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[str]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[int]):
        pulumi.set(self, "boot_disk_size", value)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @google_service_account.setter
    def google_service_account(self, value: Optional[str]):
        pulumi.set(self, "google_service_account", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[int]:
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[int]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @use_preemptible_executors.setter
    def use_preemptible_executors(self, value: Optional[bool]):
        pulumi.set(self, "use_preemptible_executors", value)

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: Optional[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs:
    def __init__(__self__, *,
                 abfss: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs'] = None,
                 dbfs: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs'] = None,
                 gcs: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs'] = None,
                 s3: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args'] = None,
                 volumes: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs'] = None,
                 workspace: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs'] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abfss=abfss,
            dbfs=dbfs,
            file=file,
            gcs=gcs,
            s3=s3,
            volumes=volumes,
            workspace=workspace,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abfss: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs'] = None,
             dbfs: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs'] = None,
             file: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs'] = None,
             gcs: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs'] = None,
             s3: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args'] = None,
             volumes: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs'] = None,
             workspace: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if abfss is not None:
            _setter("abfss", abfss)
        if dbfs is not None:
            _setter("dbfs", dbfs)
        if file is not None:
            _setter("file", file)
        if gcs is not None:
            _setter("gcs", gcs)
        if s3 is not None:
            _setter("s3", s3)
        if volumes is not None:
            _setter("volumes", volumes)
        if workspace is not None:
            _setter("workspace", workspace)

    @property
    @pulumi.getter
    def abfss(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs']:
        return pulumi.get(self, "abfss")

    @abfss.setter
    def abfss(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs']):
        pulumi.set(self, "abfss", value)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs']:
        return pulumi.get(self, "dbfs")

    @dbfs.setter
    def dbfs(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs']):
        pulumi.set(self, "dbfs", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def gcs(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs']:
        return pulumi.get(self, "gcs")

    @gcs.setter
    def gcs(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs']):
        pulumi.set(self, "gcs", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args']):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs']:
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs']):
        pulumi.set(self, "volumes", value)

    @property
    @pulumi.getter
    def workspace(self) -> Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: Optional['GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs']):
        pulumi.set(self, "workspace", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs:
    def __init__(__self__, *,
                 destination: str):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")

        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args:
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            canned_acl=canned_acl,
            enable_encryption=enable_encryption,
            encryption_type=encryption_type,
            endpoint=endpoint,
            kms_key=kms_key,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             canned_acl: Optional[str] = None,
             enable_encryption: Optional[bool] = None,
             encryption_type: Optional[str] = None,
             endpoint: Optional[str] = None,
             kms_key: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if canned_acl is None and 'cannedAcl' in kwargs:
            canned_acl = kwargs['cannedAcl']
        if enable_encryption is None and 'enableEncryption' in kwargs:
            enable_encryption = kwargs['enableEncryption']
        if encryption_type is None and 'encryptionType' in kwargs:
            encryption_type = kwargs['encryptionType']
        if kms_key is None and 'kmsKey' in kwargs:
            kms_key = kwargs['kmsKey']

        _setter("destination", destination)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)
        if enable_encryption is not None:
            _setter("enable_encryption", enable_encryption)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if kms_key is not None:
            _setter("kms_key", kms_key)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: str):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[str]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @enable_encryption.setter
    def enable_encryption(self, value: Optional[bool]):
        pulumi.set(self, "enable_encryption", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[str]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs:
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[str]):
        pulumi.set(self, "destination", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs:
    def __init__(__self__, *,
                 clients: 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs'):
        GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional['GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if clients is None:
            raise TypeError("Missing 'clients' argument")

        _setter("clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs':
        return pulumi.get(self, "clients")

    @clients.setter
    def clients(self, value: 'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs'):
        pulumi.set(self, "clients", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs:
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jobs=jobs,
            notebooks=notebooks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jobs: Optional[bool] = None,
             notebooks: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if jobs is not None:
            _setter("jobs", jobs)
        if notebooks is not None:
            _setter("notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[bool]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")

    @notebooks.setter
    def notebooks(self, value: Optional[bool]):
        pulumi.set(self, "notebooks", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNotebookTaskArgs:
    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, Any]] = None,
                 source: Optional[str] = None):
        GetJobJobSettingsSettingsTaskNotebookTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notebook_path=notebook_path,
            base_parameters=base_parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notebook_path: Optional[str] = None,
             base_parameters: Optional[Mapping[str, Any]] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if notebook_path is None and 'notebookPath' in kwargs:
            notebook_path = kwargs['notebookPath']
        if notebook_path is None:
            raise TypeError("Missing 'notebook_path' argument")
        if base_parameters is None and 'baseParameters' in kwargs:
            base_parameters = kwargs['baseParameters']

        _setter("notebook_path", notebook_path)
        if base_parameters is not None:
            _setter("base_parameters", base_parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        return pulumi.get(self, "notebook_path")

    @notebook_path.setter
    def notebook_path(self, value: str):
        pulumi.set(self, "notebook_path", value)

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "base_parameters")

    @base_parameters.setter
    def base_parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "base_parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskNotificationSettingsArgs:
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_canceled_runs: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None):
        GetJobJobSettingsSettingsTaskNotificationSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_on_last_attempt=alert_on_last_attempt,
            no_alert_for_canceled_runs=no_alert_for_canceled_runs,
            no_alert_for_skipped_runs=no_alert_for_skipped_runs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_on_last_attempt: Optional[bool] = None,
             no_alert_for_canceled_runs: Optional[bool] = None,
             no_alert_for_skipped_runs: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_on_last_attempt is None and 'alertOnLastAttempt' in kwargs:
            alert_on_last_attempt = kwargs['alertOnLastAttempt']
        if no_alert_for_canceled_runs is None and 'noAlertForCanceledRuns' in kwargs:
            no_alert_for_canceled_runs = kwargs['noAlertForCanceledRuns']
        if no_alert_for_skipped_runs is None and 'noAlertForSkippedRuns' in kwargs:
            no_alert_for_skipped_runs = kwargs['noAlertForSkippedRuns']

        if alert_on_last_attempt is not None:
            _setter("alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            _setter("no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            _setter("no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @alert_on_last_attempt.setter
    def alert_on_last_attempt(self, value: Optional[bool]):
        pulumi.set(self, "alert_on_last_attempt", value)

    @property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @no_alert_for_canceled_runs.setter
    def no_alert_for_canceled_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_canceled_runs", value)

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @no_alert_for_skipped_runs.setter
    def no_alert_for_skipped_runs(self, value: Optional[bool]):
        pulumi.set(self, "no_alert_for_skipped_runs", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskPipelineTaskArgs:
    def __init__(__self__, *,
                 pipeline_id: str,
                 full_refresh: Optional[bool] = None):
        GetJobJobSettingsSettingsTaskPipelineTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pipeline_id=pipeline_id,
            full_refresh=full_refresh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pipeline_id: Optional[str] = None,
             full_refresh: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if pipeline_id is None and 'pipelineId' in kwargs:
            pipeline_id = kwargs['pipelineId']
        if pipeline_id is None:
            raise TypeError("Missing 'pipeline_id' argument")
        if full_refresh is None and 'fullRefresh' in kwargs:
            full_refresh = kwargs['fullRefresh']

        _setter("pipeline_id", pipeline_id)
        if full_refresh is not None:
            _setter("full_refresh", full_refresh)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: str):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[bool]:
        return pulumi.get(self, "full_refresh")

    @full_refresh.setter
    def full_refresh(self, value: Optional[bool]):
        pulumi.set(self, "full_refresh", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskPythonWheelTaskArgs:
    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, Any]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsTaskPythonWheelTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entry_point=entry_point,
            named_parameters=named_parameters,
            package_name=package_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entry_point: Optional[str] = None,
             named_parameters: Optional[Mapping[str, Any]] = None,
             package_name: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if entry_point is None and 'entryPoint' in kwargs:
            entry_point = kwargs['entryPoint']
        if named_parameters is None and 'namedParameters' in kwargs:
            named_parameters = kwargs['namedParameters']
        if package_name is None and 'packageName' in kwargs:
            package_name = kwargs['packageName']

        if entry_point is not None:
            _setter("entry_point", entry_point)
        if named_parameters is not None:
            _setter("named_parameters", named_parameters)
        if package_name is not None:
            _setter("package_name", package_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        return pulumi.get(self, "entry_point")

    @entry_point.setter
    def entry_point(self, value: Optional[str]):
        pulumi.set(self, "entry_point", value)

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "named_parameters")

    @named_parameters.setter
    def named_parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "named_parameters", value)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: Optional[str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskRunJobTaskArgs:
    def __init__(__self__, *,
                 job_id: int,
                 job_parameters: Optional[Mapping[str, Any]] = None):
        GetJobJobSettingsSettingsTaskRunJobTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_id=job_id,
            job_parameters=job_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_id: Optional[int] = None,
             job_parameters: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if job_id is None and 'jobId' in kwargs:
            job_id = kwargs['jobId']
        if job_id is None:
            raise TypeError("Missing 'job_id' argument")
        if job_parameters is None and 'jobParameters' in kwargs:
            job_parameters = kwargs['jobParameters']

        _setter("job_id", job_id)
        if job_parameters is not None:
            _setter("job_parameters", job_parameters)

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> int:
        return pulumi.get(self, "job_id")

    @job_id.setter
    def job_id(self, value: int):
        pulumi.set(self, "job_id", value)

    @property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "job_parameters")

    @job_parameters.setter
    def job_parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "job_parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSparkJarTaskArgs:
    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsTaskSparkJarTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jar_uri=jar_uri,
            main_class_name=main_class_name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jar_uri: Optional[str] = None,
             main_class_name: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if jar_uri is None and 'jarUri' in kwargs:
            jar_uri = kwargs['jarUri']
        if main_class_name is None and 'mainClassName' in kwargs:
            main_class_name = kwargs['mainClassName']

        if jar_uri is not None:
            _setter("jar_uri", jar_uri)
        if main_class_name is not None:
            _setter("main_class_name", main_class_name)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @jar_uri.setter
    def jar_uri(self, value: Optional[str]):
        pulumi.set(self, "jar_uri", value)

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        return pulumi.get(self, "main_class_name")

    @main_class_name.setter
    def main_class_name(self, value: Optional[str]):
        pulumi.set(self, "main_class_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSparkPythonTaskArgs:
    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None,
                 source: Optional[str] = None):
        GetJobJobSettingsSettingsTaskSparkPythonTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            python_file=python_file,
            parameters=parameters,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             python_file: Optional[str] = None,
             parameters: Optional[Sequence[str]] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if python_file is None and 'pythonFile' in kwargs:
            python_file = kwargs['pythonFile']
        if python_file is None:
            raise TypeError("Missing 'python_file' argument")

        _setter("python_file", python_file)
        if parameters is not None:
            _setter("parameters", parameters)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        return pulumi.get(self, "python_file")

    @python_file.setter
    def python_file(self, value: str):
        pulumi.set(self, "python_file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[str]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs:
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        GetJobJobSettingsSettingsTaskSparkSubmitTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskArgs:
    def __init__(__self__, *,
                 alert: Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs'] = None,
                 dashboard: Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs'] = None,
                 file: Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs'] = None,
                 parameters: Optional[Mapping[str, Any]] = None,
                 query: Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs'] = None,
                 warehouse_id: Optional[str] = None):
        GetJobJobSettingsSettingsTaskSqlTaskArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert=alert,
            dashboard=dashboard,
            file=file,
            parameters=parameters,
            query=query,
            warehouse_id=warehouse_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert: Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs'] = None,
             dashboard: Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs'] = None,
             file: Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs'] = None,
             parameters: Optional[Mapping[str, Any]] = None,
             query: Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs'] = None,
             warehouse_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if warehouse_id is None and 'warehouseId' in kwargs:
            warehouse_id = kwargs['warehouseId']

        if alert is not None:
            _setter("alert", alert)
        if dashboard is not None:
            _setter("dashboard", dashboard)
        if file is not None:
            _setter("file", file)
        if parameters is not None:
            _setter("parameters", parameters)
        if query is not None:
            _setter("query", query)
        if warehouse_id is not None:
            _setter("warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def alert(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs']:
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs']):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def file(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs']:
        return pulumi.get(self, "file")

    @file.setter
    def file(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskFileArgs']):
        pulumi.set(self, "file", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Mapping[str, Any]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def query(self) -> Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs']:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional['GetJobJobSettingsSettingsTaskSqlTaskQueryArgs']):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")

    @warehouse_id.setter
    def warehouse_id(self, value: Optional[str]):
        pulumi.set(self, "warehouse_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskAlertArgs:
    def __init__(__self__, *,
                 alert_id: str,
                 subscriptions: Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs'],
                 pause_subscriptions: Optional[bool] = None):
        GetJobJobSettingsSettingsTaskSqlTaskAlertArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            subscriptions=subscriptions,
            pause_subscriptions=pause_subscriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: Optional[str] = None,
             subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs']] = None,
             pause_subscriptions: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if alert_id is None and 'alertId' in kwargs:
            alert_id = kwargs['alertId']
        if alert_id is None:
            raise TypeError("Missing 'alert_id' argument")
        if subscriptions is None:
            raise TypeError("Missing 'subscriptions' argument")
        if pause_subscriptions is None and 'pauseSubscriptions' in kwargs:
            pause_subscriptions = kwargs['pauseSubscriptions']

        _setter("alert_id", alert_id)
        _setter("subscriptions", subscriptions)
        if pause_subscriptions is not None:
            _setter("pause_subscriptions", pause_subscriptions)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @alert_id.setter
    def alert_id(self, value: str):
        pulumi.set(self, "alert_id", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs']:
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Sequence['GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs']):
        pulumi.set(self, "subscriptions", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[bool]:
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[bool]):
        pulumi.set(self, "pause_subscriptions", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_id=destination_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_id: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination_id is None and 'destinationId' in kwargs:
            destination_id = kwargs['destinationId']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if destination_id is not None:
            _setter("destination_id", destination_id)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs:
    def __init__(__self__, *,
                 dashboard_id: str,
                 custom_subject: Optional[str] = None,
                 pause_subscriptions: Optional[bool] = None,
                 subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']] = None):
        GetJobJobSettingsSettingsTaskSqlTaskDashboardArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard_id=dashboard_id,
            custom_subject=custom_subject,
            pause_subscriptions=pause_subscriptions,
            subscriptions=subscriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard_id: Optional[str] = None,
             custom_subject: Optional[str] = None,
             pause_subscriptions: Optional[bool] = None,
             subscriptions: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if dashboard_id is None and 'dashboardId' in kwargs:
            dashboard_id = kwargs['dashboardId']
        if dashboard_id is None:
            raise TypeError("Missing 'dashboard_id' argument")
        if custom_subject is None and 'customSubject' in kwargs:
            custom_subject = kwargs['customSubject']
        if pause_subscriptions is None and 'pauseSubscriptions' in kwargs:
            pause_subscriptions = kwargs['pauseSubscriptions']

        _setter("dashboard_id", dashboard_id)
        if custom_subject is not None:
            _setter("custom_subject", custom_subject)
        if pause_subscriptions is not None:
            _setter("pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            _setter("subscriptions", subscriptions)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> str:
        return pulumi.get(self, "dashboard_id")

    @dashboard_id.setter
    def dashboard_id(self, value: str):
        pulumi.set(self, "dashboard_id", value)

    @property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[str]:
        return pulumi.get(self, "custom_subject")

    @custom_subject.setter
    def custom_subject(self, value: Optional[str]):
        pulumi.set(self, "custom_subject", value)

    @property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[bool]:
        return pulumi.get(self, "pause_subscriptions")

    @pause_subscriptions.setter
    def pause_subscriptions(self, value: Optional[bool]):
        pulumi.set(self, "pause_subscriptions", value)

    @property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']]:
        return pulumi.get(self, "subscriptions")

    @subscriptions.setter
    def subscriptions(self, value: Optional[Sequence['GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs']]):
        pulumi.set(self, "subscriptions", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs:
    def __init__(__self__, *,
                 destination_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_id=destination_id,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_id: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if destination_id is None and 'destinationId' in kwargs:
            destination_id = kwargs['destinationId']
        if user_name is None and 'userName' in kwargs:
            user_name = kwargs['userName']

        if destination_id is not None:
            _setter("destination_id", destination_id)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_id")

    @destination_id.setter
    def destination_id(self, value: Optional[str]):
        pulumi.set(self, "destination_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskFileArgs:
    def __init__(__self__, *,
                 path: str):
        GetJobJobSettingsSettingsTaskSqlTaskFileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")

        _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTaskSqlTaskQueryArgs:
    def __init__(__self__, *,
                 query_id: str):
        GetJobJobSettingsSettingsTaskSqlTaskQueryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_id=query_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_id is None:
            raise TypeError("Missing 'query_id' argument")

        _setter("query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: str):
        pulumi.set(self, "query_id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTriggerArgs:
    def __init__(__self__, *,
                 file_arrival: 'GetJobJobSettingsSettingsTriggerFileArrivalArgs',
                 pause_status: Optional[str] = None):
        GetJobJobSettingsSettingsTriggerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_arrival=file_arrival,
            pause_status=pause_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_arrival: Optional['GetJobJobSettingsSettingsTriggerFileArrivalArgs'] = None,
             pause_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if file_arrival is None and 'fileArrival' in kwargs:
            file_arrival = kwargs['fileArrival']
        if file_arrival is None:
            raise TypeError("Missing 'file_arrival' argument")
        if pause_status is None and 'pauseStatus' in kwargs:
            pause_status = kwargs['pauseStatus']

        _setter("file_arrival", file_arrival)
        if pause_status is not None:
            _setter("pause_status", pause_status)

    @property
    @pulumi.getter(name="fileArrival")
    def file_arrival(self) -> 'GetJobJobSettingsSettingsTriggerFileArrivalArgs':
        return pulumi.get(self, "file_arrival")

    @file_arrival.setter
    def file_arrival(self, value: 'GetJobJobSettingsSettingsTriggerFileArrivalArgs'):
        pulumi.set(self, "file_arrival", value)

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        return pulumi.get(self, "pause_status")

    @pause_status.setter
    def pause_status(self, value: Optional[str]):
        pulumi.set(self, "pause_status", value)


@pulumi.input_type
class GetJobJobSettingsSettingsTriggerFileArrivalArgs:
    def __init__(__self__, *,
                 url: str,
                 min_time_between_triggers_seconds: Optional[int] = None,
                 wait_after_last_change_seconds: Optional[int] = None):
        GetJobJobSettingsSettingsTriggerFileArrivalArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            min_time_between_triggers_seconds=min_time_between_triggers_seconds,
            wait_after_last_change_seconds=wait_after_last_change_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             min_time_between_triggers_seconds: Optional[int] = None,
             wait_after_last_change_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if url is None:
            raise TypeError("Missing 'url' argument")
        if min_time_between_triggers_seconds is None and 'minTimeBetweenTriggersSeconds' in kwargs:
            min_time_between_triggers_seconds = kwargs['minTimeBetweenTriggersSeconds']
        if wait_after_last_change_seconds is None and 'waitAfterLastChangeSeconds' in kwargs:
            wait_after_last_change_seconds = kwargs['waitAfterLastChangeSeconds']

        _setter("url", url)
        if min_time_between_triggers_seconds is not None:
            _setter("min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            _setter("wait_after_last_change_seconds", wait_after_last_change_seconds)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[int]:
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @min_time_between_triggers_seconds.setter
    def min_time_between_triggers_seconds(self, value: Optional[int]):
        pulumi.set(self, "min_time_between_triggers_seconds", value)

    @property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[int]:
        return pulumi.get(self, "wait_after_last_change_seconds")

    @wait_after_last_change_seconds.setter
    def wait_after_last_change_seconds(self, value: Optional[int]):
        pulumi.set(self, "wait_after_last_change_seconds", value)


@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsArgs:
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']] = None,
                 on_failures: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']] = None,
                 on_starts: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']] = None,
                 on_successes: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']] = None):
        GetJobJobSettingsSettingsWebhookNotificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_duration_warning_threshold_exceededs=on_duration_warning_threshold_exceededs,
            on_failures=on_failures,
            on_starts=on_starts,
            on_successes=on_successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_duration_warning_threshold_exceededs: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']] = None,
             on_failures: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']] = None,
             on_starts: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']] = None,
             on_successes: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if on_duration_warning_threshold_exceededs is None and 'onDurationWarningThresholdExceededs' in kwargs:
            on_duration_warning_threshold_exceededs = kwargs['onDurationWarningThresholdExceededs']
        if on_failures is None and 'onFailures' in kwargs:
            on_failures = kwargs['onFailures']
        if on_starts is None and 'onStarts' in kwargs:
            on_starts = kwargs['onStarts']
        if on_successes is None and 'onSuccesses' in kwargs:
            on_successes = kwargs['onSuccesses']

        if on_duration_warning_threshold_exceededs is not None:
            _setter("on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            _setter("on_failures", on_failures)
        if on_starts is not None:
            _setter("on_starts", on_starts)
        if on_successes is not None:
            _setter("on_successes", on_successes)

    @property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @on_duration_warning_threshold_exceededs.setter
    def on_duration_warning_threshold_exceededs(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs']]):
        pulumi.set(self, "on_duration_warning_threshold_exceededs", value)

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']]:
        return pulumi.get(self, "on_failures")

    @on_failures.setter
    def on_failures(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs']]):
        pulumi.set(self, "on_failures", value)

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']]:
        return pulumi.get(self, "on_starts")

    @on_starts.setter
    def on_starts(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs']]):
        pulumi.set(self, "on_starts", value)

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']]:
        return pulumi.get(self, "on_successes")

    @on_successes.setter
    def on_successes(self, value: Optional[Sequence['GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs']]):
        pulumi.set(self, "on_successes", value)


@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        GetJobJobSettingsSettingsWebhookNotificationsOnFailureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        GetJobJobSettingsSettingsWebhookNotificationsOnStartArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs:
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: the id of Job if the resource was matched by name.
        """
        GetJobJobSettingsSettingsWebhookNotificationsOnSuccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GetMetastoreMetastoreInfoArgs:
    def __init__(__self__, *,
                 cloud: Optional[str] = None,
                 created_at: Optional[int] = None,
                 created_by: Optional[str] = None,
                 default_data_access_config_id: Optional[str] = None,
                 delta_sharing_organization_name: Optional[str] = None,
                 delta_sharing_recipient_token_lifetime_in_seconds: Optional[int] = None,
                 delta_sharing_scope: Optional[str] = None,
                 global_metastore_id: Optional[str] = None,
                 metastore_id: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 privilege_model_version: Optional[str] = None,
                 region: Optional[str] = None,
                 storage_root: Optional[str] = None,
                 storage_root_credential_id: Optional[str] = None,
                 storage_root_credential_name: Optional[str] = None,
                 updated_at: Optional[int] = None,
                 updated_by: Optional[str] = None):
        """
        :param str delta_sharing_organization_name: The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        :param int delta_sharing_recipient_token_lifetime_in_seconds: Used to set expiration duration in seconds on recipient data access tokens.
        :param str delta_sharing_scope: Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL.
        :param str metastore_id: Id of the metastore to be fetched
        :param str name: Name of metastore.
        :param str owner: Username/groupname/sp application_id of the metastore owner.
        :param str storage_root: Path on cloud storage account, where managed `Table` are stored. Change forces creation of a new resource.
        """
        GetMetastoreMetastoreInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud=cloud,
            created_at=created_at,
            created_by=created_by,
            default_data_access_config_id=default_data_access_config_id,
            delta_sharing_organization_name=delta_sharing_organization_name,
            delta_sharing_recipient_token_lifetime_in_seconds=delta_sharing_recipient_token_lifetime_in_seconds,
            delta_sharing_scope=delta_sharing_scope,
            global_metastore_id=global_metastore_id,
            metastore_id=metastore_id,
            name=name,
            owner=owner,
            privilege_model_version=privilege_model_version,
            region=region,
            storage_root=storage_root,
            storage_root_credential_id=storage_root_credential_id,
            storage_root_credential_name=storage_root_credential_name,
            updated_at=updated_at,
            updated_by=updated_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud: Optional[str] = None,
             created_at: Optional[int] = None,
             created_by: Optional[str] = None,
             default_data_access_config_id: Optional[str] = None,
             delta_sharing_organization_name: Optional[str] = None,
             delta_sharing_recipient_token_lifetime_in_seconds: Optional[int] = None,
             delta_sharing_scope: Optional[str] = None,
             global_metastore_id: Optional[str] = None,
             metastore_id: Optional[str] = None,
             name: Optional[str] = None,
             owner: Optional[str] = None,
             privilege_model_version: Optional[str] = None,
             region: Optional[str] = None,
             storage_root: Optional[str] = None,
             storage_root_credential_id: Optional[str] = None,
             storage_root_credential_name: Optional[str] = None,
             updated_at: Optional[int] = None,
             updated_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if default_data_access_config_id is None and 'defaultDataAccessConfigId' in kwargs:
            default_data_access_config_id = kwargs['defaultDataAccessConfigId']
        if delta_sharing_organization_name is None and 'deltaSharingOrganizationName' in kwargs:
            delta_sharing_organization_name = kwargs['deltaSharingOrganizationName']
        if delta_sharing_recipient_token_lifetime_in_seconds is None and 'deltaSharingRecipientTokenLifetimeInSeconds' in kwargs:
            delta_sharing_recipient_token_lifetime_in_seconds = kwargs['deltaSharingRecipientTokenLifetimeInSeconds']
        if delta_sharing_scope is None and 'deltaSharingScope' in kwargs:
            delta_sharing_scope = kwargs['deltaSharingScope']
        if global_metastore_id is None and 'globalMetastoreId' in kwargs:
            global_metastore_id = kwargs['globalMetastoreId']
        if metastore_id is None and 'metastoreId' in kwargs:
            metastore_id = kwargs['metastoreId']
        if privilege_model_version is None and 'privilegeModelVersion' in kwargs:
            privilege_model_version = kwargs['privilegeModelVersion']
        if storage_root is None and 'storageRoot' in kwargs:
            storage_root = kwargs['storageRoot']
        if storage_root_credential_id is None and 'storageRootCredentialId' in kwargs:
            storage_root_credential_id = kwargs['storageRootCredentialId']
        if storage_root_credential_name is None and 'storageRootCredentialName' in kwargs:
            storage_root_credential_name = kwargs['storageRootCredentialName']
        if updated_at is None and 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']
        if updated_by is None and 'updatedBy' in kwargs:
            updated_by = kwargs['updatedBy']

        if cloud is not None:
            _setter("cloud", cloud)
        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if default_data_access_config_id is not None:
            _setter("default_data_access_config_id", default_data_access_config_id)
        if delta_sharing_organization_name is not None:
            _setter("delta_sharing_organization_name", delta_sharing_organization_name)
        if delta_sharing_recipient_token_lifetime_in_seconds is not None:
            _setter("delta_sharing_recipient_token_lifetime_in_seconds", delta_sharing_recipient_token_lifetime_in_seconds)
        if delta_sharing_scope is not None:
            _setter("delta_sharing_scope", delta_sharing_scope)
        if global_metastore_id is not None:
            _setter("global_metastore_id", global_metastore_id)
        if metastore_id is not None:
            _setter("metastore_id", metastore_id)
        if name is not None:
            _setter("name", name)
        if owner is not None:
            _setter("owner", owner)
        if privilege_model_version is not None:
            _setter("privilege_model_version", privilege_model_version)
        if region is not None:
            _setter("region", region)
        if storage_root is not None:
            _setter("storage_root", storage_root)
        if storage_root_credential_id is not None:
            _setter("storage_root_credential_id", storage_root_credential_id)
        if storage_root_credential_name is not None:
            _setter("storage_root_credential_name", storage_root_credential_name)
        if updated_at is not None:
            _setter("updated_at", updated_at)
        if updated_by is not None:
            _setter("updated_by", updated_by)

    @property
    @pulumi.getter
    def cloud(self) -> Optional[str]:
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[str]):
        pulumi.set(self, "cloud", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[int]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[int]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[str]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter(name="defaultDataAccessConfigId")
    def default_data_access_config_id(self) -> Optional[str]:
        return pulumi.get(self, "default_data_access_config_id")

    @default_data_access_config_id.setter
    def default_data_access_config_id(self, value: Optional[str]):
        pulumi.set(self, "default_data_access_config_id", value)

    @property
    @pulumi.getter(name="deltaSharingOrganizationName")
    def delta_sharing_organization_name(self) -> Optional[str]:
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        return pulumi.get(self, "delta_sharing_organization_name")

    @delta_sharing_organization_name.setter
    def delta_sharing_organization_name(self, value: Optional[str]):
        pulumi.set(self, "delta_sharing_organization_name", value)

    @property
    @pulumi.getter(name="deltaSharingRecipientTokenLifetimeInSeconds")
    def delta_sharing_recipient_token_lifetime_in_seconds(self) -> Optional[int]:
        """
        Used to set expiration duration in seconds on recipient data access tokens.
        """
        return pulumi.get(self, "delta_sharing_recipient_token_lifetime_in_seconds")

    @delta_sharing_recipient_token_lifetime_in_seconds.setter
    def delta_sharing_recipient_token_lifetime_in_seconds(self, value: Optional[int]):
        pulumi.set(self, "delta_sharing_recipient_token_lifetime_in_seconds", value)

    @property
    @pulumi.getter(name="deltaSharingScope")
    def delta_sharing_scope(self) -> Optional[str]:
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL.
        """
        return pulumi.get(self, "delta_sharing_scope")

    @delta_sharing_scope.setter
    def delta_sharing_scope(self, value: Optional[str]):
        pulumi.set(self, "delta_sharing_scope", value)

    @property
    @pulumi.getter(name="globalMetastoreId")
    def global_metastore_id(self) -> Optional[str]:
        return pulumi.get(self, "global_metastore_id")

    @global_metastore_id.setter
    def global_metastore_id(self, value: Optional[str]):
        pulumi.set(self, "global_metastore_id", value)

    @property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[str]:
        """
        Id of the metastore to be fetched
        """
        return pulumi.get(self, "metastore_id")

    @metastore_id.setter
    def metastore_id(self, value: Optional[str]):
        pulumi.set(self, "metastore_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of metastore.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Username/groupname/sp application_id of the metastore owner.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="privilegeModelVersion")
    def privilege_model_version(self) -> Optional[str]:
        return pulumi.get(self, "privilege_model_version")

    @privilege_model_version.setter
    def privilege_model_version(self, value: Optional[str]):
        pulumi.set(self, "privilege_model_version", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[str]:
        """
        Path on cloud storage account, where managed `Table` are stored. Change forces creation of a new resource.
        """
        return pulumi.get(self, "storage_root")

    @storage_root.setter
    def storage_root(self, value: Optional[str]):
        pulumi.set(self, "storage_root", value)

    @property
    @pulumi.getter(name="storageRootCredentialId")
    def storage_root_credential_id(self) -> Optional[str]:
        return pulumi.get(self, "storage_root_credential_id")

    @storage_root_credential_id.setter
    def storage_root_credential_id(self, value: Optional[str]):
        pulumi.set(self, "storage_root_credential_id", value)

    @property
    @pulumi.getter(name="storageRootCredentialName")
    def storage_root_credential_name(self) -> Optional[str]:
        return pulumi.get(self, "storage_root_credential_name")

    @storage_root_credential_name.setter
    def storage_root_credential_name(self, value: Optional[str]):
        pulumi.set(self, "storage_root_credential_name", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[int]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[int]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[str]:
        return pulumi.get(self, "updated_by")

    @updated_by.setter
    def updated_by(self, value: Optional[str]):
        pulumi.set(self, "updated_by", value)


@pulumi.input_type
class GetShareObjectArgs:
    def __init__(__self__, *,
                 added_at: int,
                 added_by: str,
                 data_object_type: str,
                 name: str,
                 status: str,
                 cdf_enabled: Optional[bool] = None,
                 comment: Optional[str] = None,
                 history_data_sharing_status: Optional[str] = None,
                 partitions: Optional[Sequence['GetShareObjectPartitionArgs']] = None,
                 shared_as: Optional[str] = None,
                 start_version: Optional[int] = None):
        """
        :param str data_object_type: Type of the object.
        :param str name: The name of the share
        :param str comment: Description about the object.
        """
        GetShareObjectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            added_at=added_at,
            added_by=added_by,
            data_object_type=data_object_type,
            name=name,
            status=status,
            cdf_enabled=cdf_enabled,
            comment=comment,
            history_data_sharing_status=history_data_sharing_status,
            partitions=partitions,
            shared_as=shared_as,
            start_version=start_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             added_at: Optional[int] = None,
             added_by: Optional[str] = None,
             data_object_type: Optional[str] = None,
             name: Optional[str] = None,
             status: Optional[str] = None,
             cdf_enabled: Optional[bool] = None,
             comment: Optional[str] = None,
             history_data_sharing_status: Optional[str] = None,
             partitions: Optional[Sequence['GetShareObjectPartitionArgs']] = None,
             shared_as: Optional[str] = None,
             start_version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if added_at is None and 'addedAt' in kwargs:
            added_at = kwargs['addedAt']
        if added_at is None:
            raise TypeError("Missing 'added_at' argument")
        if added_by is None and 'addedBy' in kwargs:
            added_by = kwargs['addedBy']
        if added_by is None:
            raise TypeError("Missing 'added_by' argument")
        if data_object_type is None and 'dataObjectType' in kwargs:
            data_object_type = kwargs['dataObjectType']
        if data_object_type is None:
            raise TypeError("Missing 'data_object_type' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")
        if cdf_enabled is None and 'cdfEnabled' in kwargs:
            cdf_enabled = kwargs['cdfEnabled']
        if history_data_sharing_status is None and 'historyDataSharingStatus' in kwargs:
            history_data_sharing_status = kwargs['historyDataSharingStatus']
        if shared_as is None and 'sharedAs' in kwargs:
            shared_as = kwargs['sharedAs']
        if start_version is None and 'startVersion' in kwargs:
            start_version = kwargs['startVersion']

        _setter("added_at", added_at)
        _setter("added_by", added_by)
        _setter("data_object_type", data_object_type)
        _setter("name", name)
        _setter("status", status)
        if cdf_enabled is not None:
            _setter("cdf_enabled", cdf_enabled)
        if comment is not None:
            _setter("comment", comment)
        if history_data_sharing_status is not None:
            _setter("history_data_sharing_status", history_data_sharing_status)
        if partitions is not None:
            _setter("partitions", partitions)
        if shared_as is not None:
            _setter("shared_as", shared_as)
        if start_version is not None:
            _setter("start_version", start_version)

    @property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> int:
        return pulumi.get(self, "added_at")

    @added_at.setter
    def added_at(self, value: int):
        pulumi.set(self, "added_at", value)

    @property
    @pulumi.getter(name="addedBy")
    def added_by(self) -> str:
        return pulumi.get(self, "added_by")

    @added_by.setter
    def added_by(self, value: str):
        pulumi.set(self, "added_by", value)

    @property
    @pulumi.getter(name="dataObjectType")
    def data_object_type(self) -> str:
        """
        Type of the object.
        """
        return pulumi.get(self, "data_object_type")

    @data_object_type.setter
    def data_object_type(self, value: str):
        pulumi.set(self, "data_object_type", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the share
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="cdfEnabled")
    def cdf_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "cdf_enabled")

    @cdf_enabled.setter
    def cdf_enabled(self, value: Optional[bool]):
        pulumi.set(self, "cdf_enabled", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Description about the object.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[str]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="historyDataSharingStatus")
    def history_data_sharing_status(self) -> Optional[str]:
        return pulumi.get(self, "history_data_sharing_status")

    @history_data_sharing_status.setter
    def history_data_sharing_status(self, value: Optional[str]):
        pulumi.set(self, "history_data_sharing_status", value)

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['GetShareObjectPartitionArgs']]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: Optional[Sequence['GetShareObjectPartitionArgs']]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter(name="sharedAs")
    def shared_as(self) -> Optional[str]:
        return pulumi.get(self, "shared_as")

    @shared_as.setter
    def shared_as(self, value: Optional[str]):
        pulumi.set(self, "shared_as", value)

    @property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> Optional[int]:
        return pulumi.get(self, "start_version")

    @start_version.setter
    def start_version(self, value: Optional[int]):
        pulumi.set(self, "start_version", value)


@pulumi.input_type
class GetShareObjectPartitionArgs:
    def __init__(__self__, *,
                 values: Sequence['GetShareObjectPartitionValueArgs']):
        GetShareObjectPartitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Optional[Sequence['GetShareObjectPartitionValueArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if values is None:
            raise TypeError("Missing 'values' argument")

        _setter("values", values)

    @property
    @pulumi.getter
    def values(self) -> Sequence['GetShareObjectPartitionValueArgs']:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence['GetShareObjectPartitionValueArgs']):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetShareObjectPartitionValueArgs:
    def __init__(__self__, *,
                 name: str,
                 op: str,
                 recipient_property_key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the share
        """
        GetShareObjectPartitionValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            op=op,
            recipient_property_key=recipient_property_key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             op: Optional[str] = None,
             recipient_property_key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if op is None:
            raise TypeError("Missing 'op' argument")
        if recipient_property_key is None and 'recipientPropertyKey' in kwargs:
            recipient_property_key = kwargs['recipientPropertyKey']

        _setter("name", name)
        _setter("op", op)
        if recipient_property_key is not None:
            _setter("recipient_property_key", recipient_property_key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the share
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter(name="recipientPropertyKey")
    def recipient_property_key(self) -> Optional[str]:
        return pulumi.get(self, "recipient_property_key")

    @recipient_property_key.setter
    def recipient_property_key(self, value: Optional[str]):
        pulumi.set(self, "recipient_property_key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetSqlWarehouseChannelArgs:
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the SQL warehouse to search (case-sensitive).
        """
        GetSqlWarehouseChannelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the SQL warehouse to search (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetSqlWarehouseOdbcParamsArgs:
    def __init__(__self__, *,
                 path: str,
                 port: int,
                 protocol: str,
                 host: Optional[str] = None,
                 hostname: Optional[str] = None):
        GetSqlWarehouseOdbcParamsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            port=port,
            protocol=protocol,
            host=host,
            hostname=hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             port: Optional[int] = None,
             protocol: Optional[str] = None,
             host: Optional[str] = None,
             hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if path is None:
            raise TypeError("Missing 'path' argument")
        if port is None:
            raise TypeError("Missing 'port' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")

        _setter("path", path)
        _setter("port", port)
        _setter("protocol", protocol)
        if host is not None:
            _setter("host", host)
        if hostname is not None:
            _setter("hostname", hostname)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: int):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: str):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[str]):
        pulumi.set(self, "hostname", value)


@pulumi.input_type
class GetSqlWarehouseTagsArgs:
    def __init__(__self__, *,
                 custom_tags: Sequence['GetSqlWarehouseTagsCustomTagArgs']):
        GetSqlWarehouseTagsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_tags: Optional[Sequence['GetSqlWarehouseTagsCustomTagArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if custom_tags is None and 'customTags' in kwargs:
            custom_tags = kwargs['customTags']
        if custom_tags is None:
            raise TypeError("Missing 'custom_tags' argument")

        _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence['GetSqlWarehouseTagsCustomTagArgs']:
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Sequence['GetSqlWarehouseTagsCustomTagArgs']):
        pulumi.set(self, "custom_tags", value)


@pulumi.input_type
class GetSqlWarehouseTagsCustomTagArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        GetSqlWarehouseTagsCustomTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


