# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ClusterAutoscale',
    'ClusterAwsAttributes',
    'ClusterAzureAttributes',
    'ClusterClusterLogConf',
    'ClusterClusterLogConfDbfs',
    'ClusterClusterLogConfS3',
    'ClusterDockerImage',
    'ClusterDockerImageBasicAuth',
    'ClusterGcpAttributes',
    'ClusterInitScript',
    'ClusterInitScriptDbfs',
    'ClusterInitScriptFile',
    'ClusterInitScriptGcs',
    'ClusterInitScriptS3',
    'ClusterLibrary',
    'ClusterLibraryCran',
    'ClusterLibraryMaven',
    'ClusterLibraryPypi',
    'ClusterWorkloadType',
    'ClusterWorkloadTypeClients',
    'GrantsGrant',
    'InstancePoolAwsAttributes',
    'InstancePoolAzureAttributes',
    'InstancePoolDiskSpec',
    'InstancePoolDiskSpecDiskType',
    'InstancePoolGcpAttributes',
    'InstancePoolInstancePoolFleetAttributes',
    'InstancePoolInstancePoolFleetAttributesFleetOnDemandOption',
    'InstancePoolInstancePoolFleetAttributesFleetSpotOption',
    'InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride',
    'InstancePoolPreloadedDockerImage',
    'InstancePoolPreloadedDockerImageBasicAuth',
    'JobEmailNotifications',
    'JobGitSource',
    'JobJobCluster',
    'JobJobClusterNewCluster',
    'JobJobClusterNewClusterAutoscale',
    'JobJobClusterNewClusterAwsAttributes',
    'JobJobClusterNewClusterAzureAttributes',
    'JobJobClusterNewClusterClusterLogConf',
    'JobJobClusterNewClusterClusterLogConfDbfs',
    'JobJobClusterNewClusterClusterLogConfS3',
    'JobJobClusterNewClusterDockerImage',
    'JobJobClusterNewClusterDockerImageBasicAuth',
    'JobJobClusterNewClusterGcpAttributes',
    'JobJobClusterNewClusterInitScript',
    'JobJobClusterNewClusterInitScriptDbfs',
    'JobJobClusterNewClusterInitScriptFile',
    'JobJobClusterNewClusterInitScriptGcs',
    'JobJobClusterNewClusterInitScriptS3',
    'JobJobClusterNewClusterWorkloadType',
    'JobJobClusterNewClusterWorkloadTypeClients',
    'JobLibrary',
    'JobLibraryCran',
    'JobLibraryMaven',
    'JobLibraryPypi',
    'JobNewCluster',
    'JobNewClusterAutoscale',
    'JobNewClusterAwsAttributes',
    'JobNewClusterAzureAttributes',
    'JobNewClusterClusterLogConf',
    'JobNewClusterClusterLogConfDbfs',
    'JobNewClusterClusterLogConfS3',
    'JobNewClusterDockerImage',
    'JobNewClusterDockerImageBasicAuth',
    'JobNewClusterGcpAttributes',
    'JobNewClusterInitScript',
    'JobNewClusterInitScriptDbfs',
    'JobNewClusterInitScriptFile',
    'JobNewClusterInitScriptGcs',
    'JobNewClusterInitScriptS3',
    'JobNewClusterWorkloadType',
    'JobNewClusterWorkloadTypeClients',
    'JobNotebookTask',
    'JobPipelineTask',
    'JobPythonWheelTask',
    'JobSchedule',
    'JobSparkJarTask',
    'JobSparkPythonTask',
    'JobSparkSubmitTask',
    'JobTask',
    'JobTaskDbtTask',
    'JobTaskDependsOn',
    'JobTaskEmailNotifications',
    'JobTaskLibrary',
    'JobTaskLibraryCran',
    'JobTaskLibraryMaven',
    'JobTaskLibraryPypi',
    'JobTaskNewCluster',
    'JobTaskNewClusterAutoscale',
    'JobTaskNewClusterAwsAttributes',
    'JobTaskNewClusterAzureAttributes',
    'JobTaskNewClusterClusterLogConf',
    'JobTaskNewClusterClusterLogConfDbfs',
    'JobTaskNewClusterClusterLogConfS3',
    'JobTaskNewClusterDockerImage',
    'JobTaskNewClusterDockerImageBasicAuth',
    'JobTaskNewClusterGcpAttributes',
    'JobTaskNewClusterInitScript',
    'JobTaskNewClusterInitScriptDbfs',
    'JobTaskNewClusterInitScriptFile',
    'JobTaskNewClusterInitScriptGcs',
    'JobTaskNewClusterInitScriptS3',
    'JobTaskNewClusterWorkloadType',
    'JobTaskNewClusterWorkloadTypeClients',
    'JobTaskNotebookTask',
    'JobTaskPipelineTask',
    'JobTaskPythonWheelTask',
    'JobTaskSparkJarTask',
    'JobTaskSparkPythonTask',
    'JobTaskSparkSubmitTask',
    'JobTaskSqlTask',
    'JobTaskSqlTaskAlert',
    'JobTaskSqlTaskDashboard',
    'JobTaskSqlTaskQuery',
    'LibraryCran',
    'LibraryMaven',
    'LibraryPypi',
    'MetastoreDataAccessAwsIamRole',
    'MetastoreDataAccessAzureManagedIdentity',
    'MetastoreDataAccessAzureServicePrincipal',
    'MlflowModelTag',
    'MlflowWebhookHttpUrlSpec',
    'MlflowWebhookJobSpec',
    'MountAbfs',
    'MountAdl',
    'MountGs',
    'MountS3',
    'MountWasb',
    'MwsCustomerManagedKeysAwsKeyInfo',
    'MwsNetworksErrorMessage',
    'MwsNetworksVpcEndpoints',
    'MwsWorkspacesCloudResourceBucket',
    'MwsWorkspacesCloudResourceBucketGcp',
    'MwsWorkspacesExternalCustomerInfo',
    'MwsWorkspacesNetwork',
    'MwsWorkspacesNetworkGcpCommonNetworkConfig',
    'MwsWorkspacesNetworkGcpManagedNetworkConfig',
    'MwsWorkspacesToken',
    'PermissionsAccessControl',
    'PipelineCluster',
    'PipelineClusterAutoscale',
    'PipelineClusterAwsAttributes',
    'PipelineClusterClusterLogConf',
    'PipelineClusterClusterLogConfDbfs',
    'PipelineClusterClusterLogConfS3',
    'PipelineClusterGcpAttributes',
    'PipelineClusterInitScript',
    'PipelineClusterInitScriptDbfs',
    'PipelineClusterInitScriptFile',
    'PipelineClusterInitScriptGcs',
    'PipelineClusterInitScriptS3',
    'PipelineFilters',
    'PipelineLibrary',
    'PipelineLibraryMaven',
    'PipelineLibraryNotebook',
    'SecretScopeKeyvaultMetadata',
    'SqlEndpointChannel',
    'SqlEndpointOdbcParams',
    'SqlEndpointTags',
    'SqlEndpointTagsCustomTag',
    'SqlPermissionsPrivilegeAssignment',
    'SqlQueryParameter',
    'SqlQueryParameterDate',
    'SqlQueryParameterDateRange',
    'SqlQueryParameterDatetime',
    'SqlQueryParameterDatetimeRange',
    'SqlQueryParameterDatetimesec',
    'SqlQueryParameterDatetimesecRange',
    'SqlQueryParameterEnum',
    'SqlQueryParameterEnumMultiple',
    'SqlQueryParameterNumber',
    'SqlQueryParameterQuery',
    'SqlQueryParameterQueryMultiple',
    'SqlQueryParameterText',
    'SqlQuerySchedule',
    'SqlQueryScheduleContinuous',
    'SqlQueryScheduleDaily',
    'SqlQueryScheduleWeekly',
    'SqlWidgetParameter',
    'SqlWidgetPosition',
    'StorageCredentialAwsIamRole',
    'StorageCredentialAzureManagedIdentity',
    'StorageCredentialAzureServicePrincipal',
    'TableColumn',
    'GetClusterClusterInfoResult',
    'GetClusterClusterInfoAutoscaleResult',
    'GetClusterClusterInfoAwsAttributesResult',
    'GetClusterClusterInfoAzureAttributesResult',
    'GetClusterClusterInfoClusterLogConfResult',
    'GetClusterClusterInfoClusterLogConfDbfsResult',
    'GetClusterClusterInfoClusterLogConfS3Result',
    'GetClusterClusterInfoClusterLogStatusResult',
    'GetClusterClusterInfoDockerImageResult',
    'GetClusterClusterInfoDockerImageBasicAuthResult',
    'GetClusterClusterInfoDriverResult',
    'GetClusterClusterInfoDriverNodeAwsAttributesResult',
    'GetClusterClusterInfoExecutorResult',
    'GetClusterClusterInfoExecutorNodeAwsAttributesResult',
    'GetClusterClusterInfoGcpAttributesResult',
    'GetClusterClusterInfoInitScriptResult',
    'GetClusterClusterInfoInitScriptDbfsResult',
    'GetClusterClusterInfoInitScriptS3Result',
    'GetClusterClusterInfoTerminationReasonResult',
    'GetDbfsFilePathsPathListResult',
    'GetNotebookPathsNotebookPathListResult',
    'GetSqlWarehouseChannelResult',
    'GetSqlWarehouseOdbcParamsResult',
    'GetSqlWarehouseTagsResult',
    'GetSqlWarehouseTagsCustomTagResult',
]

@pulumi.output_type
class ClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class ClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class ClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.ClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.ClusterClusterLogConfS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.ClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.ClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class ClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['outputs.ClusterDockerImageBasicAuth'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.ClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class ClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class ClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ClusterInitScript(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.ClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.ClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.ClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.ClusterInitScriptS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.ClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.ClusterInitScriptFile']:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.ClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.ClusterInitScriptS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class ClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterLibrary(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.ClusterLibraryCran'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['outputs.ClusterLibraryMaven'] = None,
                 pypi: Optional['outputs.ClusterLibraryPypi'] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['outputs.ClusterLibraryCran']:
        return pulumi.get(self, "cran")

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @property
    @pulumi.getter
    def maven(self) -> Optional['outputs.ClusterLibraryMaven']:
        return pulumi.get(self, "maven")

    @property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.ClusterLibraryPypi']:
        return pulumi.get(self, "pypi")

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class ClusterLibraryCran(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterLibraryPypi(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.ClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'outputs.ClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class ClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GrantsGrant(dict):
    def __init__(__self__, *,
                 principal: str,
                 privileges: Sequence[str]):
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "privileges", privileges)

    @property
    @pulumi.getter
    def principal(self) -> str:
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def privileges(self) -> Sequence[str]:
        return pulumi.get(self, "privileges")


@pulumi.output_type
class InstancePoolAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        """
        :param str availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param int spot_bid_price_percent: (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        :param str zone_id: (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. This is an optional field. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        """
        (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type’s on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        """
        return pulumi.get(self, "spot_bid_price_percent")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. This is an optional field. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class InstancePoolAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 spot_bid_max_price: Optional[float] = None):
        """
        :param str availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param float spot_bid_max_price: The max price for Azure spot instances.  Use `-1` to specify the lowest price.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        """
        The max price for Azure spot instances.  Use `-1` to specify the lowest price.
        """
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class InstancePoolDiskSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskCount":
            suggest = "disk_count"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolDiskSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolDiskSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolDiskSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_count: Optional[int] = None,
                 disk_size: Optional[int] = None,
                 disk_type: Optional['outputs.InstancePoolDiskSpecDiskType'] = None):
        """
        :param int disk_count: (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        :param int disk_size: (Integer) The size of each disk (in GiB) to attach.
        """
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[int]:
        """
        (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        """
        return pulumi.get(self, "disk_count")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        """
        (Integer) The size of each disk (in GiB) to attach.
        """
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional['outputs.InstancePoolDiskSpecDiskType']:
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class InstancePoolDiskSpecDiskType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureDiskVolumeType":
            suggest = "azure_disk_volume_type"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolDiskSpecDiskType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolDiskSpecDiskType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolDiskSpecDiskType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[str] = None,
                 ebs_volume_type: Optional[str] = None):
        if azure_disk_volume_type is not None:
            pulumi.set(__self__, "azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)

    @property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "azure_disk_volume_type")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")


@pulumi.output_type
class InstancePoolGcpAttributes(dict):
    def __init__(__self__, *,
                 availability: Optional[str] = None):
        """
        :param str availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "availability")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateOverrides":
            suggest = "launch_template_overrides"
        elif key == "fleetOnDemandOption":
            suggest = "fleet_on_demand_option"
        elif key == "fleetSpotOption":
            suggest = "fleet_spot_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_overrides: Sequence['outputs.InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride'],
                 fleet_on_demand_option: Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetOnDemandOption'] = None,
                 fleet_spot_option: Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetSpotOption'] = None):
        pulumi.set(__self__, "launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            pulumi.set(__self__, "fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            pulumi.set(__self__, "fleet_spot_option", fleet_spot_option)

    @property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> Sequence['outputs.InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride']:
        return pulumi.get(self, "launch_template_overrides")

    @property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetOnDemandOption']:
        return pulumi.get(self, "fleet_on_demand_option")

    @property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetSpotOption']:
        return pulumi.get(self, "fleet_spot_option")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributesFleetOnDemandOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributesFleetOnDemandOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetOnDemandOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetOnDemandOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: str,
                 instance_pools_to_use_count: Optional[int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributesFleetSpotOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributesFleetSpotOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetSpotOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetSpotOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: str,
                 instance_pools_to_use_count: Optional[int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: str,
                 instance_type: str):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")


@pulumi.output_type
class InstancePoolPreloadedDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolPreloadedDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolPreloadedDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolPreloadedDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['outputs.InstancePoolPreloadedDockerImageBasicAuth'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.InstancePoolPreloadedDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class InstancePoolPreloadedDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnLastAttempt":
            suggest = "alert_on_last_attempt"
        elif key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        """
        :param bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs
        :param Sequence[str] on_failures: (List) list of emails to notify on failure
        :param Sequence[str] on_starts: (List) list of emails to notify on failure
        :param Sequence[str] on_successes: (List) list of emails to notify on failure
        """
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        """
        (Bool) don't send alert for skipped runs
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        """
        (List) list of emails to notify on failure
        """
        return pulumi.get(self, "on_failures")

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        """
        (List) list of emails to notify on failure
        """
        return pulumi.get(self, "on_starts")

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        """
        (List) list of emails to notify on failure
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobGitSource(dict):
    def __init__(__self__, *,
                 url: str,
                 branch: Optional[str] = None,
                 commit: Optional[str] = None,
                 provider: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str url: URL of the job on the given workspace
        :param str branch: name of the Git branch to use. Conflicts with `tag` and `commit`.
        :param str commit: hash of Git commit to use. Conflicts with `branch` and `tag`.
        :param str provider: case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        :param str tag: name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        pulumi.set(__self__, "url", url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        name of the Git branch to use. Conflicts with `tag` and `commit`.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter
    def commit(self) -> Optional[str]:
        """
        hash of Git commit to use. Conflicts with `branch` and `tag`.
        """
        return pulumi.get(self, "commit")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class JobJobCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobClusterKey":
            suggest = "job_cluster_key"
        elif key == "newCluster":
            suggest = "new_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_cluster_key: Optional[str] = None,
                 new_cluster: Optional['outputs.JobJobClusterNewCluster'] = None):
        """
        :param str job_cluster_key: Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        :param 'JobJobClusterNewClusterArgs' new_cluster: Same set of parameters as for Cluster resource.
        """
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[str]:
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        return pulumi.get(self, "job_cluster_key")

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.JobJobClusterNewCluster']:
        """
        Same set of parameters as for Cluster resource.
        """
        return pulumi.get(self, "new_cluster")


@pulumi.output_type
class JobJobClusterNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkVersion":
            suggest = "spark_version"
        elif key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "autoterminationMinutes":
            suggest = "autotermination_minutes"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['outputs.JobJobClusterNewClusterAutoscale'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['outputs.JobJobClusterNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobJobClusterNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['outputs.JobJobClusterNewClusterClusterLogConf'] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['outputs.JobJobClusterNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[str] = None,
                 driver_node_type_id: Optional[str] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 enable_local_disk_encryption: Optional[bool] = None,
                 gcp_attributes: Optional['outputs.JobJobClusterNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['outputs.JobJobClusterNewClusterInitScript']] = None,
                 instance_pool_id: Optional[str] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['outputs.JobJobClusterNewClusterWorkloadType'] = None):
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobJobClusterNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobJobClusterNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobJobClusterNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobJobClusterNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_node_type_id")

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobJobClusterNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobJobClusterNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "node_type_id")

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobJobClusterNewClusterWorkloadType']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobJobClusterNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobJobClusterNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobJobClusterNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobJobClusterNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobJobClusterNewClusterClusterLogConfS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobJobClusterNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['outputs.JobJobClusterNewClusterDockerImageBasicAuth'] = None):
        """
        :param str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobJobClusterNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobJobClusterNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobJobClusterNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobJobClusterNewClusterInitScript(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobJobClusterNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobJobClusterNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobJobClusterNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobJobClusterNewClusterInitScriptS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptFile']:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobJobClusterNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobJobClusterNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'outputs.JobJobClusterNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobJobClusterNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobLibrary(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.JobLibraryCran'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['outputs.JobLibraryMaven'] = None,
                 pypi: Optional['outputs.JobLibraryPypi'] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobLibraryCran']:
        return pulumi.get(self, "cran")

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobLibraryMaven']:
        return pulumi.get(self, "maven")

    @property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobLibraryPypi']:
        return pulumi.get(self, "pypi")

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobLibraryCran(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobLibraryPypi(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkVersion":
            suggest = "spark_version"
        elif key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "autoterminationMinutes":
            suggest = "autotermination_minutes"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['outputs.JobNewClusterAutoscale'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['outputs.JobNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['outputs.JobNewClusterClusterLogConf'] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['outputs.JobNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[str] = None,
                 driver_node_type_id: Optional[str] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 enable_local_disk_encryption: Optional[bool] = None,
                 gcp_attributes: Optional['outputs.JobNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['outputs.JobNewClusterInitScript']] = None,
                 instance_pool_id: Optional[str] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['outputs.JobNewClusterWorkloadType'] = None):
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_node_type_id")

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "node_type_id")

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobNewClusterWorkloadType']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobNewClusterClusterLogConfS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class JobNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['outputs.JobNewClusterDockerImageBasicAuth'] = None):
        """
        :param str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobNewClusterInitScript(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobNewClusterInitScriptS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobNewClusterInitScriptFile']:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class JobNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'outputs.JobNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPath":
            suggest = "notebook_path"
        elif key == "baseParameters":
            suggest = "base_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, Any]] = None):
        """
        :param str notebook_path: The absolute path of the Notebook to be run in the Databricks workspace. This path must begin with a slash. This field is required.
        :param Mapping[str, Any] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        """
        The absolute path of the Notebook to be run in the Databricks workspace. This path must begin with a slash. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, Any]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")


@pulumi.output_type
class JobPipelineTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobPipelineTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobPipelineTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobPipelineTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: str):
        """
        :param str pipeline_id: The pipeline's unique ID.
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")


@pulumi.output_type
class JobPythonWheelTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "namedParameters":
            suggest = "named_parameters"
        elif key == "packageName":
            suggest = "package_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobPythonWheelTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobPythonWheelTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobPythonWheelTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, Any]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param str entry_point: Python function as entry point for the task
        :param Mapping[str, Any] named_parameters: Named parameters for the task
        :param str package_name: Name of Python package
        :param Sequence[str] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronExpression":
            suggest = "quartz_cron_expression"
        elif key == "timezoneId":
            suggest = "timezone_id"
        elif key == "pauseStatus":
            suggest = "pause_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_expression: str,
                 timezone_id: str,
                 pause_status: Optional[str] = None):
        """
        :param str quartz_cron_expression: A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        :param str timezone_id: A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        :param str pause_status: Indicate whether this schedule is paused or not. Either “PAUSED” or “UNPAUSED”. When the pause_status field is omitted and a schedule is provided, the server will default to using "UNPAUSED" as a value for pause_status.
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> str:
        """
        A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> str:
        """
        A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        """
        return pulumi.get(self, "timezone_id")

    @property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[str]:
        """
        Indicate whether this schedule is paused or not. Either “PAUSED” or “UNPAUSED”. When the pause_status field is omitted and a schedule is provided, the server will default to using "UNPAUSED" as a value for pause_status.
        """
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class JobSparkJarTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jarUri":
            suggest = "jar_uri"
        elif key == "mainClassName":
            suggest = "main_class_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSparkJarTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSparkJarTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSparkJarTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param str main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param Sequence[str] parameters: Parameters for the task
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobSparkPythonTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonFile":
            suggest = "python_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSparkPythonTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSparkPythonTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSparkPythonTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param str python_file: The URI of the Python file to be executed. DbfsFile and S3 paths are supported. This field is required.
        :param Sequence[str] parameters: Parameters for the task
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        """
        The URI of the Python file to be executed. DbfsFile and S3 paths are supported. This field is required.
        """
        return pulumi.get(self, "python_file")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobSparkSubmitTask(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] parameters: Parameters for the task
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbtTask":
            suggest = "dbt_task"
        elif key == "dependsOns":
            suggest = "depends_ons"
        elif key == "emailNotifications":
            suggest = "email_notifications"
        elif key == "existingClusterId":
            suggest = "existing_cluster_id"
        elif key == "jobClusterKey":
            suggest = "job_cluster_key"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "minRetryIntervalMillis":
            suggest = "min_retry_interval_millis"
        elif key == "newCluster":
            suggest = "new_cluster"
        elif key == "notebookTask":
            suggest = "notebook_task"
        elif key == "pipelineTask":
            suggest = "pipeline_task"
        elif key == "pythonWheelTask":
            suggest = "python_wheel_task"
        elif key == "retryOnTimeout":
            suggest = "retry_on_timeout"
        elif key == "sparkJarTask":
            suggest = "spark_jar_task"
        elif key == "sparkPythonTask":
            suggest = "spark_python_task"
        elif key == "sparkSubmitTask":
            suggest = "spark_submit_task"
        elif key == "sqlTask":
            suggest = "sql_task"
        elif key == "taskKey":
            suggest = "task_key"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbt_task: Optional['outputs.JobTaskDbtTask'] = None,
                 depends_ons: Optional[Sequence['outputs.JobTaskDependsOn']] = None,
                 description: Optional[str] = None,
                 email_notifications: Optional['outputs.JobTaskEmailNotifications'] = None,
                 existing_cluster_id: Optional[str] = None,
                 job_cluster_key: Optional[str] = None,
                 libraries: Optional[Sequence['outputs.JobTaskLibrary']] = None,
                 max_retries: Optional[int] = None,
                 min_retry_interval_millis: Optional[int] = None,
                 new_cluster: Optional['outputs.JobTaskNewCluster'] = None,
                 notebook_task: Optional['outputs.JobTaskNotebookTask'] = None,
                 pipeline_task: Optional['outputs.JobTaskPipelineTask'] = None,
                 python_wheel_task: Optional['outputs.JobTaskPythonWheelTask'] = None,
                 retry_on_timeout: Optional[bool] = None,
                 spark_jar_task: Optional['outputs.JobTaskSparkJarTask'] = None,
                 spark_python_task: Optional['outputs.JobTaskSparkPythonTask'] = None,
                 spark_submit_task: Optional['outputs.JobTaskSparkSubmitTask'] = None,
                 sql_task: Optional['outputs.JobTaskSqlTask'] = None,
                 task_key: Optional[str] = None,
                 timeout_seconds: Optional[int] = None):
        """
        :param 'JobTaskEmailNotificationsArgs' email_notifications: (List) An optional set of email addresses notified when runs of this job begin and complete and when this job is deleted. The default behavior is to not send any emails. This field is a block and is documented below.
        :param str existing_cluster_id: If existing_cluster_id, the ID of an existing cluster that will be used for all runs of this job. When running jobs on an existing cluster, you may need to manually restart the cluster if it stops responding. We strongly suggest to use `new_cluster` for greater reliability.
        :param str job_cluster_key: Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        :param Sequence['JobTaskLibraryArgs'] libraries: (Set) An optional list of libraries to be installed on the cluster that will execute the job. Please consult libraries section for Cluster resource.
        :param int max_retries: (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a FAILED result_state or INTERNAL_ERROR life_cycle_state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry.
        :param int min_retry_interval_millis: (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        :param 'JobTaskNewClusterArgs' new_cluster: Same set of parameters as for Cluster resource.
        :param bool retry_on_timeout: (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        :param int timeout_seconds: (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if task_key is not None:
            pulumi.set(__self__, "task_key", task_key)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['outputs.JobTaskDbtTask']:
        return pulumi.get(self, "dbt_task")

    @property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['outputs.JobTaskDependsOn']]:
        return pulumi.get(self, "depends_ons")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['outputs.JobTaskEmailNotifications']:
        """
        (List) An optional set of email addresses notified when runs of this job begin and complete and when this job is deleted. The default behavior is to not send any emails. This field is a block and is documented below.
        """
        return pulumi.get(self, "email_notifications")

    @property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[str]:
        """
        If existing_cluster_id, the ID of an existing cluster that will be used for all runs of this job. When running jobs on an existing cluster, you may need to manually restart the cluster if it stops responding. We strongly suggest to use `new_cluster` for greater reliability.
        """
        return pulumi.get(self, "existing_cluster_id")

    @property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[str]:
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        return pulumi.get(self, "job_cluster_key")

    @property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobTaskLibrary']]:
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job. Please consult libraries section for Cluster resource.
        """
        return pulumi.get(self, "libraries")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a FAILED result_state or INTERNAL_ERROR life_cycle_state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry.
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[int]:
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        return pulumi.get(self, "min_retry_interval_millis")

    @property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.JobTaskNewCluster']:
        """
        Same set of parameters as for Cluster resource.
        """
        return pulumi.get(self, "new_cluster")

    @property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['outputs.JobTaskNotebookTask']:
        return pulumi.get(self, "notebook_task")

    @property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['outputs.JobTaskPipelineTask']:
        return pulumi.get(self, "pipeline_task")

    @property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['outputs.JobTaskPythonWheelTask']:
        return pulumi.get(self, "python_wheel_task")

    @property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[bool]:
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        return pulumi.get(self, "retry_on_timeout")

    @property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['outputs.JobTaskSparkJarTask']:
        return pulumi.get(self, "spark_jar_task")

    @property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['outputs.JobTaskSparkPythonTask']:
        return pulumi.get(self, "spark_python_task")

    @property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['outputs.JobTaskSparkSubmitTask']:
        return pulumi.get(self, "spark_submit_task")

    @property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['outputs.JobTaskSqlTask']:
        return pulumi.get(self, "sql_task")

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> Optional[str]:
        return pulumi.get(self, "task_key")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class JobTaskDbtTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectDirectory":
            suggest = "project_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDbtTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDbtTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDbtTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[str],
                 project_directory: Optional[str] = None,
                 schema: Optional[str] = None):
        pulumi.set(__self__, "commands", commands)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[str]:
        return pulumi.get(self, "project_directory")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        return pulumi.get(self, "schema")


@pulumi.output_type
class JobTaskDependsOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskKey":
            suggest = "task_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDependsOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDependsOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDependsOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_key: Optional[str] = None):
        if task_key is not None:
            pulumi.set(__self__, "task_key", task_key)

    @property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> Optional[str]:
        return pulumi.get(self, "task_key")


@pulumi.output_type
class JobTaskEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnLastAttempt":
            suggest = "alert_on_last_attempt"
        elif key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[bool] = None,
                 no_alert_for_skipped_runs: Optional[bool] = None,
                 on_failures: Optional[Sequence[str]] = None,
                 on_starts: Optional[Sequence[str]] = None,
                 on_successes: Optional[Sequence[str]] = None):
        """
        :param bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs
        :param Sequence[str] on_failures: (List) list of emails to notify on failure
        :param Sequence[str] on_starts: (List) list of emails to notify on failure
        :param Sequence[str] on_successes: (List) list of emails to notify on failure
        """
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[bool]:
        """
        (Bool) don't send alert for skipped runs
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[str]]:
        """
        (List) list of emails to notify on failure
        """
        return pulumi.get(self, "on_failures")

    @property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[str]]:
        """
        (List) list of emails to notify on failure
        """
        return pulumi.get(self, "on_starts")

    @property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[str]]:
        """
        (List) list of emails to notify on failure
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobTaskLibrary(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.JobTaskLibraryCran'] = None,
                 egg: Optional[str] = None,
                 jar: Optional[str] = None,
                 maven: Optional['outputs.JobTaskLibraryMaven'] = None,
                 pypi: Optional['outputs.JobTaskLibraryPypi'] = None,
                 whl: Optional[str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobTaskLibraryCran']:
        return pulumi.get(self, "cran")

    @property
    @pulumi.getter
    def egg(self) -> Optional[str]:
        return pulumi.get(self, "egg")

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobTaskLibraryMaven']:
        return pulumi.get(self, "maven")

    @property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobTaskLibraryPypi']:
        return pulumi.get(self, "pypi")

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobTaskLibraryCran(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskLibraryPypi(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sparkVersion":
            suggest = "spark_version"
        elif key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "autoterminationMinutes":
            suggest = "autotermination_minutes"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 spark_version: str,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['outputs.JobTaskNewClusterAutoscale'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['outputs.JobTaskNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobTaskNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['outputs.JobTaskNewClusterClusterLogConf'] = None,
                 cluster_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['outputs.JobTaskNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[str] = None,
                 driver_node_type_id: Optional[str] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 enable_local_disk_encryption: Optional[bool] = None,
                 gcp_attributes: Optional['outputs.JobTaskNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[str] = None,
                 init_scripts: Optional[Sequence['outputs.JobTaskNewClusterInitScript']] = None,
                 instance_pool_id: Optional[str] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 workload_type: Optional['outputs.JobTaskNewClusterWorkloadType'] = None):
        pulumi.set(__self__, "spark_version", spark_version)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        return pulumi.get(self, "spark_version")

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobTaskNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        return pulumi.get(self, "autotermination_minutes")

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobTaskNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobTaskNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobTaskNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        return pulumi.get(self, "data_security_mode")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobTaskNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_node_type_id")

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobTaskNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[str]:
        return pulumi.get(self, "idempotency_token")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobTaskNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "node_type_id")

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        return pulumi.get(self, "single_user_name")

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobTaskNewClusterWorkloadType']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobTaskNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobTaskNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobTaskNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobTaskNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobTaskNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobTaskNewClusterClusterLogConfS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobTaskNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobTaskNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class JobTaskNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobTaskNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['outputs.JobTaskNewClusterDockerImageBasicAuth'] = None):
        """
        :param str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobTaskNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobTaskNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobTaskNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobTaskNewClusterInitScript(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobTaskNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobTaskNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobTaskNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobTaskNewClusterInitScriptS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobTaskNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobTaskNewClusterInitScriptFile']:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobTaskNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobTaskNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class JobTaskNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobTaskNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobTaskNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @property
    @pulumi.getter
    def clients(self) -> 'outputs.JobTaskNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobTaskNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[bool] = None,
                 notebooks: Optional[bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[bool]:
        return pulumi.get(self, "jobs")

    @property
    @pulumi.getter
    def notebooks(self) -> Optional[bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobTaskNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPath":
            suggest = "notebook_path"
        elif key == "baseParameters":
            suggest = "base_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_path: str,
                 base_parameters: Optional[Mapping[str, Any]] = None):
        """
        :param str notebook_path: The absolute path of the Notebook to be run in the Databricks workspace. This path must begin with a slash. This field is required.
        :param Mapping[str, Any] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)

    @property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> str:
        """
        The absolute path of the Notebook to be run in the Databricks workspace. This path must begin with a slash. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, Any]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job’s base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")


@pulumi.output_type
class JobTaskPipelineTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPipelineTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPipelineTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPipelineTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: str):
        """
        :param str pipeline_id: The pipeline's unique ID.
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")


@pulumi.output_type
class JobTaskPythonWheelTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "namedParameters":
            suggest = "named_parameters"
        elif key == "packageName":
            suggest = "package_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPythonWheelTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPythonWheelTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPythonWheelTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point: Optional[str] = None,
                 named_parameters: Optional[Mapping[str, Any]] = None,
                 package_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param str entry_point: Python function as entry point for the task
        :param Mapping[str, Any] named_parameters: Named parameters for the task
        :param str package_name: Name of Python package
        :param Sequence[str] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[str]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskSparkJarTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jarUri":
            suggest = "jar_uri"
        elif key == "mainClassName":
            suggest = "main_class_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSparkJarTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSparkJarTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSparkJarTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar_uri: Optional[str] = None,
                 main_class_name: Optional[str] = None,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param str main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param Sequence[str] parameters: Parameters for the task
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[str]:
        return pulumi.get(self, "jar_uri")

    @property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[str]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskSparkPythonTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonFile":
            suggest = "python_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSparkPythonTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSparkPythonTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSparkPythonTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_file: str,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param str python_file: The URI of the Python file to be executed. DbfsFile and S3 paths are supported. This field is required.
        :param Sequence[str] parameters: Parameters for the task
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> str:
        """
        The URI of the Python file to be executed. DbfsFile and S3 paths are supported. This field is required.
        """
        return pulumi.get(self, "python_file")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskSparkSubmitTask(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] parameters: Parameters for the task
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskSqlTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: Optional['outputs.JobTaskSqlTaskAlert'] = None,
                 dashboard: Optional['outputs.JobTaskSqlTaskDashboard'] = None,
                 parameters: Optional[Mapping[str, Any]] = None,
                 query: Optional['outputs.JobTaskSqlTaskQuery'] = None,
                 warehouse_id: Optional[str] = None):
        """
        :param Mapping[str, Any] parameters: Parameters for the task
        """
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @property
    @pulumi.getter
    def alert(self) -> Optional['outputs.JobTaskSqlTaskAlert']:
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter
    def dashboard(self) -> Optional['outputs.JobTaskSqlTaskDashboard']:
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.JobTaskSqlTaskQuery']:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskSqlTaskAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str):
        pulumi.set(__self__, "alert_id", alert_id)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")


@pulumi.output_type
class JobTaskSqlTaskDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardId":
            suggest = "dashboard_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_id: str):
        pulumi.set(__self__, "dashboard_id", dashboard_id)

    @property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> str:
        return pulumi.get(self, "dashboard_id")


@pulumi.output_type
class JobTaskSqlTaskQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: str):
        pulumi.set(__self__, "query_id", query_id)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        return pulumi.get(self, "query_id")


@pulumi.output_type
class LibraryCran(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class LibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class LibraryPypi(dict):
    def __init__(__self__, *,
                 package: str,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def package(self) -> str:
        return pulumi.get(self, "package")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class MetastoreDataAccessAwsIamRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessAwsIamRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessAwsIamRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessAwsIamRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class MetastoreDataAccessAzureManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConnectorId":
            suggest = "access_connector_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessAzureManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessAzureManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessAzureManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_connector_id: str):
        """
        :param str access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> str:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`
        """
        return pulumi.get(self, "access_connector_id")


@pulumi.output_type
class MetastoreDataAccessAzureServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessAzureServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessAzureServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessAzureServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: str,
                 client_secret: str,
                 directory_id: str):
        """
        :param str application_id: The application ID of the application registration within the referenced AAD tenant
        :param str client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
        :param str directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class MlflowModelTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class MlflowWebhookHttpUrlSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSslVerification":
            suggest = "enable_ssl_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlflowWebhookHttpUrlSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlflowWebhookHttpUrlSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlflowWebhookHttpUrlSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 authorization: Optional[str] = None,
                 enable_ssl_verification: Optional[bool] = None,
                 string: Optional[str] = None):
        """
        :param str url: External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        :param str authorization: Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        :param bool enable_ssl_verification: Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        """
        pulumi.set(__self__, "url", url)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if enable_ssl_verification is not None:
            pulumi.set(__self__, "enable_ssl_verification", enable_ssl_verification)
        if string is not None:
            pulumi.set(__self__, "string", string)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def authorization(self) -> Optional[str]:
        """
        Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="enableSslVerification")
    def enable_ssl_verification(self) -> Optional[bool]:
        """
        Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        """
        return pulumi.get(self, "enable_ssl_verification")

    @property
    @pulumi.getter
    def string(self) -> Optional[str]:
        return pulumi.get(self, "string")


@pulumi.output_type
class MlflowWebhookJobSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "jobId":
            suggest = "job_id"
        elif key == "workspaceUrl":
            suggest = "workspace_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlflowWebhookJobSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlflowWebhookJobSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlflowWebhookJobSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 job_id: str,
                 workspace_url: Optional[str] = None):
        """
        :param str access_token: The personal access token used to authorize webhook's job runs.
        :param str job_id: ID of the Databricks job that the webhook runs.
        :param str workspace_url: URL of the workspace containing the job that this webhook runs. If not specified, the job’s workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "job_id", job_id)
        if workspace_url is not None:
            pulumi.set(__self__, "workspace_url", workspace_url)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The personal access token used to authorize webhook's job runs.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> str:
        """
        ID of the Databricks job that the webhook runs.
        """
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="workspaceUrl")
    def workspace_url(self) -> Optional[str]:
        """
        URL of the workspace containing the job that this webhook runs. If not specified, the job’s workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        return pulumi.get(self, "workspace_url")


@pulumi.output_type
class MountAbfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretKey":
            suggest = "client_secret_key"
        elif key == "clientSecretScope":
            suggest = "client_secret_scope"
        elif key == "initializeFileSystem":
            suggest = "initialize_file_system"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountAbfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountAbfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountAbfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_key: str,
                 client_secret_scope: str,
                 initialize_file_system: bool,
                 container_name: Optional[str] = None,
                 directory: Optional[str] = None,
                 storage_account_name: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_key", client_secret_key)
        pulumi.set(__self__, "client_secret_scope", client_secret_scope)
        pulumi.set(__self__, "initialize_file_system", initialize_file_system)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> str:
        return pulumi.get(self, "client_secret_key")

    @property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> str:
        return pulumi.get(self, "client_secret_scope")

    @property
    @pulumi.getter(name="initializeFileSystem")
    def initialize_file_system(self) -> bool:
        return pulumi.get(self, "initialize_file_system")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[str]:
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class MountAdl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretKey":
            suggest = "client_secret_key"
        elif key == "clientSecretScope":
            suggest = "client_secret_scope"
        elif key == "sparkConfPrefix":
            suggest = "spark_conf_prefix"
        elif key == "storageResourceName":
            suggest = "storage_resource_name"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountAdl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountAdl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountAdl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_key: str,
                 client_secret_scope: str,
                 directory: Optional[str] = None,
                 spark_conf_prefix: Optional[str] = None,
                 storage_resource_name: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_key", client_secret_key)
        pulumi.set(__self__, "client_secret_scope", client_secret_scope)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if spark_conf_prefix is not None:
            pulumi.set(__self__, "spark_conf_prefix", spark_conf_prefix)
        if storage_resource_name is not None:
            pulumi.set(__self__, "storage_resource_name", storage_resource_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> str:
        return pulumi.get(self, "client_secret_key")

    @property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> str:
        return pulumi.get(self, "client_secret_scope")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter(name="sparkConfPrefix")
    def spark_conf_prefix(self) -> Optional[str]:
        return pulumi.get(self, "spark_conf_prefix")

    @property
    @pulumi.getter(name="storageResourceName")
    def storage_resource_name(self) -> Optional[str]:
        return pulumi.get(self, "storage_resource_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class MountGs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountGs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountGs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountGs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 service_account: Optional[str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        return pulumi.get(self, "service_account")


@pulumi.output_type
class MountS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "instanceProfile":
            suggest = "instance_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 instance_profile: Optional[str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if instance_profile is not None:
            pulumi.set(__self__, "instance_profile", instance_profile)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="instanceProfile")
    def instance_profile(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile")


@pulumi.output_type
class MountWasb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "tokenSecretKey":
            suggest = "token_secret_key"
        elif key == "tokenSecretScope":
            suggest = "token_secret_scope"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountName":
            suggest = "storage_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountWasb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountWasb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountWasb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 token_secret_key: str,
                 token_secret_scope: str,
                 container_name: Optional[str] = None,
                 directory: Optional[str] = None,
                 storage_account_name: Optional[str] = None):
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "token_secret_key", token_secret_key)
        pulumi.set(__self__, "token_secret_scope", token_secret_scope)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="tokenSecretKey")
    def token_secret_key(self) -> str:
        return pulumi.get(self, "token_secret_key")

    @property
    @pulumi.getter(name="tokenSecretScope")
    def token_secret_scope(self) -> str:
        return pulumi.get(self, "token_secret_scope")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def directory(self) -> Optional[str]:
        return pulumi.get(self, "directory")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[str]:
        return pulumi.get(self, "storage_account_name")


@pulumi.output_type
class MwsCustomerManagedKeysAwsKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyAlias":
            suggest = "key_alias"
        elif key == "keyArn":
            suggest = "key_arn"
        elif key == "keyRegion":
            suggest = "key_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsCustomerManagedKeysAwsKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsCustomerManagedKeysAwsKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsCustomerManagedKeysAwsKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_alias: str,
                 key_arn: str,
                 key_region: Optional[str] = None):
        """
        :param str key_alias: The AWS KMS key alias.
        :param str key_arn: The AWS KMS key's Amazon Resource Name (ARN).
        :param str key_region: (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        pulumi.set(__self__, "key_alias", key_alias)
        pulumi.set(__self__, "key_arn", key_arn)
        if key_region is not None:
            pulumi.set(__self__, "key_region", key_region)

    @property
    @pulumi.getter(name="keyAlias")
    def key_alias(self) -> str:
        """
        The AWS KMS key alias.
        """
        return pulumi.get(self, "key_alias")

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> str:
        """
        The AWS KMS key's Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "key_arn")

    @property
    @pulumi.getter(name="keyRegion")
    def key_region(self) -> Optional[str]:
        """
        (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        return pulumi.get(self, "key_region")


@pulumi.output_type
class MwsNetworksErrorMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "errorType":
            suggest = "error_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworksErrorMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworksErrorMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworksErrorMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[str] = None,
                 error_type: Optional[str] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if error_type is not None:
            pulumi.set(__self__, "error_type", error_type)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="errorType")
    def error_type(self) -> Optional[str]:
        return pulumi.get(self, "error_type")


@pulumi.output_type
class MwsNetworksVpcEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataplaneRelays":
            suggest = "dataplane_relays"
        elif key == "restApis":
            suggest = "rest_apis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworksVpcEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworksVpcEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworksVpcEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataplane_relays: Sequence[str],
                 rest_apis: Sequence[str]):
        pulumi.set(__self__, "dataplane_relays", dataplane_relays)
        pulumi.set(__self__, "rest_apis", rest_apis)

    @property
    @pulumi.getter(name="dataplaneRelays")
    def dataplane_relays(self) -> Sequence[str]:
        return pulumi.get(self, "dataplane_relays")

    @property
    @pulumi.getter(name="restApis")
    def rest_apis(self) -> Sequence[str]:
        return pulumi.get(self, "rest_apis")


@pulumi.output_type
class MwsWorkspacesCloudResourceBucket(dict):
    def __init__(__self__, *,
                 gcp: 'outputs.MwsWorkspacesCloudResourceBucketGcp'):
        pulumi.set(__self__, "gcp", gcp)

    @property
    @pulumi.getter
    def gcp(self) -> 'outputs.MwsWorkspacesCloudResourceBucketGcp':
        return pulumi.get(self, "gcp")


@pulumi.output_type
class MwsWorkspacesCloudResourceBucketGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesCloudResourceBucketGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesCloudResourceBucketGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesCloudResourceBucketGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str):
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class MwsWorkspacesExternalCustomerInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authoritativeUserEmail":
            suggest = "authoritative_user_email"
        elif key == "authoritativeUserFullName":
            suggest = "authoritative_user_full_name"
        elif key == "customerName":
            suggest = "customer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesExternalCustomerInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesExternalCustomerInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesExternalCustomerInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authoritative_user_email: str,
                 authoritative_user_full_name: str,
                 customer_name: str):
        pulumi.set(__self__, "authoritative_user_email", authoritative_user_email)
        pulumi.set(__self__, "authoritative_user_full_name", authoritative_user_full_name)
        pulumi.set(__self__, "customer_name", customer_name)

    @property
    @pulumi.getter(name="authoritativeUserEmail")
    def authoritative_user_email(self) -> str:
        return pulumi.get(self, "authoritative_user_email")

    @property
    @pulumi.getter(name="authoritativeUserFullName")
    def authoritative_user_full_name(self) -> str:
        return pulumi.get(self, "authoritative_user_full_name")

    @property
    @pulumi.getter(name="customerName")
    def customer_name(self) -> str:
        return pulumi.get(self, "customer_name")


@pulumi.output_type
class MwsWorkspacesNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpCommonNetworkConfig":
            suggest = "gcp_common_network_config"
        elif key == "gcpManagedNetworkConfig":
            suggest = "gcp_managed_network_config"
        elif key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_common_network_config: 'outputs.MwsWorkspacesNetworkGcpCommonNetworkConfig',
                 gcp_managed_network_config: Optional['outputs.MwsWorkspacesNetworkGcpManagedNetworkConfig'] = None,
                 network_id: Optional[str] = None):
        pulumi.set(__self__, "gcp_common_network_config", gcp_common_network_config)
        if gcp_managed_network_config is not None:
            pulumi.set(__self__, "gcp_managed_network_config", gcp_managed_network_config)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter(name="gcpCommonNetworkConfig")
    def gcp_common_network_config(self) -> 'outputs.MwsWorkspacesNetworkGcpCommonNetworkConfig':
        return pulumi.get(self, "gcp_common_network_config")

    @property
    @pulumi.getter(name="gcpManagedNetworkConfig")
    def gcp_managed_network_config(self) -> Optional['outputs.MwsWorkspacesNetworkGcpManagedNetworkConfig']:
        return pulumi.get(self, "gcp_managed_network_config")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[str]:
        return pulumi.get(self, "network_id")


@pulumi.output_type
class MwsWorkspacesNetworkGcpCommonNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gkeClusterMasterIpRange":
            suggest = "gke_cluster_master_ip_range"
        elif key == "gkeConnectivityType":
            suggest = "gke_connectivity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesNetworkGcpCommonNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesNetworkGcpCommonNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesNetworkGcpCommonNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gke_cluster_master_ip_range: str,
                 gke_connectivity_type: str):
        pulumi.set(__self__, "gke_cluster_master_ip_range", gke_cluster_master_ip_range)
        pulumi.set(__self__, "gke_connectivity_type", gke_connectivity_type)

    @property
    @pulumi.getter(name="gkeClusterMasterIpRange")
    def gke_cluster_master_ip_range(self) -> str:
        return pulumi.get(self, "gke_cluster_master_ip_range")

    @property
    @pulumi.getter(name="gkeConnectivityType")
    def gke_connectivity_type(self) -> str:
        return pulumi.get(self, "gke_connectivity_type")


@pulumi.output_type
class MwsWorkspacesNetworkGcpManagedNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gkeClusterPodIpRange":
            suggest = "gke_cluster_pod_ip_range"
        elif key == "gkeClusterServiceIpRange":
            suggest = "gke_cluster_service_ip_range"
        elif key == "subnetCidr":
            suggest = "subnet_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesNetworkGcpManagedNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesNetworkGcpManagedNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesNetworkGcpManagedNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gke_cluster_pod_ip_range: str,
                 gke_cluster_service_ip_range: str,
                 subnet_cidr: str):
        pulumi.set(__self__, "gke_cluster_pod_ip_range", gke_cluster_pod_ip_range)
        pulumi.set(__self__, "gke_cluster_service_ip_range", gke_cluster_service_ip_range)
        pulumi.set(__self__, "subnet_cidr", subnet_cidr)

    @property
    @pulumi.getter(name="gkeClusterPodIpRange")
    def gke_cluster_pod_ip_range(self) -> str:
        return pulumi.get(self, "gke_cluster_pod_ip_range")

    @property
    @pulumi.getter(name="gkeClusterServiceIpRange")
    def gke_cluster_service_ip_range(self) -> str:
        return pulumi.get(self, "gke_cluster_service_ip_range")

    @property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> str:
        return pulumi.get(self, "subnet_cidr")


@pulumi.output_type
class MwsWorkspacesToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifetimeSeconds":
            suggest = "lifetime_seconds"
        elif key == "tokenId":
            suggest = "token_id"
        elif key == "tokenValue":
            suggest = "token_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 lifetime_seconds: Optional[int] = None,
                 token_id: Optional[str] = None,
                 token_value: Optional[str] = None):
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if token_id is not None:
            pulumi.set(__self__, "token_id", token_id)
        if token_value is not None:
            pulumi.set(__self__, "token_value", token_value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[int]:
        return pulumi.get(self, "lifetime_seconds")

    @property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> Optional[str]:
        return pulumi.get(self, "token_id")

    @property
    @pulumi.getter(name="tokenValue")
    def token_value(self) -> Optional[str]:
        return pulumi.get(self, "token_value")


@pulumi.output_type
class PermissionsAccessControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionLevel":
            suggest = "permission_level"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "servicePrincipalName":
            suggest = "service_principal_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionsAccessControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionsAccessControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionsAccessControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_level: str,
                 group_name: Optional[str] = None,
                 service_principal_name: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        :param str permission_level: permission level according to specific resource. See examples above for the reference.
        :param str group_name: name of the group. We recommend setting permissions on groups.
        :param str service_principal_name: Application ID of the service_principal.
        :param str user_name: name of the user.
        """
        pulumi.set(__self__, "permission_level", permission_level)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> str:
        """
        permission level according to specific resource. See examples above for the reference.
        """
        return pulumi.get(self, "permission_level")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        name of the group. We recommend setting permissions on groups.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[str]:
        """
        Application ID of the service_principal.
        """
        return pulumi.get(self, "service_principal_name")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        name of the user.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class PipelineCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_policy_default_values: Optional[bool] = None,
                 autoscale: Optional['outputs.PipelineClusterAutoscale'] = None,
                 aws_attributes: Optional['outputs.PipelineClusterAwsAttributes'] = None,
                 cluster_log_conf: Optional['outputs.PipelineClusterClusterLogConf'] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 driver_instance_pool_id: Optional[str] = None,
                 driver_node_type_id: Optional[str] = None,
                 gcp_attributes: Optional['outputs.PipelineClusterGcpAttributes'] = None,
                 init_scripts: Optional[Sequence['outputs.PipelineClusterInitScript']] = None,
                 instance_pool_id: Optional[str] = None,
                 label: Optional[str] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None):
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.PipelineClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.PipelineClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.PipelineClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "driver_node_type_id")

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.PipelineClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.PipelineClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        return pulumi.get(self, "node_type_id")

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_conf")

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "spark_env_vars")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class PipelineClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class PipelineClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 zone_id: Optional[str] = None):
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class PipelineClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.PipelineClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.PipelineClusterClusterLogConfS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.PipelineClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.PipelineClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class PipelineClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PipelineClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "googleServiceAccount":
            suggest = "google_service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 google_service_account: Optional[str] = None):
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")


@pulumi.output_type
class PipelineClusterInitScript(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.PipelineClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.PipelineClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.PipelineClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.PipelineClusterInitScriptS3'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.PipelineClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def file(self) -> Optional['outputs.PipelineClusterInitScriptFile']:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.PipelineClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.PipelineClusterInitScriptS3']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class PipelineClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: Optional[str] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional[str]:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PipelineFilters(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineLibrary(dict):
    def __init__(__self__, *,
                 jar: Optional[str] = None,
                 maven: Optional['outputs.PipelineLibraryMaven'] = None,
                 notebook: Optional['outputs.PipelineLibraryNotebook'] = None,
                 whl: Optional[str] = None):
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if notebook is not None:
            pulumi.set(__self__, "notebook", notebook)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @property
    @pulumi.getter
    def jar(self) -> Optional[str]:
        return pulumi.get(self, "jar")

    @property
    @pulumi.getter
    def maven(self) -> Optional['outputs.PipelineLibraryMaven']:
        return pulumi.get(self, "maven")

    @property
    @pulumi.getter
    def notebook(self) -> Optional['outputs.PipelineLibraryNotebook']:
        return pulumi.get(self, "notebook")

    @property
    @pulumi.getter
    def whl(self) -> Optional[str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class PipelineLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: str,
                 exclusions: Optional[Sequence[str]] = None,
                 repo: Optional[str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def coordinates(self) -> str:
        return pulumi.get(self, "coordinates")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class PipelineLibraryNotebook(dict):
    def __init__(__self__, *,
                 path: str):
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")


@pulumi.output_type
class SecretScopeKeyvaultMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretScopeKeyvaultMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretScopeKeyvaultMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretScopeKeyvaultMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: str,
                 resource_id: str):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> str:
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class SqlEndpointChannel(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SqlEndpointOdbcParams(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int,
                 protocol: str,
                 host: Optional[str] = None,
                 hostname: Optional[str] = None):
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")


@pulumi.output_type
class SqlEndpointTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlEndpointTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlEndpointTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlEndpointTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_tags: Sequence['outputs.SqlEndpointTagsCustomTag']):
        pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence['outputs.SqlEndpointTagsCustomTag']:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class SqlEndpointTagsCustomTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlPermissionsPrivilegeAssignment(dict):
    def __init__(__self__, *,
                 principal: str,
                 privileges: Sequence[str]):
        """
        :param str principal: `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        :param Sequence[str] privileges: set of available privilege names in upper case.
        """
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "privileges", privileges)

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        """
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def privileges(self) -> Sequence[str]:
        """
        set of available privilege names in upper case.
        """
        return pulumi.get(self, "privileges")


@pulumi.output_type
class SqlQueryParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRange":
            suggest = "date_range"
        elif key == "datetimeRange":
            suggest = "datetime_range"
        elif key == "datetimesecRange":
            suggest = "datetimesec_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 date: Optional['outputs.SqlQueryParameterDate'] = None,
                 date_range: Optional['outputs.SqlQueryParameterDateRange'] = None,
                 datetime: Optional['outputs.SqlQueryParameterDatetime'] = None,
                 datetime_range: Optional['outputs.SqlQueryParameterDatetimeRange'] = None,
                 datetimesec: Optional['outputs.SqlQueryParameterDatetimesec'] = None,
                 datetimesec_range: Optional['outputs.SqlQueryParameterDatetimesecRange'] = None,
                 enum: Optional['outputs.SqlQueryParameterEnum'] = None,
                 number: Optional['outputs.SqlQueryParameterNumber'] = None,
                 query: Optional['outputs.SqlQueryParameterQuery'] = None,
                 text: Optional['outputs.SqlQueryParameterText'] = None,
                 title: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if date_range is not None:
            pulumi.set(__self__, "date_range", date_range)
        if datetime is not None:
            pulumi.set(__self__, "datetime", datetime)
        if datetime_range is not None:
            pulumi.set(__self__, "datetime_range", datetime_range)
        if datetimesec is not None:
            pulumi.set(__self__, "datetimesec", datetimesec)
        if datetimesec_range is not None:
            pulumi.set(__self__, "datetimesec_range", datetimesec_range)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def date(self) -> Optional['outputs.SqlQueryParameterDate']:
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> Optional['outputs.SqlQueryParameterDateRange']:
        return pulumi.get(self, "date_range")

    @property
    @pulumi.getter
    def datetime(self) -> Optional['outputs.SqlQueryParameterDatetime']:
        return pulumi.get(self, "datetime")

    @property
    @pulumi.getter(name="datetimeRange")
    def datetime_range(self) -> Optional['outputs.SqlQueryParameterDatetimeRange']:
        return pulumi.get(self, "datetime_range")

    @property
    @pulumi.getter
    def datetimesec(self) -> Optional['outputs.SqlQueryParameterDatetimesec']:
        return pulumi.get(self, "datetimesec")

    @property
    @pulumi.getter(name="datetimesecRange")
    def datetimesec_range(self) -> Optional['outputs.SqlQueryParameterDatetimesecRange']:
        return pulumi.get(self, "datetimesec_range")

    @property
    @pulumi.getter
    def enum(self) -> Optional['outputs.SqlQueryParameterEnum']:
        return pulumi.get(self, "enum")

    @property
    @pulumi.getter
    def number(self) -> Optional['outputs.SqlQueryParameterNumber']:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def query(self) -> Optional['outputs.SqlQueryParameterQuery']:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def text(self) -> Optional['outputs.SqlQueryParameterText']:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")


@pulumi.output_type
class SqlQueryParameterDate(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDateRange(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetime(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimeRange(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimesec(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimesecRange(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterEnum(dict):
    def __init__(__self__, *,
                 options: Sequence[str],
                 multiple: Optional['outputs.SqlQueryParameterEnumMultiple'] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "options", options)
        if multiple is not None:
            pulumi.set(__self__, "multiple", multiple)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def options(self) -> Sequence[str]:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def multiple(self) -> Optional['outputs.SqlQueryParameterEnumMultiple']:
        return pulumi.get(self, "multiple")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SqlQueryParameterEnumMultiple(dict):
    def __init__(__self__, *,
                 prefix: str,
                 separator: str,
                 suffix: str):
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "separator", separator)
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def separator(self) -> str:
        return pulumi.get(self, "separator")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class SqlQueryParameterNumber(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryParameterQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryParameterQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryParameterQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: str,
                 multiple: Optional['outputs.SqlQueryParameterQueryMultiple'] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "query_id", query_id)
        if multiple is not None:
            pulumi.set(__self__, "multiple", multiple)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        return pulumi.get(self, "query_id")

    @property
    @pulumi.getter
    def multiple(self) -> Optional['outputs.SqlQueryParameterQueryMultiple']:
        return pulumi.get(self, "multiple")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SqlQueryParameterQueryMultiple(dict):
    def __init__(__self__, *,
                 prefix: str,
                 separator: str,
                 suffix: str):
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "separator", separator)
        pulumi.set(__self__, "suffix", suffix)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def separator(self) -> str:
        return pulumi.get(self, "separator")

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class SqlQueryParameterText(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQuerySchedule(dict):
    def __init__(__self__, *,
                 continuous: Optional['outputs.SqlQueryScheduleContinuous'] = None,
                 daily: Optional['outputs.SqlQueryScheduleDaily'] = None,
                 weekly: Optional['outputs.SqlQueryScheduleWeekly'] = None):
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @property
    @pulumi.getter
    def continuous(self) -> Optional['outputs.SqlQueryScheduleContinuous']:
        return pulumi.get(self, "continuous")

    @property
    @pulumi.getter
    def daily(self) -> Optional['outputs.SqlQueryScheduleDaily']:
        return pulumi.get(self, "daily")

    @property
    @pulumi.getter
    def weekly(self) -> Optional['outputs.SqlQueryScheduleWeekly']:
        return pulumi.get(self, "weekly")


@pulumi.output_type
class SqlQueryScheduleContinuous(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSeconds":
            suggest = "interval_seconds"
        elif key == "untilDate":
            suggest = "until_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryScheduleContinuous. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryScheduleContinuous.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryScheduleContinuous.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_seconds: int,
                 until_date: Optional[str] = None):
        pulumi.set(__self__, "interval_seconds", interval_seconds)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> int:
        return pulumi.get(self, "interval_seconds")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[str]:
        return pulumi.get(self, "until_date")


@pulumi.output_type
class SqlQueryScheduleDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDays":
            suggest = "interval_days"
        elif key == "timeOfDay":
            suggest = "time_of_day"
        elif key == "untilDate":
            suggest = "until_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryScheduleDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryScheduleDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryScheduleDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_days: int,
                 time_of_day: str,
                 until_date: Optional[str] = None):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "time_of_day", time_of_day)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> int:
        return pulumi.get(self, "interval_days")

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> str:
        return pulumi.get(self, "time_of_day")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[str]:
        return pulumi.get(self, "until_date")


@pulumi.output_type
class SqlQueryScheduleWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "intervalWeeks":
            suggest = "interval_weeks"
        elif key == "timeOfDay":
            suggest = "time_of_day"
        elif key == "untilDate":
            suggest = "until_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryScheduleWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryScheduleWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryScheduleWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: str,
                 interval_weeks: int,
                 time_of_day: str,
                 until_date: Optional[str] = None):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "interval_weeks", interval_weeks)
        pulumi.set(__self__, "time_of_day", time_of_day)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> str:
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="intervalWeeks")
    def interval_weeks(self) -> int:
        return pulumi.get(self, "interval_weeks")

    @property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> str:
        return pulumi.get(self, "time_of_day")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[str]:
        return pulumi.get(self, "until_date")


@pulumi.output_type
class SqlWidgetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapTo":
            suggest = "map_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlWidgetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlWidgetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlWidgetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: str,
                 map_to: Optional[str] = None,
                 title: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if map_to is not None:
            pulumi.set(__self__, "map_to", map_to)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="mapTo")
    def map_to(self) -> Optional[str]:
        return pulumi.get(self, "map_to")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SqlWidgetPosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeX":
            suggest = "size_x"
        elif key == "sizeY":
            suggest = "size_y"
        elif key == "autoHeight":
            suggest = "auto_height"
        elif key == "posX":
            suggest = "pos_x"
        elif key == "posY":
            suggest = "pos_y"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlWidgetPosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlWidgetPosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlWidgetPosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_x: int,
                 size_y: int,
                 auto_height: Optional[bool] = None,
                 pos_x: Optional[int] = None,
                 pos_y: Optional[int] = None):
        pulumi.set(__self__, "size_x", size_x)
        pulumi.set(__self__, "size_y", size_y)
        if auto_height is not None:
            pulumi.set(__self__, "auto_height", auto_height)
        if pos_x is not None:
            pulumi.set(__self__, "pos_x", pos_x)
        if pos_y is not None:
            pulumi.set(__self__, "pos_y", pos_y)

    @property
    @pulumi.getter(name="sizeX")
    def size_x(self) -> int:
        return pulumi.get(self, "size_x")

    @property
    @pulumi.getter(name="sizeY")
    def size_y(self) -> int:
        return pulumi.get(self, "size_y")

    @property
    @pulumi.getter(name="autoHeight")
    def auto_height(self) -> Optional[bool]:
        return pulumi.get(self, "auto_height")

    @property
    @pulumi.getter(name="posX")
    def pos_x(self) -> Optional[int]:
        return pulumi.get(self, "pos_x")

    @property
    @pulumi.getter(name="posY")
    def pos_y(self) -> Optional[int]:
        return pulumi.get(self, "pos_y")


@pulumi.output_type
class StorageCredentialAwsIamRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialAwsIamRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialAwsIamRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialAwsIamRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class StorageCredentialAzureManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConnectorId":
            suggest = "access_connector_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialAzureManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialAzureManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialAzureManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_connector_id: str):
        """
        :param str access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)

    @property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> str:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`
        """
        return pulumi.get(self, "access_connector_id")


@pulumi.output_type
class StorageCredentialAzureServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialAzureServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialAzureServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialAzureServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: str,
                 client_secret: str,
                 directory_id: str):
        """
        :param str application_id: The application ID of the application registration within the referenced AAD tenant
        :param str client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
        :param str directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class TableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "typeText":
            suggest = "type_text"
        elif key == "partitionIndex":
            suggest = "partition_index"
        elif key == "typeIntervalType":
            suggest = "type_interval_type"
        elif key == "typeJson":
            suggest = "type_json"
        elif key == "typePrecision":
            suggest = "type_precision"
        elif key == "typeScale":
            suggest = "type_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 position: int,
                 type_name: str,
                 type_text: str,
                 comment: Optional[str] = None,
                 nullable: Optional[bool] = None,
                 partition_index: Optional[int] = None,
                 type_interval_type: Optional[str] = None,
                 type_json: Optional[str] = None,
                 type_precision: Optional[int] = None,
                 type_scale: Optional[int] = None):
        """
        :param str name: User-visible name of column
        :param int position: Ordinal position of column, starting at 0.
        :param str type_name: Name of (outer) type
        :param str type_text: Column type spec (with metadata) as SQL text
        :param str comment: User-supplied free-form text.
        :param bool nullable: Whether field is nullable (Default: `true`)
        :param int partition_index: Partition ID
        :param str type_interval_type: Format of `INTERVAL` columns
        :param str type_json: Column type spec (with metadata) as JSON string
        :param int type_precision: Digits of precision; applies to `DECIMAL` columns
        :param int type_scale: Digits to right of decimal; applies to `DECIMAL` columns
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if partition_index is not None:
            pulumi.set(__self__, "partition_index", partition_index)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User-visible name of column
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def position(self) -> int:
        """
        Ordinal position of column, starting at 0.
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Name of (outer) type
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="typeText")
    def type_text(self) -> str:
        """
        Column type spec (with metadata) as SQL text
        """
        return pulumi.get(self, "type_text")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        User-supplied free-form text.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def nullable(self) -> Optional[bool]:
        """
        Whether field is nullable (Default: `true`)
        """
        return pulumi.get(self, "nullable")

    @property
    @pulumi.getter(name="partitionIndex")
    def partition_index(self) -> Optional[int]:
        """
        Partition ID
        """
        return pulumi.get(self, "partition_index")

    @property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[str]:
        """
        Format of `INTERVAL` columns
        """
        return pulumi.get(self, "type_interval_type")

    @property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[str]:
        """
        Column type spec (with metadata) as JSON string
        """
        return pulumi.get(self, "type_json")

    @property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[int]:
        """
        Digits of precision; applies to `DECIMAL` columns
        """
        return pulumi.get(self, "type_precision")

    @property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[int]:
        """
        Digits to right of decimal; applies to `DECIMAL` columns
        """
        return pulumi.get(self, "type_scale")


@pulumi.output_type
class GetClusterClusterInfoResult(dict):
    def __init__(__self__, *,
                 default_tags: Mapping[str, Any],
                 driver_instance_pool_id: str,
                 spark_version: str,
                 state: str,
                 autoscale: Optional['outputs.GetClusterClusterInfoAutoscaleResult'] = None,
                 autotermination_minutes: Optional[int] = None,
                 aws_attributes: Optional['outputs.GetClusterClusterInfoAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetClusterClusterInfoAzureAttributesResult'] = None,
                 cluster_cores: Optional[float] = None,
                 cluster_id: Optional[str] = None,
                 cluster_log_conf: Optional['outputs.GetClusterClusterInfoClusterLogConfResult'] = None,
                 cluster_log_status: Optional['outputs.GetClusterClusterInfoClusterLogStatusResult'] = None,
                 cluster_memory_mb: Optional[int] = None,
                 cluster_name: Optional[str] = None,
                 cluster_source: Optional[str] = None,
                 creator_user_name: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, Any]] = None,
                 data_security_mode: Optional[str] = None,
                 docker_image: Optional['outputs.GetClusterClusterInfoDockerImageResult'] = None,
                 driver: Optional['outputs.GetClusterClusterInfoDriverResult'] = None,
                 driver_node_type_id: Optional[str] = None,
                 enable_elastic_disk: Optional[bool] = None,
                 enable_local_disk_encryption: Optional[bool] = None,
                 executors: Optional[Sequence['outputs.GetClusterClusterInfoExecutorResult']] = None,
                 gcp_attributes: Optional['outputs.GetClusterClusterInfoGcpAttributesResult'] = None,
                 init_scripts: Optional[Sequence['outputs.GetClusterClusterInfoInitScriptResult']] = None,
                 instance_pool_id: Optional[str] = None,
                 jdbc_port: Optional[int] = None,
                 last_activity_time: Optional[int] = None,
                 last_state_loss_time: Optional[int] = None,
                 node_type_id: Optional[str] = None,
                 num_workers: Optional[int] = None,
                 policy_id: Optional[str] = None,
                 single_user_name: Optional[str] = None,
                 spark_conf: Optional[Mapping[str, Any]] = None,
                 spark_context_id: Optional[int] = None,
                 spark_env_vars: Optional[Mapping[str, Any]] = None,
                 ssh_public_keys: Optional[Sequence[str]] = None,
                 start_time: Optional[int] = None,
                 state_message: Optional[str] = None,
                 terminate_time: Optional[int] = None,
                 termination_reason: Optional['outputs.GetClusterClusterInfoTerminationReasonResult'] = None):
        """
        :param str driver_instance_pool_id: similar to `instance_pool_id`, but for driver node.
        :param str spark_version: [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        :param int autotermination_minutes: Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        :param str cluster_id: The id of the cluster
        :param str cluster_name: Cluster name, which doesn’t have to be unique.
        :param Mapping[str, Any] custom_tags: Additional tags for cluster resources.
        :param str data_security_mode: Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        :param str driver_node_type_id: The node type of the Spark driver.
        :param bool enable_elastic_disk: Use autoscaling local storage.
        :param bool enable_local_disk_encryption: Enable local disk encryption.
        :param str node_type_id: Any supported get_node_type id.
               * `instance_pool_id` The pool of idle instances the cluster is attached to.
        :param str policy_id: Identifier of Cluster Policy to validate cluster and preset certain defaults.
        :param str single_user_name: The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        :param Mapping[str, Any] spark_conf: Map with key-value pairs to fine-tune Spark clusters.
        :param Mapping[str, Any] spark_env_vars: Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        :param Sequence[str] ssh_public_keys: SSH public key contents that will be added to each Spark node in this cluster.
        """
        pulumi.set(__self__, "default_tags", default_tags)
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "spark_version", spark_version)
        pulumi.set(__self__, "state", state)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_cores is not None:
            pulumi.set(__self__, "cluster_cores", cluster_cores)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_log_status is not None:
            pulumi.set(__self__, "cluster_log_status", cluster_log_status)
        if cluster_memory_mb is not None:
            pulumi.set(__self__, "cluster_memory_mb", cluster_memory_mb)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_source is not None:
            pulumi.set(__self__, "cluster_source", cluster_source)
        if creator_user_name is not None:
            pulumi.set(__self__, "creator_user_name", creator_user_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if executors is not None:
            pulumi.set(__self__, "executors", executors)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if jdbc_port is not None:
            pulumi.set(__self__, "jdbc_port", jdbc_port)
        if last_activity_time is not None:
            pulumi.set(__self__, "last_activity_time", last_activity_time)
        if last_state_loss_time is not None:
            pulumi.set(__self__, "last_state_loss_time", last_state_loss_time)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_context_id is not None:
            pulumi.set(__self__, "spark_context_id", spark_context_id)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)
        if terminate_time is not None:
            pulumi.set(__self__, "terminate_time", terminate_time)
        if termination_reason is not None:
            pulumi.set(__self__, "termination_reason", termination_reason)

    @property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Mapping[str, Any]:
        return pulumi.get(self, "default_tags")

    @property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> str:
        """
        similar to `instance_pool_id`, but for driver node.
        """
        return pulumi.get(self, "driver_instance_pool_id")

    @property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> str:
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        return pulumi.get(self, "spark_version")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetClusterClusterInfoAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[int]:
        """
        Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        """
        return pulumi.get(self, "autotermination_minutes")

    @property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetClusterClusterInfoAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @property
    @pulumi.getter(name="clusterCores")
    def cluster_cores(self) -> Optional[float]:
        return pulumi.get(self, "cluster_cores")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The id of the cluster
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @property
    @pulumi.getter(name="clusterLogStatus")
    def cluster_log_status(self) -> Optional['outputs.GetClusterClusterInfoClusterLogStatusResult']:
        return pulumi.get(self, "cluster_log_status")

    @property
    @pulumi.getter(name="clusterMemoryMb")
    def cluster_memory_mb(self) -> Optional[int]:
        return pulumi.get(self, "cluster_memory_mb")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Cluster name, which doesn’t have to be unique.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterSource")
    def cluster_source(self) -> Optional[str]:
        return pulumi.get(self, "cluster_source")

    @property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[str]:
        return pulumi.get(self, "creator_user_name")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, Any]]:
        """
        Additional tags for cluster resources.
        """
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[str]:
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        return pulumi.get(self, "data_security_mode")

    @property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetClusterClusterInfoDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @property
    @pulumi.getter
    def driver(self) -> Optional['outputs.GetClusterClusterInfoDriverResult']:
        return pulumi.get(self, "driver")

    @property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[str]:
        """
        The node type of the Spark driver.
        """
        return pulumi.get(self, "driver_node_type_id")

    @property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[bool]:
        """
        Use autoscaling local storage.
        """
        return pulumi.get(self, "enable_elastic_disk")

    @property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[bool]:
        """
        Enable local disk encryption.
        """
        return pulumi.get(self, "enable_local_disk_encryption")

    @property
    @pulumi.getter
    def executors(self) -> Optional[Sequence['outputs.GetClusterClusterInfoExecutorResult']]:
        return pulumi.get(self, "executors")

    @property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetClusterClusterInfoGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetClusterClusterInfoInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter(name="jdbcPort")
    def jdbc_port(self) -> Optional[int]:
        return pulumi.get(self, "jdbc_port")

    @property
    @pulumi.getter(name="lastActivityTime")
    def last_activity_time(self) -> Optional[int]:
        return pulumi.get(self, "last_activity_time")

    @property
    @pulumi.getter(name="lastStateLossTime")
    def last_state_loss_time(self) -> Optional[int]:
        return pulumi.get(self, "last_state_loss_time")

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[str]:
        """
        Any supported get_node_type id.
        * `instance_pool_id` The pool of idle instances the cluster is attached to.
        """
        return pulumi.get(self, "node_type_id")

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        return pulumi.get(self, "num_workers")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[str]:
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[str]:
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        return pulumi.get(self, "single_user_name")

    @property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, Any]]:
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        return pulumi.get(self, "spark_conf")

    @property
    @pulumi.getter(name="sparkContextId")
    def spark_context_id(self) -> Optional[int]:
        return pulumi.get(self, "spark_context_id")

    @property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, Any]]:
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        return pulumi.get(self, "spark_env_vars")

    @property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[str]]:
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[str]:
        return pulumi.get(self, "state_message")

    @property
    @pulumi.getter(name="terminateTime")
    def terminate_time(self) -> Optional[int]:
        return pulumi.get(self, "terminate_time")

    @property
    @pulumi.getter(name="terminationReason")
    def termination_reason(self) -> Optional['outputs.GetClusterClusterInfoTerminationReasonResult']:
        return pulumi.get(self, "termination_reason")


@pulumi.output_type
class GetClusterClusterInfoAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[int] = None,
                 min_workers: Optional[int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[int]:
        return pulumi.get(self, "max_workers")

    @property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetClusterClusterInfoAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 ebs_volume_count: Optional[int] = None,
                 ebs_volume_size: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 instance_profile_arn: Optional[str] = None,
                 spot_bid_price_percent: Optional[int] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_count")

    @property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[int]:
        return pulumi.get(self, "ebs_volume_size")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[str]:
        return pulumi.get(self, "instance_profile_arn")

    @property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetClusterClusterInfoAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 first_on_demand: Optional[int] = None,
                 spot_bid_max_price: Optional[float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[int]:
        return pulumi.get(self, "first_on_demand")

    @property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetClusterClusterInfoClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetClusterClusterInfoClusterLogConfS3Result'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterClusterInfoClusterLogStatusResult(dict):
    def __init__(__self__, *,
                 last_attempted: Optional[int] = None,
                 last_exception: Optional[str] = None):
        if last_attempted is not None:
            pulumi.set(__self__, "last_attempted", last_attempted)
        if last_exception is not None:
            pulumi.set(__self__, "last_exception", last_exception)

    @property
    @pulumi.getter(name="lastAttempted")
    def last_attempted(self) -> Optional[int]:
        return pulumi.get(self, "last_attempted")

    @property
    @pulumi.getter(name="lastException")
    def last_exception(self) -> Optional[str]:
        return pulumi.get(self, "last_exception")


@pulumi.output_type
class GetClusterClusterInfoDockerImageResult(dict):
    def __init__(__self__, *,
                 url: str,
                 basic_auth: Optional['outputs.GetClusterClusterInfoDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetClusterClusterInfoDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetClusterClusterInfoDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterClusterInfoDriverResult(dict):
    def __init__(__self__, *,
                 host_private_ip: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 node_aws_attributes: Optional['outputs.GetClusterClusterInfoDriverNodeAwsAttributesResult'] = None,
                 node_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_dns: Optional[str] = None,
                 start_timestamp: Optional[int] = None):
        if host_private_ip is not None:
            pulumi.set(__self__, "host_private_ip", host_private_ip)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if node_aws_attributes is not None:
            pulumi.set(__self__, "node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_dns is not None:
            pulumi.set(__self__, "public_dns", public_dns)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[str]:
        return pulumi.get(self, "host_private_ip")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoDriverNodeAwsAttributesResult']:
        return pulumi.get(self, "node_aws_attributes")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[str]:
        return pulumi.get(self, "public_dns")

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "start_timestamp")


@pulumi.output_type
class GetClusterClusterInfoDriverNodeAwsAttributesResult(dict):
    def __init__(__self__, *,
                 is_spot: Optional[bool] = None):
        if is_spot is not None:
            pulumi.set(__self__, "is_spot", is_spot)

    @property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[bool]:
        return pulumi.get(self, "is_spot")


@pulumi.output_type
class GetClusterClusterInfoExecutorResult(dict):
    def __init__(__self__, *,
                 host_private_ip: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 node_aws_attributes: Optional['outputs.GetClusterClusterInfoExecutorNodeAwsAttributesResult'] = None,
                 node_id: Optional[str] = None,
                 private_ip: Optional[str] = None,
                 public_dns: Optional[str] = None,
                 start_timestamp: Optional[int] = None):
        if host_private_ip is not None:
            pulumi.set(__self__, "host_private_ip", host_private_ip)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if node_aws_attributes is not None:
            pulumi.set(__self__, "node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_dns is not None:
            pulumi.set(__self__, "public_dns", public_dns)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[str]:
        return pulumi.get(self, "host_private_ip")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoExecutorNodeAwsAttributesResult']:
        return pulumi.get(self, "node_aws_attributes")

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[str]:
        return pulumi.get(self, "node_id")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[str]:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[str]:
        return pulumi.get(self, "public_dns")

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[int]:
        return pulumi.get(self, "start_timestamp")


@pulumi.output_type
class GetClusterClusterInfoExecutorNodeAwsAttributesResult(dict):
    def __init__(__self__, *,
                 is_spot: Optional[bool] = None):
        if is_spot is not None:
            pulumi.set(__self__, "is_spot", is_spot)

    @property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[bool]:
        return pulumi.get(self, "is_spot")


@pulumi.output_type
class GetClusterClusterInfoGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[str] = None,
                 boot_disk_size: Optional[int] = None,
                 google_service_account: Optional[str] = None,
                 use_preemptible_executors: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter
    def availability(self) -> Optional[str]:
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[str]:
        return pulumi.get(self, "google_service_account")

    @property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetClusterClusterInfoInitScriptResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetClusterClusterInfoInitScriptDbfsResult'] = None,
                 s3: Optional['outputs.GetClusterClusterInfoInitScriptS3Result'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetClusterClusterInfoInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetClusterClusterInfoInitScriptS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetClusterClusterInfoInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: str):
        pulumi.set(__self__, "destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: str,
                 canned_acl: Optional[str] = None,
                 enable_encryption: Optional[bool] = None,
                 encryption_type: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 kms_key: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def destination(self) -> str:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[bool]:
        return pulumi.get(self, "enable_encryption")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[str]:
        return pulumi.get(self, "kms_key")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterClusterInfoTerminationReasonResult(dict):
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 parameters: Optional[Mapping[str, Any]] = None,
                 type: Optional[str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDbfsFilePathsPathListResult(dict):
    def __init__(__self__, *,
                 file_size: Optional[int] = None,
                 path: Optional[str] = None):
        """
        :param str path: Path on DBFS for the file to perform listing
        """
        if file_size is not None:
            pulumi.set(__self__, "file_size", file_size)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="fileSize")
    def file_size(self) -> Optional[int]:
        return pulumi.get(self, "file_size")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path on DBFS for the file to perform listing
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetNotebookPathsNotebookPathListResult(dict):
    def __init__(__self__, *,
                 language: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str path: Path to workspace directory
        """
        if language is not None:
            pulumi.set(__self__, "language", language)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        return pulumi.get(self, "language")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to workspace directory
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetSqlWarehouseChannelResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSqlWarehouseOdbcParamsResult(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int,
                 protocol: str,
                 host: Optional[str] = None,
                 hostname: Optional[str] = None):
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")


@pulumi.output_type
class GetSqlWarehouseTagsResult(dict):
    def __init__(__self__, *,
                 custom_tags: Sequence['outputs.GetSqlWarehouseTagsCustomTagResult']):
        pulumi.set(__self__, "custom_tags", custom_tags)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence['outputs.GetSqlWarehouseTagsCustomTagResult']:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetSqlWarehouseTagsCustomTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


