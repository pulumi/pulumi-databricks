# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AccessControlRuleSetGrantRule',
    'AccountFederationPolicyOidcPolicy',
    'AccountNetworkPolicyEgress',
    'AccountNetworkPolicyEgressNetworkAccess',
    'AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination',
    'AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination',
    'AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement',
    'AccountSettingV2AibiDashboardEmbeddingAccessPolicy',
    'AccountSettingV2AibiDashboardEmbeddingApprovedDomains',
    'AccountSettingV2AutomaticClusterUpdateWorkspace',
    'AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails',
    'AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow',
    'AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule',
    'AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime',
    'AccountSettingV2BooleanVal',
    'AccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy',
    'AccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains',
    'AccountSettingV2EffectiveAutomaticClusterUpdateWorkspace',
    'AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails',
    'AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow',
    'AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule',
    'AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime',
    'AccountSettingV2EffectiveBooleanVal',
    'AccountSettingV2EffectiveIntegerVal',
    'AccountSettingV2EffectivePersonalCompute',
    'AccountSettingV2EffectiveRestrictWorkspaceAdmins',
    'AccountSettingV2EffectiveStringVal',
    'AccountSettingV2IntegerVal',
    'AccountSettingV2PersonalCompute',
    'AccountSettingV2RestrictWorkspaceAdmins',
    'AccountSettingV2StringVal',
    'AibiDashboardEmbeddingAccessPolicySettingAibiDashboardEmbeddingAccessPolicy',
    'AibiDashboardEmbeddingApprovedDomainsSettingAibiDashboardEmbeddingApprovedDomains',
    'AlertCondition',
    'AlertConditionOperand',
    'AlertConditionOperandColumn',
    'AlertConditionThreshold',
    'AlertConditionThresholdValue',
    'AlertV2EffectiveRunAs',
    'AlertV2Evaluation',
    'AlertV2EvaluationNotification',
    'AlertV2EvaluationNotificationSubscription',
    'AlertV2EvaluationSource',
    'AlertV2EvaluationThreshold',
    'AlertV2EvaluationThresholdColumn',
    'AlertV2EvaluationThresholdValue',
    'AlertV2RunAs',
    'AlertV2Schedule',
    'AppActiveDeployment',
    'AppActiveDeploymentDeploymentArtifacts',
    'AppActiveDeploymentStatus',
    'AppAppStatus',
    'AppComputeStatus',
    'AppPendingDeployment',
    'AppPendingDeploymentDeploymentArtifacts',
    'AppPendingDeploymentStatus',
    'AppProviderConfig',
    'AppResource',
    'AppResourceDatabase',
    'AppResourceGenieSpace',
    'AppResourceJob',
    'AppResourceSecret',
    'AppResourceServingEndpoint',
    'AppResourceSqlWarehouse',
    'AppResourceUcSecurable',
    'AppsSettingsCustomTemplateManifest',
    'AppsSettingsCustomTemplateManifestResourceSpec',
    'AppsSettingsCustomTemplateManifestResourceSpecJobSpec',
    'AppsSettingsCustomTemplateManifestResourceSpecSecretSpec',
    'AppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpec',
    'AppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpec',
    'AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec',
    'ArtifactAllowlistArtifactMatcher',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspace',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule',
    'AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime',
    'BudgetAlertConfiguration',
    'BudgetAlertConfigurationActionConfiguration',
    'BudgetFilter',
    'BudgetFilterTag',
    'BudgetFilterTagValue',
    'BudgetFilterWorkspaceId',
    'BudgetPolicyCustomTag',
    'CatalogEffectivePredictiveOptimizationFlag',
    'CatalogProvisioningInfo',
    'ClusterAutoscale',
    'ClusterAwsAttributes',
    'ClusterAzureAttributes',
    'ClusterAzureAttributesLogAnalyticsInfo',
    'ClusterClusterLogConf',
    'ClusterClusterLogConfDbfs',
    'ClusterClusterLogConfS3',
    'ClusterClusterLogConfVolumes',
    'ClusterClusterMountInfo',
    'ClusterClusterMountInfoNetworkFilesystemInfo',
    'ClusterDockerImage',
    'ClusterDockerImageBasicAuth',
    'ClusterGcpAttributes',
    'ClusterInitScript',
    'ClusterInitScriptAbfss',
    'ClusterInitScriptDbfs',
    'ClusterInitScriptFile',
    'ClusterInitScriptGcs',
    'ClusterInitScriptS3',
    'ClusterInitScriptVolumes',
    'ClusterInitScriptWorkspace',
    'ClusterLibrary',
    'ClusterLibraryCran',
    'ClusterLibraryMaven',
    'ClusterLibraryPypi',
    'ClusterPolicyLibrary',
    'ClusterPolicyLibraryCran',
    'ClusterPolicyLibraryMaven',
    'ClusterPolicyLibraryProviderConfig',
    'ClusterPolicyLibraryPypi',
    'ClusterProviderConfig',
    'ClusterWorkloadType',
    'ClusterWorkloadTypeClients',
    'ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspace',
    'ConnectionProvisioningInfo',
    'CredentialAwsIamRole',
    'CredentialAzureManagedIdentity',
    'CredentialAzureServicePrincipal',
    'CredentialDatabricksGcpServiceAccount',
    'CustomAppIntegrationTokenAccessPolicy',
    'DataQualityMonitorAnomalyDetectionConfig',
    'DataQualityMonitorDataProfilingConfig',
    'DataQualityMonitorDataProfilingConfigCustomMetric',
    'DataQualityMonitorDataProfilingConfigInferenceLog',
    'DataQualityMonitorDataProfilingConfigNotificationSettings',
    'DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure',
    'DataQualityMonitorDataProfilingConfigSchedule',
    'DataQualityMonitorDataProfilingConfigSnapshot',
    'DataQualityMonitorDataProfilingConfigTimeSeries',
    'DatabaseInstanceChildInstanceRef',
    'DatabaseInstanceCustomTag',
    'DatabaseInstanceEffectiveCustomTag',
    'DatabaseInstanceParentInstanceRef',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatus',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus',
    'DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress',
    'DatabaseSyncedDatabaseTableSpec',
    'DatabaseSyncedDatabaseTableSpecNewPipelineSpec',
    'DefaultNamespaceSettingNamespace',
    'DisableLegacyAccessSettingDisableLegacyAccess',
    'DisableLegacyDbfsSettingDisableLegacyDbfs',
    'DisableLegacyFeaturesSettingDisableLegacyFeatures',
    'EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspace',
    'ExternalLocationEncryptionDetails',
    'ExternalLocationEncryptionDetailsSseEncryptionDetails',
    'ExternalLocationFileEventQueue',
    'ExternalLocationFileEventQueueManagedAqs',
    'ExternalLocationFileEventQueueManagedPubsub',
    'ExternalLocationFileEventQueueManagedSqs',
    'ExternalLocationFileEventQueueProvidedAqs',
    'ExternalLocationFileEventQueueProvidedPubsub',
    'ExternalLocationFileEventQueueProvidedSqs',
    'FeatureEngineeringFeatureFunction',
    'FeatureEngineeringFeatureFunctionExtraParameter',
    'FeatureEngineeringFeatureSource',
    'FeatureEngineeringFeatureSourceDeltaTableSource',
    'FeatureEngineeringFeatureTimeWindow',
    'FeatureEngineeringFeatureTimeWindowContinuous',
    'FeatureEngineeringFeatureTimeWindowSliding',
    'FeatureEngineeringFeatureTimeWindowTumbling',
    'FeatureEngineeringMaterializedFeatureOfflineStoreConfig',
    'FeatureEngineeringMaterializedFeatureOnlineStoreConfig',
    'GrantsGrant',
    'InstancePoolAwsAttributes',
    'InstancePoolAzureAttributes',
    'InstancePoolDiskSpec',
    'InstancePoolDiskSpecDiskType',
    'InstancePoolGcpAttributes',
    'InstancePoolInstancePoolFleetAttributes',
    'InstancePoolInstancePoolFleetAttributesFleetOnDemandOption',
    'InstancePoolInstancePoolFleetAttributesFleetSpotOption',
    'InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride',
    'InstancePoolPreloadedDockerImage',
    'InstancePoolPreloadedDockerImageBasicAuth',
    'JobContinuous',
    'JobDbtTask',
    'JobDeployment',
    'JobEmailNotifications',
    'JobEnvironment',
    'JobEnvironmentSpec',
    'JobGitSource',
    'JobGitSourceGitSnapshot',
    'JobGitSourceJobSource',
    'JobHealth',
    'JobHealthRule',
    'JobJobCluster',
    'JobJobClusterNewCluster',
    'JobJobClusterNewClusterAutoscale',
    'JobJobClusterNewClusterAwsAttributes',
    'JobJobClusterNewClusterAzureAttributes',
    'JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo',
    'JobJobClusterNewClusterClusterLogConf',
    'JobJobClusterNewClusterClusterLogConfDbfs',
    'JobJobClusterNewClusterClusterLogConfS3',
    'JobJobClusterNewClusterClusterLogConfVolumes',
    'JobJobClusterNewClusterClusterMountInfo',
    'JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo',
    'JobJobClusterNewClusterDockerImage',
    'JobJobClusterNewClusterDockerImageBasicAuth',
    'JobJobClusterNewClusterGcpAttributes',
    'JobJobClusterNewClusterInitScript',
    'JobJobClusterNewClusterInitScriptAbfss',
    'JobJobClusterNewClusterInitScriptDbfs',
    'JobJobClusterNewClusterInitScriptFile',
    'JobJobClusterNewClusterInitScriptGcs',
    'JobJobClusterNewClusterInitScriptS3',
    'JobJobClusterNewClusterInitScriptVolumes',
    'JobJobClusterNewClusterInitScriptWorkspace',
    'JobJobClusterNewClusterLibrary',
    'JobJobClusterNewClusterLibraryCran',
    'JobJobClusterNewClusterLibraryMaven',
    'JobJobClusterNewClusterLibraryProviderConfig',
    'JobJobClusterNewClusterLibraryPypi',
    'JobJobClusterNewClusterProviderConfig',
    'JobJobClusterNewClusterWorkloadType',
    'JobJobClusterNewClusterWorkloadTypeClients',
    'JobLibrary',
    'JobLibraryCran',
    'JobLibraryMaven',
    'JobLibraryProviderConfig',
    'JobLibraryPypi',
    'JobNewCluster',
    'JobNewClusterAutoscale',
    'JobNewClusterAwsAttributes',
    'JobNewClusterAzureAttributes',
    'JobNewClusterAzureAttributesLogAnalyticsInfo',
    'JobNewClusterClusterLogConf',
    'JobNewClusterClusterLogConfDbfs',
    'JobNewClusterClusterLogConfS3',
    'JobNewClusterClusterLogConfVolumes',
    'JobNewClusterClusterMountInfo',
    'JobNewClusterClusterMountInfoNetworkFilesystemInfo',
    'JobNewClusterDockerImage',
    'JobNewClusterDockerImageBasicAuth',
    'JobNewClusterGcpAttributes',
    'JobNewClusterInitScript',
    'JobNewClusterInitScriptAbfss',
    'JobNewClusterInitScriptDbfs',
    'JobNewClusterInitScriptFile',
    'JobNewClusterInitScriptGcs',
    'JobNewClusterInitScriptS3',
    'JobNewClusterInitScriptVolumes',
    'JobNewClusterInitScriptWorkspace',
    'JobNewClusterLibrary',
    'JobNewClusterLibraryCran',
    'JobNewClusterLibraryMaven',
    'JobNewClusterLibraryProviderConfig',
    'JobNewClusterLibraryPypi',
    'JobNewClusterProviderConfig',
    'JobNewClusterWorkloadType',
    'JobNewClusterWorkloadTypeClients',
    'JobNotebookTask',
    'JobNotificationSettings',
    'JobParameter',
    'JobPipelineTask',
    'JobProviderConfig',
    'JobPythonWheelTask',
    'JobQueue',
    'JobRunAs',
    'JobRunJobTask',
    'JobSchedule',
    'JobSparkJarTask',
    'JobSparkPythonTask',
    'JobSparkSubmitTask',
    'JobTask',
    'JobTaskCleanRoomsNotebookTask',
    'JobTaskConditionTask',
    'JobTaskDashboardTask',
    'JobTaskDashboardTaskSubscription',
    'JobTaskDashboardTaskSubscriptionSubscriber',
    'JobTaskDbtCloudTask',
    'JobTaskDbtPlatformTask',
    'JobTaskDbtTask',
    'JobTaskDependsOn',
    'JobTaskEmailNotifications',
    'JobTaskForEachTask',
    'JobTaskForEachTaskTask',
    'JobTaskForEachTaskTaskCleanRoomsNotebookTask',
    'JobTaskForEachTaskTaskConditionTask',
    'JobTaskForEachTaskTaskDashboardTask',
    'JobTaskForEachTaskTaskDashboardTaskSubscription',
    'JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber',
    'JobTaskForEachTaskTaskDbtCloudTask',
    'JobTaskForEachTaskTaskDbtPlatformTask',
    'JobTaskForEachTaskTaskDbtTask',
    'JobTaskForEachTaskTaskDependsOn',
    'JobTaskForEachTaskTaskEmailNotifications',
    'JobTaskForEachTaskTaskGenAiComputeTask',
    'JobTaskForEachTaskTaskGenAiComputeTaskCompute',
    'JobTaskForEachTaskTaskHealth',
    'JobTaskForEachTaskTaskHealthRule',
    'JobTaskForEachTaskTaskLibrary',
    'JobTaskForEachTaskTaskLibraryCran',
    'JobTaskForEachTaskTaskLibraryMaven',
    'JobTaskForEachTaskTaskLibraryProviderConfig',
    'JobTaskForEachTaskTaskLibraryPypi',
    'JobTaskForEachTaskTaskNewCluster',
    'JobTaskForEachTaskTaskNewClusterAutoscale',
    'JobTaskForEachTaskTaskNewClusterAwsAttributes',
    'JobTaskForEachTaskTaskNewClusterAzureAttributes',
    'JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo',
    'JobTaskForEachTaskTaskNewClusterClusterLogConf',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfDbfs',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfS3',
    'JobTaskForEachTaskTaskNewClusterClusterLogConfVolumes',
    'JobTaskForEachTaskTaskNewClusterClusterMountInfo',
    'JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo',
    'JobTaskForEachTaskTaskNewClusterDockerImage',
    'JobTaskForEachTaskTaskNewClusterDockerImageBasicAuth',
    'JobTaskForEachTaskTaskNewClusterGcpAttributes',
    'JobTaskForEachTaskTaskNewClusterInitScript',
    'JobTaskForEachTaskTaskNewClusterInitScriptAbfss',
    'JobTaskForEachTaskTaskNewClusterInitScriptDbfs',
    'JobTaskForEachTaskTaskNewClusterInitScriptFile',
    'JobTaskForEachTaskTaskNewClusterInitScriptGcs',
    'JobTaskForEachTaskTaskNewClusterInitScriptS3',
    'JobTaskForEachTaskTaskNewClusterInitScriptVolumes',
    'JobTaskForEachTaskTaskNewClusterInitScriptWorkspace',
    'JobTaskForEachTaskTaskNewClusterLibrary',
    'JobTaskForEachTaskTaskNewClusterLibraryCran',
    'JobTaskForEachTaskTaskNewClusterLibraryMaven',
    'JobTaskForEachTaskTaskNewClusterLibraryProviderConfig',
    'JobTaskForEachTaskTaskNewClusterLibraryPypi',
    'JobTaskForEachTaskTaskNewClusterProviderConfig',
    'JobTaskForEachTaskTaskNewClusterWorkloadType',
    'JobTaskForEachTaskTaskNewClusterWorkloadTypeClients',
    'JobTaskForEachTaskTaskNotebookTask',
    'JobTaskForEachTaskTaskNotificationSettings',
    'JobTaskForEachTaskTaskPipelineTask',
    'JobTaskForEachTaskTaskPowerBiTask',
    'JobTaskForEachTaskTaskPowerBiTaskPowerBiModel',
    'JobTaskForEachTaskTaskPowerBiTaskTable',
    'JobTaskForEachTaskTaskPythonWheelTask',
    'JobTaskForEachTaskTaskRunJobTask',
    'JobTaskForEachTaskTaskRunJobTaskPipelineParams',
    'JobTaskForEachTaskTaskSparkJarTask',
    'JobTaskForEachTaskTaskSparkPythonTask',
    'JobTaskForEachTaskTaskSparkSubmitTask',
    'JobTaskForEachTaskTaskSqlTask',
    'JobTaskForEachTaskTaskSqlTaskAlert',
    'JobTaskForEachTaskTaskSqlTaskAlertSubscription',
    'JobTaskForEachTaskTaskSqlTaskDashboard',
    'JobTaskForEachTaskTaskSqlTaskDashboardSubscription',
    'JobTaskForEachTaskTaskSqlTaskFile',
    'JobTaskForEachTaskTaskSqlTaskQuery',
    'JobTaskForEachTaskTaskWebhookNotifications',
    'JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceeded',
    'JobTaskForEachTaskTaskWebhookNotificationsOnFailure',
    'JobTaskForEachTaskTaskWebhookNotificationsOnStart',
    'JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceeded',
    'JobTaskForEachTaskTaskWebhookNotificationsOnSuccess',
    'JobTaskGenAiComputeTask',
    'JobTaskGenAiComputeTaskCompute',
    'JobTaskHealth',
    'JobTaskHealthRule',
    'JobTaskLibrary',
    'JobTaskLibraryCran',
    'JobTaskLibraryMaven',
    'JobTaskLibraryProviderConfig',
    'JobTaskLibraryPypi',
    'JobTaskNewCluster',
    'JobTaskNewClusterAutoscale',
    'JobTaskNewClusterAwsAttributes',
    'JobTaskNewClusterAzureAttributes',
    'JobTaskNewClusterAzureAttributesLogAnalyticsInfo',
    'JobTaskNewClusterClusterLogConf',
    'JobTaskNewClusterClusterLogConfDbfs',
    'JobTaskNewClusterClusterLogConfS3',
    'JobTaskNewClusterClusterLogConfVolumes',
    'JobTaskNewClusterClusterMountInfo',
    'JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo',
    'JobTaskNewClusterDockerImage',
    'JobTaskNewClusterDockerImageBasicAuth',
    'JobTaskNewClusterGcpAttributes',
    'JobTaskNewClusterInitScript',
    'JobTaskNewClusterInitScriptAbfss',
    'JobTaskNewClusterInitScriptDbfs',
    'JobTaskNewClusterInitScriptFile',
    'JobTaskNewClusterInitScriptGcs',
    'JobTaskNewClusterInitScriptS3',
    'JobTaskNewClusterInitScriptVolumes',
    'JobTaskNewClusterInitScriptWorkspace',
    'JobTaskNewClusterLibrary',
    'JobTaskNewClusterLibraryCran',
    'JobTaskNewClusterLibraryMaven',
    'JobTaskNewClusterLibraryProviderConfig',
    'JobTaskNewClusterLibraryPypi',
    'JobTaskNewClusterProviderConfig',
    'JobTaskNewClusterWorkloadType',
    'JobTaskNewClusterWorkloadTypeClients',
    'JobTaskNotebookTask',
    'JobTaskNotificationSettings',
    'JobTaskPipelineTask',
    'JobTaskPowerBiTask',
    'JobTaskPowerBiTaskPowerBiModel',
    'JobTaskPowerBiTaskTable',
    'JobTaskPythonWheelTask',
    'JobTaskRunJobTask',
    'JobTaskRunJobTaskPipelineParams',
    'JobTaskSparkJarTask',
    'JobTaskSparkPythonTask',
    'JobTaskSparkSubmitTask',
    'JobTaskSqlTask',
    'JobTaskSqlTaskAlert',
    'JobTaskSqlTaskAlertSubscription',
    'JobTaskSqlTaskDashboard',
    'JobTaskSqlTaskDashboardSubscription',
    'JobTaskSqlTaskFile',
    'JobTaskSqlTaskQuery',
    'JobTaskWebhookNotifications',
    'JobTaskWebhookNotificationsOnDurationWarningThresholdExceeded',
    'JobTaskWebhookNotificationsOnFailure',
    'JobTaskWebhookNotificationsOnStart',
    'JobTaskWebhookNotificationsOnStreamingBacklogExceeded',
    'JobTaskWebhookNotificationsOnSuccess',
    'JobTrigger',
    'JobTriggerFileArrival',
    'JobTriggerPeriodic',
    'JobTriggerTableUpdate',
    'JobWebhookNotifications',
    'JobWebhookNotificationsOnDurationWarningThresholdExceeded',
    'JobWebhookNotificationsOnFailure',
    'JobWebhookNotificationsOnStart',
    'JobWebhookNotificationsOnStreamingBacklogExceeded',
    'JobWebhookNotificationsOnSuccess',
    'LakehouseMonitorCustomMetric',
    'LakehouseMonitorDataClassificationConfig',
    'LakehouseMonitorInferenceLog',
    'LakehouseMonitorNotifications',
    'LakehouseMonitorNotificationsOnFailure',
    'LakehouseMonitorNotificationsOnNewClassificationTagDetected',
    'LakehouseMonitorSchedule',
    'LakehouseMonitorSnapshot',
    'LakehouseMonitorTimeSeries',
    'LibraryCran',
    'LibraryMaven',
    'LibraryProviderConfig',
    'LibraryPypi',
    'MetastoreDataAccessAwsIamRole',
    'MetastoreDataAccessAzureManagedIdentity',
    'MetastoreDataAccessAzureServicePrincipal',
    'MetastoreDataAccessCloudflareApiToken',
    'MetastoreDataAccessDatabricksGcpServiceAccount',
    'MetastoreDataAccessGcpServiceAccountKey',
    'MlflowExperimentTag',
    'MlflowModelTag',
    'MlflowWebhookHttpUrlSpec',
    'MlflowWebhookJobSpec',
    'ModelServingAiGateway',
    'ModelServingAiGatewayFallbackConfig',
    'ModelServingAiGatewayGuardrails',
    'ModelServingAiGatewayGuardrailsInput',
    'ModelServingAiGatewayGuardrailsInputPii',
    'ModelServingAiGatewayGuardrailsOutput',
    'ModelServingAiGatewayGuardrailsOutputPii',
    'ModelServingAiGatewayInferenceTableConfig',
    'ModelServingAiGatewayRateLimit',
    'ModelServingAiGatewayUsageTrackingConfig',
    'ModelServingConfig',
    'ModelServingConfigAutoCaptureConfig',
    'ModelServingConfigServedEntity',
    'ModelServingConfigServedEntityExternalModel',
    'ModelServingConfigServedEntityExternalModelAi21labsConfig',
    'ModelServingConfigServedEntityExternalModelAmazonBedrockConfig',
    'ModelServingConfigServedEntityExternalModelAnthropicConfig',
    'ModelServingConfigServedEntityExternalModelCohereConfig',
    'ModelServingConfigServedEntityExternalModelCustomProviderConfig',
    'ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth',
    'ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth',
    'ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig',
    'ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig',
    'ModelServingConfigServedEntityExternalModelOpenaiConfig',
    'ModelServingConfigServedEntityExternalModelPalmConfig',
    'ModelServingConfigServedModel',
    'ModelServingConfigTrafficConfig',
    'ModelServingConfigTrafficConfigRoute',
    'ModelServingEmailNotifications',
    'ModelServingProvisionedThroughputAiGateway',
    'ModelServingProvisionedThroughputAiGatewayFallbackConfig',
    'ModelServingProvisionedThroughputAiGatewayGuardrails',
    'ModelServingProvisionedThroughputAiGatewayGuardrailsInput',
    'ModelServingProvisionedThroughputAiGatewayGuardrailsInputPii',
    'ModelServingProvisionedThroughputAiGatewayGuardrailsOutput',
    'ModelServingProvisionedThroughputAiGatewayGuardrailsOutputPii',
    'ModelServingProvisionedThroughputAiGatewayInferenceTableConfig',
    'ModelServingProvisionedThroughputAiGatewayRateLimit',
    'ModelServingProvisionedThroughputAiGatewayUsageTrackingConfig',
    'ModelServingProvisionedThroughputConfig',
    'ModelServingProvisionedThroughputConfigServedEntity',
    'ModelServingProvisionedThroughputConfigTrafficConfig',
    'ModelServingProvisionedThroughputConfigTrafficConfigRoute',
    'ModelServingProvisionedThroughputEmailNotifications',
    'ModelServingProvisionedThroughputTag',
    'ModelServingRateLimit',
    'ModelServingTag',
    'MountAbfs',
    'MountAdl',
    'MountGs',
    'MountS3',
    'MountWasb',
    'MwsCustomerManagedKeysAwsKeyInfo',
    'MwsCustomerManagedKeysGcpKeyInfo',
    'MwsNetworkConnectivityConfigEgressConfig',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRules',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule',
    'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule',
    'MwsNetworkConnectivityConfigEgressConfigTargetRules',
    'MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule',
    'MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule',
    'MwsNetworksErrorMessage',
    'MwsNetworksGcpNetworkInfo',
    'MwsNetworksVpcEndpoints',
    'MwsVpcEndpointGcpVpcEndpointInfo',
    'MwsWorkspacesCloudResourceContainer',
    'MwsWorkspacesCloudResourceContainerGcp',
    'MwsWorkspacesExternalCustomerInfo',
    'MwsWorkspacesGcpManagedNetworkConfig',
    'MwsWorkspacesGkeConfig',
    'MwsWorkspacesToken',
    'NotebookProviderConfig',
    'NotificationDestinationConfig',
    'NotificationDestinationConfigEmail',
    'NotificationDestinationConfigGenericWebhook',
    'NotificationDestinationConfigMicrosoftTeams',
    'NotificationDestinationConfigPagerduty',
    'NotificationDestinationConfigSlack',
    'OnlineTableSpec',
    'OnlineTableSpecRunContinuously',
    'OnlineTableSpecRunTriggered',
    'OnlineTableStatus',
    'OnlineTableStatusContinuousUpdateStatus',
    'OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress',
    'OnlineTableStatusFailedStatus',
    'OnlineTableStatusProvisioningStatus',
    'OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress',
    'OnlineTableStatusTriggeredUpdateStatus',
    'OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress',
    'PermissionAssignmentProviderConfig',
    'PermissionsAccessControl',
    'PipelineCluster',
    'PipelineClusterAutoscale',
    'PipelineClusterAwsAttributes',
    'PipelineClusterAzureAttributes',
    'PipelineClusterAzureAttributesLogAnalyticsInfo',
    'PipelineClusterClusterLogConf',
    'PipelineClusterClusterLogConfDbfs',
    'PipelineClusterClusterLogConfS3',
    'PipelineClusterClusterLogConfVolumes',
    'PipelineClusterGcpAttributes',
    'PipelineClusterInitScript',
    'PipelineClusterInitScriptAbfss',
    'PipelineClusterInitScriptDbfs',
    'PipelineClusterInitScriptFile',
    'PipelineClusterInitScriptGcs',
    'PipelineClusterInitScriptS3',
    'PipelineClusterInitScriptVolumes',
    'PipelineClusterInitScriptWorkspace',
    'PipelineDeployment',
    'PipelineEnvironment',
    'PipelineEventLog',
    'PipelineFilters',
    'PipelineGatewayDefinition',
    'PipelineIngestionDefinition',
    'PipelineIngestionDefinitionObject',
    'PipelineIngestionDefinitionObjectReport',
    'PipelineIngestionDefinitionObjectReportTableConfiguration',
    'PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig',
    'PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters',
    'PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParametersReportParameter',
    'PipelineIngestionDefinitionObjectSchema',
    'PipelineIngestionDefinitionObjectSchemaTableConfiguration',
    'PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig',
    'PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters',
    'PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParametersReportParameter',
    'PipelineIngestionDefinitionObjectTable',
    'PipelineIngestionDefinitionObjectTableTableConfiguration',
    'PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig',
    'PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters',
    'PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParametersReportParameter',
    'PipelineIngestionDefinitionSourceConfiguration',
    'PipelineIngestionDefinitionSourceConfigurationCatalog',
    'PipelineIngestionDefinitionSourceConfigurationCatalogPostgres',
    'PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig',
    'PipelineIngestionDefinitionTableConfiguration',
    'PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig',
    'PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters',
    'PipelineIngestionDefinitionTableConfigurationWorkdayReportParametersReportParameter',
    'PipelineLatestUpdate',
    'PipelineLibrary',
    'PipelineLibraryFile',
    'PipelineLibraryGlob',
    'PipelineLibraryMaven',
    'PipelineLibraryNotebook',
    'PipelineNotification',
    'PipelineRestartWindow',
    'PipelineRunAs',
    'PipelineTrigger',
    'PipelineTriggerCron',
    'PipelineTriggerManual',
    'PolicyInfoColumnMask',
    'PolicyInfoColumnMaskUsing',
    'PolicyInfoMatchColumn',
    'PolicyInfoRowFilter',
    'PolicyInfoRowFilterUsing',
    'QualityMonitorCustomMetric',
    'QualityMonitorDataClassificationConfig',
    'QualityMonitorInferenceLog',
    'QualityMonitorNotifications',
    'QualityMonitorNotificationsOnFailure',
    'QualityMonitorNotificationsOnNewClassificationTagDetected',
    'QualityMonitorProviderConfig',
    'QualityMonitorSchedule',
    'QualityMonitorSnapshot',
    'QualityMonitorTimeSeries',
    'QualityMonitorV2AnomalyDetectionConfig',
    'QueryParameter',
    'QueryParameterDateRangeValue',
    'QueryParameterDateRangeValueDateRangeValue',
    'QueryParameterDateValue',
    'QueryParameterEnumValue',
    'QueryParameterEnumValueMultiValuesOptions',
    'QueryParameterNumericValue',
    'QueryParameterQueryBackedValue',
    'QueryParameterQueryBackedValueMultiValuesOptions',
    'QueryParameterTextValue',
    'RecipientIpAccessList',
    'RecipientPropertiesKvpairs',
    'RecipientToken',
    'RegisteredModelAlias',
    'RepoSparseCheckout',
    'RestrictWorkspaceAdminsSettingRestrictWorkspaceAdmins',
    'RfaAccessRequestDestinationsDestination',
    'RfaAccessRequestDestinationsSecurable',
    'SecretScopeKeyvaultMetadata',
    'ServicePrincipalFederationPolicyOidcPolicy',
    'ShareObject',
    'ShareObjectPartition',
    'ShareObjectPartitionValue',
    'ShareProviderConfig',
    'SqlAlertOptions',
    'SqlEndpointChannel',
    'SqlEndpointHealth',
    'SqlEndpointHealthFailureReason',
    'SqlEndpointOdbcParams',
    'SqlEndpointTags',
    'SqlEndpointTagsCustomTag',
    'SqlPermissionsPrivilegeAssignment',
    'SqlQueryParameter',
    'SqlQueryParameterDate',
    'SqlQueryParameterDateRange',
    'SqlQueryParameterDateRangeRange',
    'SqlQueryParameterDatetime',
    'SqlQueryParameterDatetimeRange',
    'SqlQueryParameterDatetimeRangeRange',
    'SqlQueryParameterDatetimesec',
    'SqlQueryParameterDatetimesecRange',
    'SqlQueryParameterDatetimesecRangeRange',
    'SqlQueryParameterEnum',
    'SqlQueryParameterEnumMultiple',
    'SqlQueryParameterNumber',
    'SqlQueryParameterQuery',
    'SqlQueryParameterQueryMultiple',
    'SqlQueryParameterText',
    'SqlQuerySchedule',
    'SqlQueryScheduleContinuous',
    'SqlQueryScheduleDaily',
    'SqlQueryScheduleWeekly',
    'SqlTableColumn',
    'SqlWidgetParameter',
    'SqlWidgetPosition',
    'StorageCredentialAwsIamRole',
    'StorageCredentialAzureManagedIdentity',
    'StorageCredentialAzureServicePrincipal',
    'StorageCredentialCloudflareApiToken',
    'StorageCredentialDatabricksGcpServiceAccount',
    'StorageCredentialGcpServiceAccountKey',
    'TableColumn',
    'TagPolicyValue',
    'VectorSearchEndpointEndpointStatus',
    'VectorSearchIndexDeltaSyncIndexSpec',
    'VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn',
    'VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn',
    'VectorSearchIndexDirectAccessIndexSpec',
    'VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn',
    'VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn',
    'VectorSearchIndexStatus',
    'WorkspaceSettingV2AibiDashboardEmbeddingAccessPolicy',
    'WorkspaceSettingV2AibiDashboardEmbeddingApprovedDomains',
    'WorkspaceSettingV2AutomaticClusterUpdateWorkspace',
    'WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails',
    'WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow',
    'WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule',
    'WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime',
    'WorkspaceSettingV2BooleanVal',
    'WorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy',
    'WorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains',
    'WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspace',
    'WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails',
    'WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow',
    'WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule',
    'WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime',
    'WorkspaceSettingV2EffectiveBooleanVal',
    'WorkspaceSettingV2EffectiveIntegerVal',
    'WorkspaceSettingV2EffectivePersonalCompute',
    'WorkspaceSettingV2EffectiveRestrictWorkspaceAdmins',
    'WorkspaceSettingV2EffectiveStringVal',
    'WorkspaceSettingV2IntegerVal',
    'WorkspaceSettingV2PersonalCompute',
    'WorkspaceSettingV2RestrictWorkspaceAdmins',
    'WorkspaceSettingV2StringVal',
    'GetAccountFederationPoliciesPolicyResult',
    'GetAccountFederationPoliciesPolicyOidcPolicyResult',
    'GetAccountFederationPolicyOidcPolicyResult',
    'GetAccountNetworkPoliciesItemResult',
    'GetAccountNetworkPoliciesItemEgressResult',
    'GetAccountNetworkPoliciesItemEgressNetworkAccessResult',
    'GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedInternetDestinationResult',
    'GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedStorageDestinationResult',
    'GetAccountNetworkPoliciesItemEgressNetworkAccessPolicyEnforcementResult',
    'GetAccountNetworkPolicyEgressResult',
    'GetAccountNetworkPolicyEgressNetworkAccessResult',
    'GetAccountNetworkPolicyEgressNetworkAccessAllowedInternetDestinationResult',
    'GetAccountNetworkPolicyEgressNetworkAccessAllowedStorageDestinationResult',
    'GetAccountNetworkPolicyEgressNetworkAccessPolicyEnforcementResult',
    'GetAccountSettingV2AibiDashboardEmbeddingAccessPolicyResult',
    'GetAccountSettingV2AibiDashboardEmbeddingApprovedDomainsResult',
    'GetAccountSettingV2AutomaticClusterUpdateWorkspaceResult',
    'GetAccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult',
    'GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult',
    'GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult',
    'GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult',
    'GetAccountSettingV2BooleanValResult',
    'GetAccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicyResult',
    'GetAccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomainsResult',
    'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceResult',
    'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult',
    'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult',
    'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult',
    'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult',
    'GetAccountSettingV2EffectiveBooleanValResult',
    'GetAccountSettingV2EffectiveIntegerValResult',
    'GetAccountSettingV2EffectivePersonalComputeResult',
    'GetAccountSettingV2EffectiveRestrictWorkspaceAdminsResult',
    'GetAccountSettingV2EffectiveStringValResult',
    'GetAccountSettingV2IntegerValResult',
    'GetAccountSettingV2PersonalComputeResult',
    'GetAccountSettingV2RestrictWorkspaceAdminsResult',
    'GetAccountSettingV2StringValResult',
    'GetAlertV2EffectiveRunAsResult',
    'GetAlertV2EvaluationResult',
    'GetAlertV2EvaluationNotificationResult',
    'GetAlertV2EvaluationNotificationSubscriptionResult',
    'GetAlertV2EvaluationSourceResult',
    'GetAlertV2EvaluationThresholdResult',
    'GetAlertV2EvaluationThresholdColumnResult',
    'GetAlertV2EvaluationThresholdValueResult',
    'GetAlertV2RunAsResult',
    'GetAlertV2ScheduleResult',
    'GetAlertsV2AlertResult',
    'GetAlertsV2AlertEffectiveRunAsResult',
    'GetAlertsV2AlertEvaluationResult',
    'GetAlertsV2AlertEvaluationNotificationResult',
    'GetAlertsV2AlertEvaluationNotificationSubscriptionResult',
    'GetAlertsV2AlertEvaluationSourceResult',
    'GetAlertsV2AlertEvaluationThresholdResult',
    'GetAlertsV2AlertEvaluationThresholdColumnResult',
    'GetAlertsV2AlertEvaluationThresholdValueResult',
    'GetAlertsV2AlertRunAsResult',
    'GetAlertsV2AlertScheduleResult',
    'GetAppAppResult',
    'GetAppAppActiveDeploymentResult',
    'GetAppAppActiveDeploymentDeploymentArtifactsResult',
    'GetAppAppActiveDeploymentStatusResult',
    'GetAppAppAppStatusResult',
    'GetAppAppComputeStatusResult',
    'GetAppAppPendingDeploymentResult',
    'GetAppAppPendingDeploymentDeploymentArtifactsResult',
    'GetAppAppPendingDeploymentStatusResult',
    'GetAppAppResourceResult',
    'GetAppAppResourceDatabaseResult',
    'GetAppAppResourceGenieSpaceResult',
    'GetAppAppResourceJobResult',
    'GetAppAppResourceSecretResult',
    'GetAppAppResourceServingEndpointResult',
    'GetAppAppResourceSqlWarehouseResult',
    'GetAppAppResourceUcSecurableResult',
    'GetAppProviderConfigResult',
    'GetAppsAppResult',
    'GetAppsAppActiveDeploymentResult',
    'GetAppsAppActiveDeploymentDeploymentArtifactsResult',
    'GetAppsAppActiveDeploymentStatusResult',
    'GetAppsAppAppStatusResult',
    'GetAppsAppComputeStatusResult',
    'GetAppsAppPendingDeploymentResult',
    'GetAppsAppPendingDeploymentDeploymentArtifactsResult',
    'GetAppsAppPendingDeploymentStatusResult',
    'GetAppsAppResourceResult',
    'GetAppsAppResourceDatabaseResult',
    'GetAppsAppResourceGenieSpaceResult',
    'GetAppsAppResourceJobResult',
    'GetAppsAppResourceSecretResult',
    'GetAppsAppResourceServingEndpointResult',
    'GetAppsAppResourceSqlWarehouseResult',
    'GetAppsAppResourceUcSecurableResult',
    'GetAppsProviderConfigResult',
    'GetAppsSettingsCustomTemplateManifestResult',
    'GetAppsSettingsCustomTemplateManifestResourceSpecResult',
    'GetAppsSettingsCustomTemplateManifestResourceSpecJobSpecResult',
    'GetAppsSettingsCustomTemplateManifestResourceSpecSecretSpecResult',
    'GetAppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpecResult',
    'GetAppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpecResult',
    'GetAppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpecResult',
    'GetAppsSettingsCustomTemplatesTemplateResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecJobSpecResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSecretSpecResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecServingEndpointSpecResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSqlWarehouseSpecResult',
    'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecUcSecurableSpecResult',
    'GetBudgetPoliciesFilterByResult',
    'GetBudgetPoliciesPolicyResult',
    'GetBudgetPoliciesPolicyCustomTagResult',
    'GetBudgetPoliciesSortSpecResult',
    'GetBudgetPolicyCustomTagResult',
    'GetCatalogCatalogInfoResult',
    'GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagResult',
    'GetCatalogCatalogInfoProvisioningInfoResult',
    'GetCatalogProviderConfigResult',
    'GetCatalogsProviderConfigResult',
    'GetClusterClusterInfoResult',
    'GetClusterClusterInfoAutoscaleResult',
    'GetClusterClusterInfoAwsAttributesResult',
    'GetClusterClusterInfoAzureAttributesResult',
    'GetClusterClusterInfoAzureAttributesLogAnalyticsInfoResult',
    'GetClusterClusterInfoClusterLogConfResult',
    'GetClusterClusterInfoClusterLogConfDbfsResult',
    'GetClusterClusterInfoClusterLogConfS3Result',
    'GetClusterClusterInfoClusterLogConfVolumesResult',
    'GetClusterClusterInfoClusterLogStatusResult',
    'GetClusterClusterInfoDockerImageResult',
    'GetClusterClusterInfoDockerImageBasicAuthResult',
    'GetClusterClusterInfoDriverResult',
    'GetClusterClusterInfoDriverNodeAwsAttributesResult',
    'GetClusterClusterInfoExecutorResult',
    'GetClusterClusterInfoExecutorNodeAwsAttributesResult',
    'GetClusterClusterInfoGcpAttributesResult',
    'GetClusterClusterInfoInitScriptResult',
    'GetClusterClusterInfoInitScriptAbfssResult',
    'GetClusterClusterInfoInitScriptDbfsResult',
    'GetClusterClusterInfoInitScriptFileResult',
    'GetClusterClusterInfoInitScriptGcsResult',
    'GetClusterClusterInfoInitScriptS3Result',
    'GetClusterClusterInfoInitScriptVolumesResult',
    'GetClusterClusterInfoInitScriptWorkspaceResult',
    'GetClusterClusterInfoSpecResult',
    'GetClusterClusterInfoSpecAutoscaleResult',
    'GetClusterClusterInfoSpecAwsAttributesResult',
    'GetClusterClusterInfoSpecAzureAttributesResult',
    'GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoResult',
    'GetClusterClusterInfoSpecClusterLogConfResult',
    'GetClusterClusterInfoSpecClusterLogConfDbfsResult',
    'GetClusterClusterInfoSpecClusterLogConfS3Result',
    'GetClusterClusterInfoSpecClusterLogConfVolumesResult',
    'GetClusterClusterInfoSpecClusterMountInfoResult',
    'GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoResult',
    'GetClusterClusterInfoSpecDockerImageResult',
    'GetClusterClusterInfoSpecDockerImageBasicAuthResult',
    'GetClusterClusterInfoSpecGcpAttributesResult',
    'GetClusterClusterInfoSpecInitScriptResult',
    'GetClusterClusterInfoSpecInitScriptAbfssResult',
    'GetClusterClusterInfoSpecInitScriptDbfsResult',
    'GetClusterClusterInfoSpecInitScriptFileResult',
    'GetClusterClusterInfoSpecInitScriptGcsResult',
    'GetClusterClusterInfoSpecInitScriptS3Result',
    'GetClusterClusterInfoSpecInitScriptVolumesResult',
    'GetClusterClusterInfoSpecInitScriptWorkspaceResult',
    'GetClusterClusterInfoSpecLibraryResult',
    'GetClusterClusterInfoSpecLibraryCranResult',
    'GetClusterClusterInfoSpecLibraryMavenResult',
    'GetClusterClusterInfoSpecLibraryProviderConfigResult',
    'GetClusterClusterInfoSpecLibraryPypiResult',
    'GetClusterClusterInfoSpecProviderConfigResult',
    'GetClusterClusterInfoSpecWorkloadTypeResult',
    'GetClusterClusterInfoSpecWorkloadTypeClientsResult',
    'GetClusterClusterInfoTerminationReasonResult',
    'GetClusterClusterInfoWorkloadTypeResult',
    'GetClusterClusterInfoWorkloadTypeClientsResult',
    'GetClusterPolicyProviderConfigResult',
    'GetClusterProviderConfigResult',
    'GetClustersFilterByResult',
    'GetClustersProviderConfigResult',
    'GetCurrentMetastoreMetastoreInfoResult',
    'GetCurrentMetastoreProviderConfigResult',
    'GetDashboardsDashboardResult',
    'GetDashboardsProviderConfigResult',
    'GetDataQualityMonitorAnomalyDetectionConfigResult',
    'GetDataQualityMonitorDataProfilingConfigResult',
    'GetDataQualityMonitorDataProfilingConfigCustomMetricResult',
    'GetDataQualityMonitorDataProfilingConfigInferenceLogResult',
    'GetDataQualityMonitorDataProfilingConfigNotificationSettingsResult',
    'GetDataQualityMonitorDataProfilingConfigNotificationSettingsOnFailureResult',
    'GetDataQualityMonitorDataProfilingConfigScheduleResult',
    'GetDataQualityMonitorDataProfilingConfigSnapshotResult',
    'GetDataQualityMonitorDataProfilingConfigTimeSeriesResult',
    'GetDataQualityMonitorsMonitorResult',
    'GetDataQualityMonitorsMonitorAnomalyDetectionConfigResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigCustomMetricResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigInferenceLogResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsOnFailureResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigScheduleResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigSnapshotResult',
    'GetDataQualityMonitorsMonitorDataProfilingConfigTimeSeriesResult',
    'GetDataQualityRefreshesRefreshResult',
    'GetDatabaseDatabaseCatalogsDatabaseCatalogResult',
    'GetDatabaseInstanceChildInstanceRefResult',
    'GetDatabaseInstanceCustomTagResult',
    'GetDatabaseInstanceEffectiveCustomTagResult',
    'GetDatabaseInstanceParentInstanceRefResult',
    'GetDatabaseInstancesDatabaseInstanceResult',
    'GetDatabaseInstancesDatabaseInstanceChildInstanceRefResult',
    'GetDatabaseInstancesDatabaseInstanceCustomTagResult',
    'GetDatabaseInstancesDatabaseInstanceEffectiveCustomTagResult',
    'GetDatabaseInstancesDatabaseInstanceParentInstanceRefResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatusResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusResult',
    'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult',
    'GetDatabaseSyncedDatabaseTableSpecResult',
    'GetDatabaseSyncedDatabaseTableSpecNewPipelineSpecResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusFailedStatusResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableSpecResult',
    'GetDatabaseSyncedDatabaseTablesSyncedTableSpecNewPipelineSpecResult',
    'GetDbfsFilePathsPathListResult',
    'GetDirectoryProviderConfigResult',
    'GetEntityTagAssignmentsTagAssignmentResult',
    'GetExternalLocationExternalLocationInfoResult',
    'GetExternalLocationExternalLocationInfoEncryptionDetailsResult',
    'GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueManagedAqsResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueManagedPubsubResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueManagedSqsResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueProvidedAqsResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueProvidedPubsubResult',
    'GetExternalLocationExternalLocationInfoFileEventQueueProvidedSqsResult',
    'GetExternalLocationProviderConfigResult',
    'GetExternalLocationsProviderConfigResult',
    'GetExternalMetadatasExternalMetadataResult',
    'GetFeatureEngineeringFeatureFunctionResult',
    'GetFeatureEngineeringFeatureFunctionExtraParameterResult',
    'GetFeatureEngineeringFeatureSourceResult',
    'GetFeatureEngineeringFeatureSourceDeltaTableSourceResult',
    'GetFeatureEngineeringFeatureTimeWindowResult',
    'GetFeatureEngineeringFeatureTimeWindowContinuousResult',
    'GetFeatureEngineeringFeatureTimeWindowSlidingResult',
    'GetFeatureEngineeringFeatureTimeWindowTumblingResult',
    'GetFeatureEngineeringFeaturesFeatureResult',
    'GetFeatureEngineeringFeaturesFeatureFunctionResult',
    'GetFeatureEngineeringFeaturesFeatureFunctionExtraParameterResult',
    'GetFeatureEngineeringFeaturesFeatureSourceResult',
    'GetFeatureEngineeringFeaturesFeatureSourceDeltaTableSourceResult',
    'GetFeatureEngineeringFeaturesFeatureTimeWindowResult',
    'GetFeatureEngineeringFeaturesFeatureTimeWindowContinuousResult',
    'GetFeatureEngineeringFeaturesFeatureTimeWindowSlidingResult',
    'GetFeatureEngineeringFeaturesFeatureTimeWindowTumblingResult',
    'GetFeatureEngineeringMaterializedFeatureOfflineStoreConfigResult',
    'GetFeatureEngineeringMaterializedFeatureOnlineStoreConfigResult',
    'GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureResult',
    'GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOfflineStoreConfigResult',
    'GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOnlineStoreConfigResult',
    'GetFunctionsFunctionResult',
    'GetFunctionsFunctionInputParamsResult',
    'GetFunctionsFunctionInputParamsParameterResult',
    'GetFunctionsFunctionReturnParamsResult',
    'GetFunctionsFunctionReturnParamsParameterResult',
    'GetFunctionsFunctionRoutineDependenciesResult',
    'GetFunctionsFunctionRoutineDependenciesDependencyResult',
    'GetFunctionsFunctionRoutineDependenciesDependencyConnectionResult',
    'GetFunctionsFunctionRoutineDependenciesDependencyCredentialResult',
    'GetFunctionsFunctionRoutineDependenciesDependencyFunctionResult',
    'GetFunctionsFunctionRoutineDependenciesDependencyTableResult',
    'GetFunctionsProviderConfigResult',
    'GetInstancePoolPoolInfoResult',
    'GetInstancePoolPoolInfoAwsAttributesResult',
    'GetInstancePoolPoolInfoAzureAttributesResult',
    'GetInstancePoolPoolInfoDiskSpecResult',
    'GetInstancePoolPoolInfoDiskSpecDiskTypeResult',
    'GetInstancePoolPoolInfoGcpAttributesResult',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeResult',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionResult',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionResult',
    'GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideResult',
    'GetInstancePoolPoolInfoPreloadedDockerImageResult',
    'GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthResult',
    'GetInstancePoolPoolInfoStatsResult',
    'GetInstanceProfilesInstanceProfileResult',
    'GetInstanceProfilesProviderConfigResult',
    'GetJobJobSettingsResult',
    'GetJobJobSettingsSettingsResult',
    'GetJobJobSettingsSettingsContinuousResult',
    'GetJobJobSettingsSettingsDbtTaskResult',
    'GetJobJobSettingsSettingsDeploymentResult',
    'GetJobJobSettingsSettingsEmailNotificationsResult',
    'GetJobJobSettingsSettingsEnvironmentResult',
    'GetJobJobSettingsSettingsEnvironmentSpecResult',
    'GetJobJobSettingsSettingsGitSourceResult',
    'GetJobJobSettingsSettingsGitSourceJobSourceResult',
    'GetJobJobSettingsSettingsHealthResult',
    'GetJobJobSettingsSettingsHealthRuleResult',
    'GetJobJobSettingsSettingsJobClusterResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Result',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Result',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeResult',
    'GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsResult',
    'GetJobJobSettingsSettingsLibraryResult',
    'GetJobJobSettingsSettingsLibraryCranResult',
    'GetJobJobSettingsSettingsLibraryMavenResult',
    'GetJobJobSettingsSettingsLibraryProviderConfigResult',
    'GetJobJobSettingsSettingsLibraryPypiResult',
    'GetJobJobSettingsSettingsNewClusterResult',
    'GetJobJobSettingsSettingsNewClusterAutoscaleResult',
    'GetJobJobSettingsSettingsNewClusterAwsAttributesResult',
    'GetJobJobSettingsSettingsNewClusterAzureAttributesResult',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfResult',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsResult',
    'GetJobJobSettingsSettingsNewClusterClusterLogConfS3Result',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoResult',
    'GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoResult',
    'GetJobJobSettingsSettingsNewClusterDockerImageResult',
    'GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthResult',
    'GetJobJobSettingsSettingsNewClusterGcpAttributesResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptAbfssResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptDbfsResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptFileResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptGcsResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptS3Result',
    'GetJobJobSettingsSettingsNewClusterInitScriptVolumesResult',
    'GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceResult',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeResult',
    'GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsResult',
    'GetJobJobSettingsSettingsNotebookTaskResult',
    'GetJobJobSettingsSettingsNotificationSettingsResult',
    'GetJobJobSettingsSettingsParameterResult',
    'GetJobJobSettingsSettingsPipelineTaskResult',
    'GetJobJobSettingsSettingsPythonWheelTaskResult',
    'GetJobJobSettingsSettingsQueueResult',
    'GetJobJobSettingsSettingsRunAsResult',
    'GetJobJobSettingsSettingsRunJobTaskResult',
    'GetJobJobSettingsSettingsScheduleResult',
    'GetJobJobSettingsSettingsSparkJarTaskResult',
    'GetJobJobSettingsSettingsSparkPythonTaskResult',
    'GetJobJobSettingsSettingsSparkSubmitTaskResult',
    'GetJobJobSettingsSettingsTaskResult',
    'GetJobJobSettingsSettingsTaskConditionTaskResult',
    'GetJobJobSettingsSettingsTaskDashboardTaskResult',
    'GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionResult',
    'GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionSubscriberResult',
    'GetJobJobSettingsSettingsTaskDbtTaskResult',
    'GetJobJobSettingsSettingsTaskDependsOnResult',
    'GetJobJobSettingsSettingsTaskEmailNotificationsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionSubscriberResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskHealthResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryProviderConfigResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Result',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Result',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskPowerBiModelResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskTableResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededResult',
    'GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessResult',
    'GetJobJobSettingsSettingsTaskHealthResult',
    'GetJobJobSettingsSettingsTaskHealthRuleResult',
    'GetJobJobSettingsSettingsTaskLibraryResult',
    'GetJobJobSettingsSettingsTaskLibraryCranResult',
    'GetJobJobSettingsSettingsTaskLibraryMavenResult',
    'GetJobJobSettingsSettingsTaskLibraryProviderConfigResult',
    'GetJobJobSettingsSettingsTaskLibraryPypiResult',
    'GetJobJobSettingsSettingsTaskNewClusterResult',
    'GetJobJobSettingsSettingsTaskNewClusterAutoscaleResult',
    'GetJobJobSettingsSettingsTaskNewClusterAwsAttributesResult',
    'GetJobJobSettingsSettingsTaskNewClusterAzureAttributesResult',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfResult',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsResult',
    'GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Result',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoResult',
    'GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageResult',
    'GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthResult',
    'GetJobJobSettingsSettingsTaskNewClusterGcpAttributesResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptFileResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Result',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesResult',
    'GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceResult',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeResult',
    'GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsResult',
    'GetJobJobSettingsSettingsTaskNotebookTaskResult',
    'GetJobJobSettingsSettingsTaskNotificationSettingsResult',
    'GetJobJobSettingsSettingsTaskPipelineTaskResult',
    'GetJobJobSettingsSettingsTaskPowerBiTaskResult',
    'GetJobJobSettingsSettingsTaskPowerBiTaskPowerBiModelResult',
    'GetJobJobSettingsSettingsTaskPowerBiTaskTableResult',
    'GetJobJobSettingsSettingsTaskPythonWheelTaskResult',
    'GetJobJobSettingsSettingsTaskRunJobTaskResult',
    'GetJobJobSettingsSettingsTaskSparkJarTaskResult',
    'GetJobJobSettingsSettingsTaskSparkPythonTaskResult',
    'GetJobJobSettingsSettingsTaskSparkSubmitTaskResult',
    'GetJobJobSettingsSettingsTaskSqlTaskResult',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertResult',
    'GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionResult',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardResult',
    'GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionResult',
    'GetJobJobSettingsSettingsTaskSqlTaskFileResult',
    'GetJobJobSettingsSettingsTaskSqlTaskQueryResult',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsResult',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededResult',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureResult',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartResult',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededResult',
    'GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessResult',
    'GetJobJobSettingsSettingsTriggerResult',
    'GetJobJobSettingsSettingsTriggerFileArrivalResult',
    'GetJobJobSettingsSettingsTriggerPeriodicResult',
    'GetJobJobSettingsSettingsTriggerTableUpdateResult',
    'GetJobJobSettingsSettingsWebhookNotificationsResult',
    'GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededResult',
    'GetJobJobSettingsSettingsWebhookNotificationsOnFailureResult',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStartResult',
    'GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededResult',
    'GetJobJobSettingsSettingsWebhookNotificationsOnSuccessResult',
    'GetJobsProviderConfigResult',
    'GetMaterializedFeaturesFeatureTagsFeatureTagResult',
    'GetMetastoreMetastoreInfoResult',
    'GetMlflowExperimentProviderConfigResult',
    'GetMlflowExperimentTagResult',
    'GetMlflowModelLatestVersionResult',
    'GetMlflowModelLatestVersionTagResult',
    'GetMlflowModelProviderConfigResult',
    'GetMlflowModelTagResult',
    'GetMlflowModelsProviderConfigResult',
    'GetMwsNetworkConnectivityConfigEgressConfigResult',
    'GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesResult',
    'GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleResult',
    'GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleResult',
    'GetMwsNetworkConnectivityConfigEgressConfigTargetRulesResult',
    'GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRuleResult',
    'GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleResult',
    'GetNodeTypeProviderConfigResult',
    'GetNotebookPathsNotebookPathListResult',
    'GetNotebookProviderConfigResult',
    'GetNotificationDestinationsNotificationDestinationResult',
    'GetNotificationDestinationsProviderConfigResult',
    'GetOnlineStoresOnlineStoreResult',
    'GetPipelinesProviderConfigResult',
    'GetPolicyInfoColumnMaskResult',
    'GetPolicyInfoColumnMaskUsingResult',
    'GetPolicyInfoMatchColumnResult',
    'GetPolicyInfoRowFilterResult',
    'GetPolicyInfoRowFilterUsingResult',
    'GetPolicyInfosPolicyResult',
    'GetPolicyInfosPolicyColumnMaskResult',
    'GetPolicyInfosPolicyColumnMaskUsingResult',
    'GetPolicyInfosPolicyMatchColumnResult',
    'GetPolicyInfosPolicyRowFilterResult',
    'GetPolicyInfosPolicyRowFilterUsingResult',
    'GetQualityMonitorV2AnomalyDetectionConfigResult',
    'GetQualityMonitorsV2QualityMonitorResult',
    'GetQualityMonitorsV2QualityMonitorAnomalyDetectionConfigResult',
    'GetRegisteredModelModelInfoResult',
    'GetRegisteredModelModelInfoAliasResult',
    'GetRegisteredModelProviderConfigResult',
    'GetRegisteredModelVersionsModelVersionResult',
    'GetRegisteredModelVersionsModelVersionAliasResult',
    'GetRegisteredModelVersionsModelVersionModelVersionDependencyResult',
    'GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyResult',
    'GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyConnectionResult',
    'GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyCredentialResult',
    'GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyFunctionResult',
    'GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyTableResult',
    'GetRegisteredModelVersionsProviderConfigResult',
    'GetRfaAccessRequestDestinationsDestinationResult',
    'GetRfaAccessRequestDestinationsSecurableResult',
    'GetSchemaProviderConfigResult',
    'GetSchemaSchemaInfoResult',
    'GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagResult',
    'GetSchemasProviderConfigResult',
    'GetServicePrincipalFederationPoliciesPolicyResult',
    'GetServicePrincipalFederationPoliciesPolicyOidcPolicyResult',
    'GetServicePrincipalFederationPolicyOidcPolicyResult',
    'GetServingEndpointsEndpointResult',
    'GetServingEndpointsEndpointAiGatewayResult',
    'GetServingEndpointsEndpointAiGatewayFallbackConfigResult',
    'GetServingEndpointsEndpointAiGatewayGuardrailResult',
    'GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyResult',
    'GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyPiiResult',
    'GetServingEndpointsEndpointAiGatewayGuardrailOutputResult',
    'GetServingEndpointsEndpointAiGatewayGuardrailOutputPiiResult',
    'GetServingEndpointsEndpointAiGatewayInferenceTableConfigResult',
    'GetServingEndpointsEndpointAiGatewayRateLimitResult',
    'GetServingEndpointsEndpointAiGatewayUsageTrackingConfigResult',
    'GetServingEndpointsEndpointConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelAi21labsConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelAmazonBedrockConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelAnthropicConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelCohereConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigApiKeyAuthResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuthResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelDatabricksModelServingConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelGoogleCloudVertexAiConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelOpenaiConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityExternalModelPalmConfigResult',
    'GetServingEndpointsEndpointConfigServedEntityFoundationModelResult',
    'GetServingEndpointsEndpointConfigServedModelResult',
    'GetServingEndpointsEndpointStateResult',
    'GetServingEndpointsEndpointTagResult',
    'GetServingEndpointsProviderConfigResult',
    'GetShareObjectResult',
    'GetShareObjectPartitionResult',
    'GetShareObjectPartitionValueResult',
    'GetShareProviderConfigResult',
    'GetSharesProviderConfigResult',
    'GetSparkVersionProviderConfigResult',
    'GetSqlWarehouseChannelResult',
    'GetSqlWarehouseHealthResult',
    'GetSqlWarehouseHealthFailureReasonResult',
    'GetSqlWarehouseOdbcParamsResult',
    'GetSqlWarehouseProviderConfigResult',
    'GetSqlWarehouseTagsResult',
    'GetSqlWarehouseTagsCustomTagResult',
    'GetSqlWarehousesProviderConfigResult',
    'GetStorageCredentialProviderConfigResult',
    'GetStorageCredentialStorageCredentialInfoResult',
    'GetStorageCredentialStorageCredentialInfoAwsIamRoleResult',
    'GetStorageCredentialStorageCredentialInfoAzureManagedIdentityResult',
    'GetStorageCredentialStorageCredentialInfoAzureServicePrincipalResult',
    'GetStorageCredentialStorageCredentialInfoCloudflareApiTokenResult',
    'GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountResult',
    'GetStorageCredentialsProviderConfigResult',
    'GetTableProviderConfigResult',
    'GetTableTableInfoResult',
    'GetTableTableInfoColumnResult',
    'GetTableTableInfoColumnMaskResult',
    'GetTableTableInfoDeltaRuntimePropertiesKvpairsResult',
    'GetTableTableInfoEffectivePredictiveOptimizationFlagResult',
    'GetTableTableInfoEncryptionDetailsResult',
    'GetTableTableInfoEncryptionDetailsSseEncryptionDetailsResult',
    'GetTableTableInfoRowFilterResult',
    'GetTableTableInfoSecurableKindManifestResult',
    'GetTableTableInfoSecurableKindManifestOptionResult',
    'GetTableTableInfoTableConstraintResult',
    'GetTableTableInfoTableConstraintForeignKeyConstraintResult',
    'GetTableTableInfoTableConstraintNamedTableConstraintResult',
    'GetTableTableInfoTableConstraintPrimaryKeyConstraintResult',
    'GetTableTableInfoViewDependenciesResult',
    'GetTableTableInfoViewDependenciesDependencyResult',
    'GetTableTableInfoViewDependenciesDependencyConnectionResult',
    'GetTableTableInfoViewDependenciesDependencyCredentialResult',
    'GetTableTableInfoViewDependenciesDependencyFunctionResult',
    'GetTableTableInfoViewDependenciesDependencyTableResult',
    'GetTablesProviderConfigResult',
    'GetTagPoliciesTagPolicyResult',
    'GetTagPoliciesTagPolicyValueResult',
    'GetTagPolicyValueResult',
    'GetViewsProviderConfigResult',
    'GetVolumeProviderConfigResult',
    'GetVolumeVolumeInfoResult',
    'GetVolumeVolumeInfoEncryptionDetailsResult',
    'GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsResult',
    'GetVolumesProviderConfigResult',
    'GetWorkspaceSettingV2AibiDashboardEmbeddingAccessPolicyResult',
    'GetWorkspaceSettingV2AibiDashboardEmbeddingApprovedDomainsResult',
    'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceResult',
    'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult',
    'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult',
    'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult',
    'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult',
    'GetWorkspaceSettingV2BooleanValResult',
    'GetWorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicyResult',
    'GetWorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomainsResult',
    'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceResult',
    'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult',
    'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult',
    'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult',
    'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult',
    'GetWorkspaceSettingV2EffectiveBooleanValResult',
    'GetWorkspaceSettingV2EffectiveIntegerValResult',
    'GetWorkspaceSettingV2EffectivePersonalComputeResult',
    'GetWorkspaceSettingV2EffectiveRestrictWorkspaceAdminsResult',
    'GetWorkspaceSettingV2EffectiveStringValResult',
    'GetWorkspaceSettingV2IntegerValResult',
    'GetWorkspaceSettingV2PersonalComputeResult',
    'GetWorkspaceSettingV2RestrictWorkspaceAdminsResult',
    'GetWorkspaceSettingV2StringValResult',
    'GetZonesProviderConfigResult',
]

@pulumi.output_type
class AccessControlRuleSetGrantRule(dict):
    def __init__(__self__, *,
                 role: _builtins.str,
                 principals: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str role: Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page), [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role) or [budget policy permissions](https://docs.databricks.com/aws/en/admin/usage/budget-policies#manage-budget-policy-permissions), depending on the `name` defined:
               * `accounts/{account_id}/ruleSets/default`
               * `roles/marketplace.admin` - Databricks Marketplace administrator.
               * `roles/billing.admin` - Billing administrator.
               * `accounts/{account_id}/servicePrincipals/{service_principal_application_id}/ruleSets/default`
               * `roles/servicePrincipal.manager` - Manager of a service principal.
               * `roles/servicePrincipal.user` - User of a service principal.
               * `accounts/{account_id}/groups/{group_id}/ruleSets/default`
               * `roles/group.manager` - Manager of a group.
               * `accounts/{account_id}/budgetPolicies/{budget_policy_id}/ruleSets/default`
               * `roles/budgetPolicy.manager` - Manager of a budget policy.
               * `roles/budgetPolicy.user` - User of a budget policy.
        :param Sequence[_builtins.str] principals: a list of principals who are granted a role. The following format is supported:
               * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
               * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
               * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
        pulumi.set(__self__, "role", role)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Role to be granted. The supported roles are listed below. For more information about these roles, refer to [service principal roles](https://docs.databricks.com/security/auth-authz/access-control/service-principal-acl.html#service-principal-roles), [group roles](https://docs.databricks.com/en/administration-guide/users-groups/groups.html#manage-roles-on-an-account-group-using-the-workspace-admin-settings-page), [marketplace roles](https://docs.databricks.com/en/marketplace/get-started-provider.html#assign-the-marketplace-admin-role) or [budget policy permissions](https://docs.databricks.com/aws/en/admin/usage/budget-policies#manage-budget-policy-permissions), depending on the `name` defined:
        * `accounts/{account_id}/ruleSets/default`
        * `roles/marketplace.admin` - Databricks Marketplace administrator.
        * `roles/billing.admin` - Billing administrator.
        * `accounts/{account_id}/servicePrincipals/{service_principal_application_id}/ruleSets/default`
        * `roles/servicePrincipal.manager` - Manager of a service principal.
        * `roles/servicePrincipal.user` - User of a service principal.
        * `accounts/{account_id}/groups/{group_id}/ruleSets/default`
        * `roles/group.manager` - Manager of a group.
        * `accounts/{account_id}/budgetPolicies/{budget_policy_id}/ruleSets/default`
        * `roles/budgetPolicy.manager` - Manager of a budget policy.
        * `roles/budgetPolicy.user` - User of a budget policy.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[Sequence[_builtins.str]]:
        """
        a list of principals who are granted a role. The following format is supported:
        * `users/{username}` (also exposed as `acl_principal_id` attribute of `User` resource).
        * `groups/{groupname}` (also exposed as `acl_principal_id` attribute of `Group` resource).
        * `servicePrincipals/{applicationId}` (also exposed as `acl_principal_id` attribute of `ServicePrincipal` resource).
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class AccountFederationPolicyOidcPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jwksJson":
            suggest = "jwks_json"
        elif key == "jwksUri":
            suggest = "jwks_uri"
        elif key == "subjectClaim":
            suggest = "subject_claim"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountFederationPolicyOidcPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountFederationPolicyOidcPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountFederationPolicyOidcPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_json: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 subject_claim: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] audiences: The allowed token audiences, as specified in the 'aud' claim of federated tokens.
               The audience identifier is intended to represent the recipient of the token.
               Can be any non-empty string value. As long as the audience in the token matches
               at least one audience in the policy, the token is considered a match. If audiences
               is unspecified, defaults to your Databricks account id
        :param _builtins.str issuer: The required token issuer, as specified in the 'iss' claim of federated tokens
        :param _builtins.str jwks_json: The public keys used to validate the signature of federated tokens, in JWKS format.
               Most use cases should not need to specify this field. If jwks_uri and jwks_json
               are both unspecified (recommended), Databricks automatically fetches the public
               keys from your issuers well known endpoint. Databricks strongly recommends
               relying on your issuers well known endpoint for discovering public keys
        :param _builtins.str jwks_uri: URL of the public keys used to validate the signature of federated tokens, in
               JWKS format. Most use cases should not need to specify this field. If jwks_uri
               and jwks_json are both unspecified (recommended), Databricks automatically
               fetches the public keys from your issuers well known endpoint. Databricks
               strongly recommends relying on your issuers well known endpoint for discovering
               public keys
        :param _builtins.str subject: The required token subject, as specified in the subject claim of federated tokens.
               Must be specified for service principal federation policies. Must not be specified
               for account federation policies
        :param _builtins.str subject_claim: The claim that contains the subject of the token. If unspecified, the default value
               is 'sub'
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_json is not None:
            pulumi.set(__self__, "jwks_json", jwks_json)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_claim is not None:
            pulumi.set(__self__, "subject_claim", subject_claim)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed token audiences, as specified in the 'aud' claim of federated tokens.
        The audience identifier is intended to represent the recipient of the token.
        Can be any non-empty string value. As long as the audience in the token matches
        at least one audience in the policy, the token is considered a match. If audiences
        is unspecified, defaults to your Databricks account id
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The required token issuer, as specified in the 'iss' claim of federated tokens
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksJson")
    def jwks_json(self) -> Optional[_builtins.str]:
        """
        The public keys used to validate the signature of federated tokens, in JWKS format.
        Most use cases should not need to specify this field. If jwks_uri and jwks_json
        are both unspecified (recommended), Databricks automatically fetches the public
        keys from your issuers well known endpoint. Databricks strongly recommends
        relying on your issuers well known endpoint for discovering public keys
        """
        return pulumi.get(self, "jwks_json")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        URL of the public keys used to validate the signature of federated tokens, in
        JWKS format. Most use cases should not need to specify this field. If jwks_uri
        and jwks_json are both unspecified (recommended), Databricks automatically
        fetches the public keys from your issuers well known endpoint. Databricks
        strongly recommends relying on your issuers well known endpoint for discovering
        public keys
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        The required token subject, as specified in the subject claim of federated tokens.
        Must be specified for service principal federation policies. Must not be specified
        for account federation policies
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="subjectClaim")
    def subject_claim(self) -> Optional[_builtins.str]:
        """
        The claim that contains the subject of the token. If unspecified, the default value
        is 'sub'
        """
        return pulumi.get(self, "subject_claim")


@pulumi.output_type
class AccountNetworkPolicyEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkAccess":
            suggest = "network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountNetworkPolicyEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountNetworkPolicyEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountNetworkPolicyEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_access: Optional['outputs.AccountNetworkPolicyEgressNetworkAccess'] = None):
        """
        :param 'AccountNetworkPolicyEgressNetworkAccessArgs' network_access: The access policy enforced for egress traffic to the internet
        """
        if network_access is not None:
            pulumi.set(__self__, "network_access", network_access)

    @_builtins.property
    @pulumi.getter(name="networkAccess")
    def network_access(self) -> Optional['outputs.AccountNetworkPolicyEgressNetworkAccess']:
        """
        The access policy enforced for egress traffic to the internet
        """
        return pulumi.get(self, "network_access")


@pulumi.output_type
class AccountNetworkPolicyEgressNetworkAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictionMode":
            suggest = "restriction_mode"
        elif key == "allowedInternetDestinations":
            suggest = "allowed_internet_destinations"
        elif key == "allowedStorageDestinations":
            suggest = "allowed_storage_destinations"
        elif key == "policyEnforcement":
            suggest = "policy_enforcement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountNetworkPolicyEgressNetworkAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountNetworkPolicyEgressNetworkAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountNetworkPolicyEgressNetworkAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restriction_mode: _builtins.str,
                 allowed_internet_destinations: Optional[Sequence['outputs.AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination']] = None,
                 allowed_storage_destinations: Optional[Sequence['outputs.AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination']] = None,
                 policy_enforcement: Optional['outputs.AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement'] = None):
        """
        :param _builtins.str restriction_mode: The restriction mode that controls how serverless workloads can access the internet. Possible values are: `FULL_ACCESS`, `RESTRICTED_ACCESS`
        :param Sequence['AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestinationArgs'] allowed_internet_destinations: List of internet destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        :param Sequence['AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestinationArgs'] allowed_storage_destinations: List of storage destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        :param 'AccountNetworkPolicyEgressNetworkAccessPolicyEnforcementArgs' policy_enforcement: Optional. When policy_enforcement is not provided, we default to ENFORCE_MODE_ALL_SERVICES
        """
        pulumi.set(__self__, "restriction_mode", restriction_mode)
        if allowed_internet_destinations is not None:
            pulumi.set(__self__, "allowed_internet_destinations", allowed_internet_destinations)
        if allowed_storage_destinations is not None:
            pulumi.set(__self__, "allowed_storage_destinations", allowed_storage_destinations)
        if policy_enforcement is not None:
            pulumi.set(__self__, "policy_enforcement", policy_enforcement)

    @_builtins.property
    @pulumi.getter(name="restrictionMode")
    def restriction_mode(self) -> _builtins.str:
        """
        The restriction mode that controls how serverless workloads can access the internet. Possible values are: `FULL_ACCESS`, `RESTRICTED_ACCESS`
        """
        return pulumi.get(self, "restriction_mode")

    @_builtins.property
    @pulumi.getter(name="allowedInternetDestinations")
    def allowed_internet_destinations(self) -> Optional[Sequence['outputs.AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination']]:
        """
        List of internet destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        """
        return pulumi.get(self, "allowed_internet_destinations")

    @_builtins.property
    @pulumi.getter(name="allowedStorageDestinations")
    def allowed_storage_destinations(self) -> Optional[Sequence['outputs.AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination']]:
        """
        List of storage destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        """
        return pulumi.get(self, "allowed_storage_destinations")

    @_builtins.property
    @pulumi.getter(name="policyEnforcement")
    def policy_enforcement(self) -> Optional['outputs.AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement']:
        """
        Optional. When policy_enforcement is not provided, we default to ENFORCE_MODE_ALL_SERVICES
        """
        return pulumi.get(self, "policy_enforcement")


@pulumi.output_type
class AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetDestinationType":
            suggest = "internet_destination_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountNetworkPolicyEgressNetworkAccessAllowedInternetDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 internet_destination_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: The internet destination to which access will be allowed. Format dependent on the destination type
        :param _builtins.str internet_destination_type: The type of internet destination. Currently only DNS_NAME is supported. Possible values are: `DNS_NAME`
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if internet_destination_type is not None:
            pulumi.set(__self__, "internet_destination_type", internet_destination_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        The internet destination to which access will be allowed. Format dependent on the destination type
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="internetDestinationType")
    def internet_destination_type(self) -> Optional[_builtins.str]:
        """
        The type of internet destination. Currently only DNS_NAME is supported. Possible values are: `DNS_NAME`
        """
        return pulumi.get(self, "internet_destination_type")


@pulumi.output_type
class AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureStorageAccount":
            suggest = "azure_storage_account"
        elif key == "azureStorageService":
            suggest = "azure_storage_service"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "storageDestinationType":
            suggest = "storage_destination_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountNetworkPolicyEgressNetworkAccessAllowedStorageDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_storage_account: Optional[_builtins.str] = None,
                 azure_storage_service: Optional[_builtins.str] = None,
                 bucket_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 storage_destination_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str azure_storage_account: The Azure storage account name
        :param _builtins.str azure_storage_service: The Azure storage service type (blob, dfs, etc.)
        :param _builtins.str storage_destination_type: The type of storage destination. Possible values are: `AWS_S3`, `AZURE_STORAGE`, `GOOGLE_CLOUD_STORAGE`
        """
        if azure_storage_account is not None:
            pulumi.set(__self__, "azure_storage_account", azure_storage_account)
        if azure_storage_service is not None:
            pulumi.set(__self__, "azure_storage_service", azure_storage_service)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_destination_type is not None:
            pulumi.set(__self__, "storage_destination_type", storage_destination_type)

    @_builtins.property
    @pulumi.getter(name="azureStorageAccount")
    def azure_storage_account(self) -> Optional[_builtins.str]:
        """
        The Azure storage account name
        """
        return pulumi.get(self, "azure_storage_account")

    @_builtins.property
    @pulumi.getter(name="azureStorageService")
    def azure_storage_service(self) -> Optional[_builtins.str]:
        """
        The Azure storage service type (blob, dfs, etc.)
        """
        return pulumi.get(self, "azure_storage_service")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="storageDestinationType")
    def storage_destination_type(self) -> Optional[_builtins.str]:
        """
        The type of storage destination. Possible values are: `AWS_S3`, `AZURE_STORAGE`, `GOOGLE_CLOUD_STORAGE`
        """
        return pulumi.get(self, "storage_destination_type")


@pulumi.output_type
class AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dryRunModeProductFilters":
            suggest = "dry_run_mode_product_filters"
        elif key == "enforcementMode":
            suggest = "enforcement_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountNetworkPolicyEgressNetworkAccessPolicyEnforcement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dry_run_mode_product_filters: Optional[Sequence[_builtins.str]] = None,
                 enforcement_mode: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dry_run_mode_product_filters: When empty, it means dry run for all products.
               When non-empty, it means dry run for specific products and for the other products, they will run in enforced mode
        :param _builtins.str enforcement_mode: The mode of policy enforcement. ENFORCED blocks traffic that violates policy,
               while DRY_RUN only logs violations without blocking. When not specified,
               defaults to ENFORCED. Possible values are: `DRY_RUN`, `ENFORCED`
        """
        if dry_run_mode_product_filters is not None:
            pulumi.set(__self__, "dry_run_mode_product_filters", dry_run_mode_product_filters)
        if enforcement_mode is not None:
            pulumi.set(__self__, "enforcement_mode", enforcement_mode)

    @_builtins.property
    @pulumi.getter(name="dryRunModeProductFilters")
    def dry_run_mode_product_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        When empty, it means dry run for all products.
        When non-empty, it means dry run for specific products and for the other products, they will run in enforced mode
        """
        return pulumi.get(self, "dry_run_mode_product_filters")

    @_builtins.property
    @pulumi.getter(name="enforcementMode")
    def enforcement_mode(self) -> Optional[_builtins.str]:
        """
        The mode of policy enforcement. ENFORCED blocks traffic that violates policy,
        while DRY_RUN only logs violations without blocking. When not specified,
        defaults to ENFORCED. Possible values are: `DRY_RUN`, `ENFORCED`
        """
        return pulumi.get(self, "enforcement_mode")


@pulumi.output_type
class AccountSettingV2AibiDashboardEmbeddingAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicyType":
            suggest = "access_policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2AibiDashboardEmbeddingAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2AibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2AibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class AccountSettingV2AibiDashboardEmbeddingApprovedDomains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvedDomains":
            suggest = "approved_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2AibiDashboardEmbeddingApprovedDomains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2AibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2AibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class AccountSettingV2AutomaticClusterUpdateWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canToggle":
            suggest = "can_toggle"
        elif key == "enablementDetails":
            suggest = "enablement_details"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "restartEvenIfNoUpdatesAvailable":
            suggest = "restart_even_if_no_updates_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2AutomaticClusterUpdateWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails'] = None,
                 maintenance_window: Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails']:
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow']:
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forcedForComplianceMode":
            suggest = "forced_for_compliance_mode"
        elif key == "unavailableForDisabledEntitlement":
            suggest = "unavailable_for_disabled_entitlement"
        elif key == "unavailableForNonEnterpriseTier":
            suggest = "unavailable_for_non_enterprise_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weekDayBasedSchedule":
            suggest = "week_day_based_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule'] = None):
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule']:
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime'] = None):
        """
        :param _builtins.str day_of_week: Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime']:
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class AccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class AccountSettingV2BooleanVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicyType":
            suggest = "access_policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class AccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvedDomains":
            suggest = "approved_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class AccountSettingV2EffectiveAutomaticClusterUpdateWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canToggle":
            suggest = "can_toggle"
        elif key == "enablementDetails":
            suggest = "enablement_details"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "restartEvenIfNoUpdatesAvailable":
            suggest = "restart_even_if_no_updates_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2EffectiveAutomaticClusterUpdateWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails'] = None,
                 maintenance_window: Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails']:
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow']:
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forcedForComplianceMode":
            suggest = "forced_for_compliance_mode"
        elif key == "unavailableForDisabledEntitlement":
            suggest = "unavailable_for_disabled_entitlement"
        elif key == "unavailableForNonEnterpriseTier":
            suggest = "unavailable_for_non_enterprise_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weekDayBasedSchedule":
            suggest = "week_day_based_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule'] = None):
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule']:
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime'] = None):
        """
        :param _builtins.str day_of_week: Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime']:
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class AccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class AccountSettingV2EffectiveBooleanVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2EffectiveIntegerVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2EffectivePersonalCompute(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2EffectiveRestrictWorkspaceAdmins(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AccountSettingV2EffectiveStringVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2IntegerVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2PersonalCompute(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AccountSettingV2RestrictWorkspaceAdmins(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AccountSettingV2StringVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AibiDashboardEmbeddingAccessPolicySettingAibiDashboardEmbeddingAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicyType":
            suggest = "access_policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AibiDashboardEmbeddingAccessPolicySettingAibiDashboardEmbeddingAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AibiDashboardEmbeddingAccessPolicySettingAibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AibiDashboardEmbeddingAccessPolicySettingAibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: Configured embedding policy. Possible values are `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`.
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        Configured embedding policy. Possible values are `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`.
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class AibiDashboardEmbeddingApprovedDomainsSettingAibiDashboardEmbeddingApprovedDomains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvedDomains":
            suggest = "approved_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AibiDashboardEmbeddingApprovedDomainsSettingAibiDashboardEmbeddingApprovedDomains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AibiDashboardEmbeddingApprovedDomainsSettingAibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AibiDashboardEmbeddingApprovedDomainsSettingAibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approved_domains: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] approved_domains: the list of approved domains. To allow all subdomains for a given domain, use a wildcard symbol (`*`) before the domain name, i.e., `*.databricks.com` will allow to embed into any site under the `databricks.com`.
        """
        pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Sequence[_builtins.str]:
        """
        the list of approved domains. To allow all subdomains for a given domain, use a wildcard symbol (`*`) before the domain name, i.e., `*.databricks.com` will allow to embed into any site under the `databricks.com`.
        """
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class AlertCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emptyResultState":
            suggest = "empty_result_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 op: _builtins.str,
                 operand: 'outputs.AlertConditionOperand',
                 empty_result_state: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.AlertConditionThreshold'] = None):
        """
        :param _builtins.str op: Operator used for comparison in alert evaluation. (Enum: `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `EQUAL`, `NOT_EQUAL`, `IS_NULL`)
        :param 'AlertConditionOperandArgs' operand: Name of the column from the query result to use for comparison in alert evaluation:
        :param _builtins.str empty_result_state: Alert state if the result is empty (`UNKNOWN`, `OK`, `TRIGGERED`)
        :param 'AlertConditionThresholdArgs' threshold: Threshold value used for comparison in alert evaluation:
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "operand", operand)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        Operator used for comparison in alert evaluation. (Enum: `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `EQUAL`, `NOT_EQUAL`, `IS_NULL`)
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def operand(self) -> 'outputs.AlertConditionOperand':
        """
        Name of the column from the query result to use for comparison in alert evaluation:
        """
        return pulumi.get(self, "operand")

    @_builtins.property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[_builtins.str]:
        """
        Alert state if the result is empty (`UNKNOWN`, `OK`, `TRIGGERED`)
        """
        return pulumi.get(self, "empty_result_state")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.AlertConditionThreshold']:
        """
        Threshold value used for comparison in alert evaluation:
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AlertConditionOperand(dict):
    def __init__(__self__, *,
                 column: 'outputs.AlertConditionOperandColumn'):
        """
        :param 'AlertConditionOperandColumnArgs' column: Block describing the column from the query result to use for comparison in alert evaluation:
        """
        pulumi.set(__self__, "column", column)

    @_builtins.property
    @pulumi.getter
    def column(self) -> 'outputs.AlertConditionOperandColumn':
        """
        Block describing the column from the query result to use for comparison in alert evaluation:
        """
        return pulumi.get(self, "column")


@pulumi.output_type
class AlertConditionOperandColumn(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the column.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the column.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AlertConditionThreshold(dict):
    def __init__(__self__, *,
                 value: 'outputs.AlertConditionThresholdValue'):
        """
        :param 'AlertConditionThresholdValueArgs' value: actual value used in comparison (one of the attributes is required):
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.AlertConditionThresholdValue':
        """
        actual value used in comparison (one of the attributes is required):
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConditionThresholdValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boolValue":
            suggest = "bool_value"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConditionThresholdValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConditionThresholdValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConditionThresholdValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bool_value: Optional[_builtins.bool] = None,
                 double_value: Optional[_builtins.float] = None,
                 string_value: Optional[_builtins.str] = None):
        """
        :param _builtins.bool bool_value: boolean value (`true` or `false`) to compare against boolean results.
        :param _builtins.float double_value: double value to compare against integer and double results.
        :param _builtins.str string_value: string value to compare against string results.
        """
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[_builtins.bool]:
        """
        boolean value (`true` or `false`) to compare against boolean results.
        """
        return pulumi.get(self, "bool_value")

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[_builtins.float]:
        """
        double value to compare against integer and double results.
        """
        return pulumi.get(self, "double_value")

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[_builtins.str]:
        """
        string value to compare against string results.
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class AlertV2EffectiveRunAs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "servicePrincipalName":
            suggest = "service_principal_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2EffectiveRunAs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2EffectiveRunAs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2EffectiveRunAs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        :param _builtins.str user_name: The email of an active workspace user. Can only set this field to their own email
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        The email of an active workspace user. Can only set this field to their own email
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class AlertV2Evaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "emptyResultState":
            suggest = "empty_result_state"
        elif key == "lastEvaluatedAt":
            suggest = "last_evaluated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2Evaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2Evaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2Evaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 source: 'outputs.AlertV2EvaluationSource',
                 empty_result_state: Optional[_builtins.str] = None,
                 last_evaluated_at: Optional[_builtins.str] = None,
                 notification: Optional['outputs.AlertV2EvaluationNotification'] = None,
                 state: Optional[_builtins.str] = None,
                 threshold: Optional['outputs.AlertV2EvaluationThreshold'] = None):
        """
        :param _builtins.str comparison_operator: Operator used for comparison in alert evaluation. Possible values are: `EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`
        :param 'AlertV2EvaluationSourceArgs' source: Source column from result to use to evaluate alert
        :param _builtins.str empty_result_state: Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        :param _builtins.str last_evaluated_at: (string) - Timestamp of the last evaluation
        :param 'AlertV2EvaluationNotificationArgs' notification: User or Notification Destination to notify when alert is triggered
        :param _builtins.str state: (string) - Latest state of alert evaluation. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        :param 'AlertV2EvaluationThresholdArgs' threshold: Threshold to user for alert evaluation, can be a column or a value
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "source", source)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if last_evaluated_at is not None:
            pulumi.set(__self__, "last_evaluated_at", last_evaluated_at)
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        Operator used for comparison in alert evaluation. Possible values are: `EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.AlertV2EvaluationSource':
        """
        Source column from result to use to evaluate alert
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[_builtins.str]:
        """
        Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        """
        return pulumi.get(self, "empty_result_state")

    @_builtins.property
    @pulumi.getter(name="lastEvaluatedAt")
    def last_evaluated_at(self) -> Optional[_builtins.str]:
        """
        (string) - Timestamp of the last evaluation
        """
        return pulumi.get(self, "last_evaluated_at")

    @_builtins.property
    @pulumi.getter
    def notification(self) -> Optional['outputs.AlertV2EvaluationNotification']:
        """
        User or Notification Destination to notify when alert is triggered
        """
        return pulumi.get(self, "notification")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (string) - Latest state of alert evaluation. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.AlertV2EvaluationThreshold']:
        """
        Threshold to user for alert evaluation, can be a column or a value
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AlertV2EvaluationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveNotifyOnOk":
            suggest = "effective_notify_on_ok"
        elif key == "effectiveRetriggerSeconds":
            suggest = "effective_retrigger_seconds"
        elif key == "notifyOnOk":
            suggest = "notify_on_ok"
        elif key == "retriggerSeconds":
            suggest = "retrigger_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2EvaluationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2EvaluationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2EvaluationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_notify_on_ok: Optional[_builtins.bool] = None,
                 effective_retrigger_seconds: Optional[_builtins.int] = None,
                 notify_on_ok: Optional[_builtins.bool] = None,
                 retrigger_seconds: Optional[_builtins.int] = None,
                 subscriptions: Optional[Sequence['outputs.AlertV2EvaluationNotificationSubscription']] = None):
        """
        :param _builtins.bool notify_on_ok: Whether to notify alert subscribers when alert returns back to normal
        :param _builtins.int retrigger_seconds: Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again
        """
        if effective_notify_on_ok is not None:
            pulumi.set(__self__, "effective_notify_on_ok", effective_notify_on_ok)
        if effective_retrigger_seconds is not None:
            pulumi.set(__self__, "effective_retrigger_seconds", effective_retrigger_seconds)
        if notify_on_ok is not None:
            pulumi.set(__self__, "notify_on_ok", notify_on_ok)
        if retrigger_seconds is not None:
            pulumi.set(__self__, "retrigger_seconds", retrigger_seconds)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="effectiveNotifyOnOk")
    def effective_notify_on_ok(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "effective_notify_on_ok")

    @_builtins.property
    @pulumi.getter(name="effectiveRetriggerSeconds")
    def effective_retrigger_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "effective_retrigger_seconds")

    @_builtins.property
    @pulumi.getter(name="notifyOnOk")
    def notify_on_ok(self) -> Optional[_builtins.bool]:
        """
        Whether to notify alert subscribers when alert returns back to normal
        """
        return pulumi.get(self, "notify_on_ok")

    @_builtins.property
    @pulumi.getter(name="retriggerSeconds")
    def retrigger_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again
        """
        return pulumi.get(self, "retrigger_seconds")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.AlertV2EvaluationNotificationSubscription']]:
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class AlertV2EvaluationNotificationSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userEmail":
            suggest = "user_email"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2EvaluationNotificationSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2EvaluationNotificationSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2EvaluationNotificationSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_email: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_email")


@pulumi.output_type
class AlertV2EvaluationSource(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 aggregation: Optional[_builtins.str] = None,
                 display: Optional[_builtins.str] = None):
        """
        :param _builtins.str aggregation: Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if display is not None:
            pulumi.set(__self__, "display", display)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "display")


@pulumi.output_type
class AlertV2EvaluationThreshold(dict):
    def __init__(__self__, *,
                 column: Optional['outputs.AlertV2EvaluationThresholdColumn'] = None,
                 value: Optional['outputs.AlertV2EvaluationThresholdValue'] = None):
        if column is not None:
            pulumi.set(__self__, "column", column)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional['outputs.AlertV2EvaluationThresholdColumn']:
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.AlertV2EvaluationThresholdValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertV2EvaluationThresholdColumn(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 aggregation: Optional[_builtins.str] = None,
                 display: Optional[_builtins.str] = None):
        """
        :param _builtins.str aggregation: Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if display is not None:
            pulumi.set(__self__, "display", display)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "display")


@pulumi.output_type
class AlertV2EvaluationThresholdValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boolValue":
            suggest = "bool_value"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2EvaluationThresholdValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2EvaluationThresholdValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2EvaluationThresholdValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bool_value: Optional[_builtins.bool] = None,
                 double_value: Optional[_builtins.float] = None,
                 string_value: Optional[_builtins.str] = None):
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "bool_value")

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "double_value")

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "string_value")


@pulumi.output_type
class AlertV2RunAs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "servicePrincipalName":
            suggest = "service_principal_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2RunAs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2RunAs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2RunAs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        :param _builtins.str user_name: The email of an active workspace user. Can only set this field to their own email
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        The email of an active workspace user. Can only set this field to their own email
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class AlertV2Schedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronSchedule":
            suggest = "quartz_cron_schedule"
        elif key == "timezoneId":
            suggest = "timezone_id"
        elif key == "pauseStatus":
            suggest = "pause_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertV2Schedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertV2Schedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertV2Schedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_schedule: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_schedule: A cron expression using quartz syntax that specifies the schedule for this pipeline.
               Should use the quartz format described here: http://www.quartz-scheduler.org/documentation/quartz-2.1.7/tutorials/tutorial-lesson-06.html
        :param _builtins.str timezone_id: A Java timezone id. The schedule will be resolved using this timezone.
               This will be combined with the quartz_cron_schedule to determine the schedule.
               See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details
        :param _builtins.str pause_status: Indicate whether this schedule is paused or not. Possible values are: `PAUSED`, `UNPAUSED`
        """
        pulumi.set(__self__, "quartz_cron_schedule", quartz_cron_schedule)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronSchedule")
    def quartz_cron_schedule(self) -> _builtins.str:
        """
        A cron expression using quartz syntax that specifies the schedule for this pipeline.
        Should use the quartz format described here: http://www.quartz-scheduler.org/documentation/quartz-2.1.7/tutorials/tutorial-lesson-06.html
        """
        return pulumi.get(self, "quartz_cron_schedule")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        A Java timezone id. The schedule will be resolved using this timezone.
        This will be combined with the quartz_cron_schedule to determine the schedule.
        See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        Indicate whether this schedule is paused or not. Possible values are: `PAUSED`, `UNPAUSED`
        """
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class AppActiveDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "deploymentArtifacts":
            suggest = "deployment_artifacts"
        elif key == "deploymentId":
            suggest = "deployment_id"
        elif key == "sourceCodePath":
            suggest = "source_code_path"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppActiveDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppActiveDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppActiveDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: Optional[_builtins.str] = None,
                 creator: Optional[_builtins.str] = None,
                 deployment_artifacts: Optional['outputs.AppActiveDeploymentDeploymentArtifacts'] = None,
                 deployment_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source_code_path: Optional[_builtins.str] = None,
                 status: Optional['outputs.AppActiveDeploymentStatus'] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str update_time: The update time of the app.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator is not None:
            pulumi.set(__self__, "creator", creator)
        if deployment_artifacts is not None:
            pulumi.set(__self__, "deployment_artifacts", deployment_artifacts)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> Optional[_builtins.str]:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="deploymentArtifacts")
    def deployment_artifacts(self) -> Optional['outputs.AppActiveDeploymentDeploymentArtifacts']:
        return pulumi.get(self, "deployment_artifacts")

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.AppActiveDeploymentStatus']:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppActiveDeploymentDeploymentArtifacts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCodePath":
            suggest = "source_code_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppActiveDeploymentDeploymentArtifacts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppActiveDeploymentDeploymentArtifacts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppActiveDeploymentDeploymentArtifacts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_code_path: Optional[_builtins.str] = None):
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class AppActiveDeploymentStatus(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AppAppStatus(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AppComputeStatus(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AppPendingDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "deploymentArtifacts":
            suggest = "deployment_artifacts"
        elif key == "deploymentId":
            suggest = "deployment_id"
        elif key == "sourceCodePath":
            suggest = "source_code_path"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppPendingDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppPendingDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppPendingDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: Optional[_builtins.str] = None,
                 creator: Optional[_builtins.str] = None,
                 deployment_artifacts: Optional['outputs.AppPendingDeploymentDeploymentArtifacts'] = None,
                 deployment_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source_code_path: Optional[_builtins.str] = None,
                 status: Optional['outputs.AppPendingDeploymentStatus'] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str update_time: The update time of the app.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if creator is not None:
            pulumi.set(__self__, "creator", creator)
        if deployment_artifacts is not None:
            pulumi.set(__self__, "deployment_artifacts", deployment_artifacts)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> Optional[_builtins.str]:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="deploymentArtifacts")
    def deployment_artifacts(self) -> Optional['outputs.AppPendingDeploymentDeploymentArtifacts']:
        return pulumi.get(self, "deployment_artifacts")

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.AppPendingDeploymentStatus']:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppPendingDeploymentDeploymentArtifacts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCodePath":
            suggest = "source_code_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppPendingDeploymentDeploymentArtifacts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppPendingDeploymentDeploymentArtifacts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppPendingDeploymentDeploymentArtifacts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_code_path: Optional[_builtins.str] = None):
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class AppPendingDeploymentStatus(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AppProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class AppResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "genieSpace":
            suggest = "genie_space"
        elif key == "servingEndpoint":
            suggest = "serving_endpoint"
        elif key == "sqlWarehouse":
            suggest = "sql_warehouse"
        elif key == "ucSecurable":
            suggest = "uc_securable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database: Optional['outputs.AppResourceDatabase'] = None,
                 description: Optional[_builtins.str] = None,
                 genie_space: Optional['outputs.AppResourceGenieSpace'] = None,
                 job: Optional['outputs.AppResourceJob'] = None,
                 secret: Optional['outputs.AppResourceSecret'] = None,
                 serving_endpoint: Optional['outputs.AppResourceServingEndpoint'] = None,
                 sql_warehouse: Optional['outputs.AppResourceSqlWarehouse'] = None,
                 uc_securable: Optional['outputs.AppResourceUcSecurable'] = None):
        """
        :param _builtins.str name: The name of the resource.
        :param 'AppResourceDatabaseArgs' database: attribute
        :param _builtins.str description: The description of the resource.
               
               Exactly one of the following attributes must be provided:
        :param 'AppResourceGenieSpaceArgs' genie_space: attribute
        :param 'AppResourceJobArgs' job: attribute
        :param 'AppResourceSecretArgs' secret: attribute
        :param 'AppResourceServingEndpointArgs' serving_endpoint: attribute
        :param 'AppResourceSqlWarehouseArgs' sql_warehouse: attribute
        :param 'AppResourceUcSecurableArgs' uc_securable: attribute (see the [API docs](https://docs.databricks.com/api/workspace/apps/create#resources-uc_securable) for full list of supported UC objects)
        """
        pulumi.set(__self__, "name", name)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if genie_space is not None:
            pulumi.set(__self__, "genie_space", genie_space)
        if job is not None:
            pulumi.set(__self__, "job", job)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if serving_endpoint is not None:
            pulumi.set(__self__, "serving_endpoint", serving_endpoint)
        if sql_warehouse is not None:
            pulumi.set(__self__, "sql_warehouse", sql_warehouse)
        if uc_securable is not None:
            pulumi.set(__self__, "uc_securable", uc_securable)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional['outputs.AppResourceDatabase']:
        """
        attribute
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the resource.

        Exactly one of the following attributes must be provided:
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="genieSpace")
    def genie_space(self) -> Optional['outputs.AppResourceGenieSpace']:
        """
        attribute
        """
        return pulumi.get(self, "genie_space")

    @_builtins.property
    @pulumi.getter
    def job(self) -> Optional['outputs.AppResourceJob']:
        """
        attribute
        """
        return pulumi.get(self, "job")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.AppResourceSecret']:
        """
        attribute
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="servingEndpoint")
    def serving_endpoint(self) -> Optional['outputs.AppResourceServingEndpoint']:
        """
        attribute
        """
        return pulumi.get(self, "serving_endpoint")

    @_builtins.property
    @pulumi.getter(name="sqlWarehouse")
    def sql_warehouse(self) -> Optional['outputs.AppResourceSqlWarehouse']:
        """
        attribute
        """
        return pulumi.get(self, "sql_warehouse")

    @_builtins.property
    @pulumi.getter(name="ucSecurable")
    def uc_securable(self) -> Optional['outputs.AppResourceUcSecurable']:
        """
        attribute (see the [API docs](https://docs.databricks.com/api/workspace/apps/create#resources-uc_securable) for full list of supported UC objects)
        """
        return pulumi.get(self, "uc_securable")


@pulumi.output_type
class AppResourceDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "instanceName":
            suggest = "instance_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppResourceDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppResourceDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppResourceDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 instance_name: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str database_name: The name of database.
        :param _builtins.str instance_name: The name of database instance.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of database.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The name of database instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppResourceGenieSpace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spaceId":
            suggest = "space_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppResourceGenieSpace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppResourceGenieSpace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppResourceGenieSpace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 permission: _builtins.str,
                 space_id: _builtins.str):
        """
        :param _builtins.str name: The name of Genie Space.
        :param _builtins.str space_id: The unique ID of Genie Space.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "space_id", space_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Genie Space.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        The unique ID of Genie Space.
        """
        return pulumi.get(self, "space_id")


@pulumi.output_type
class AppResourceJob(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str permission: Permissions to grant on the Job. Supported permissions are: `CAN_MANAGE`, `IS_OWNER`, `CAN_MANAGE_RUN`, `CAN_VIEW`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permissions to grant on the Job. Supported permissions are: `CAN_MANAGE`, `IS_OWNER`, `CAN_MANAGE_RUN`, `CAN_VIEW`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppResourceSecret(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 permission: _builtins.str,
                 scope: _builtins.str):
        """
        :param _builtins.str key: Key of the secret to grant permission on.
        :param _builtins.str permission: Permission to grant on the secret scope. For secrets, only one permission is allowed. Permission must be one of: `READ`, `WRITE`, `MANAGE`.
        :param _builtins.str scope: Scope of the secret to grant permission on.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the secret to grant permission on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on the secret scope. For secrets, only one permission is allowed. Permission must be one of: `READ`, `WRITE`, `MANAGE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Scope of the secret to grant permission on.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class AppResourceServingEndpoint(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str name: Name of the serving endpoint to grant permission on.
        :param _builtins.str permission: Permission to grant on the serving endpoint. Supported permissions are: `CAN_MANAGE`, `CAN_QUERY`, `CAN_VIEW`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the serving endpoint to grant permission on.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on the serving endpoint. Supported permissions are: `CAN_MANAGE`, `CAN_QUERY`, `CAN_VIEW`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppResourceSqlWarehouse(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str id: Id of the SQL warehouse to grant permission on.
        :param _builtins.str permission: Permission to grant on the SQL warehouse. Supported permissions are: `CAN_MANAGE`, `CAN_USE`, `IS_OWNER`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the SQL warehouse to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on the SQL warehouse. Supported permissions are: `CAN_MANAGE`, `CAN_USE`, `IS_OWNER`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppResourceUcSecurable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securableFullName":
            suggest = "securable_full_name"
        elif key == "securableType":
            suggest = "securable_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppResourceUcSecurable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppResourceUcSecurable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppResourceUcSecurable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: _builtins.str,
                 securable_full_name: _builtins.str,
                 securable_type: _builtins.str):
        """
        :param _builtins.str permission: Permissions to grant on UC securable, i.e. `READ_VOLUME`, `WRITE_VOLUME`.
        :param _builtins.str securable_full_name: the full name of UC securable, i.e. `my-catalog.my-schema.my-volume`.
        :param _builtins.str securable_type: the type of UC securable, i.e. `VOLUME`.
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "securable_full_name", securable_full_name)
        pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permissions to grant on UC securable, i.e. `READ_VOLUME`, `WRITE_VOLUME`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="securableFullName")
    def securable_full_name(self) -> _builtins.str:
        """
        the full name of UC securable, i.e. `my-catalog.my-schema.my-volume`.
        """
        return pulumi.get(self, "securable_full_name")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> _builtins.str:
        """
        the type of UC securable, i.e. `VOLUME`.
        """
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class AppsSettingsCustomTemplateManifest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceSpecs":
            suggest = "resource_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsSettingsCustomTemplateManifest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsSettingsCustomTemplateManifest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsSettingsCustomTemplateManifest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 resource_specs: Optional[Sequence['outputs.AppsSettingsCustomTemplateManifestResourceSpec']] = None):
        """
        :param _builtins.str name: The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
               It must be unique within the workspace
        :param _builtins.int version: The manifest schema version, for now only 1 is allowed
        :param _builtins.str description: The description of the template
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_specs is not None:
            pulumi.set(__self__, "resource_specs", resource_specs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
        It must be unique within the workspace
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The manifest schema version, for now only 1 is allowed
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the template
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="resourceSpecs")
    def resource_specs(self) -> Optional[Sequence['outputs.AppsSettingsCustomTemplateManifestResourceSpec']]:
        return pulumi.get(self, "resource_specs")


@pulumi.output_type
class AppsSettingsCustomTemplateManifestResourceSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobSpec":
            suggest = "job_spec"
        elif key == "secretSpec":
            suggest = "secret_spec"
        elif key == "servingEndpointSpec":
            suggest = "serving_endpoint_spec"
        elif key == "sqlWarehouseSpec":
            suggest = "sql_warehouse_spec"
        elif key == "ucSecurableSpec":
            suggest = "uc_securable_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsSettingsCustomTemplateManifestResourceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsSettingsCustomTemplateManifestResourceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsSettingsCustomTemplateManifestResourceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 job_spec: Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecJobSpec'] = None,
                 secret_spec: Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecSecretSpec'] = None,
                 serving_endpoint_spec: Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpec'] = None,
                 sql_warehouse_spec: Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpec'] = None,
                 uc_securable_spec: Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec'] = None):
        """
        :param _builtins.str name: The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
               It must be unique within the workspace
        :param _builtins.str description: The description of the template
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if job_spec is not None:
            pulumi.set(__self__, "job_spec", job_spec)
        if secret_spec is not None:
            pulumi.set(__self__, "secret_spec", secret_spec)
        if serving_endpoint_spec is not None:
            pulumi.set(__self__, "serving_endpoint_spec", serving_endpoint_spec)
        if sql_warehouse_spec is not None:
            pulumi.set(__self__, "sql_warehouse_spec", sql_warehouse_spec)
        if uc_securable_spec is not None:
            pulumi.set(__self__, "uc_securable_spec", uc_securable_spec)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
        It must be unique within the workspace
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the template
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="jobSpec")
    def job_spec(self) -> Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecJobSpec']:
        return pulumi.get(self, "job_spec")

    @_builtins.property
    @pulumi.getter(name="secretSpec")
    def secret_spec(self) -> Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecSecretSpec']:
        return pulumi.get(self, "secret_spec")

    @_builtins.property
    @pulumi.getter(name="servingEndpointSpec")
    def serving_endpoint_spec(self) -> Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpec']:
        return pulumi.get(self, "serving_endpoint_spec")

    @_builtins.property
    @pulumi.getter(name="sqlWarehouseSpec")
    def sql_warehouse_spec(self) -> Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpec']:
        return pulumi.get(self, "sql_warehouse_spec")

    @_builtins.property
    @pulumi.getter(name="ucSecurableSpec")
    def uc_securable_spec(self) -> Optional['outputs.AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec']:
        return pulumi.get(self, "uc_securable_spec")


@pulumi.output_type
class AppsSettingsCustomTemplateManifestResourceSpecJobSpec(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppsSettingsCustomTemplateManifestResourceSpecSecretSpec(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpec(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpec(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")


@pulumi.output_type
class AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securableType":
            suggest = "securable_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission: _builtins.str,
                 securable_type: _builtins.str):
        """
        :param _builtins.str securable_type: Possible values are: `TABLE`, `VOLUME`
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> _builtins.str:
        """
        Possible values are: `TABLE`, `VOLUME`
        """
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class ArtifactAllowlistArtifactMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactAllowlistArtifactMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactAllowlistArtifactMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactAllowlistArtifactMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact: _builtins.str,
                 match_type: _builtins.str):
        """
        :param _builtins.str artifact: The artifact path or maven coordinate.
        :param _builtins.str match_type: The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
        pulumi.set(__self__, "artifact", artifact)
        pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def artifact(self) -> _builtins.str:
        """
        The artifact path or maven coordinate.
        """
        return pulumi.get(self, "artifact")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        The pattern matching type of the artifact. Only `PREFIX_MATCH` is supported.
        """
        return pulumi.get(self, "match_type")


@pulumi.output_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canToggle":
            suggest = "can_toggle"
        elif key == "enablementDetails":
            suggest = "enablement_details"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "restartEvenIfNoUpdatesAvailable":
            suggest = "restart_even_if_no_updates_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 can_toggle: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails'] = None,
                 maintenance_window: Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "enabled", enabled)
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails']:
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow']:
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forcedForComplianceMode":
            suggest = "forced_for_compliance_mode"
        elif key == "unavailableForDisabledEntitlement":
            suggest = "unavailable_for_disabled_entitlement"
        elif key == "unavailableForNonEnterpriseTier":
            suggest = "unavailable_for_non_enterprise_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weekDayBasedSchedule":
            suggest = "week_day_based_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule'] = None):
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule']:
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 frequency: _builtins.str,
                 window_start_time: Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime'] = None):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime']:
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class AutomaticClusterUpdateWorkspaceSettingAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class BudgetAlertConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionConfigurations":
            suggest = "action_configurations"
        elif key == "alertConfigurationId":
            suggest = "alert_configuration_id"
        elif key == "quantityThreshold":
            suggest = "quantity_threshold"
        elif key == "quantityType":
            suggest = "quantity_type"
        elif key == "timePeriod":
            suggest = "time_period"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetAlertConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetAlertConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetAlertConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_configurations: Optional[Sequence['outputs.BudgetAlertConfigurationActionConfiguration']] = None,
                 alert_configuration_id: Optional[_builtins.str] = None,
                 quantity_threshold: Optional[_builtins.str] = None,
                 quantity_type: Optional[_builtins.str] = None,
                 time_period: Optional[_builtins.str] = None,
                 trigger_type: Optional[_builtins.str] = None):
        """
        :param Sequence['BudgetAlertConfigurationActionConfigurationArgs'] action_configurations: List of action configurations to take when the budget alert is triggered. Consists of the following fields:
        :param _builtins.str quantity_threshold: The threshold for the budget alert to determine if it is in a triggered state. The number is evaluated based on `quantity_type`.
        :param _builtins.str quantity_type: The way to calculate cost for this budget alert. This is what quantity_threshold is measured in. (Enum: `LIST_PRICE_DOLLARS_USD`)
        :param _builtins.str time_period: The time window of usage data for the budget. (Enum: `MONTH`)
        :param _builtins.str trigger_type: The evaluation method to determine when this budget alert is in a triggered state. (Enum: `CUMULATIVE_SPENDING_EXCEEDED`)
        """
        if action_configurations is not None:
            pulumi.set(__self__, "action_configurations", action_configurations)
        if alert_configuration_id is not None:
            pulumi.set(__self__, "alert_configuration_id", alert_configuration_id)
        if quantity_threshold is not None:
            pulumi.set(__self__, "quantity_threshold", quantity_threshold)
        if quantity_type is not None:
            pulumi.set(__self__, "quantity_type", quantity_type)
        if time_period is not None:
            pulumi.set(__self__, "time_period", time_period)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @_builtins.property
    @pulumi.getter(name="actionConfigurations")
    def action_configurations(self) -> Optional[Sequence['outputs.BudgetAlertConfigurationActionConfiguration']]:
        """
        List of action configurations to take when the budget alert is triggered. Consists of the following fields:
        """
        return pulumi.get(self, "action_configurations")

    @_builtins.property
    @pulumi.getter(name="alertConfigurationId")
    def alert_configuration_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alert_configuration_id")

    @_builtins.property
    @pulumi.getter(name="quantityThreshold")
    def quantity_threshold(self) -> Optional[_builtins.str]:
        """
        The threshold for the budget alert to determine if it is in a triggered state. The number is evaluated based on `quantity_type`.
        """
        return pulumi.get(self, "quantity_threshold")

    @_builtins.property
    @pulumi.getter(name="quantityType")
    def quantity_type(self) -> Optional[_builtins.str]:
        """
        The way to calculate cost for this budget alert. This is what quantity_threshold is measured in. (Enum: `LIST_PRICE_DOLLARS_USD`)
        """
        return pulumi.get(self, "quantity_type")

    @_builtins.property
    @pulumi.getter(name="timePeriod")
    def time_period(self) -> Optional[_builtins.str]:
        """
        The time window of usage data for the budget. (Enum: `MONTH`)
        """
        return pulumi.get(self, "time_period")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[_builtins.str]:
        """
        The evaluation method to determine when this budget alert is in a triggered state. (Enum: `CUMULATIVE_SPENDING_EXCEEDED`)
        """
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class BudgetAlertConfigurationActionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionConfigurationId":
            suggest = "action_configuration_id"
        elif key == "actionType":
            suggest = "action_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetAlertConfigurationActionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetAlertConfigurationActionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetAlertConfigurationActionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_configuration_id: Optional[_builtins.str] = None,
                 action_type: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None):
        """
        :param _builtins.str action_type: The type of action to take when the budget alert is triggered. (Enum: `EMAIL_NOTIFICATION`)
        :param _builtins.str target: The target of the action. For `EMAIL_NOTIFICATION`, this is the email address to send the notification to.
        """
        if action_configuration_id is not None:
            pulumi.set(__self__, "action_configuration_id", action_configuration_id)
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="actionConfigurationId")
    def action_configuration_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "action_configuration_id")

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[_builtins.str]:
        """
        The type of action to take when the budget alert is triggered. (Enum: `EMAIL_NOTIFICATION`)
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The target of the action. For `EMAIL_NOTIFICATION`, this is the email address to send the notification to.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class BudgetFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BudgetFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BudgetFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BudgetFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tags: Optional[Sequence['outputs.BudgetFilterTag']] = None,
                 workspace_id: Optional['outputs.BudgetFilterWorkspaceId'] = None):
        """
        :param Sequence['BudgetFilterTagArgs'] tags: List of tags to filter by. Consists of the following fields:
        :param 'BudgetFilterWorkspaceIdArgs' workspace_id: Filter by workspace ID (if empty, include usage all usage for this account). Consists of the following fields:
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.BudgetFilterTag']]:
        """
        List of tags to filter by. Consists of the following fields:
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional['outputs.BudgetFilterWorkspaceId']:
        """
        Filter by workspace ID (if empty, include usage all usage for this account). Consists of the following fields:
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class BudgetFilterTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional['outputs.BudgetFilterTagValue'] = None):
        """
        :param _builtins.str key: The key of the tag.
        :param 'BudgetFilterTagValueArgs' value: Consists of the following fields:
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key of the tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.BudgetFilterTagValue']:
        """
        Consists of the following fields:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BudgetFilterTagValue(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str operator: The operator to use for the filter. (Enum: `IN`)
        :param Sequence[_builtins.str] values: The values to filter by.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The operator to use for the filter. (Enum: `IN`)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The values to filter by.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetFilterWorkspaceId(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.str operator: The operator to use for the filter. (Enum: `IN`)
        :param Sequence[_builtins.int] values: The values to filter by.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The operator to use for the filter. (Enum: `IN`)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.int]]:
        """
        The values to filter by.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class BudgetPolicyCustomTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the tag.
               - Must be unique among all custom tags of the same policy
               - Cannot be budget-policy-name, budget-policy-id or "budget-policy-resolution-result" -
               these tags are preserved
        :param _builtins.str value: The value of the tag
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the tag.
        - Must be unique among all custom tags of the same policy
        - Cannot be budget-policy-name, budget-policy-id or "budget-policy-resolution-result" -
        these tags are preserved
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CatalogEffectivePredictiveOptimizationFlag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inheritedFromName":
            suggest = "inherited_from_name"
        elif key == "inheritedFromType":
            suggest = "inherited_from_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogEffectivePredictiveOptimizationFlag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogEffectivePredictiveOptimizationFlag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogEffectivePredictiveOptimizationFlag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: _builtins.str,
                 inherited_from_name: Optional[_builtins.str] = None,
                 inherited_from_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_name")

    @_builtins.property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_type")


@pulumi.output_type
class CatalogProvisioningInfo(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class ClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_workers: The maximum number of workers to which the cluster can scale up when overloaded. max_workers must be strictly greater than min_workers.
               
               To create a [single node cluster](https://docs.databricks.com/clusters/single-node.html), set `is_single_node = true` and `kind = "CLASSIC_PREVIEW"` for the cluster. Single-node clusters are suitable for small, non-distributed workloads like single-node machine learning use-cases.
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               smallest = databricks.get_node_type(local_disk=True)
               latest_lts = databricks.get_spark_version(long_term_support=True)
               single_node = databricks.Cluster("single_node",
                   cluster_name="Single Node",
                   spark_version=latest_lts.id,
                   node_type_id=smallest.id,
                   autotermination_minutes=20,
                   is_single_node=True,
                   kind="CLASSIC_PREVIEW")
               ```
        :param _builtins.int min_workers: The minimum number of workers to which the cluster can scale down when underutilized. It is also the initial number of workers the cluster will have after creation.
        """
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        """
        The maximum number of workers to which the cluster can scale up when overloaded. max_workers must be strictly greater than min_workers.

        To create a [single node cluster](https://docs.databricks.com/clusters/single-node.html), set `is_single_node = true` and `kind = "CLASSIC_PREVIEW"` for the cluster. Single-node clusters are suitable for small, non-distributed workloads like single-node machine learning use-cases.

        ```python
        import pulumi
        import pulumi_databricks as databricks

        smallest = databricks.get_node_type(local_disk=True)
        latest_lts = databricks.get_spark_version(long_term_support=True)
        single_node = databricks.Cluster("single_node",
            cluster_name="Single Node",
            spark_version=latest_lts.id,
            node_type_id=smallest.id,
            autotermination_minutes=20,
            is_single_node=True,
            kind="CLASSIC_PREVIEW")
        ```
        """
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        """
        The minimum number of workers to which the cluster can scale down when underutilized. It is also the initial number of workers the cluster will have after creation.
        """
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class ClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeIops":
            suggest = "ebs_volume_iops"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeThroughput":
            suggest = "ebs_volume_throughput"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability: Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT`, `SPOT_WITH_FALLBACK` and `ON_DEMAND`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster. Backend default value is `SPOT_WITH_FALLBACK` and could change in the future
        :param _builtins.int ebs_volume_count: The number of volumes launched for each instance. You can choose up to 10 volumes. This feature is only enabled for supported node types. Legacy node types cannot specify custom EBS volumes. For node types with no instance store, at least one EBS volume needs to be specified; otherwise, cluster creation will fail. These EBS volumes will be mounted at /ebs0, /ebs1, and etc. Instance store volumes will be mounted at /local_disk0, /local_disk1, and etc. If EBS volumes are attached, Databricks will configure Spark to use only the EBS volumes for scratch storage because heterogeneously sized scratch devices can lead to inefficient disk utilization. If no EBS volumes are attached, Databricks will configure Spark to use instance store volumes. If EBS volumes are specified, then the Spark configuration spark.local.dir will be overridden.
        :param _builtins.int ebs_volume_size: The size of each EBS volume (in GiB) launched for each instance. For general purpose SSD, this value must be within the range 100 - 4096. For throughput optimized HDD, this value must be within the range 500 - 4096. Custom EBS volumes cannot be specified for the legacy node types (memory-optimized and compute-optimized).
        :param _builtins.str ebs_volume_type: The type of EBS volumes that will be launched with this cluster. Valid values are `GENERAL_PURPOSE_SSD` or `THROUGHPUT_OPTIMIZED_HDD`. Use this option only if you're not picking *Delta Optimized `i3.*`* node types.
        :param _builtins.int first_on_demand: The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster. If unspecified, the default value is 0.
        :param _builtins.str instance_profile_arn: Nodes for this cluster will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        :param _builtins.int spot_bid_price_percent: The max price for AWS spot instances, as a percentage of the corresponding instance types on-demand price. For example, if this field is set to 50, and the cluster needs a new `i3.xlarge` spot instance, then the max price is half of the price of on-demand `i3.xlarge` instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand `i3.xlarge` instances. If not specified, the default value is `100`. When spot instances are requested for this cluster, only spot instances whose max price percentage matches this field will be considered. For safety, we enforce this field to be no more than `10000`.
        :param _builtins.str zone_id: Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-west-2a`. The provided availability zone must be in the same region as the Databricks deployment. For example, `us-west-2a` is not a valid zone ID if the Databricks deployment resides in the `us-east-1` region. Enable automatic availability zone selection ("Auto-AZ"), by setting the value `auto`. Databricks selects the AZ based on available IPs in the workspace subnets and retries in other availability zones if AWS returns insufficient capacity errors.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT`, `SPOT_WITH_FALLBACK` and `ON_DEMAND`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster. Backend default value is `SPOT_WITH_FALLBACK` and could change in the future
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        """
        The number of volumes launched for each instance. You can choose up to 10 volumes. This feature is only enabled for supported node types. Legacy node types cannot specify custom EBS volumes. For node types with no instance store, at least one EBS volume needs to be specified; otherwise, cluster creation will fail. These EBS volumes will be mounted at /ebs0, /ebs1, and etc. Instance store volumes will be mounted at /local_disk0, /local_disk1, and etc. If EBS volumes are attached, Databricks will configure Spark to use only the EBS volumes for scratch storage because heterogeneously sized scratch devices can lead to inefficient disk utilization. If no EBS volumes are attached, Databricks will configure Spark to use instance store volumes. If EBS volumes are specified, then the Spark configuration spark.local.dir will be overridden.
        """
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        """
        The size of each EBS volume (in GiB) launched for each instance. For general purpose SSD, this value must be within the range 100 - 4096. For throughput optimized HDD, this value must be within the range 500 - 4096. Custom EBS volumes cannot be specified for the legacy node types (memory-optimized and compute-optimized).
        """
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        """
        The type of EBS volumes that will be launched with this cluster. Valid values are `GENERAL_PURPOSE_SSD` or `THROUGHPUT_OPTIMIZED_HDD`. Use this option only if you're not picking *Delta Optimized `i3.*`* node types.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster. If unspecified, the default value is 0.
        """
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        """
        Nodes for this cluster will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        """
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        """
        The max price for AWS spot instances, as a percentage of the corresponding instance types on-demand price. For example, if this field is set to 50, and the cluster needs a new `i3.xlarge` spot instance, then the max price is half of the price of on-demand `i3.xlarge` instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand `i3.xlarge` instances. If not specified, the default value is `100`. When spot instances are requested for this cluster, only spot instances whose max price percentage matches this field will be considered. For safety, we enforce this field to be no more than `10000`.
        """
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-west-2a`. The provided availability zone must be in the same region as the Databricks deployment. For example, `us-west-2a` is not a valid zone ID if the Databricks deployment resides in the `us-east-1` region. Enable automatic availability zone selection ("Auto-AZ"), by setting the value `auto`. Databricks selects the AZ based on available IPs in the workspace subnets and retries in other availability zones if AWS returns insufficient capacity errors.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "logAnalyticsInfo":
            suggest = "log_analytics_info"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.ClusterAzureAttributesLogAnalyticsInfo'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability: Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT_AZURE`, `SPOT_WITH_FALLBACK_AZURE`, and `ON_DEMAND_AZURE`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster.
        :param _builtins.int first_on_demand: The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        :param _builtins.float spot_bid_max_price: The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        Availability type used for all subsequent nodes past the `first_on_demand` ones. Valid values are `SPOT_AZURE`, `SPOT_WITH_FALLBACK_AZURE`, and `ON_DEMAND_AZURE`. Note: If `first_on_demand` is zero, this availability type will be used for the entire cluster.
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        """
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.ClusterAzureAttributesLogAnalyticsInfo']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        """
        The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class ClusterAzureAttributesLogAnalyticsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsPrimaryKey":
            suggest = "log_analytics_primary_key"
        elif key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAzureAttributesLogAnalyticsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class ClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.ClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.ClusterClusterLogConfS3'] = None,
                 volumes: Optional['outputs.ClusterClusterLogConfVolumes'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.ClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.ClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.ClusterClusterLogConfVolumes']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class ClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        :param _builtins.str canned_acl: Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        :param _builtins.bool enable_encryption: Enable server-side encryption, false by default.
        :param _builtins.str encryption_type: The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        :param _builtins.str endpoint: S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        :param _builtins.str kms_key: KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        :param _builtins.str region: S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        """
        Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        """
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        """
        Enable server-side encryption, false by default.
        """
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        """
        The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        """
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterClusterLogConfVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterClusterMountInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountDirPath":
            suggest = "local_mount_dir_path"
        elif key == "networkFilesystemInfo":
            suggest = "network_filesystem_info"
        elif key == "remoteMountDirPath":
            suggest = "remote_mount_dir_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterMountInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterMountInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterMountInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.ClusterClusterMountInfoNetworkFilesystemInfo',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str local_mount_dir_path: path inside the Spark container.
               
               For example, you can mount Azure Data Lake Storage container using the following code:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               storage_account = "ewfw3ggwegwg"
               storage_container = "test"
               with_nfs = databricks.Cluster("with_nfs", cluster_mount_infos=[{
                   "network_filesystem_info": {
                       "server_address": f"{storage_account}.blob.core.windows.net",
                       "mount_options": "sec=sys,vers=3,nolock,proto=tcp",
                   },
                   "remote_mount_dir_path": f"{storage_account}/{storage_container}",
                   "local_mount_dir_path": "/mnt/nfs-test",
               }])
               ```
        :param 'ClusterClusterMountInfoNetworkFilesystemInfoArgs' network_filesystem_info: block specifying connection. It consists of:
        :param _builtins.str remote_mount_dir_path: string specifying path to mount on the remote service.
        """
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        """
        path inside the Spark container.

        For example, you can mount Azure Data Lake Storage container using the following code:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        storage_account = "ewfw3ggwegwg"
        storage_container = "test"
        with_nfs = databricks.Cluster("with_nfs", cluster_mount_infos=[{
            "network_filesystem_info": {
                "server_address": f"{storage_account}.blob.core.windows.net",
                "mount_options": "sec=sys,vers=3,nolock,proto=tcp",
            },
            "remote_mount_dir_path": f"{storage_account}/{storage_container}",
            "local_mount_dir_path": "/mnt/nfs-test",
        }])
        ```
        """
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.ClusterClusterMountInfoNetworkFilesystemInfo':
        """
        block specifying connection. It consists of:
        """
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        """
        string specifying path to mount on the remote service.
        """
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class ClusterClusterMountInfoNetworkFilesystemInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterMountInfoNetworkFilesystemInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        """
        :param _builtins.str server_address: host name.
        :param _builtins.str mount_options: string that will be passed as options passed to the `mount` command.
        """
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        """
        host name.
        """
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        """
        string that will be passed as options passed to the `mount` command.
        """
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class ClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.ClusterDockerImageBasicAuth'] = None):
        """
        :param _builtins.str url: URL for the Docker image
        :param 'ClusterDockerImageBasicAuthArgs' basic_auth: `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch.  For better security, these credentials should be stored in the secret scope and referred using secret path syntax: `{{secrets/scope/key}}`, otherwise other users of the workspace may access them via UI/API.
               
               Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL for the Docker image
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.ClusterDockerImageBasicAuth']:
        """
        `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch.  For better security, these credentials should be stored in the secret scope and referred using secret path syntax: `{{secrets/scope/key}}`, otherwise other users of the workspace may access them via UI/API.

        Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:
        """
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class ClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class ClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param _builtins.int boot_disk_size: Boot disk size in GB
        :param _builtins.int first_on_demand: The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        :param _builtins.str google_service_account: Google Service Account email address that the cluster uses to authenticate with Google Identity. This field is used for authentication with the GCS and BigQuery data sources.
        :param _builtins.int local_ssd_count: Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        :param _builtins.bool use_preemptible_executors: if we should use preemptible executors ([GCP documentation](https://cloud.google.com/compute/docs/instances/preemptible)). *Warning: this field is deprecated in favor of `availability`, and will be removed soon.*
        :param _builtins.str zone_id: Identifier for the availability zone in which the cluster resides. This can be one of the following:
               * `HA` (default): High availability, spread nodes across availability zones for a Databricks deployment region.
               * `AUTO`: Databricks picks an availability zone to schedule the cluster on.
               * name of a GCP availability zone: pick one of the available zones from the [list of available availability zones](https://cloud.google.com/compute/docs/regions-zones#available).
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        """
        Boot disk size in GB
        """
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        """
        The first `first_on_demand` nodes of the cluster will be placed on on-demand instances. If this value is greater than 0, the cluster driver node will be placed on an on-demand instance. If this value is greater than or equal to the current cluster size, all nodes will be placed on on-demand instances. If this value is less than the current cluster size, `first_on_demand` nodes will be placed on on-demand instances, and the remainder will be placed on availability instances. This value does not affect cluster size and cannot be mutated over the lifetime of a cluster.
        """
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        """
        Google Service Account email address that the cluster uses to authenticate with Google Identity. This field is used for authentication with the GCS and BigQuery data sources.
        """
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        """
        if we should use preemptible executors ([GCP documentation](https://cloud.google.com/compute/docs/instances/preemptible)). *Warning: this field is deprecated in favor of `availability`, and will be removed soon.*
        """
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Identifier for the availability zone in which the cluster resides. This can be one of the following:
        * `HA` (default): High availability, spread nodes across availability zones for a Databricks deployment region.
        * `AUTO`: Databricks picks an availability zone to schedule the cluster on.
        * name of a GCP availability zone: pick one of the available zones from the [list of available availability zones](https://cloud.google.com/compute/docs/regions-zones#available).
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class ClusterInitScript(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.ClusterInitScriptAbfss'] = None,
                 dbfs: Optional['outputs.ClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.ClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.ClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.ClusterInitScriptS3'] = None,
                 volumes: Optional['outputs.ClusterInitScriptVolumes'] = None,
                 workspace: Optional['outputs.ClusterInitScriptWorkspace'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.ClusterInitScriptAbfss']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.ClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.ClusterInitScriptFile']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.ClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.ClusterInitScriptS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.ClusterInitScriptVolumes']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.ClusterInitScriptWorkspace']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class ClusterInitScriptAbfss(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        :param _builtins.str canned_acl: Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        :param _builtins.bool enable_encryption: Enable server-side encryption, false by default.
        :param _builtins.str encryption_type: The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        :param _builtins.str endpoint: S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        :param _builtins.str kms_key: KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        :param _builtins.str region: S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        """
        Set canned access control list, e.g. `bucket-owner-full-control`. If `canned_cal` is set, the cluster instance profile must have `s3:PutObjectAcl` permission on the destination bucket and prefix. The full list of possible canned ACLs can be found [here](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl). By default, only the object owner gets full control. If you are using a cross-account role for writing data, you may want to set `bucket-owner-full-control` to make bucket owners able to read the logs.
        """
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        """
        Enable server-side encryption, false by default.
        """
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        """
        The encryption type, it could be `sse-s3` or `sse-kms`. It is used only when encryption is enabled, and the default type is `sse-s3`.
        """
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        S3 endpoint, e.g. <https://s3-us-west-2.amazonaws.com>. Either `region` or `endpoint` needs to be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        KMS key used if encryption is enabled and encryption type is set to `sse-kms`.
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        S3 region, e.g. `us-west-2`. Either `region` or `endpoint` must be set. If both are set, the endpoint is used.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterInitScriptVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterInitScriptWorkspace(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        """
        :param _builtins.str destination: S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        S3 destination, e.g., `s3://my-bucket/some-prefix` You must configure the cluster with an instance profile, and the instance profile must have write access to the destination. You cannot use AWS keys.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ClusterLibrary(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.ClusterLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.ClusterLibraryMaven'] = None,
                 pypi: Optional['outputs.ClusterLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.ClusterLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.ClusterLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.ClusterLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class ClusterLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterPolicyLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPolicyLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPolicyLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPolicyLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.ClusterPolicyLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.ClusterPolicyLibraryMaven'] = None,
                 provider_config: Optional['outputs.ClusterPolicyLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.ClusterPolicyLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.ClusterPolicyLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.ClusterPolicyLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.ClusterPolicyLibraryProviderConfig']:
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.ClusterPolicyLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class ClusterPolicyLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterPolicyLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterPolicyLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPolicyLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPolicyLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPolicyLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class ClusterPolicyLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class ClusterProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
               
               The following example demonstrates how to create an autoscaling cluster with [Delta Cache](https://docs.databricks.com/delta/optimizations/delta-cache.html) enabled:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               smallest = databricks.get_node_type(local_disk=True)
               latest_lts = databricks.get_spark_version(long_term_support=True)
               shared_autoscaling = databricks.Cluster("shared_autoscaling",
                   cluster_name="Shared Autoscaling",
                   spark_version=latest_lts.id,
                   node_type_id=smallest.id,
                   autotermination_minutes=20,
                   autoscale={
                       "min_workers": 1,
                       "max_workers": 50,
                   },
                   spark_conf={
                       "spark.databricks.io.cache.enabled": "true",
                       "spark.databricks.io.cache.maxDiskUsage": "50g",
                       "spark.databricks.io.cache.maxMetaDataCache": "1g",
                   })
               ```
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.

        The following example demonstrates how to create an autoscaling cluster with [Delta Cache](https://docs.databricks.com/delta/optimizations/delta-cache.html) enabled:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        smallest = databricks.get_node_type(local_disk=True)
        latest_lts = databricks.get_spark_version(long_term_support=True)
        shared_autoscaling = databricks.Cluster("shared_autoscaling",
            cluster_name="Shared Autoscaling",
            spark_version=latest_lts.id,
            node_type_id=smallest.id,
            autotermination_minutes=20,
            autoscale={
                "min_workers": 1,
                "max_workers": 50,
            },
            spark_conf={
                "spark.databricks.io.cache.enabled": "true",
                "spark.databricks.io.cache.maxDiskUsage": "50g",
                "spark.databricks.io.cache.maxMetaDataCache": "1g",
            })
        ```
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class ClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.ClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.ClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class ClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool jobs: boolean flag defining if it's possible to run Databricks Jobs on this cluster. Default: `true`.
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               with_nfs = databricks.Cluster("with_nfs", workload_type={
                   "clients": {
                       "jobs": False,
                       "notebooks": True,
                   },
               })
               ```
        :param _builtins.bool notebooks: boolean flag defining if it's possible to run notebooks on this cluster. Default: `true`.
        """
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        """
        boolean flag defining if it's possible to run Databricks Jobs on this cluster. Default: `true`.

        ```python
        import pulumi
        import pulumi_databricks as databricks

        with_nfs = databricks.Cluster("with_nfs", workload_type={
            "clients": {
                "jobs": False,
                "notebooks": True,
            },
        })
        ```
        """
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        """
        boolean flag defining if it's possible to run notebooks on this cluster. Default: `true`.
        """
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complianceStandards":
            suggest = "compliance_standards"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComplianceSecurityProfileWorkspaceSettingComplianceSecurityProfileWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compliance_standards: Sequence[_builtins.str],
                 is_enabled: _builtins.bool):
        pulumi.set(__self__, "compliance_standards", compliance_standards)
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="complianceStandards")
    def compliance_standards(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "compliance_standards")

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class ConnectionProvisioningInfo(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class CredentialAwsIamRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "unityCatalogIamArn":
            suggest = "unity_catalog_iam_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialAwsIamRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialAwsIamRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialAwsIamRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_id: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 unity_catalog_iam_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str role_arn: The Amazon Resource Name (ARN) of the AWS IAM role you want to use to setup the trust policy, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
               
               `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over `azure_service_principal`):
        """
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role you want to use to setup the trust policy, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`

        `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over `azure_service_principal`):
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unity_catalog_iam_arn")


@pulumi.output_type
class CredentialAzureManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConnectorId":
            suggest = "access_connector_id"
        elif key == "credentialId":
            suggest = "credential_id"
        elif key == "managedIdentityId":
            suggest = "managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialAzureManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialAzureManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialAzureManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_connector_id: _builtins.str,
                 credential_id: Optional[_builtins.str] = None,
                 managed_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param _builtins.str credential_id: Unique ID of the credential.
        :param _builtins.str managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
               
               `azure_service_principal` optional configuration block to use service principal as credential details for Azure. Only applicable when purpose is `STORAGE` (Legacy):
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @_builtins.property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> _builtins.str:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        """
        Unique ID of the credential.
        """
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[_builtins.str]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.

        `azure_service_principal` optional configuration block to use service principal as credential details for Azure. Only applicable when purpose is `STORAGE` (Legacy):
        """
        return pulumi.get(self, "managed_identity_id")


@pulumi.output_type
class CredentialAzureServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialAzureServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialAzureServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialAzureServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: _builtins.str,
                 client_secret: _builtins.str,
                 directory_id: _builtins.str):
        """
        :param _builtins.str application_id: The application ID of the application registration within the referenced AAD tenant
        :param _builtins.str client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
               
               `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        :param _builtins.str directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**

        `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> _builtins.str:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class CredentialDatabricksGcpServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialId":
            suggest = "credential_id"
        elif key == "privateKeyId":
            suggest = "private_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CredentialDatabricksGcpServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CredentialDatabricksGcpServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CredentialDatabricksGcpServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_id: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None,
                 private_key_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str credential_id: Unique ID of the credential.
        :param _builtins.str email: The email of the GCP service account created, to be granted access to relevant buckets.
        """
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        """
        Unique ID of the credential.
        """
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_key_id")


@pulumi.output_type
class CustomAppIntegrationTokenAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absoluteSessionLifetimeInMinutes":
            suggest = "absolute_session_lifetime_in_minutes"
        elif key == "accessTokenTtlInMinutes":
            suggest = "access_token_ttl_in_minutes"
        elif key == "enableSingleUseRefreshTokens":
            suggest = "enable_single_use_refresh_tokens"
        elif key == "refreshTokenTtlInMinutes":
            suggest = "refresh_token_ttl_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomAppIntegrationTokenAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomAppIntegrationTokenAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomAppIntegrationTokenAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absolute_session_lifetime_in_minutes: Optional[_builtins.int] = None,
                 access_token_ttl_in_minutes: Optional[_builtins.int] = None,
                 enable_single_use_refresh_tokens: Optional[_builtins.bool] = None,
                 refresh_token_ttl_in_minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int access_token_ttl_in_minutes: access token time to live (TTL) in minutes.
        :param _builtins.int refresh_token_ttl_in_minutes: refresh token TTL in minutes. The TTL of refresh token cannot be lower than TTL of access token.
        """
        if absolute_session_lifetime_in_minutes is not None:
            pulumi.set(__self__, "absolute_session_lifetime_in_minutes", absolute_session_lifetime_in_minutes)
        if access_token_ttl_in_minutes is not None:
            pulumi.set(__self__, "access_token_ttl_in_minutes", access_token_ttl_in_minutes)
        if enable_single_use_refresh_tokens is not None:
            pulumi.set(__self__, "enable_single_use_refresh_tokens", enable_single_use_refresh_tokens)
        if refresh_token_ttl_in_minutes is not None:
            pulumi.set(__self__, "refresh_token_ttl_in_minutes", refresh_token_ttl_in_minutes)

    @_builtins.property
    @pulumi.getter(name="absoluteSessionLifetimeInMinutes")
    def absolute_session_lifetime_in_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "absolute_session_lifetime_in_minutes")

    @_builtins.property
    @pulumi.getter(name="accessTokenTtlInMinutes")
    def access_token_ttl_in_minutes(self) -> Optional[_builtins.int]:
        """
        access token time to live (TTL) in minutes.
        """
        return pulumi.get(self, "access_token_ttl_in_minutes")

    @_builtins.property
    @pulumi.getter(name="enableSingleUseRefreshTokens")
    def enable_single_use_refresh_tokens(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_single_use_refresh_tokens")

    @_builtins.property
    @pulumi.getter(name="refreshTokenTtlInMinutes")
    def refresh_token_ttl_in_minutes(self) -> Optional[_builtins.int]:
        """
        refresh token TTL in minutes. The TTL of refresh token cannot be lower than TTL of access token.
        """
        return pulumi.get(self, "refresh_token_ttl_in_minutes")


@pulumi.output_type
class DataQualityMonitorAnomalyDetectionConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DataQualityMonitorDataProfilingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputSchemaId":
            suggest = "output_schema_id"
        elif key == "assetsDir":
            suggest = "assets_dir"
        elif key == "baselineTableName":
            suggest = "baseline_table_name"
        elif key == "customMetrics":
            suggest = "custom_metrics"
        elif key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "driftMetricsTableName":
            suggest = "drift_metrics_table_name"
        elif key == "effectiveWarehouseId":
            suggest = "effective_warehouse_id"
        elif key == "inferenceLog":
            suggest = "inference_log"
        elif key == "latestMonitorFailureMessage":
            suggest = "latest_monitor_failure_message"
        elif key == "monitorVersion":
            suggest = "monitor_version"
        elif key == "monitoredTableName":
            suggest = "monitored_table_name"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "profileMetricsTableName":
            suggest = "profile_metrics_table_name"
        elif key == "skipBuiltinDashboard":
            suggest = "skip_builtin_dashboard"
        elif key == "slicingExprs":
            suggest = "slicing_exprs"
        elif key == "timeSeries":
            suggest = "time_series"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_schema_id: _builtins.str,
                 assets_dir: Optional[_builtins.str] = None,
                 baseline_table_name: Optional[_builtins.str] = None,
                 custom_metrics: Optional[Sequence['outputs.DataQualityMonitorDataProfilingConfigCustomMetric']] = None,
                 dashboard_id: Optional[_builtins.str] = None,
                 drift_metrics_table_name: Optional[_builtins.str] = None,
                 effective_warehouse_id: Optional[_builtins.str] = None,
                 inference_log: Optional['outputs.DataQualityMonitorDataProfilingConfigInferenceLog'] = None,
                 latest_monitor_failure_message: Optional[_builtins.str] = None,
                 monitor_version: Optional[_builtins.int] = None,
                 monitored_table_name: Optional[_builtins.str] = None,
                 notification_settings: Optional['outputs.DataQualityMonitorDataProfilingConfigNotificationSettings'] = None,
                 profile_metrics_table_name: Optional[_builtins.str] = None,
                 schedule: Optional['outputs.DataQualityMonitorDataProfilingConfigSchedule'] = None,
                 skip_builtin_dashboard: Optional[_builtins.bool] = None,
                 slicing_exprs: Optional[Sequence[_builtins.str]] = None,
                 snapshot: Optional['outputs.DataQualityMonitorDataProfilingConfigSnapshot'] = None,
                 status: Optional[_builtins.str] = None,
                 time_series: Optional['outputs.DataQualityMonitorDataProfilingConfigTimeSeries'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str output_schema_id: ID of the schema where output tables are created
        :param _builtins.str assets_dir: Field for specifying the absolute path to a custom directory to store data-monitoring
               assets. Normally prepopulated to a default user location via UI and Python APIs
        :param _builtins.str baseline_table_name: Baseline table name.
               Baseline data is used to compute drift from the data in the monitored `table_name`.
               The baseline table and the monitored table shall have the same schema
        :param Sequence['DataQualityMonitorDataProfilingConfigCustomMetricArgs'] custom_metrics: Custom metrics
        :param 'DataQualityMonitorDataProfilingConfigInferenceLogArgs' inference_log: `Analysis Configuration` for monitoring inference log tables
        :param 'DataQualityMonitorDataProfilingConfigNotificationSettingsArgs' notification_settings: Field for specifying notification settings
        :param 'DataQualityMonitorDataProfilingConfigScheduleArgs' schedule: The cron schedule
        :param _builtins.bool skip_builtin_dashboard: Whether to skip creating a default dashboard summarizing data quality metrics
        :param Sequence[_builtins.str] slicing_exprs: List of column expressions to slice data with for targeted analysis. The data is grouped by
               each expression independently, resulting in a separate slice for each predicate and its
               complements. For example `slicing_exprs=[col_1, col_2 > 10]` will generate the following
               slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in
               `col1`. For high-cardinality columns, only the top 100 unique values by frequency will
               generate slices
        :param 'DataQualityMonitorDataProfilingConfigSnapshotArgs' snapshot: `Analysis Configuration` for monitoring snapshot tables
        :param 'DataQualityMonitorDataProfilingConfigTimeSeriesArgs' time_series: `Analysis Configuration` for monitoring time series tables
        :param _builtins.str warehouse_id: Optional argument to specify the warehouse for dashboard creation. If not specified, the first running
               warehouse will be used
        """
        pulumi.set(__self__, "output_schema_id", output_schema_id)
        if assets_dir is not None:
            pulumi.set(__self__, "assets_dir", assets_dir)
        if baseline_table_name is not None:
            pulumi.set(__self__, "baseline_table_name", baseline_table_name)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if dashboard_id is not None:
            pulumi.set(__self__, "dashboard_id", dashboard_id)
        if drift_metrics_table_name is not None:
            pulumi.set(__self__, "drift_metrics_table_name", drift_metrics_table_name)
        if effective_warehouse_id is not None:
            pulumi.set(__self__, "effective_warehouse_id", effective_warehouse_id)
        if inference_log is not None:
            pulumi.set(__self__, "inference_log", inference_log)
        if latest_monitor_failure_message is not None:
            pulumi.set(__self__, "latest_monitor_failure_message", latest_monitor_failure_message)
        if monitor_version is not None:
            pulumi.set(__self__, "monitor_version", monitor_version)
        if monitored_table_name is not None:
            pulumi.set(__self__, "monitored_table_name", monitored_table_name)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if profile_metrics_table_name is not None:
            pulumi.set(__self__, "profile_metrics_table_name", profile_metrics_table_name)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if skip_builtin_dashboard is not None:
            pulumi.set(__self__, "skip_builtin_dashboard", skip_builtin_dashboard)
        if slicing_exprs is not None:
            pulumi.set(__self__, "slicing_exprs", slicing_exprs)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if time_series is not None:
            pulumi.set(__self__, "time_series", time_series)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="outputSchemaId")
    def output_schema_id(self) -> _builtins.str:
        """
        ID of the schema where output tables are created
        """
        return pulumi.get(self, "output_schema_id")

    @_builtins.property
    @pulumi.getter(name="assetsDir")
    def assets_dir(self) -> Optional[_builtins.str]:
        """
        Field for specifying the absolute path to a custom directory to store data-monitoring
        assets. Normally prepopulated to a default user location via UI and Python APIs
        """
        return pulumi.get(self, "assets_dir")

    @_builtins.property
    @pulumi.getter(name="baselineTableName")
    def baseline_table_name(self) -> Optional[_builtins.str]:
        """
        Baseline table name.
        Baseline data is used to compute drift from the data in the monitored `table_name`.
        The baseline table and the monitored table shall have the same schema
        """
        return pulumi.get(self, "baseline_table_name")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[Sequence['outputs.DataQualityMonitorDataProfilingConfigCustomMetric']]:
        """
        Custom metrics
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="driftMetricsTableName")
    def drift_metrics_table_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "drift_metrics_table_name")

    @_builtins.property
    @pulumi.getter(name="effectiveWarehouseId")
    def effective_warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effective_warehouse_id")

    @_builtins.property
    @pulumi.getter(name="inferenceLog")
    def inference_log(self) -> Optional['outputs.DataQualityMonitorDataProfilingConfigInferenceLog']:
        """
        `Analysis Configuration` for monitoring inference log tables
        """
        return pulumi.get(self, "inference_log")

    @_builtins.property
    @pulumi.getter(name="latestMonitorFailureMessage")
    def latest_monitor_failure_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "latest_monitor_failure_message")

    @_builtins.property
    @pulumi.getter(name="monitorVersion")
    def monitor_version(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "monitor_version")

    @_builtins.property
    @pulumi.getter(name="monitoredTableName")
    def monitored_table_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitored_table_name")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.DataQualityMonitorDataProfilingConfigNotificationSettings']:
        """
        Field for specifying notification settings
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="profileMetricsTableName")
    def profile_metrics_table_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profile_metrics_table_name")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.DataQualityMonitorDataProfilingConfigSchedule']:
        """
        The cron schedule
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="skipBuiltinDashboard")
    def skip_builtin_dashboard(self) -> Optional[_builtins.bool]:
        """
        Whether to skip creating a default dashboard summarizing data quality metrics
        """
        return pulumi.get(self, "skip_builtin_dashboard")

    @_builtins.property
    @pulumi.getter(name="slicingExprs")
    def slicing_exprs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of column expressions to slice data with for targeted analysis. The data is grouped by
        each expression independently, resulting in a separate slice for each predicate and its
        complements. For example `slicing_exprs=[col_1, col_2 > 10]` will generate the following
        slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in
        `col1`. For high-cardinality columns, only the top 100 unique values by frequency will
        generate slices
        """
        return pulumi.get(self, "slicing_exprs")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.DataQualityMonitorDataProfilingConfigSnapshot']:
        """
        `Analysis Configuration` for monitoring snapshot tables
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> Optional['outputs.DataQualityMonitorDataProfilingConfigTimeSeries']:
        """
        `Analysis Configuration` for monitoring time series tables
        """
        return pulumi.get(self, "time_series")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        Optional argument to specify the warehouse for dashboard creation. If not specified, the first running
        warehouse will be used
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputColumns":
            suggest = "input_columns"
        elif key == "outputDataType":
            suggest = "output_data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfigCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfigCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfigCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: _builtins.str,
                 input_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 output_data_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str definition: Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param Sequence[_builtins.str] input_columns: A list of column names in the input table the metric should be computed for.
               Can use ``":table"`` to indicate that the metric needs information from multiple columns
        :param _builtins.str name: Name of the metric in the output tables
        :param _builtins.str output_data_type: The output type of the custom metric
        :param _builtins.str type: The type of the custom metric. Possible values are: `DATA_PROFILING_CUSTOM_METRIC_TYPE_AGGREGATE`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DERIVED`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DRIFT`
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence[_builtins.str]:
        """
        A list of column names in the input table the metric should be computed for.
        Can use ``":table"`` to indicate that the metric needs information from multiple columns
        """
        return pulumi.get(self, "input_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the metric in the output tables
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> _builtins.str:
        """
        The output type of the custom metric
        """
        return pulumi.get(self, "output_data_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the custom metric. Possible values are: `DATA_PROFILING_CUSTOM_METRIC_TYPE_AGGREGATE`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DERIVED`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DRIFT`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigInferenceLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelIdColumn":
            suggest = "model_id_column"
        elif key == "predictionColumn":
            suggest = "prediction_column"
        elif key == "problemType":
            suggest = "problem_type"
        elif key == "timestampColumn":
            suggest = "timestamp_column"
        elif key == "labelColumn":
            suggest = "label_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfigInferenceLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfigInferenceLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfigInferenceLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 model_id_column: _builtins.str,
                 prediction_column: _builtins.str,
                 problem_type: _builtins.str,
                 timestamp_column: _builtins.str,
                 label_column: Optional[_builtins.str] = None):
        """
        :param _builtins.str model_id_column: Column for the model identifier
        :param _builtins.str prediction_column: Column for the prediction
        :param _builtins.str problem_type: Problem type the model aims to solve. Possible values are: `INFERENCE_PROBLEM_TYPE_CLASSIFICATION`, `INFERENCE_PROBLEM_TYPE_REGRESSION`
        :param _builtins.str label_column: Column for the label
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_column", model_id_column)
        pulumi.set(__self__, "prediction_column", prediction_column)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_column", timestamp_column)
        if label_column is not None:
            pulumi.set(__self__, "label_column", label_column)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="modelIdColumn")
    def model_id_column(self) -> _builtins.str:
        """
        Column for the model identifier
        """
        return pulumi.get(self, "model_id_column")

    @_builtins.property
    @pulumi.getter(name="predictionColumn")
    def prediction_column(self) -> _builtins.str:
        """
        Column for the prediction
        """
        return pulumi.get(self, "prediction_column")

    @_builtins.property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> _builtins.str:
        """
        Problem type the model aims to solve. Possible values are: `INFERENCE_PROBLEM_TYPE_CLASSIFICATION`, `INFERENCE_PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @_builtins.property
    @pulumi.getter(name="timestampColumn")
    def timestamp_column(self) -> _builtins.str:
        return pulumi.get(self, "timestamp_column")

    @_builtins.property
    @pulumi.getter(name="labelColumn")
    def label_column(self) -> Optional[_builtins.str]:
        """
        Column for the label
        """
        return pulumi.get(self, "label_column")


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfigNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfigNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfigNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure'] = None):
        """
        :param 'DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailureArgs' on_failure: Destinations to send notifications on failure/timeout
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure']:
        """
        Destinations to send notifications on failure/timeout
        """
        return pulumi.get(self, "on_failure")


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddresses":
            suggest = "email_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfigNotificationSettingsOnFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] email_addresses: The list of email addresses to send the notification to. A maximum of 5 email addresses is supported
        """
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of email addresses to send the notification to. A maximum of 5 email addresses is supported
        """
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronExpression":
            suggest = "quartz_cron_expression"
        elif key == "timezoneId":
            suggest = "timezone_id"
        elif key == "pauseStatus":
            suggest = "pause_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfigSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfigSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfigSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_expression: The expression that determines when to run the monitor. See [examples](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html)
        :param _builtins.str timezone_id: A Java timezone id. The schedule for a job will be resolved with respect to this timezone.
               See `Java TimeZone <http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html>`_ for details.
               The timezone id (e.g., ``America/Los_Angeles``) in which to evaluate the quartz expression
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        """
        The expression that determines when to run the monitor. See [examples](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html)
        """
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        A Java timezone id. The schedule for a job will be resolved with respect to this timezone.
        See `Java TimeZone <http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html>`_ for details.
        The timezone id (e.g., ``America/Los_Angeles``) in which to evaluate the quartz expression
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigSnapshot(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DataQualityMonitorDataProfilingConfigTimeSeries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timestampColumn":
            suggest = "timestamp_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityMonitorDataProfilingConfigTimeSeries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityMonitorDataProfilingConfigTimeSeries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityMonitorDataProfilingConfigTimeSeries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 timestamp_column: _builtins.str):
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_column", timestamp_column)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="timestampColumn")
    def timestamp_column(self) -> _builtins.str:
        return pulumi.get(self, "timestamp_column")


@pulumi.output_type
class DatabaseInstanceChildInstanceRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchTime":
            suggest = "branch_time"
        elif key == "effectiveLsn":
            suggest = "effective_lsn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInstanceChildInstanceRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInstanceChildInstanceRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInstanceChildInstanceRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_time: Optional[_builtins.str] = None,
                 effective_lsn: Optional[_builtins.str] = None,
                 lsn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch_time: Branch time of the ref database instance.
               For a parent ref instance, this is the point in time on the parent instance from which the
               instance was created.
               For a child ref instance, this is the point in time on the instance from which the child
               instance was created.
               Input: For specifying the point in time to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str effective_lsn: (string) - For a parent ref instance, this is the LSN on the parent instance from which the
               instance was created.
               For a child ref instance, this is the LSN on the instance from which the child instance
               was created
        :param _builtins.str lsn: User-specified WAL LSN of the ref database instance.
               
               Input: For specifying the WAL LSN to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str name: The name of the instance. This is the unique identifier for the instance
        :param _builtins.str uid: (string) - Id of the ref database instance
        """
        if branch_time is not None:
            pulumi.set(__self__, "branch_time", branch_time)
        if effective_lsn is not None:
            pulumi.set(__self__, "effective_lsn", effective_lsn)
        if lsn is not None:
            pulumi.set(__self__, "lsn", lsn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="branchTime")
    def branch_time(self) -> Optional[_builtins.str]:
        """
        Branch time of the ref database instance.
        For a parent ref instance, this is the point in time on the parent instance from which the
        instance was created.
        For a child ref instance, this is the point in time on the instance from which the child
        instance was created.
        Input: For specifying the point in time to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "branch_time")

    @_builtins.property
    @pulumi.getter(name="effectiveLsn")
    def effective_lsn(self) -> Optional[_builtins.str]:
        """
        (string) - For a parent ref instance, this is the LSN on the parent instance from which the
        instance was created.
        For a child ref instance, this is the LSN on the instance from which the child instance
        was created
        """
        return pulumi.get(self, "effective_lsn")

    @_builtins.property
    @pulumi.getter
    def lsn(self) -> Optional[_builtins.str]:
        """
        User-specified WAL LSN of the ref database instance.

        Input: For specifying the WAL LSN to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "lsn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance. This is the unique identifier for the instance
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class DatabaseInstanceCustomTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the custom tag
        :param _builtins.str value: The value of the custom tag
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key of the custom tag
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the custom tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseInstanceEffectiveCustomTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the custom tag
        :param _builtins.str value: The value of the custom tag
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key of the custom tag
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the custom tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseInstanceParentInstanceRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchTime":
            suggest = "branch_time"
        elif key == "effectiveLsn":
            suggest = "effective_lsn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInstanceParentInstanceRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInstanceParentInstanceRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInstanceParentInstanceRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_time: Optional[_builtins.str] = None,
                 effective_lsn: Optional[_builtins.str] = None,
                 lsn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uid: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch_time: Branch time of the ref database instance.
               For a parent ref instance, this is the point in time on the parent instance from which the
               instance was created.
               For a child ref instance, this is the point in time on the instance from which the child
               instance was created.
               Input: For specifying the point in time to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str effective_lsn: (string) - For a parent ref instance, this is the LSN on the parent instance from which the
               instance was created.
               For a child ref instance, this is the LSN on the instance from which the child instance
               was created
        :param _builtins.str lsn: User-specified WAL LSN of the ref database instance.
               
               Input: For specifying the WAL LSN to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str name: The name of the instance. This is the unique identifier for the instance
        :param _builtins.str uid: (string) - Id of the ref database instance
        """
        if branch_time is not None:
            pulumi.set(__self__, "branch_time", branch_time)
        if effective_lsn is not None:
            pulumi.set(__self__, "effective_lsn", effective_lsn)
        if lsn is not None:
            pulumi.set(__self__, "lsn", lsn)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="branchTime")
    def branch_time(self) -> Optional[_builtins.str]:
        """
        Branch time of the ref database instance.
        For a parent ref instance, this is the point in time on the parent instance from which the
        instance was created.
        For a child ref instance, this is the point in time on the instance from which the child
        instance was created.
        Input: For specifying the point in time to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "branch_time")

    @_builtins.property
    @pulumi.getter(name="effectiveLsn")
    def effective_lsn(self) -> Optional[_builtins.str]:
        """
        (string) - For a parent ref instance, this is the LSN on the parent instance from which the
        instance was created.
        For a child ref instance, this is the LSN on the instance from which the child instance
        was created
        """
        return pulumi.get(self, "effective_lsn")

    @_builtins.property
    @pulumi.getter
    def lsn(self) -> Optional[_builtins.str]:
        """
        User-specified WAL LSN of the ref database instance.

        Input: For specifying the WAL LSN to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "lsn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance. This is the unique identifier for the instance
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.str]:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continuousUpdateStatus":
            suggest = "continuous_update_status"
        elif key == "detailedState":
            suggest = "detailed_state"
        elif key == "failedStatus":
            suggest = "failed_status"
        elif key == "lastSync":
            suggest = "last_sync"
        elif key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "provisioningStatus":
            suggest = "provisioning_status"
        elif key == "triggeredUpdateStatus":
            suggest = "triggered_update_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continuous_update_status: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus'] = None,
                 detailed_state: Optional[_builtins.str] = None,
                 failed_status: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus'] = None,
                 last_sync: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync'] = None,
                 message: Optional[_builtins.str] = None,
                 pipeline_id: Optional[_builtins.str] = None,
                 provisioning_status: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus'] = None,
                 triggered_update_status: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus'] = None):
        """
        :param _builtins.str detailed_state: (string) - The state of the synced table. Possible values are: `SYNCED_TABLED_OFFLINE`, `SYNCED_TABLE_OFFLINE_FAILED`, `SYNCED_TABLE_ONLINE`, `SYNCED_TABLE_ONLINE_CONTINUOUS_UPDATE`, `SYNCED_TABLE_ONLINE_NO_PENDING_UPDATE`, `SYNCED_TABLE_ONLINE_PIPELINE_FAILED`, `SYNCED_TABLE_ONLINE_TRIGGERED_UPDATE`, `SYNCED_TABLE_ONLINE_UPDATING_PIPELINE_RESOURCES`, `SYNCED_TABLE_PROVISIONING`, `SYNCED_TABLE_PROVISIONING_INITIAL_SNAPSHOT`, `SYNCED_TABLE_PROVISIONING_PIPELINE_RESOURCES`
        :param 'DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncArgs' last_sync: (SyncedTablePosition) - Summary of the last successful synchronization from source to destination.
        :param _builtins.str message: (string) - A text description of the current state of the synced table
        :param _builtins.str pipeline_id: (string) - ID of the associated pipeline. The pipeline ID may have been provided by the client
               (in the case of bin packing), or generated by the server (when creating a new pipeline)
        """
        if continuous_update_status is not None:
            pulumi.set(__self__, "continuous_update_status", continuous_update_status)
        if detailed_state is not None:
            pulumi.set(__self__, "detailed_state", detailed_state)
        if failed_status is not None:
            pulumi.set(__self__, "failed_status", failed_status)
        if last_sync is not None:
            pulumi.set(__self__, "last_sync", last_sync)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if triggered_update_status is not None:
            pulumi.set(__self__, "triggered_update_status", triggered_update_status)

    @_builtins.property
    @pulumi.getter(name="continuousUpdateStatus")
    def continuous_update_status(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus']:
        return pulumi.get(self, "continuous_update_status")

    @_builtins.property
    @pulumi.getter(name="detailedState")
    def detailed_state(self) -> Optional[_builtins.str]:
        """
        (string) - The state of the synced table. Possible values are: `SYNCED_TABLED_OFFLINE`, `SYNCED_TABLE_OFFLINE_FAILED`, `SYNCED_TABLE_ONLINE`, `SYNCED_TABLE_ONLINE_CONTINUOUS_UPDATE`, `SYNCED_TABLE_ONLINE_NO_PENDING_UPDATE`, `SYNCED_TABLE_ONLINE_PIPELINE_FAILED`, `SYNCED_TABLE_ONLINE_TRIGGERED_UPDATE`, `SYNCED_TABLE_ONLINE_UPDATING_PIPELINE_RESOURCES`, `SYNCED_TABLE_PROVISIONING`, `SYNCED_TABLE_PROVISIONING_INITIAL_SNAPSHOT`, `SYNCED_TABLE_PROVISIONING_PIPELINE_RESOURCES`
        """
        return pulumi.get(self, "detailed_state")

    @_builtins.property
    @pulumi.getter(name="failedStatus")
    def failed_status(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus']:
        return pulumi.get(self, "failed_status")

    @_builtins.property
    @pulumi.getter(name="lastSync")
    def last_sync(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync']:
        """
        (SyncedTablePosition) - Summary of the last successful synchronization from source to destination.
        """
        return pulumi.get(self, "last_sync")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (string) - A text description of the current state of the synced table
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        (string) - ID of the associated pipeline. The pipeline ID may have been provided by the client
        (in the case of bin packing), or generated by the server (when creating a new pipeline)
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus']:
        return pulumi.get(self, "provisioning_status")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateStatus")
    def triggered_update_status(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus']:
        return pulumi.get(self, "triggered_update_status")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialPipelineSyncProgress":
            suggest = "initial_pipeline_sync_progress"
        elif key == "lastProcessedCommitVersion":
            suggest = "last_processed_commit_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_pipeline_sync_progress: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress'] = None,
                 last_processed_commit_version: Optional[_builtins.int] = None,
                 timestamp: Optional[_builtins.str] = None):
        """
        :param 'DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs' initial_pipeline_sync_progress: (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
               PROVISIONING_INITIAL_SNAPSHOT state
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        """
        if initial_pipeline_sync_progress is not None:
            pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress']:
        """
        (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
        PROVISIONING_INITIAL_SNAPSHOT state
        """
        return pulumi.get(self, "initial_pipeline_sync_progress")

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[_builtins.int]:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[_builtins.str]:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedCompletionTimeSeconds":
            suggest = "estimated_completion_time_seconds"
        elif key == "latestVersionCurrentlyProcessing":
            suggest = "latest_version_currently_processing"
        elif key == "provisioningPhase":
            suggest = "provisioning_phase"
        elif key == "syncProgressCompletion":
            suggest = "sync_progress_completion"
        elif key == "syncedRowCount":
            suggest = "synced_row_count"
        elif key == "totalRowCount":
            suggest = "total_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[_builtins.float] = None,
                 latest_version_currently_processing: Optional[_builtins.int] = None,
                 provisioning_phase: Optional[_builtins.str] = None,
                 sync_progress_completion: Optional[_builtins.float] = None,
                 synced_row_count: Optional[_builtins.int] = None,
                 total_row_count: Optional[_builtins.int] = None):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if provisioning_phase is not None:
            pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[_builtins.float]:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[_builtins.int]:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> Optional[_builtins.str]:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[_builtins.float]:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastProcessedCommitVersion":
            suggest = "last_processed_commit_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_processed_commit_version: Optional[_builtins.int] = None,
                 timestamp: Optional[_builtins.str] = None):
        """
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        """
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[_builtins.int]:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[_builtins.str]:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deltaTableSyncInfo":
            suggest = "delta_table_sync_info"
        elif key == "syncEndTimestamp":
            suggest = "sync_end_timestamp"
        elif key == "syncStartTimestamp":
            suggest = "sync_start_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSync.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delta_table_sync_info: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo'] = None,
                 sync_end_timestamp: Optional[_builtins.str] = None,
                 sync_start_timestamp: Optional[_builtins.str] = None):
        """
        :param 'DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoArgs' delta_table_sync_info: (DeltaTableSyncInfo)
        :param _builtins.str sync_end_timestamp: (string) - The end timestamp of the most recent successful synchronization.
               This is the time when the data is available in the synced table
        :param _builtins.str sync_start_timestamp: (string) - The starting timestamp of the most recent successful synchronization from the source table
               to the destination (synced) table.
               Note this is the starting timestamp of the sync operation, not the end time.
               E.g., for a batch, this is the time when the sync operation started
        """
        if delta_table_sync_info is not None:
            pulumi.set(__self__, "delta_table_sync_info", delta_table_sync_info)
        if sync_end_timestamp is not None:
            pulumi.set(__self__, "sync_end_timestamp", sync_end_timestamp)
        if sync_start_timestamp is not None:
            pulumi.set(__self__, "sync_start_timestamp", sync_start_timestamp)

    @_builtins.property
    @pulumi.getter(name="deltaTableSyncInfo")
    def delta_table_sync_info(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo']:
        """
        (DeltaTableSyncInfo)
        """
        return pulumi.get(self, "delta_table_sync_info")

    @_builtins.property
    @pulumi.getter(name="syncEndTimestamp")
    def sync_end_timestamp(self) -> Optional[_builtins.str]:
        """
        (string) - The end timestamp of the most recent successful synchronization.
        This is the time when the data is available in the synced table
        """
        return pulumi.get(self, "sync_end_timestamp")

    @_builtins.property
    @pulumi.getter(name="syncStartTimestamp")
    def sync_start_timestamp(self) -> Optional[_builtins.str]:
        """
        (string) - The starting timestamp of the most recent successful synchronization from the source table
        to the destination (synced) table.
        Note this is the starting timestamp of the sync operation, not the end time.
        E.g., for a batch, this is the time when the sync operation started
        """
        return pulumi.get(self, "sync_start_timestamp")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deltaCommitTimestamp":
            suggest = "delta_commit_timestamp"
        elif key == "deltaCommitVersion":
            suggest = "delta_commit_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delta_commit_timestamp: Optional[_builtins.str] = None,
                 delta_commit_version: Optional[_builtins.int] = None):
        """
        :param _builtins.str delta_commit_timestamp: (string) - The timestamp when the above Delta version was committed in the source Delta table.
               Note: This is the Delta commit time, not the time the data was written to the synced table
        :param _builtins.int delta_commit_version: (integer) - The Delta Lake commit version that was last successfully synced
        """
        if delta_commit_timestamp is not None:
            pulumi.set(__self__, "delta_commit_timestamp", delta_commit_timestamp)
        if delta_commit_version is not None:
            pulumi.set(__self__, "delta_commit_version", delta_commit_version)

    @_builtins.property
    @pulumi.getter(name="deltaCommitTimestamp")
    def delta_commit_timestamp(self) -> Optional[_builtins.str]:
        """
        (string) - The timestamp when the above Delta version was committed in the source Delta table.
        Note: This is the Delta commit time, not the time the data was written to the synced table
        """
        return pulumi.get(self, "delta_commit_timestamp")

    @_builtins.property
    @pulumi.getter(name="deltaCommitVersion")
    def delta_commit_version(self) -> Optional[_builtins.int]:
        """
        (integer) - The Delta Lake commit version that was last successfully synced
        """
        return pulumi.get(self, "delta_commit_version")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialPipelineSyncProgress":
            suggest = "initial_pipeline_sync_progress"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_pipeline_sync_progress: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress'] = None):
        """
        :param 'DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressArgs' initial_pipeline_sync_progress: (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
               PROVISIONING_INITIAL_SNAPSHOT state
        """
        if initial_pipeline_sync_progress is not None:
            pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress']:
        """
        (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
        PROVISIONING_INITIAL_SNAPSHOT state
        """
        return pulumi.get(self, "initial_pipeline_sync_progress")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedCompletionTimeSeconds":
            suggest = "estimated_completion_time_seconds"
        elif key == "latestVersionCurrentlyProcessing":
            suggest = "latest_version_currently_processing"
        elif key == "provisioningPhase":
            suggest = "provisioning_phase"
        elif key == "syncProgressCompletion":
            suggest = "sync_progress_completion"
        elif key == "syncedRowCount":
            suggest = "synced_row_count"
        elif key == "totalRowCount":
            suggest = "total_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[_builtins.float] = None,
                 latest_version_currently_processing: Optional[_builtins.int] = None,
                 provisioning_phase: Optional[_builtins.str] = None,
                 sync_progress_completion: Optional[_builtins.float] = None,
                 synced_row_count: Optional[_builtins.int] = None,
                 total_row_count: Optional[_builtins.int] = None):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if provisioning_phase is not None:
            pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[_builtins.float]:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[_builtins.int]:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> Optional[_builtins.str]:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[_builtins.float]:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastProcessedCommitVersion":
            suggest = "last_processed_commit_version"
        elif key == "triggeredUpdateProgress":
            suggest = "triggered_update_progress"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_processed_commit_version: Optional[_builtins.int] = None,
                 timestamp: Optional[_builtins.str] = None,
                 triggered_update_progress: Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress'] = None):
        """
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        :param 'DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs' triggered_update_progress: (SyncedTablePipelineProgress) - Progress of the active data synchronization pipeline
        """
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)
        if triggered_update_progress is not None:
            pulumi.set(__self__, "triggered_update_progress", triggered_update_progress)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[_builtins.int]:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[_builtins.str]:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateProgress")
    def triggered_update_progress(self) -> Optional['outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress']:
        """
        (SyncedTablePipelineProgress) - Progress of the active data synchronization pipeline
        """
        return pulumi.get(self, "triggered_update_progress")


@pulumi.output_type
class DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedCompletionTimeSeconds":
            suggest = "estimated_completion_time_seconds"
        elif key == "latestVersionCurrentlyProcessing":
            suggest = "latest_version_currently_processing"
        elif key == "provisioningPhase":
            suggest = "provisioning_phase"
        elif key == "syncProgressCompletion":
            suggest = "sync_progress_completion"
        elif key == "syncedRowCount":
            suggest = "synced_row_count"
        elif key == "totalRowCount":
            suggest = "total_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[_builtins.float] = None,
                 latest_version_currently_processing: Optional[_builtins.int] = None,
                 provisioning_phase: Optional[_builtins.str] = None,
                 sync_progress_completion: Optional[_builtins.float] = None,
                 synced_row_count: Optional[_builtins.int] = None,
                 total_row_count: Optional[_builtins.int] = None):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if provisioning_phase is not None:
            pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[_builtins.float]:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[_builtins.int]:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> Optional[_builtins.str]:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[_builtins.float]:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class DatabaseSyncedDatabaseTableSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createDatabaseObjectsIfMissing":
            suggest = "create_database_objects_if_missing"
        elif key == "existingPipelineId":
            suggest = "existing_pipeline_id"
        elif key == "newPipelineSpec":
            suggest = "new_pipeline_spec"
        elif key == "primaryKeyColumns":
            suggest = "primary_key_columns"
        elif key == "schedulingPolicy":
            suggest = "scheduling_policy"
        elif key == "sourceTableFullName":
            suggest = "source_table_full_name"
        elif key == "timeseriesKey":
            suggest = "timeseries_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_database_objects_if_missing: Optional[_builtins.bool] = None,
                 existing_pipeline_id: Optional[_builtins.str] = None,
                 new_pipeline_spec: Optional['outputs.DatabaseSyncedDatabaseTableSpecNewPipelineSpec'] = None,
                 primary_key_columns: Optional[Sequence[_builtins.str]] = None,
                 scheduling_policy: Optional[_builtins.str] = None,
                 source_table_full_name: Optional[_builtins.str] = None,
                 timeseries_key: Optional[_builtins.str] = None):
        """
        :param _builtins.bool create_database_objects_if_missing: If true, the synced table's logical database and schema resources in PG
               will be created if they do not already exist
        :param _builtins.str existing_pipeline_id: At most one of existing_pipeline_id and new_pipeline_spec should be defined.
               
               If existing_pipeline_id is defined, the synced table will be bin packed into the existing pipeline
               referenced. This avoids creating a new pipeline and allows sharing existing compute.
               In this case, the scheduling_policy of this synced table must match the scheduling policy of the existing pipeline
        :param 'DatabaseSyncedDatabaseTableSpecNewPipelineSpecArgs' new_pipeline_spec: At most one of existing_pipeline_id and new_pipeline_spec should be defined.
               
               If new_pipeline_spec is defined, a new pipeline is created for this synced table. The location pointed to is used
               to store intermediate files (checkpoints, event logs etc). The caller must have write permissions to create Delta
               tables in the specified catalog and schema. Again, note this requires write permissions, whereas the source table
               only requires read permissions
        :param Sequence[_builtins.str] primary_key_columns: Primary Key columns to be used for data insert/update in the destination
        :param _builtins.str scheduling_policy: Scheduling policy of the underlying pipeline. Possible values are: `CONTINUOUS`, `SNAPSHOT`, `TRIGGERED`
        :param _builtins.str source_table_full_name: Three-part (catalog, schema, table) name of the source Delta table
        :param _builtins.str timeseries_key: Time series key to deduplicate (tie-break) rows with the same primary key
        """
        if create_database_objects_if_missing is not None:
            pulumi.set(__self__, "create_database_objects_if_missing", create_database_objects_if_missing)
        if existing_pipeline_id is not None:
            pulumi.set(__self__, "existing_pipeline_id", existing_pipeline_id)
        if new_pipeline_spec is not None:
            pulumi.set(__self__, "new_pipeline_spec", new_pipeline_spec)
        if primary_key_columns is not None:
            pulumi.set(__self__, "primary_key_columns", primary_key_columns)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        if source_table_full_name is not None:
            pulumi.set(__self__, "source_table_full_name", source_table_full_name)
        if timeseries_key is not None:
            pulumi.set(__self__, "timeseries_key", timeseries_key)

    @_builtins.property
    @pulumi.getter(name="createDatabaseObjectsIfMissing")
    def create_database_objects_if_missing(self) -> Optional[_builtins.bool]:
        """
        If true, the synced table's logical database and schema resources in PG
        will be created if they do not already exist
        """
        return pulumi.get(self, "create_database_objects_if_missing")

    @_builtins.property
    @pulumi.getter(name="existingPipelineId")
    def existing_pipeline_id(self) -> Optional[_builtins.str]:
        """
        At most one of existing_pipeline_id and new_pipeline_spec should be defined.

        If existing_pipeline_id is defined, the synced table will be bin packed into the existing pipeline
        referenced. This avoids creating a new pipeline and allows sharing existing compute.
        In this case, the scheduling_policy of this synced table must match the scheduling policy of the existing pipeline
        """
        return pulumi.get(self, "existing_pipeline_id")

    @_builtins.property
    @pulumi.getter(name="newPipelineSpec")
    def new_pipeline_spec(self) -> Optional['outputs.DatabaseSyncedDatabaseTableSpecNewPipelineSpec']:
        """
        At most one of existing_pipeline_id and new_pipeline_spec should be defined.

        If new_pipeline_spec is defined, a new pipeline is created for this synced table. The location pointed to is used
        to store intermediate files (checkpoints, event logs etc). The caller must have write permissions to create Delta
        tables in the specified catalog and schema. Again, note this requires write permissions, whereas the source table
        only requires read permissions
        """
        return pulumi.get(self, "new_pipeline_spec")

    @_builtins.property
    @pulumi.getter(name="primaryKeyColumns")
    def primary_key_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Primary Key columns to be used for data insert/update in the destination
        """
        return pulumi.get(self, "primary_key_columns")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional[_builtins.str]:
        """
        Scheduling policy of the underlying pipeline. Possible values are: `CONTINUOUS`, `SNAPSHOT`, `TRIGGERED`
        """
        return pulumi.get(self, "scheduling_policy")

    @_builtins.property
    @pulumi.getter(name="sourceTableFullName")
    def source_table_full_name(self) -> Optional[_builtins.str]:
        """
        Three-part (catalog, schema, table) name of the source Delta table
        """
        return pulumi.get(self, "source_table_full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesKey")
    def timeseries_key(self) -> Optional[_builtins.str]:
        """
        Time series key to deduplicate (tie-break) rows with the same primary key
        """
        return pulumi.get(self, "timeseries_key")


@pulumi.output_type
class DatabaseSyncedDatabaseTableSpecNewPipelineSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageCatalog":
            suggest = "storage_catalog"
        elif key == "storageSchema":
            suggest = "storage_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseSyncedDatabaseTableSpecNewPipelineSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseSyncedDatabaseTableSpecNewPipelineSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseSyncedDatabaseTableSpecNewPipelineSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_catalog: Optional[_builtins.str] = None,
                 storage_schema: Optional[_builtins.str] = None):
        """
        :param _builtins.str storage_catalog: This field needs to be specified if the destination catalog is a managed postgres catalog.
               
               UC catalog for the pipeline to store intermediate files (checkpoints, event logs etc).
               This needs to be a standard catalog where the user has permissions to create Delta tables
        :param _builtins.str storage_schema: This field needs to be specified if the destination catalog is a managed postgres catalog.
               
               UC schema for the pipeline to store intermediate files (checkpoints, event logs etc).
               This needs to be in the standard catalog where the user has permissions to create Delta tables
        """
        if storage_catalog is not None:
            pulumi.set(__self__, "storage_catalog", storage_catalog)
        if storage_schema is not None:
            pulumi.set(__self__, "storage_schema", storage_schema)

    @_builtins.property
    @pulumi.getter(name="storageCatalog")
    def storage_catalog(self) -> Optional[_builtins.str]:
        """
        This field needs to be specified if the destination catalog is a managed postgres catalog.

        UC catalog for the pipeline to store intermediate files (checkpoints, event logs etc).
        This needs to be a standard catalog where the user has permissions to create Delta tables
        """
        return pulumi.get(self, "storage_catalog")

    @_builtins.property
    @pulumi.getter(name="storageSchema")
    def storage_schema(self) -> Optional[_builtins.str]:
        """
        This field needs to be specified if the destination catalog is a managed postgres catalog.

        UC schema for the pipeline to store intermediate files (checkpoints, event logs etc).
        This needs to be in the standard catalog where the user has permissions to create Delta tables
        """
        return pulumi.get(self, "storage_schema")


@pulumi.output_type
class DefaultNamespaceSettingNamespace(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: The value for the setting.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value for the setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DisableLegacyAccessSettingDisableLegacyAccess(dict):
    def __init__(__self__, *,
                 value: _builtins.bool):
        """
        :param _builtins.bool value: The boolean value for the setting.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.bool:
        """
        The boolean value for the setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DisableLegacyDbfsSettingDisableLegacyDbfs(dict):
    def __init__(__self__, *,
                 value: _builtins.bool):
        """
        :param _builtins.bool value: The boolean value for the setting.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.bool:
        """
        The boolean value for the setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DisableLegacyFeaturesSettingDisableLegacyFeatures(dict):
    def __init__(__self__, *,
                 value: _builtins.bool):
        """
        :param _builtins.bool value: The boolean value for the setting.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.bool:
        """
        The boolean value for the setting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnhancedSecurityMonitoringWorkspaceSettingEnhancedSecurityMonitoringWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: _builtins.bool):
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class ExternalLocationEncryptionDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sseEncryptionDetails":
            suggest = "sse_encryption_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationEncryptionDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationEncryptionDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationEncryptionDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sse_encryption_details: Optional['outputs.ExternalLocationEncryptionDetailsSseEncryptionDetails'] = None):
        """
        :param 'ExternalLocationEncryptionDetailsSseEncryptionDetailsArgs' sse_encryption_details: a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
        """
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @_builtins.property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['outputs.ExternalLocationEncryptionDetailsSseEncryptionDetails']:
        """
        a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
        """
        return pulumi.get(self, "sse_encryption_details")


@pulumi.output_type
class ExternalLocationEncryptionDetailsSseEncryptionDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsKmsKeyArn":
            suggest = "aws_kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationEncryptionDetailsSseEncryptionDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationEncryptionDetailsSseEncryptionDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationEncryptionDetailsSseEncryptionDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[_builtins.str] = None,
                 aws_kms_key_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str algorithm: Encryption algorithm value. Sets the value of the `x-amz-server-side-encryption` header in S3 request.
        :param _builtins.str aws_kms_key_arn: Optional ARN of the SSE-KMS key used with the S3 location, when `algorithm = "SSE-KMS"`. Sets the value of the `x-amz-server-side-encryption-aws-kms-key-id` header.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        """
        Encryption algorithm value. Sets the value of the `x-amz-server-side-encryption` header in S3 request.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[_builtins.str]:
        """
        Optional ARN of the SSE-KMS key used with the S3 location, when `algorithm = "SSE-KMS"`. Sets the value of the `x-amz-server-side-encryption-aws-kms-key-id` header.
        """
        return pulumi.get(self, "aws_kms_key_arn")


@pulumi.output_type
class ExternalLocationFileEventQueue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedAqs":
            suggest = "managed_aqs"
        elif key == "managedPubsub":
            suggest = "managed_pubsub"
        elif key == "managedSqs":
            suggest = "managed_sqs"
        elif key == "providedAqs":
            suggest = "provided_aqs"
        elif key == "providedPubsub":
            suggest = "provided_pubsub"
        elif key == "providedSqs":
            suggest = "provided_sqs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_aqs: Optional['outputs.ExternalLocationFileEventQueueManagedAqs'] = None,
                 managed_pubsub: Optional['outputs.ExternalLocationFileEventQueueManagedPubsub'] = None,
                 managed_sqs: Optional['outputs.ExternalLocationFileEventQueueManagedSqs'] = None,
                 provided_aqs: Optional['outputs.ExternalLocationFileEventQueueProvidedAqs'] = None,
                 provided_pubsub: Optional['outputs.ExternalLocationFileEventQueueProvidedPubsub'] = None,
                 provided_sqs: Optional['outputs.ExternalLocationFileEventQueueProvidedSqs'] = None):
        """
        :param 'ExternalLocationFileEventQueueManagedAqsArgs' managed_aqs: Configuration for managed Azure Queue Storage queue.
        :param 'ExternalLocationFileEventQueueManagedPubsubArgs' managed_pubsub: Configuration for managed Google Cloud Pub/Sub queue.
        :param 'ExternalLocationFileEventQueueManagedSqsArgs' managed_sqs: Configuration for managed Amazon SQS queue.
        :param 'ExternalLocationFileEventQueueProvidedAqsArgs' provided_aqs: Configuration for provided Azure Storage Queue.
        :param 'ExternalLocationFileEventQueueProvidedPubsubArgs' provided_pubsub: Configuration for provided Google Cloud Pub/Sub queue.
        :param 'ExternalLocationFileEventQueueProvidedSqsArgs' provided_sqs: Configuration for provided Amazon SQS queue.
        """
        if managed_aqs is not None:
            pulumi.set(__self__, "managed_aqs", managed_aqs)
        if managed_pubsub is not None:
            pulumi.set(__self__, "managed_pubsub", managed_pubsub)
        if managed_sqs is not None:
            pulumi.set(__self__, "managed_sqs", managed_sqs)
        if provided_aqs is not None:
            pulumi.set(__self__, "provided_aqs", provided_aqs)
        if provided_pubsub is not None:
            pulumi.set(__self__, "provided_pubsub", provided_pubsub)
        if provided_sqs is not None:
            pulumi.set(__self__, "provided_sqs", provided_sqs)

    @_builtins.property
    @pulumi.getter(name="managedAqs")
    def managed_aqs(self) -> Optional['outputs.ExternalLocationFileEventQueueManagedAqs']:
        """
        Configuration for managed Azure Queue Storage queue.
        """
        return pulumi.get(self, "managed_aqs")

    @_builtins.property
    @pulumi.getter(name="managedPubsub")
    def managed_pubsub(self) -> Optional['outputs.ExternalLocationFileEventQueueManagedPubsub']:
        """
        Configuration for managed Google Cloud Pub/Sub queue.
        """
        return pulumi.get(self, "managed_pubsub")

    @_builtins.property
    @pulumi.getter(name="managedSqs")
    def managed_sqs(self) -> Optional['outputs.ExternalLocationFileEventQueueManagedSqs']:
        """
        Configuration for managed Amazon SQS queue.
        """
        return pulumi.get(self, "managed_sqs")

    @_builtins.property
    @pulumi.getter(name="providedAqs")
    def provided_aqs(self) -> Optional['outputs.ExternalLocationFileEventQueueProvidedAqs']:
        """
        Configuration for provided Azure Storage Queue.
        """
        return pulumi.get(self, "provided_aqs")

    @_builtins.property
    @pulumi.getter(name="providedPubsub")
    def provided_pubsub(self) -> Optional['outputs.ExternalLocationFileEventQueueProvidedPubsub']:
        """
        Configuration for provided Google Cloud Pub/Sub queue.
        """
        return pulumi.get(self, "provided_pubsub")

    @_builtins.property
    @pulumi.getter(name="providedSqs")
    def provided_sqs(self) -> Optional['outputs.ExternalLocationFileEventQueueProvidedSqs']:
        """
        Configuration for provided Amazon SQS queue.
        """
        return pulumi.get(self, "provided_sqs")


@pulumi.output_type
class ExternalLocationFileEventQueueManagedAqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroup":
            suggest = "resource_group"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "managedResourceId":
            suggest = "managed_resource_id"
        elif key == "queueUrl":
            suggest = "queue_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueueManagedAqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueueManagedAqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueueManagedAqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group: _builtins.str,
                 subscription_id: _builtins.str,
                 managed_resource_id: Optional[_builtins.str] = None,
                 queue_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str resource_group: The name of the Azure resource group.
        :param _builtins.str subscription_id: The Azure subscription ID.
        :param _builtins.str managed_resource_id: The ID of the managed resource.
        """
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "subscription_id", subscription_id)
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        """
        The name of the Azure resource group.
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        The Azure subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        """
        The ID of the managed resource.
        """
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "queue_url")


@pulumi.output_type
class ExternalLocationFileEventQueueManagedPubsub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedResourceId":
            suggest = "managed_resource_id"
        elif key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueueManagedPubsub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueueManagedPubsub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueueManagedPubsub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 subscription_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str managed_resource_id: The ID of the managed resource.
        :param _builtins.str subscription_name: The name of the subscription.
        """
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        """
        The ID of the managed resource.
        """
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[_builtins.str]:
        """
        The name of the subscription.
        """
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class ExternalLocationFileEventQueueManagedSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedResourceId":
            suggest = "managed_resource_id"
        elif key == "queueUrl":
            suggest = "queue_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueueManagedSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueueManagedSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueueManagedSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 queue_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str managed_resource_id: The ID of the managed resource.
        """
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        """
        The ID of the managed resource.
        """
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "queue_url")


@pulumi.output_type
class ExternalLocationFileEventQueueProvidedAqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "managedResourceId":
            suggest = "managed_resource_id"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueueProvidedAqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueueProvidedAqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueueProvidedAqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: _builtins.str,
                 managed_resource_id: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str queue_url: The URL of the queue.
        :param _builtins.str resource_group: The name of the Azure resource group.
        :param _builtins.str subscription_id: The Azure subscription ID.
        """
        pulumi.set(__self__, "queue_url", queue_url)
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> _builtins.str:
        """
        The URL of the queue.
        """
        return pulumi.get(self, "queue_url")

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        The name of the Azure resource group.
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        The Azure subscription ID.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class ExternalLocationFileEventQueueProvidedPubsub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionName":
            suggest = "subscription_name"
        elif key == "managedResourceId":
            suggest = "managed_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueueProvidedPubsub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueueProvidedPubsub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueueProvidedPubsub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subscription_name: _builtins.str,
                 managed_resource_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str subscription_name: The name of the subscription.
        """
        pulumi.set(__self__, "subscription_name", subscription_name)
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> _builtins.str:
        """
        The name of the subscription.
        """
        return pulumi.get(self, "subscription_name")

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")


@pulumi.output_type
class ExternalLocationFileEventQueueProvidedSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "managedResourceId":
            suggest = "managed_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalLocationFileEventQueueProvidedSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalLocationFileEventQueueProvidedSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalLocationFileEventQueueProvidedSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: _builtins.str,
                 managed_resource_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str queue_url: The URL of the SQS queue.
        """
        pulumi.set(__self__, "queue_url", queue_url)
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> _builtins.str:
        """
        The URL of the SQS queue.
        """
        return pulumi.get(self, "queue_url")

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")


@pulumi.output_type
class FeatureEngineeringFeatureFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionType":
            suggest = "function_type"
        elif key == "extraParameters":
            suggest = "extra_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringFeatureFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringFeatureFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringFeatureFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_type: _builtins.str,
                 extra_parameters: Optional[Sequence['outputs.FeatureEngineeringFeatureFunctionExtraParameter']] = None):
        """
        :param _builtins.str function_type: The type of the function. Possible values are: `APPROX_COUNT_DISTINCT`, `APPROX_PERCENTILE`, `AVG`, `COUNT`, `FIRST`, `LAST`, `MAX`, `MIN`, `STDDEV_POP`, `STDDEV_SAMP`, `SUM`, `VAR_POP`, `VAR_SAMP`
        :param Sequence['FeatureEngineeringFeatureFunctionExtraParameterArgs'] extra_parameters: Extra parameters for parameterized functions
        """
        pulumi.set(__self__, "function_type", function_type)
        if extra_parameters is not None:
            pulumi.set(__self__, "extra_parameters", extra_parameters)

    @_builtins.property
    @pulumi.getter(name="functionType")
    def function_type(self) -> _builtins.str:
        """
        The type of the function. Possible values are: `APPROX_COUNT_DISTINCT`, `APPROX_PERCENTILE`, `AVG`, `COUNT`, `FIRST`, `LAST`, `MAX`, `MIN`, `STDDEV_POP`, `STDDEV_SAMP`, `SUM`, `VAR_POP`, `VAR_SAMP`
        """
        return pulumi.get(self, "function_type")

    @_builtins.property
    @pulumi.getter(name="extraParameters")
    def extra_parameters(self) -> Optional[Sequence['outputs.FeatureEngineeringFeatureFunctionExtraParameter']]:
        """
        Extra parameters for parameterized functions
        """
        return pulumi.get(self, "extra_parameters")


@pulumi.output_type
class FeatureEngineeringFeatureFunctionExtraParameter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The name of the parameter
        :param _builtins.str value: The value of the parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The name of the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FeatureEngineeringFeatureSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deltaTableSource":
            suggest = "delta_table_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringFeatureSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringFeatureSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringFeatureSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delta_table_source: Optional['outputs.FeatureEngineeringFeatureSourceDeltaTableSource'] = None):
        if delta_table_source is not None:
            pulumi.set(__self__, "delta_table_source", delta_table_source)

    @_builtins.property
    @pulumi.getter(name="deltaTableSource")
    def delta_table_source(self) -> Optional['outputs.FeatureEngineeringFeatureSourceDeltaTableSource']:
        return pulumi.get(self, "delta_table_source")


@pulumi.output_type
class FeatureEngineeringFeatureSourceDeltaTableSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityColumns":
            suggest = "entity_columns"
        elif key == "fullName":
            suggest = "full_name"
        elif key == "timeseriesColumn":
            suggest = "timeseries_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringFeatureSourceDeltaTableSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringFeatureSourceDeltaTableSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringFeatureSourceDeltaTableSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_columns: Sequence[_builtins.str],
                 full_name: _builtins.str,
                 timeseries_column: _builtins.str):
        """
        :param Sequence[_builtins.str] entity_columns: The entity columns of the Delta table
        :param _builtins.str full_name: The full three-part name (catalog, schema, name) of the feature
        :param _builtins.str timeseries_column: The timeseries column of the Delta table
        """
        pulumi.set(__self__, "entity_columns", entity_columns)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "timeseries_column", timeseries_column)

    @_builtins.property
    @pulumi.getter(name="entityColumns")
    def entity_columns(self) -> Sequence[_builtins.str]:
        """
        The entity columns of the Delta table
        """
        return pulumi.get(self, "entity_columns")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        The full three-part name (catalog, schema, name) of the feature
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesColumn")
    def timeseries_column(self) -> _builtins.str:
        """
        The timeseries column of the Delta table
        """
        return pulumi.get(self, "timeseries_column")


@pulumi.output_type
class FeatureEngineeringFeatureTimeWindow(dict):
    def __init__(__self__, *,
                 continuous: Optional['outputs.FeatureEngineeringFeatureTimeWindowContinuous'] = None,
                 sliding: Optional['outputs.FeatureEngineeringFeatureTimeWindowSliding'] = None,
                 tumbling: Optional['outputs.FeatureEngineeringFeatureTimeWindowTumbling'] = None):
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if sliding is not None:
            pulumi.set(__self__, "sliding", sliding)
        if tumbling is not None:
            pulumi.set(__self__, "tumbling", tumbling)

    @_builtins.property
    @pulumi.getter
    def continuous(self) -> Optional['outputs.FeatureEngineeringFeatureTimeWindowContinuous']:
        return pulumi.get(self, "continuous")

    @_builtins.property
    @pulumi.getter
    def sliding(self) -> Optional['outputs.FeatureEngineeringFeatureTimeWindowSliding']:
        return pulumi.get(self, "sliding")

    @_builtins.property
    @pulumi.getter
    def tumbling(self) -> Optional['outputs.FeatureEngineeringFeatureTimeWindowTumbling']:
        return pulumi.get(self, "tumbling")


@pulumi.output_type
class FeatureEngineeringFeatureTimeWindowContinuous(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowDuration":
            suggest = "window_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringFeatureTimeWindowContinuous. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringFeatureTimeWindowContinuous.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringFeatureTimeWindowContinuous.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_duration: _builtins.str,
                 offset: Optional[_builtins.str] = None):
        """
        :param _builtins.str offset: The offset of the continuous window (must be non-positive)
        """
        pulumi.set(__self__, "window_duration", window_duration)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        return pulumi.get(self, "window_duration")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        The offset of the continuous window (must be non-positive)
        """
        return pulumi.get(self, "offset")


@pulumi.output_type
class FeatureEngineeringFeatureTimeWindowSliding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slideDuration":
            suggest = "slide_duration"
        elif key == "windowDuration":
            suggest = "window_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringFeatureTimeWindowSliding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringFeatureTimeWindowSliding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringFeatureTimeWindowSliding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slide_duration: _builtins.str,
                 window_duration: _builtins.str):
        """
        :param _builtins.str slide_duration: The slide duration (interval by which windows advance, must be positive and less than duration)
        """
        pulumi.set(__self__, "slide_duration", slide_duration)
        pulumi.set(__self__, "window_duration", window_duration)

    @_builtins.property
    @pulumi.getter(name="slideDuration")
    def slide_duration(self) -> _builtins.str:
        """
        The slide duration (interval by which windows advance, must be positive and less than duration)
        """
        return pulumi.get(self, "slide_duration")

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        return pulumi.get(self, "window_duration")


@pulumi.output_type
class FeatureEngineeringFeatureTimeWindowTumbling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "windowDuration":
            suggest = "window_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringFeatureTimeWindowTumbling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringFeatureTimeWindowTumbling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringFeatureTimeWindowTumbling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 window_duration: _builtins.str):
        pulumi.set(__self__, "window_duration", window_duration)

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        return pulumi.get(self, "window_duration")


@pulumi.output_type
class FeatureEngineeringMaterializedFeatureOfflineStoreConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogName":
            suggest = "catalog_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "tableNamePrefix":
            suggest = "table_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringMaterializedFeatureOfflineStoreConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringMaterializedFeatureOfflineStoreConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringMaterializedFeatureOfflineStoreConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_name: _builtins.str,
                 schema_name: _builtins.str,
                 table_name_prefix: _builtins.str):
        """
        :param _builtins.str catalog_name: The Unity Catalog catalog name
        :param _builtins.str schema_name: The Unity Catalog schema name
        :param _builtins.str table_name_prefix: Prefix for Unity Catalog table name.
               The materialized feature will be stored in a table with this prefix and a generated postfix
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> _builtins.str:
        """
        The Unity Catalog catalog name
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        """
        The Unity Catalog schema name
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> _builtins.str:
        """
        Prefix for Unity Catalog table name.
        The materialized feature will be stored in a table with this prefix and a generated postfix
        """
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class FeatureEngineeringMaterializedFeatureOnlineStoreConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationTime":
            suggest = "creation_time"
        elif key == "readReplicaCount":
            suggest = "read_replica_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEngineeringMaterializedFeatureOnlineStoreConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEngineeringMaterializedFeatureOnlineStoreConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEngineeringMaterializedFeatureOnlineStoreConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity: _builtins.str,
                 name: _builtins.str,
                 creation_time: Optional[_builtins.str] = None,
                 creator: Optional[_builtins.str] = None,
                 read_replica_count: Optional[_builtins.int] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str capacity: The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        :param _builtins.str name: The name of the online store. This is the unique identifier for the online store
        :param _builtins.str creation_time: (string) - The timestamp when the online store was created
        :param _builtins.str creator: (string) - The email of the creator of the online store
        :param _builtins.int read_replica_count: The number of read replicas for the online store. Defaults to 0
        :param _builtins.str state: (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "name", name)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if creator is not None:
            pulumi.set(__self__, "creator", creator)
        if read_replica_count is not None:
            pulumi.set(__self__, "read_replica_count", read_replica_count)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.str:
        """
        The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the online store. This is the unique identifier for the online store
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.str]:
        """
        (string) - The timestamp when the online store was created
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> Optional[_builtins.str]:
        """
        (string) - The email of the creator of the online store
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="readReplicaCount")
    def read_replica_count(self) -> Optional[_builtins.int]:
        """
        The number of read replicas for the online store. Defaults to 0
        """
        return pulumi.get(self, "read_replica_count")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GrantsGrant(dict):
    def __init__(__self__, *,
                 principal: _builtins.str,
                 privileges: Sequence[_builtins.str]):
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "privileges", privileges)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def privileges(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "privileges")


@pulumi.output_type
class InstancePoolAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str availability: (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        :param _builtins.str instance_profile_arn: Nodes belonging to the pool will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        :param _builtins.int spot_bid_price_percent: (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type's on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        :param _builtins.str zone_id: (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        (String) Availability type used for all instances in the pool. Only `ON_DEMAND` and `SPOT` are supported.
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        """
        Nodes belonging to the pool will only be placed on AWS instances with this instance profile. Please see InstanceProfile resource documentation for extended examples on adding a valid instance profile using Pulumi.
        """
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        """
        (Integer) The max price for AWS spot instances, as a percentage of the corresponding instance type's on-demand price. For example, if this field is set to 50, and the instance pool needs a new i3.xlarge spot instance, then the max price is half of the price of on-demand i3.xlarge instances. Similarly, if this field is set to 200, the max price is twice the price of on-demand i3.xlarge instances. If not specified, the *default value is 100*. When spot instances are requested for this instance pool, only spot instances whose max price percentage matches this field are considered. *For safety, this field cannot be greater than 10000.*
        """
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        (String) Identifier for the availability zone/datacenter in which the instance pool resides. This string is of the form like `"us-west-2a"`. The provided availability zone must be in the same region as the Databricks deployment. For example, `"us-west-2a"` is not a valid zone ID if the Databricks deployment resides in the `"us-east-1"` region. If not specified, a default zone is used. You can find the list of available zones as well as the default value by using the [List Zones API](https://docs.databricks.com/dev-tools/api/latest/clusters.html#clusterclusterservicelistavailablezones).
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class InstancePoolAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability: Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        :param _builtins.float spot_bid_max_price: The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        """
        Availability type used for all nodes. Valid values are `SPOT_AZURE` and `ON_DEMAND_AZURE`.
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        """
        The max bid price used for Azure spot instances. You can set this to greater than or equal to the current spot price. You can also set this to `-1`, which specifies that the instance cannot be evicted on the basis of price. The price for the instance will be the current price for spot instances or the price for a standard instance.
        """
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class InstancePoolDiskSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskCount":
            suggest = "disk_count"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolDiskSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolDiskSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolDiskSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_count: Optional[_builtins.int] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional['outputs.InstancePoolDiskSpecDiskType'] = None):
        """
        :param _builtins.int disk_count: (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        :param _builtins.int disk_size: (Integer) The size of each disk (in GiB) to attach.
        """
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[_builtins.int]:
        """
        (Integer) The number of disks to attach to each instance. This feature is only enabled for supported node types. Users can choose up to the limit of the disks supported by the node type. For node types with no local disk, at least one disk needs to be specified.
        """
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        (Integer) The size of each disk (in GiB) to attach.
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional['outputs.InstancePoolDiskSpecDiskType']:
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class InstancePoolDiskSpecDiskType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureDiskVolumeType":
            suggest = "azure_disk_volume_type"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolDiskSpecDiskType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolDiskSpecDiskType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolDiskSpecDiskType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[_builtins.str] = None,
                 ebs_volume_type: Optional[_builtins.str] = None):
        if azure_disk_volume_type is not None:
            pulumi.set(__self__, "azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)

    @_builtins.property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "azure_disk_volume_type")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")


@pulumi.output_type
class InstancePoolGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpAvailability":
            suggest = "gcp_availability"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_availability: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str gcp_availability: Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        :param _builtins.int local_ssd_count: Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        :param _builtins.str zone_id: Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-central1-a`. The provided availability zone must be in the same region as the Databricks workspace.
        """
        if gcp_availability is not None:
            pulumi.set(__self__, "gcp_availability", gcp_availability)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="gcpAvailability")
    def gcp_availability(self) -> Optional[_builtins.str]:
        """
        Availability type used for all nodes. Valid values are `PREEMPTIBLE_GCP`, `PREEMPTIBLE_WITH_FALLBACK_GCP` and `ON_DEMAND_GCP`, default: `ON_DEMAND_GCP`.
        """
        return pulumi.get(self, "gcp_availability")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        """
        Number of local SSD disks (each is 375GB in size) that will be attached to each node of the cluster.
        """
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Identifier for the availability zone/datacenter in which the cluster resides. This string will be of a form like `us-central1-a`. The provided availability zone must be in the same region as the Databricks workspace.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateOverrides":
            suggest = "launch_template_overrides"
        elif key == "fleetOnDemandOption":
            suggest = "fleet_on_demand_option"
        elif key == "fleetSpotOption":
            suggest = "fleet_spot_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_overrides: Sequence['outputs.InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride'],
                 fleet_on_demand_option: Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetOnDemandOption'] = None,
                 fleet_spot_option: Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetSpotOption'] = None):
        pulumi.set(__self__, "launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            pulumi.set(__self__, "fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            pulumi.set(__self__, "fleet_spot_option", fleet_spot_option)

    @_builtins.property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> Sequence['outputs.InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride']:
        return pulumi.get(self, "launch_template_overrides")

    @_builtins.property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetOnDemandOption']:
        return pulumi.get(self, "fleet_on_demand_option")

    @_builtins.property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional['outputs.InstancePoolInstancePoolFleetAttributesFleetSpotOption']:
        return pulumi.get(self, "fleet_spot_option")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributesFleetOnDemandOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributesFleetOnDemandOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetOnDemandOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetOnDemandOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: _builtins.str,
                 instance_pools_to_use_count: Optional[_builtins.int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> _builtins.str:
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_pools_to_use_count")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributesFleetSpotOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributesFleetSpotOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetSpotOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributesFleetSpotOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: _builtins.str,
                 instance_pools_to_use_count: Optional[_builtins.int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> _builtins.str:
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_pools_to_use_count")


@pulumi.output_type
class InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstancePoolFleetAttributesLaunchTemplateOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 instance_type: _builtins.str):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "instance_type", instance_type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        return pulumi.get(self, "instance_type")


@pulumi.output_type
class InstancePoolPreloadedDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolPreloadedDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolPreloadedDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolPreloadedDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.InstancePoolPreloadedDockerImageBasicAuth'] = None):
        """
        :param _builtins.str url: URL for the Docker image
        :param 'InstancePoolPreloadedDockerImageBasicAuthArgs' basic_auth: `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch.  For better security, these credentials should be stored in the secret scope and referred using secret path syntax: `{{secrets/scope/key}}`, otherwise other users of the workspace may access them via UI/API.
               
               Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL for the Docker image
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.InstancePoolPreloadedDockerImageBasicAuth']:
        """
        `basic_auth.username` and `basic_auth.password` for Docker repository. Docker registry credentials are encrypted when they are stored in Databricks internal storage and when they are passed to a registry upon fetching Docker images at cluster launch.  For better security, these credentials should be stored in the secret scope and referred using secret path syntax: `{{secrets/scope/key}}`, otherwise other users of the workspace may access them via UI/API.

        Example usage with azurerm_container_registry and docker_registry_image, that you can adapt to your specific use-case:
        """
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class InstancePoolPreloadedDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobContinuous(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pauseStatus":
            suggest = "pause_status"
        elif key == "taskRetryMode":
            suggest = "task_retry_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobContinuous. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobContinuous.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobContinuous.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pause_status: Optional[_builtins.str] = None,
                 task_retry_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str pause_status: Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        :param _builtins.str task_retry_mode: Controls task level retry behaviour. Allowed values are:
               * `NEVER` (default): The failed task will not be retried.
               * `ON_FAILURE`: Retry a failed task if at least one other task in the job is still running its first attempt. When this condition is no longer met or the retry limit is reached, the job run is cancelled and a new run is started.
        """
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)
        if task_retry_mode is not None:
            pulumi.set(__self__, "task_retry_mode", task_retry_mode)

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        Indicate whether this continuous job is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @_builtins.property
    @pulumi.getter(name="taskRetryMode")
    def task_retry_mode(self) -> Optional[_builtins.str]:
        """
        Controls task level retry behaviour. Allowed values are:
        * `NEVER` (default): The failed task will not be retried.
        * `ON_FAILURE`: Retry a failed task if at least one other task in the job is still running its first attempt. When this condition is no longer met or the retry limit is reached, the job run is cancelled and a new run is started.
        """
        return pulumi.get(self, "task_retry_mode")


@pulumi.output_type
class JobDbtTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profilesDirectory":
            suggest = "profiles_directory"
        elif key == "projectDirectory":
            suggest = "project_directory"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobDbtTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobDbtTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobDbtTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[_builtins.str],
                 catalog: Optional[_builtins.str] = None,
                 profiles_directory: Optional[_builtins.str] = None,
                 project_directory: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param _builtins.str catalog: The name of the catalog to use inside Unity Catalog.
        :param _builtins.str profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param _builtins.str project_directory: The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
               * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
               * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        :param _builtins.str schema: The name of the schema dbt should run in. Defaults to `default`.
        :param _builtins.str source: The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        :param _builtins.str warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[_builtins.str]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @_builtins.property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[_builtins.str]:
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        return pulumi.get(self, "project_directory")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataFilePath":
            suggest = "metadata_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: _builtins.str,
                 metadata_file_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "kind", kind)
        if metadata_file_path is not None:
            pulumi.set(__self__, "metadata_file_path", metadata_file_path)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metadata_file_path")


@pulumi.output_type
class JobEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"
        elif key == "onDurationWarningThresholdExceededs":
            suggest = "on_duration_warning_threshold_exceededs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onStreamingBacklogExceededs":
            suggest = "on_streaming_backlog_exceededs"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_failures: Optional[Sequence[_builtins.str]] = None,
                 on_starts: Optional[Sequence[_builtins.str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_successes: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param Sequence[_builtins.str] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param Sequence[_builtins.str] on_failures: (List) list of emails to notify when the run fails.
        :param Sequence[_builtins.str] on_starts: (List) list of emails to notify when the run starts.
        :param Sequence[_builtins.str] on_streaming_backlog_exceededs: (List) list of emails to notify when any streaming backlog thresholds are exceeded for any stream.
               
               The following parameter is only available for the job level configuration.
        :param Sequence[_builtins.str] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when any streaming backlog thresholds are exceeded for any stream.

        The following parameter is only available for the job level configuration.
        """
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobEnvironment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentKey":
            suggest = "environment_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobEnvironment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobEnvironment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobEnvironment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_key: _builtins.str,
                 spec: Optional['outputs.JobEnvironmentSpec'] = None):
        """
        :param _builtins.str environment_key: an unique identifier of the Environment.  It will be referenced from `environment_key` attribute of corresponding task.
        :param 'JobEnvironmentSpecArgs' spec: block describing the Environment. Consists of following attributes:
        """
        pulumi.set(__self__, "environment_key", environment_key)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> _builtins.str:
        """
        an unique identifier of the Environment.  It will be referenced from `environment_key` attribute of corresponding task.
        """
        return pulumi.get(self, "environment_key")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.JobEnvironmentSpec']:
        """
        block describing the Environment. Consists of following attributes:
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class JobEnvironmentSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVersion":
            suggest = "environment_version"
        elif key == "javaDependencies":
            suggest = "java_dependencies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobEnvironmentSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobEnvironmentSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobEnvironmentSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client: Optional[_builtins.str] = None,
                 dependencies: Optional[Sequence[_builtins.str]] = None,
                 environment_version: Optional[_builtins.str] = None,
                 java_dependencies: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] dependencies: List of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See [API docs](https://docs.databricks.com/api/workspace/jobs/create#environments-spec-dependencies) for more information.
        :param _builtins.str environment_version: client version used by the environment. Each version comes with a specific Python version and a set of Python packages.
        """
        if client is not None:
            pulumi.set(__self__, "client", client)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if environment_version is not None:
            pulumi.set(__self__, "environment_version", environment_version)
        if java_dependencies is not None:
            pulumi.set(__self__, "java_dependencies", java_dependencies)

    @_builtins.property
    @pulumi.getter
    def client(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client")

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of pip dependencies, as supported by the version of pip in this environment. Each dependency is a pip requirement file line.  See [API docs](https://docs.databricks.com/api/workspace/jobs/create#environments-spec-dependencies) for more information.
        """
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="environmentVersion")
    def environment_version(self) -> Optional[_builtins.str]:
        """
        client version used by the environment. Each version comes with a specific Python version and a set of Python packages.
        """
        return pulumi.get(self, "environment_version")

    @_builtins.property
    @pulumi.getter(name="javaDependencies")
    def java_dependencies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "java_dependencies")


@pulumi.output_type
class JobGitSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gitSnapshot":
            suggest = "git_snapshot"
        elif key == "jobSource":
            suggest = "job_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobGitSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobGitSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobGitSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 branch: Optional[_builtins.str] = None,
                 commit: Optional[_builtins.str] = None,
                 git_snapshot: Optional['outputs.JobGitSourceGitSnapshot'] = None,
                 job_source: Optional['outputs.JobGitSourceJobSource'] = None,
                 provider: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: URL of the Git repository to use.
        :param _builtins.str branch: name of the Git branch to use. Conflicts with `tag` and `commit`.
        :param _builtins.str commit: hash of Git commit to use. Conflicts with `branch` and `tag`.
        :param _builtins.str provider: case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        :param _builtins.str tag: name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        pulumi.set(__self__, "url", url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if git_snapshot is not None:
            pulumi.set(__self__, "git_snapshot", git_snapshot)
        if job_source is not None:
            pulumi.set(__self__, "job_source", job_source)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of the Git repository to use.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        name of the Git branch to use. Conflicts with `tag` and `commit`.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter
    def commit(self) -> Optional[_builtins.str]:
        """
        hash of Git commit to use. Conflicts with `branch` and `tag`.
        """
        return pulumi.get(self, "commit")

    @_builtins.property
    @pulumi.getter(name="gitSnapshot")
    def git_snapshot(self) -> Optional['outputs.JobGitSourceGitSnapshot']:
        return pulumi.get(self, "git_snapshot")

    @_builtins.property
    @pulumi.getter(name="jobSource")
    def job_source(self) -> Optional['outputs.JobGitSourceJobSource']:
        return pulumi.get(self, "job_source")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        case insensitive name of the Git provider.  Following values are supported right now (could be a subject for change, consult [Repos API documentation](https://docs.databricks.com/dev-tools/api/latest/repos.html)): `gitHub`, `gitHubEnterprise`, `bitbucketCloud`, `bitbucketServer`, `azureDevOpsServices`, `gitLab`, `gitLabEnterpriseEdition`.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        name of the Git branch to use. Conflicts with `branch` and `commit`.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class JobGitSourceGitSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usedCommit":
            suggest = "used_commit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobGitSourceGitSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobGitSourceGitSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobGitSourceGitSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 used_commit: Optional[_builtins.str] = None):
        if used_commit is not None:
            pulumi.set(__self__, "used_commit", used_commit)

    @_builtins.property
    @pulumi.getter(name="usedCommit")
    def used_commit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "used_commit")


@pulumi.output_type
class JobGitSourceJobSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "importFromGitBranch":
            suggest = "import_from_git_branch"
        elif key == "jobConfigPath":
            suggest = "job_config_path"
        elif key == "dirtyState":
            suggest = "dirty_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobGitSourceJobSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobGitSourceJobSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobGitSourceJobSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 import_from_git_branch: _builtins.str,
                 job_config_path: _builtins.str,
                 dirty_state: Optional[_builtins.str] = None):
        pulumi.set(__self__, "import_from_git_branch", import_from_git_branch)
        pulumi.set(__self__, "job_config_path", job_config_path)
        if dirty_state is not None:
            pulumi.set(__self__, "dirty_state", dirty_state)

    @_builtins.property
    @pulumi.getter(name="importFromGitBranch")
    def import_from_git_branch(self) -> _builtins.str:
        return pulumi.get(self, "import_from_git_branch")

    @_builtins.property
    @pulumi.getter(name="jobConfigPath")
    def job_config_path(self) -> _builtins.str:
        return pulumi.get(self, "job_config_path")

    @_builtins.property
    @pulumi.getter(name="dirtyState")
    def dirty_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dirty_state")


@pulumi.output_type
class JobHealth(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.JobHealthRule']):
        """
        :param Sequence['JobHealthRuleArgs'] rules: list of rules that are represented as objects with the following attributes:
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.JobHealthRule']:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class JobHealthRule(dict):
    def __init__(__self__, *,
                 metric: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.str metric: string specifying the metric to check, like `RUN_DURATION_SECONDS`, `STREAMING_BACKLOG_FILES`, etc. - check the [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create#health-rules-metric) for the full list of supported metrics.
        :param _builtins.str op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param _builtins.int value: integer value used to compare to the given metric.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        string specifying the metric to check, like `RUN_DURATION_SECONDS`, `STREAMING_BACKLOG_FILES`, etc. - check the [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create#health-rules-metric) for the full list of supported metrics.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JobJobCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobClusterKey":
            suggest = "job_cluster_key"
        elif key == "newCluster":
            suggest = "new_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_cluster_key: _builtins.str,
                 new_cluster: 'outputs.JobJobClusterNewCluster'):
        """
        :param _builtins.str job_cluster_key: Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        :param 'JobJobClusterNewClusterArgs' new_cluster: Block with almost the same set of parameters as for Cluster resource, except following (check the [REST API documentation for full list of supported parameters](https://docs.databricks.com/api/workspace/jobs/create#job_clusters-new_cluster)):
        """
        pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        pulumi.set(__self__, "new_cluster", new_cluster)

    @_builtins.property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> _builtins.str:
        """
        Identifier that can be referenced in `task` block, so that cluster is shared between tasks
        """
        return pulumi.get(self, "job_cluster_key")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> 'outputs.JobJobClusterNewCluster':
        """
        Block with almost the same set of parameters as for Cluster resource, except following (check the [REST API documentation for full list of supported parameters](https://docs.databricks.com/api/workspace/jobs/create#job_clusters-new_cluster)):
        """
        return pulumi.get(self, "new_cluster")


@pulumi.output_type
class JobJobClusterNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "__applyPolicyDefaultValuesAllowLists":
            suggest = "__apply_policy_default_values_allow_lists"
        elif key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterMountInfos":
            suggest = "cluster_mount_infos"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "isSingleNode":
            suggest = "is_single_node"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "providerConfig":
            suggest = "provider_config"
        elif key == "remoteDiskThroughput":
            suggest = "remote_disk_throughput"
        elif key == "runtimeEngine":
            suggest = "runtime_engine"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sparkVersion":
            suggest = "spark_version"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "totalInitialRemoteDiskSize":
            suggest = "total_initial_remote_disk_size"
        elif key == "useMlRuntime":
            suggest = "use_ml_runtime"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 __apply_policy_default_values_allow_lists: Optional[Sequence[_builtins.str]] = None,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.JobJobClusterNewClusterAutoscale'] = None,
                 aws_attributes: Optional['outputs.JobJobClusterNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobJobClusterNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.JobJobClusterNewClusterClusterLogConf'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.JobJobClusterNewClusterClusterMountInfo']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.JobJobClusterNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[_builtins.str] = None,
                 driver_node_type_id: Optional[_builtins.str] = None,
                 enable_elastic_disk: Optional[_builtins.bool] = None,
                 enable_local_disk_encryption: Optional[_builtins.bool] = None,
                 gcp_attributes: Optional['outputs.JobJobClusterNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.JobJobClusterNewClusterInitScript']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 is_single_node: Optional[_builtins.bool] = None,
                 kind: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.JobJobClusterNewClusterLibrary']] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 provider_config: Optional['outputs.JobJobClusterNewClusterProviderConfig'] = None,
                 remote_disk_throughput: Optional[_builtins.int] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 total_initial_remote_disk_size: Optional[_builtins.int] = None,
                 use_ml_runtime: Optional[_builtins.bool] = None,
                 workload_type: Optional['outputs.JobJobClusterNewClusterWorkloadType'] = None):
        """
        :param Sequence['JobJobClusterNewClusterLibraryArgs'] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param 'JobJobClusterNewClusterProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        :param 'JobJobClusterNewClusterWorkloadTypeArgs' workload_type: isn't supported
        """
        if __apply_policy_default_values_allow_lists is not None:
            pulumi.set(__self__, "__apply_policy_default_values_allow_lists", __apply_policy_default_values_allow_lists)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if is_single_node is not None:
            pulumi.set(__self__, "is_single_node", is_single_node)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if remote_disk_throughput is not None:
            pulumi.set(__self__, "remote_disk_throughput", remote_disk_throughput)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if total_initial_remote_disk_size is not None:
            pulumi.set(__self__, "total_initial_remote_disk_size", total_initial_remote_disk_size)
        if use_ml_runtime is not None:
            pulumi.set(__self__, "use_ml_runtime", use_ml_runtime)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="__applyPolicyDefaultValuesAllowLists")
    def __apply_policy_default_values_allow_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "__apply_policy_default_values_allow_lists")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobJobClusterNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobJobClusterNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobJobClusterNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.JobJobClusterNewClusterClusterMountInfo']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobJobClusterNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobJobClusterNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobJobClusterNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="isSingleNode")
    def is_single_node(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_single_node")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobJobClusterNewClusterLibrary']]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobJobClusterNewClusterProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter(name="remoteDiskThroughput")
    def remote_disk_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "remote_disk_throughput")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="totalInitialRemoteDiskSize")
    def total_initial_remote_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_initial_remote_disk_size")

    @_builtins.property
    @pulumi.getter(name="useMlRuntime")
    def use_ml_runtime(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_ml_runtime")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobJobClusterNewClusterWorkloadType']:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobJobClusterNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobJobClusterNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeIops":
            suggest = "ebs_volume_iops"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeThroughput":
            suggest = "ebs_volume_throughput"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobJobClusterNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "logAnalyticsInfo":
            suggest = "log_analytics_info"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsPrimaryKey":
            suggest = "log_analytics_primary_key"
        elif key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobJobClusterNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobJobClusterNewClusterClusterLogConfS3'] = None,
                 volumes: Optional['outputs.JobJobClusterNewClusterClusterLogConfVolumes'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobJobClusterNewClusterClusterLogConfVolumes']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobJobClusterNewClusterClusterLogConfVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterClusterMountInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountDirPath":
            suggest = "local_mount_dir_path"
        elif key == "networkFilesystemInfo":
            suggest = "network_filesystem_info"
        elif key == "remoteMountDirPath":
            suggest = "remote_mount_dir_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterClusterMountInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterClusterMountInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterClusterMountInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class JobJobClusterNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.JobJobClusterNewClusterDockerImageBasicAuth'] = None):
        """
        :param _builtins.str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobJobClusterNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobJobClusterNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobJobClusterNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobJobClusterNewClusterInitScript(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.JobJobClusterNewClusterInitScriptAbfss'] = None,
                 dbfs: Optional['outputs.JobJobClusterNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobJobClusterNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobJobClusterNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobJobClusterNewClusterInitScriptS3'] = None,
                 volumes: Optional['outputs.JobJobClusterNewClusterInitScriptVolumes'] = None,
                 workspace: Optional['outputs.JobJobClusterNewClusterInitScriptWorkspace'] = None):
        """
        :param 'JobJobClusterNewClusterInitScriptFileArgs' file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptAbfss']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptFile']:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptVolumes']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.JobJobClusterNewClusterInitScriptWorkspace']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptAbfss(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterInitScriptWorkspace(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobJobClusterNewClusterLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobJobClusterNewClusterLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobJobClusterNewClusterLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobJobClusterNewClusterLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobJobClusterNewClusterLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobJobClusterNewClusterLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobJobClusterNewClusterLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobJobClusterNewClusterLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobJobClusterNewClusterLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobJobClusterNewClusterLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobJobClusterNewClusterLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobJobClusterNewClusterLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobJobClusterNewClusterLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobJobClusterNewClusterLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobJobClusterNewClusterProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobJobClusterNewClusterProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobJobClusterNewClusterProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobJobClusterNewClusterProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobJobClusterNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobJobClusterNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.JobJobClusterNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobJobClusterNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterMountInfos":
            suggest = "cluster_mount_infos"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "isSingleNode":
            suggest = "is_single_node"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "providerConfig":
            suggest = "provider_config"
        elif key == "remoteDiskThroughput":
            suggest = "remote_disk_throughput"
        elif key == "runtimeEngine":
            suggest = "runtime_engine"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sparkVersion":
            suggest = "spark_version"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "totalInitialRemoteDiskSize":
            suggest = "total_initial_remote_disk_size"
        elif key == "useMlRuntime":
            suggest = "use_ml_runtime"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.JobNewClusterAutoscale'] = None,
                 aws_attributes: Optional['outputs.JobNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.JobNewClusterClusterLogConf'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.JobNewClusterClusterMountInfo']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.JobNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[_builtins.str] = None,
                 driver_node_type_id: Optional[_builtins.str] = None,
                 enable_elastic_disk: Optional[_builtins.bool] = None,
                 enable_local_disk_encryption: Optional[_builtins.bool] = None,
                 gcp_attributes: Optional['outputs.JobNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.JobNewClusterInitScript']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 is_single_node: Optional[_builtins.bool] = None,
                 kind: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.JobNewClusterLibrary']] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 provider_config: Optional['outputs.JobNewClusterProviderConfig'] = None,
                 remote_disk_throughput: Optional[_builtins.int] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 total_initial_remote_disk_size: Optional[_builtins.int] = None,
                 use_ml_runtime: Optional[_builtins.bool] = None,
                 workload_type: Optional['outputs.JobNewClusterWorkloadType'] = None):
        """
        :param Sequence['JobNewClusterLibraryArgs'] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param 'JobNewClusterProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        :param 'JobNewClusterWorkloadTypeArgs' workload_type: isn't supported
        """
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if is_single_node is not None:
            pulumi.set(__self__, "is_single_node", is_single_node)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if remote_disk_throughput is not None:
            pulumi.set(__self__, "remote_disk_throughput", remote_disk_throughput)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if total_initial_remote_disk_size is not None:
            pulumi.set(__self__, "total_initial_remote_disk_size", total_initial_remote_disk_size)
        if use_ml_runtime is not None:
            pulumi.set(__self__, "use_ml_runtime", use_ml_runtime)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.JobNewClusterClusterMountInfo']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="isSingleNode")
    def is_single_node(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_single_node")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobNewClusterLibrary']]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobNewClusterProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter(name="remoteDiskThroughput")
    def remote_disk_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "remote_disk_throughput")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="totalInitialRemoteDiskSize")
    def total_initial_remote_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_initial_remote_disk_size")

    @_builtins.property
    @pulumi.getter(name="useMlRuntime")
    def use_ml_runtime(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_ml_runtime")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobNewClusterWorkloadType']:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeIops":
            suggest = "ebs_volume_iops"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeThroughput":
            suggest = "ebs_volume_throughput"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "logAnalyticsInfo":
            suggest = "log_analytics_info"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.JobNewClusterAzureAttributesLogAnalyticsInfo'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.JobNewClusterAzureAttributesLogAnalyticsInfo']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobNewClusterAzureAttributesLogAnalyticsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsPrimaryKey":
            suggest = "log_analytics_primary_key"
        elif key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterAzureAttributesLogAnalyticsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class JobNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobNewClusterClusterLogConfS3'] = None,
                 volumes: Optional['outputs.JobNewClusterClusterLogConfVolumes'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobNewClusterClusterLogConfVolumes']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class JobNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobNewClusterClusterLogConfVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterClusterMountInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountDirPath":
            suggest = "local_mount_dir_path"
        elif key == "networkFilesystemInfo":
            suggest = "network_filesystem_info"
        elif key == "remoteMountDirPath":
            suggest = "remote_mount_dir_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterClusterMountInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterClusterMountInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterClusterMountInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.JobNewClusterClusterMountInfoNetworkFilesystemInfo',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.JobNewClusterClusterMountInfoNetworkFilesystemInfo':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class JobNewClusterClusterMountInfoNetworkFilesystemInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterClusterMountInfoNetworkFilesystemInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class JobNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.JobNewClusterDockerImageBasicAuth'] = None):
        """
        :param _builtins.str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobNewClusterInitScript(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.JobNewClusterInitScriptAbfss'] = None,
                 dbfs: Optional['outputs.JobNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobNewClusterInitScriptS3'] = None,
                 volumes: Optional['outputs.JobNewClusterInitScriptVolumes'] = None,
                 workspace: Optional['outputs.JobNewClusterInitScriptWorkspace'] = None):
        """
        :param 'JobNewClusterInitScriptFileArgs' file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.JobNewClusterInitScriptAbfss']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.JobNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobNewClusterInitScriptFile']:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobNewClusterInitScriptVolumes']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.JobNewClusterInitScriptWorkspace']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class JobNewClusterInitScriptAbfss(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobNewClusterInitScriptVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterInitScriptWorkspace(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobNewClusterLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobNewClusterLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobNewClusterLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobNewClusterLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobNewClusterLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobNewClusterLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobNewClusterLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobNewClusterLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobNewClusterLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobNewClusterLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobNewClusterLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobNewClusterLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobNewClusterLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobNewClusterLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobNewClusterProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNewClusterProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNewClusterProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNewClusterProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.JobNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPath":
            suggest = "notebook_path"
        elif key == "baseParameters":
            suggest = "base_parameters"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_path: _builtins.str,
                 base_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param Mapping[str, _builtins.str] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job's base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param _builtins.str source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        :param _builtins.str warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> _builtins.str:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @_builtins.property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job's base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAlertForCanceledRuns":
            suggest = "no_alert_for_canceled_runs"
        elif key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_alert_for_canceled_runs: Optional[_builtins.bool] = None,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
               
               The following parameter is only available on task level.
        :param _builtins.bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @_builtins.property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")


@pulumi.output_type
class JobParameter(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str default: Default value of the parameter.
               
               *You can use this block only together with `task` blocks, not with the legacy tasks specification!*
        :param _builtins.str name: The name of the defined parameter. May only contain alphanumeric characters, `_`, `-`, and `.`.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        """
        Default value of the parameter.

        *You can use this block only together with `task` blocks, not with the legacy tasks specification!*
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the defined parameter. May only contain alphanumeric characters, `_`, `-`, and `.`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class JobPipelineTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "fullRefresh":
            suggest = "full_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobPipelineTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobPipelineTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobPipelineTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: _builtins.str,
                 full_refresh: Optional[_builtins.bool] = None):
        """
        :param _builtins.str pipeline_id: The pipeline's unique ID.
        :param _builtins.bool full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class JobProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobPythonWheelTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "namedParameters":
            suggest = "named_parameters"
        elif key == "packageName":
            suggest = "package_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobPythonWheelTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobPythonWheelTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobPythonWheelTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point: Optional[_builtins.str] = None,
                 named_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 package_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str entry_point: Python function as entry point for the task
        :param Mapping[str, _builtins.str] named_parameters: Named parameters for the task
        :param _builtins.str package_name: Name of Python package
        :param Sequence[_builtins.str] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobQueue(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: If true, enable queueing for the job.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If true, enable queueing for the job.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class JobRunAs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "servicePrincipalName":
            suggest = "service_principal_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobRunAs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobRunAs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobRunAs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               this = databricks.Job("this", run_as={
                   "service_principal_name": "8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
               })
               ```
        :param _builtins.str user_name: The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        The application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role.

        Example:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        this = databricks.Job("this", run_as={
            "service_principal_name": "8d23ae77-912e-4a19-81e4-b9c3f5cc9349",
        })
        ```
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        The email of an active workspace user. Non-admin users can only set this field to their own email.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobRunJobTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobId":
            suggest = "job_id"
        elif key == "jobParameters":
            suggest = "job_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobRunJobTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobRunJobTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobRunJobTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_id: _builtins.int,
                 job_parameters: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int job_id: (String) ID of the job
        :param Mapping[str, _builtins.str] job_parameters: (Map) Job parameters for the task
        """
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.int:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")


@pulumi.output_type
class JobSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronExpression":
            suggest = "quartz_cron_expression"
        elif key == "timezoneId":
            suggest = "timezone_id"
        elif key == "pauseStatus":
            suggest = "pause_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_expression: A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        :param _builtins.str timezone_id: A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        :param _builtins.str pause_status: Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        """
        A [Cron expression using Quartz syntax](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) that describes the schedule for a job. This field is required.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        A Java timezone ID. The schedule for a job will be resolved with respect to this timezone. See Java TimeZone for details. This field is required.
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        Indicate whether this schedule is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted and a schedule is provided, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class JobSparkJarTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jarUri":
            suggest = "jar_uri"
        elif key == "mainClassName":
            suggest = "main_class_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSparkJarTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSparkJarTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSparkJarTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar_uri: Optional[_builtins.str] = None,
                 main_class_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param Sequence[_builtins.str] parameters: (List) Parameters passed to the main method.
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar_uri")

    @_builtins.property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[_builtins.str]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobSparkPythonTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonFile":
            suggest = "python_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobSparkPythonTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobSparkPythonTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobSparkPythonTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_file: _builtins.str,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str python_file: The URI of the Python file to be executed. Cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/`. For files stored in a remote repository, the path must be relative. This field is required.
        :param Sequence[_builtins.str] parameters: (List) Command line parameters passed to the Python file.
        :param _builtins.str source: Location type of the Python file. When set to `WORKSPACE` or not specified, the file will be retrieved from the local Databricks workspace or cloud location (if the python_file has a URI format). When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
               * `WORKSPACE`: The Python file is located in a Databricks workspace or at a cloud filesystem URI.
               * `GIT`: The Python file is located in a remote Git repository.
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> _builtins.str:
        """
        The URI of the Python file to be executed. Cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Location type of the Python file. When set to `WORKSPACE` or not specified, the file will be retrieved from the local Databricks workspace or cloud location (if the python_file has a URI format). When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        * `WORKSPACE`: The Python file is located in a Databricks workspace or at a cloud filesystem URI.
        * `GIT`: The Python file is located in a remote Git repository.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class JobSparkSubmitTask(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] parameters: (List) Command-line parameters passed to spark submit.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskKey":
            suggest = "task_key"
        elif key == "cleanRoomsNotebookTask":
            suggest = "clean_rooms_notebook_task"
        elif key == "conditionTask":
            suggest = "condition_task"
        elif key == "dashboardTask":
            suggest = "dashboard_task"
        elif key == "dbtCloudTask":
            suggest = "dbt_cloud_task"
        elif key == "dbtPlatformTask":
            suggest = "dbt_platform_task"
        elif key == "dbtTask":
            suggest = "dbt_task"
        elif key == "dependsOns":
            suggest = "depends_ons"
        elif key == "disableAutoOptimization":
            suggest = "disable_auto_optimization"
        elif key == "emailNotifications":
            suggest = "email_notifications"
        elif key == "environmentKey":
            suggest = "environment_key"
        elif key == "existingClusterId":
            suggest = "existing_cluster_id"
        elif key == "forEachTask":
            suggest = "for_each_task"
        elif key == "genAiComputeTask":
            suggest = "gen_ai_compute_task"
        elif key == "jobClusterKey":
            suggest = "job_cluster_key"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "minRetryIntervalMillis":
            suggest = "min_retry_interval_millis"
        elif key == "newCluster":
            suggest = "new_cluster"
        elif key == "notebookTask":
            suggest = "notebook_task"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "pipelineTask":
            suggest = "pipeline_task"
        elif key == "powerBiTask":
            suggest = "power_bi_task"
        elif key == "pythonWheelTask":
            suggest = "python_wheel_task"
        elif key == "retryOnTimeout":
            suggest = "retry_on_timeout"
        elif key == "runIf":
            suggest = "run_if"
        elif key == "runJobTask":
            suggest = "run_job_task"
        elif key == "sparkJarTask":
            suggest = "spark_jar_task"
        elif key == "sparkPythonTask":
            suggest = "spark_python_task"
        elif key == "sparkSubmitTask":
            suggest = "spark_submit_task"
        elif key == "sqlTask":
            suggest = "sql_task"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"
        elif key == "webhookNotifications":
            suggest = "webhook_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_key: _builtins.str,
                 clean_rooms_notebook_task: Optional['outputs.JobTaskCleanRoomsNotebookTask'] = None,
                 condition_task: Optional['outputs.JobTaskConditionTask'] = None,
                 dashboard_task: Optional['outputs.JobTaskDashboardTask'] = None,
                 dbt_cloud_task: Optional['outputs.JobTaskDbtCloudTask'] = None,
                 dbt_platform_task: Optional['outputs.JobTaskDbtPlatformTask'] = None,
                 dbt_task: Optional['outputs.JobTaskDbtTask'] = None,
                 depends_ons: Optional[Sequence['outputs.JobTaskDependsOn']] = None,
                 description: Optional[_builtins.str] = None,
                 disable_auto_optimization: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 email_notifications: Optional['outputs.JobTaskEmailNotifications'] = None,
                 environment_key: Optional[_builtins.str] = None,
                 existing_cluster_id: Optional[_builtins.str] = None,
                 for_each_task: Optional['outputs.JobTaskForEachTask'] = None,
                 gen_ai_compute_task: Optional['outputs.JobTaskGenAiComputeTask'] = None,
                 health: Optional['outputs.JobTaskHealth'] = None,
                 job_cluster_key: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.JobTaskLibrary']] = None,
                 max_retries: Optional[_builtins.int] = None,
                 min_retry_interval_millis: Optional[_builtins.int] = None,
                 new_cluster: Optional['outputs.JobTaskNewCluster'] = None,
                 notebook_task: Optional['outputs.JobTaskNotebookTask'] = None,
                 notification_settings: Optional['outputs.JobTaskNotificationSettings'] = None,
                 pipeline_task: Optional['outputs.JobTaskPipelineTask'] = None,
                 power_bi_task: Optional['outputs.JobTaskPowerBiTask'] = None,
                 python_wheel_task: Optional['outputs.JobTaskPythonWheelTask'] = None,
                 retry_on_timeout: Optional[_builtins.bool] = None,
                 run_if: Optional[_builtins.str] = None,
                 run_job_task: Optional['outputs.JobTaskRunJobTask'] = None,
                 spark_jar_task: Optional['outputs.JobTaskSparkJarTask'] = None,
                 spark_python_task: Optional['outputs.JobTaskSparkPythonTask'] = None,
                 spark_submit_task: Optional['outputs.JobTaskSparkSubmitTask'] = None,
                 sql_task: Optional['outputs.JobTaskSqlTask'] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 webhook_notifications: Optional['outputs.JobTaskWebhookNotifications'] = None):
        """
        :param _builtins.str task_key: string specifying an unique key for a given task.
               * `*_task` - (Required) one of the specific task blocks described below:
        :param Sequence['JobTaskDependsOnArgs'] depends_ons: block specifying dependency(-ies) for a given task.
        :param _builtins.str description: description for this task.
        :param _builtins.bool disable_auto_optimization: A flag to disable auto optimization in serverless tasks.
        :param 'JobTaskEmailNotificationsArgs' email_notifications: An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        :param _builtins.str environment_key: identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        :param _builtins.str existing_cluster_id: Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        :param 'JobTaskHealthArgs' health: block described below that specifies health conditions for a given task.
        :param _builtins.str job_cluster_key: Identifier of the Job cluster specified in the `job_cluster` block.
        :param Sequence['JobTaskLibraryArgs'] libraries: (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        :param _builtins.int max_retries: (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        :param _builtins.int min_retry_interval_millis: (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        :param 'JobTaskNewClusterArgs' new_cluster: Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        :param 'JobTaskNotificationSettingsArgs' notification_settings: An optional block controlling the notification settings on the job level documented below.
        :param _builtins.bool retry_on_timeout: (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        :param _builtins.str run_if: An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        :param _builtins.int timeout_seconds: (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        :param 'JobTaskWebhookNotificationsArgs' webhook_notifications: (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
               
               > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        pulumi.set(__self__, "task_key", task_key)
        if clean_rooms_notebook_task is not None:
            pulumi.set(__self__, "clean_rooms_notebook_task", clean_rooms_notebook_task)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dashboard_task is not None:
            pulumi.set(__self__, "dashboard_task", dashboard_task)
        if dbt_cloud_task is not None:
            pulumi.set(__self__, "dbt_cloud_task", dbt_cloud_task)
        if dbt_platform_task is not None:
            pulumi.set(__self__, "dbt_platform_task", dbt_platform_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_auto_optimization is not None:
            pulumi.set(__self__, "disable_auto_optimization", disable_auto_optimization)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if for_each_task is not None:
            pulumi.set(__self__, "for_each_task", for_each_task)
        if gen_ai_compute_task is not None:
            pulumi.set(__self__, "gen_ai_compute_task", gen_ai_compute_task)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if power_bi_task is not None:
            pulumi.set(__self__, "power_bi_task", power_bi_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter(name="cleanRoomsNotebookTask")
    def clean_rooms_notebook_task(self) -> Optional['outputs.JobTaskCleanRoomsNotebookTask']:
        return pulumi.get(self, "clean_rooms_notebook_task")

    @_builtins.property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['outputs.JobTaskConditionTask']:
        return pulumi.get(self, "condition_task")

    @_builtins.property
    @pulumi.getter(name="dashboardTask")
    def dashboard_task(self) -> Optional['outputs.JobTaskDashboardTask']:
        return pulumi.get(self, "dashboard_task")

    @_builtins.property
    @pulumi.getter(name="dbtCloudTask")
    def dbt_cloud_task(self) -> Optional['outputs.JobTaskDbtCloudTask']:
        return pulumi.get(self, "dbt_cloud_task")

    @_builtins.property
    @pulumi.getter(name="dbtPlatformTask")
    def dbt_platform_task(self) -> Optional['outputs.JobTaskDbtPlatformTask']:
        return pulumi.get(self, "dbt_platform_task")

    @_builtins.property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['outputs.JobTaskDbtTask']:
        return pulumi.get(self, "dbt_task")

    @_builtins.property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['outputs.JobTaskDependsOn']]:
        """
        block specifying dependency(-ies) for a given task.
        """
        return pulumi.get(self, "depends_ons")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        description for this task.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoOptimization")
    def disable_auto_optimization(self) -> Optional[_builtins.bool]:
        """
        A flag to disable auto optimization in serverless tasks.
        """
        return pulumi.get(self, "disable_auto_optimization")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['outputs.JobTaskEmailNotifications']:
        """
        An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        """
        return pulumi.get(self, "email_notifications")

    @_builtins.property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[_builtins.str]:
        """
        identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        """
        return pulumi.get(self, "environment_key")

    @_builtins.property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        """
        return pulumi.get(self, "existing_cluster_id")

    @_builtins.property
    @pulumi.getter(name="forEachTask")
    def for_each_task(self) -> Optional['outputs.JobTaskForEachTask']:
        return pulumi.get(self, "for_each_task")

    @_builtins.property
    @pulumi.getter(name="genAiComputeTask")
    def gen_ai_compute_task(self) -> Optional['outputs.JobTaskGenAiComputeTask']:
        return pulumi.get(self, "gen_ai_compute_task")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional['outputs.JobTaskHealth']:
        """
        block described below that specifies health conditions for a given task.
        """
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[_builtins.str]:
        """
        Identifier of the Job cluster specified in the `job_cluster` block.
        """
        return pulumi.get(self, "job_cluster_key")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobTaskLibrary']]:
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[_builtins.int]:
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        return pulumi.get(self, "min_retry_interval_millis")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.JobTaskNewCluster']:
        """
        Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        """
        return pulumi.get(self, "new_cluster")

    @_builtins.property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['outputs.JobTaskNotebookTask']:
        return pulumi.get(self, "notebook_task")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.JobTaskNotificationSettings']:
        """
        An optional block controlling the notification settings on the job level documented below.
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['outputs.JobTaskPipelineTask']:
        return pulumi.get(self, "pipeline_task")

    @_builtins.property
    @pulumi.getter(name="powerBiTask")
    def power_bi_task(self) -> Optional['outputs.JobTaskPowerBiTask']:
        return pulumi.get(self, "power_bi_task")

    @_builtins.property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['outputs.JobTaskPythonWheelTask']:
        return pulumi.get(self, "python_wheel_task")

    @_builtins.property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[_builtins.bool]:
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        return pulumi.get(self, "retry_on_timeout")

    @_builtins.property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[_builtins.str]:
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        """
        return pulumi.get(self, "run_if")

    @_builtins.property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['outputs.JobTaskRunJobTask']:
        return pulumi.get(self, "run_job_task")

    @_builtins.property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['outputs.JobTaskSparkJarTask']:
        return pulumi.get(self, "spark_jar_task")

    @_builtins.property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['outputs.JobTaskSparkPythonTask']:
        return pulumi.get(self, "spark_python_task")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['outputs.JobTaskSparkSubmitTask']:
        return pulumi.get(self, "spark_submit_task")

    @_builtins.property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['outputs.JobTaskSqlTask']:
        return pulumi.get(self, "sql_task")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['outputs.JobTaskWebhookNotifications']:
        """
        (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.

        > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        return pulumi.get(self, "webhook_notifications")


@pulumi.output_type
class JobTaskCleanRoomsNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanRoomName":
            suggest = "clean_room_name"
        elif key == "notebookName":
            suggest = "notebook_name"
        elif key == "notebookBaseParameters":
            suggest = "notebook_base_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskCleanRoomsNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskCleanRoomsNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskCleanRoomsNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clean_room_name: _builtins.str,
                 notebook_name: _builtins.str,
                 etag: Optional[_builtins.str] = None,
                 notebook_base_parameters: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str clean_room_name: The clean room that the notebook belongs to.
        :param _builtins.str notebook_name: Name of the notebook being run.
        :param _builtins.str etag: Checksum to validate the freshness of the notebook resource.
        :param Mapping[str, _builtins.str] notebook_base_parameters: Base parameters to be used for the clean room notebook job.
        """
        pulumi.set(__self__, "clean_room_name", clean_room_name)
        pulumi.set(__self__, "notebook_name", notebook_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if notebook_base_parameters is not None:
            pulumi.set(__self__, "notebook_base_parameters", notebook_base_parameters)

    @_builtins.property
    @pulumi.getter(name="cleanRoomName")
    def clean_room_name(self) -> _builtins.str:
        """
        The clean room that the notebook belongs to.
        """
        return pulumi.get(self, "clean_room_name")

    @_builtins.property
    @pulumi.getter(name="notebookName")
    def notebook_name(self) -> _builtins.str:
        """
        Name of the notebook being run.
        """
        return pulumi.get(self, "notebook_name")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        Checksum to validate the freshness of the notebook resource.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="notebookBaseParameters")
    def notebook_base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Base parameters to be used for the clean room notebook job.
        """
        return pulumi.get(self, "notebook_base_parameters")


@pulumi.output_type
class JobTaskConditionTask(dict):
    def __init__(__self__, *,
                 left: _builtins.str,
                 op: _builtins.str,
                 right: _builtins.str):
        """
        :param _builtins.str left: The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        :param _builtins.str op: The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
               
               This task does not require a cluster to execute and does not support retries or notifications.
        :param _builtins.str right: The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @_builtins.property
    @pulumi.getter
    def left(self) -> _builtins.str:
        """
        The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        """
        return pulumi.get(self, "left")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).

        This task does not require a cluster to execute and does not support retries or notifications.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def right(self) -> _builtins.str:
        """
        The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        return pulumi.get(self, "right")


@pulumi.output_type
class JobTaskDashboardTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDashboardTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDashboardTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDashboardTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_id: Optional[_builtins.str] = None,
                 subscription: Optional['outputs.JobTaskDashboardTaskSubscription'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str dashboard_id: The identifier of the dashboard to refresh
        :param 'JobTaskDashboardTaskSubscriptionArgs' subscription: Represents a subscription configuration for scheduled dashboard snapshots.
        :param _builtins.str warehouse_id: The warehouse id to execute the dashboard with for the schedule. If not specified, will use the default warehouse of dashboard
        """
        if dashboard_id is not None:
            pulumi.set(__self__, "dashboard_id", dashboard_id)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the dashboard to refresh
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.JobTaskDashboardTaskSubscription']:
        """
        Represents a subscription configuration for scheduled dashboard snapshots.
        """
        return pulumi.get(self, "subscription")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The warehouse id to execute the dashboard with for the schedule. If not specified, will use the default warehouse of dashboard
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskDashboardTaskSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSubject":
            suggest = "custom_subject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDashboardTaskSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDashboardTaskSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDashboardTaskSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_subject: Optional[_builtins.str] = None,
                 paused: Optional[_builtins.bool] = None,
                 subscribers: Optional[Sequence['outputs.JobTaskDashboardTaskSubscriptionSubscriber']] = None):
        """
        :param _builtins.str custom_subject: Allows users to specify a custom subject line on the email sent to subscribers.
        :param _builtins.bool paused: When true, the subscription will not send emails.
        :param Sequence['JobTaskDashboardTaskSubscriptionSubscriberArgs'] subscribers: The list of subscribers to send the snapshot of the dashboard to.
        """
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        """
        Allows users to specify a custom subject line on the email sent to subscribers.
        """
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        When true, the subscription will not send emails.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.JobTaskDashboardTaskSubscriptionSubscriber']]:
        """
        The list of subscribers to send the snapshot of the dashboard to.
        """
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class JobTaskDashboardTaskSubscriptionSubscriber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDashboardTaskSubscriptionSubscriber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDashboardTaskSubscriptionSubscriber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDashboardTaskSubscriptionSubscriber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        :param _builtins.str user_name: A snapshot of the dashboard will be sent to the user's email when the `user_name` field is present.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the user's email when the `user_name` field is present.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobTaskDbtCloudTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionResourceName":
            suggest = "connection_resource_name"
        elif key == "dbtCloudJobId":
            suggest = "dbt_cloud_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDbtCloudTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDbtCloudTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDbtCloudTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 dbt_cloud_job_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str connection_resource_name: The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if dbt_cloud_job_id is not None:
            pulumi.set(__self__, "dbt_cloud_job_id", dbt_cloud_job_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        """
        The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="dbtCloudJobId")
    def dbt_cloud_job_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "dbt_cloud_job_id")


@pulumi.output_type
class JobTaskDbtPlatformTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionResourceName":
            suggest = "connection_resource_name"
        elif key == "dbtPlatformJobId":
            suggest = "dbt_platform_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDbtPlatformTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDbtPlatformTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDbtPlatformTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 dbt_platform_job_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_resource_name: The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if dbt_platform_job_id is not None:
            pulumi.set(__self__, "dbt_platform_job_id", dbt_platform_job_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        """
        The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="dbtPlatformJobId")
    def dbt_platform_job_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dbt_platform_job_id")


@pulumi.output_type
class JobTaskDbtTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profilesDirectory":
            suggest = "profiles_directory"
        elif key == "projectDirectory":
            suggest = "project_directory"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDbtTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDbtTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDbtTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[_builtins.str],
                 catalog: Optional[_builtins.str] = None,
                 profiles_directory: Optional[_builtins.str] = None,
                 project_directory: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param _builtins.str catalog: The name of the catalog to use inside Unity Catalog.
        :param _builtins.str profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param _builtins.str project_directory: The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
               * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
               * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        :param _builtins.str schema: The name of the schema dbt should run in. Defaults to `default`.
        :param _builtins.str source: The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        :param _builtins.str warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[_builtins.str]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @_builtins.property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[_builtins.str]:
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        return pulumi.get(self, "project_directory")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskDependsOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskKey":
            suggest = "task_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskDependsOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskDependsOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskDependsOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_key: _builtins.str,
                 outcome: Optional[_builtins.str] = None):
        """
        :param _builtins.str task_key: The name of the task this task depends on.
        :param _builtins.str outcome: Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.
               
               > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        """
        The name of the task this task depends on.
        """
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter
    def outcome(self) -> Optional[_builtins.str]:
        """
        Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.

        > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        return pulumi.get(self, "outcome")


@pulumi.output_type
class JobTaskEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"
        elif key == "onDurationWarningThresholdExceededs":
            suggest = "on_duration_warning_threshold_exceededs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onStreamingBacklogExceededs":
            suggest = "on_streaming_backlog_exceededs"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_failures: Optional[Sequence[_builtins.str]] = None,
                 on_starts: Optional[Sequence[_builtins.str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_successes: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param Sequence[_builtins.str] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param Sequence[_builtins.str] on_failures: (List) list of emails to notify when the run fails.
        :param Sequence[_builtins.str] on_starts: (List) list of emails to notify when the run starts.
        :param Sequence[_builtins.str] on_streaming_backlog_exceededs: (List) list of emails to notify when any streaming backlog thresholds are exceeded for any stream.
               
               The following parameter is only available for the job level configuration.
        :param Sequence[_builtins.str] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when any streaming backlog thresholds are exceeded for any stream.

        The following parameter is only available for the job level configuration.
        """
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobTaskForEachTask(dict):
    def __init__(__self__, *,
                 inputs: _builtins.str,
                 task: 'outputs.JobTaskForEachTaskTask',
                 concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.str inputs: (String) Array for task to iterate on. This can be a JSON string or a reference to an array parameter.
        :param 'JobTaskForEachTaskTaskArgs' task: Task to run against the `inputs` list.
        :param _builtins.int concurrency: Controls the number of active iteration task runs. Default is 20, maximum allowed is 100.
        """
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "task", task)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> _builtins.str:
        """
        (String) Array for task to iterate on. This can be a JSON string or a reference to an array parameter.
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def task(self) -> 'outputs.JobTaskForEachTaskTask':
        """
        Task to run against the `inputs` list.
        """
        return pulumi.get(self, "task")

    @_builtins.property
    @pulumi.getter
    def concurrency(self) -> Optional[_builtins.int]:
        """
        Controls the number of active iteration task runs. Default is 20, maximum allowed is 100.
        """
        return pulumi.get(self, "concurrency")


@pulumi.output_type
class JobTaskForEachTaskTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskKey":
            suggest = "task_key"
        elif key == "cleanRoomsNotebookTask":
            suggest = "clean_rooms_notebook_task"
        elif key == "conditionTask":
            suggest = "condition_task"
        elif key == "dashboardTask":
            suggest = "dashboard_task"
        elif key == "dbtCloudTask":
            suggest = "dbt_cloud_task"
        elif key == "dbtPlatformTask":
            suggest = "dbt_platform_task"
        elif key == "dbtTask":
            suggest = "dbt_task"
        elif key == "dependsOns":
            suggest = "depends_ons"
        elif key == "disableAutoOptimization":
            suggest = "disable_auto_optimization"
        elif key == "emailNotifications":
            suggest = "email_notifications"
        elif key == "environmentKey":
            suggest = "environment_key"
        elif key == "existingClusterId":
            suggest = "existing_cluster_id"
        elif key == "genAiComputeTask":
            suggest = "gen_ai_compute_task"
        elif key == "jobClusterKey":
            suggest = "job_cluster_key"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "minRetryIntervalMillis":
            suggest = "min_retry_interval_millis"
        elif key == "newCluster":
            suggest = "new_cluster"
        elif key == "notebookTask":
            suggest = "notebook_task"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "pipelineTask":
            suggest = "pipeline_task"
        elif key == "powerBiTask":
            suggest = "power_bi_task"
        elif key == "pythonWheelTask":
            suggest = "python_wheel_task"
        elif key == "retryOnTimeout":
            suggest = "retry_on_timeout"
        elif key == "runIf":
            suggest = "run_if"
        elif key == "runJobTask":
            suggest = "run_job_task"
        elif key == "sparkJarTask":
            suggest = "spark_jar_task"
        elif key == "sparkPythonTask":
            suggest = "spark_python_task"
        elif key == "sparkSubmitTask":
            suggest = "spark_submit_task"
        elif key == "sqlTask":
            suggest = "sql_task"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"
        elif key == "webhookNotifications":
            suggest = "webhook_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_key: _builtins.str,
                 clean_rooms_notebook_task: Optional['outputs.JobTaskForEachTaskTaskCleanRoomsNotebookTask'] = None,
                 condition_task: Optional['outputs.JobTaskForEachTaskTaskConditionTask'] = None,
                 dashboard_task: Optional['outputs.JobTaskForEachTaskTaskDashboardTask'] = None,
                 dbt_cloud_task: Optional['outputs.JobTaskForEachTaskTaskDbtCloudTask'] = None,
                 dbt_platform_task: Optional['outputs.JobTaskForEachTaskTaskDbtPlatformTask'] = None,
                 dbt_task: Optional['outputs.JobTaskForEachTaskTaskDbtTask'] = None,
                 depends_ons: Optional[Sequence['outputs.JobTaskForEachTaskTaskDependsOn']] = None,
                 description: Optional[_builtins.str] = None,
                 disable_auto_optimization: Optional[_builtins.bool] = None,
                 disabled: Optional[_builtins.bool] = None,
                 email_notifications: Optional['outputs.JobTaskForEachTaskTaskEmailNotifications'] = None,
                 environment_key: Optional[_builtins.str] = None,
                 existing_cluster_id: Optional[_builtins.str] = None,
                 gen_ai_compute_task: Optional['outputs.JobTaskForEachTaskTaskGenAiComputeTask'] = None,
                 health: Optional['outputs.JobTaskForEachTaskTaskHealth'] = None,
                 job_cluster_key: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.JobTaskForEachTaskTaskLibrary']] = None,
                 max_retries: Optional[_builtins.int] = None,
                 min_retry_interval_millis: Optional[_builtins.int] = None,
                 new_cluster: Optional['outputs.JobTaskForEachTaskTaskNewCluster'] = None,
                 notebook_task: Optional['outputs.JobTaskForEachTaskTaskNotebookTask'] = None,
                 notification_settings: Optional['outputs.JobTaskForEachTaskTaskNotificationSettings'] = None,
                 pipeline_task: Optional['outputs.JobTaskForEachTaskTaskPipelineTask'] = None,
                 power_bi_task: Optional['outputs.JobTaskForEachTaskTaskPowerBiTask'] = None,
                 python_wheel_task: Optional['outputs.JobTaskForEachTaskTaskPythonWheelTask'] = None,
                 retry_on_timeout: Optional[_builtins.bool] = None,
                 run_if: Optional[_builtins.str] = None,
                 run_job_task: Optional['outputs.JobTaskForEachTaskTaskRunJobTask'] = None,
                 spark_jar_task: Optional['outputs.JobTaskForEachTaskTaskSparkJarTask'] = None,
                 spark_python_task: Optional['outputs.JobTaskForEachTaskTaskSparkPythonTask'] = None,
                 spark_submit_task: Optional['outputs.JobTaskForEachTaskTaskSparkSubmitTask'] = None,
                 sql_task: Optional['outputs.JobTaskForEachTaskTaskSqlTask'] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 webhook_notifications: Optional['outputs.JobTaskForEachTaskTaskWebhookNotifications'] = None):
        """
        :param _builtins.str task_key: string specifying an unique key for a given task.
               * `*_task` - (Required) one of the specific task blocks described below:
        :param Sequence['JobTaskForEachTaskTaskDependsOnArgs'] depends_ons: block specifying dependency(-ies) for a given task.
        :param _builtins.str description: description for this task.
        :param _builtins.bool disable_auto_optimization: A flag to disable auto optimization in serverless tasks.
        :param 'JobTaskForEachTaskTaskEmailNotificationsArgs' email_notifications: An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        :param _builtins.str environment_key: identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        :param _builtins.str existing_cluster_id: Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        :param 'JobTaskForEachTaskTaskHealthArgs' health: block described below that specifies health conditions for a given task.
        :param _builtins.str job_cluster_key: Identifier of the Job cluster specified in the `job_cluster` block.
        :param Sequence['JobTaskForEachTaskTaskLibraryArgs'] libraries: (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        :param _builtins.int max_retries: (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        :param _builtins.int min_retry_interval_millis: (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        :param 'JobTaskForEachTaskTaskNewClusterArgs' new_cluster: Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        :param 'JobTaskForEachTaskTaskNotificationSettingsArgs' notification_settings: An optional block controlling the notification settings on the job level documented below.
        :param _builtins.bool retry_on_timeout: (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        :param _builtins.str run_if: An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        :param _builtins.int timeout_seconds: (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        :param 'JobTaskForEachTaskTaskWebhookNotificationsArgs' webhook_notifications: (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
               
               > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        pulumi.set(__self__, "task_key", task_key)
        if clean_rooms_notebook_task is not None:
            pulumi.set(__self__, "clean_rooms_notebook_task", clean_rooms_notebook_task)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dashboard_task is not None:
            pulumi.set(__self__, "dashboard_task", dashboard_task)
        if dbt_cloud_task is not None:
            pulumi.set(__self__, "dbt_cloud_task", dbt_cloud_task)
        if dbt_platform_task is not None:
            pulumi.set(__self__, "dbt_platform_task", dbt_platform_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disable_auto_optimization is not None:
            pulumi.set(__self__, "disable_auto_optimization", disable_auto_optimization)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if gen_ai_compute_task is not None:
            pulumi.set(__self__, "gen_ai_compute_task", gen_ai_compute_task)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if power_bi_task is not None:
            pulumi.set(__self__, "power_bi_task", power_bi_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        """
        string specifying an unique key for a given task.
        * `*_task` - (Required) one of the specific task blocks described below:
        """
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter(name="cleanRoomsNotebookTask")
    def clean_rooms_notebook_task(self) -> Optional['outputs.JobTaskForEachTaskTaskCleanRoomsNotebookTask']:
        return pulumi.get(self, "clean_rooms_notebook_task")

    @_builtins.property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['outputs.JobTaskForEachTaskTaskConditionTask']:
        return pulumi.get(self, "condition_task")

    @_builtins.property
    @pulumi.getter(name="dashboardTask")
    def dashboard_task(self) -> Optional['outputs.JobTaskForEachTaskTaskDashboardTask']:
        return pulumi.get(self, "dashboard_task")

    @_builtins.property
    @pulumi.getter(name="dbtCloudTask")
    def dbt_cloud_task(self) -> Optional['outputs.JobTaskForEachTaskTaskDbtCloudTask']:
        return pulumi.get(self, "dbt_cloud_task")

    @_builtins.property
    @pulumi.getter(name="dbtPlatformTask")
    def dbt_platform_task(self) -> Optional['outputs.JobTaskForEachTaskTaskDbtPlatformTask']:
        return pulumi.get(self, "dbt_platform_task")

    @_builtins.property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['outputs.JobTaskForEachTaskTaskDbtTask']:
        return pulumi.get(self, "dbt_task")

    @_builtins.property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskDependsOn']]:
        """
        block specifying dependency(-ies) for a given task.
        """
        return pulumi.get(self, "depends_ons")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        description for this task.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="disableAutoOptimization")
    def disable_auto_optimization(self) -> Optional[_builtins.bool]:
        """
        A flag to disable auto optimization in serverless tasks.
        """
        return pulumi.get(self, "disable_auto_optimization")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['outputs.JobTaskForEachTaskTaskEmailNotifications']:
        """
        An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
        """
        return pulumi.get(self, "email_notifications")

    @_builtins.property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[_builtins.str]:
        """
        identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`spark_python_task`, `python_wheel_task`, ...) running on serverless compute.
        """
        return pulumi.get(self, "environment_key")

    @_builtins.property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
        """
        return pulumi.get(self, "existing_cluster_id")

    @_builtins.property
    @pulumi.getter(name="genAiComputeTask")
    def gen_ai_compute_task(self) -> Optional['outputs.JobTaskForEachTaskTaskGenAiComputeTask']:
        return pulumi.get(self, "gen_ai_compute_task")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional['outputs.JobTaskForEachTaskTaskHealth']:
        """
        block described below that specifies health conditions for a given task.
        """
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[_builtins.str]:
        """
        Identifier of the Job cluster specified in the `job_cluster` block.
        """
        return pulumi.get(self, "job_cluster_key")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskLibrary']]:
        """
        (Set) An optional list of libraries to be installed on the cluster that will execute the job.
        """
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[_builtins.int]:
        """
        (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
        """
        return pulumi.get(self, "min_retry_interval_millis")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.JobTaskForEachTaskTaskNewCluster']:
        """
        Task will run on a dedicated cluster.  See Cluster documentation for specification. *Some parameters, such as `autotermination_minutes`, `is_pinned`, `workload_type` aren't supported!*
        """
        return pulumi.get(self, "new_cluster")

    @_builtins.property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['outputs.JobTaskForEachTaskTaskNotebookTask']:
        return pulumi.get(self, "notebook_task")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.JobTaskForEachTaskTaskNotificationSettings']:
        """
        An optional block controlling the notification settings on the job level documented below.
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['outputs.JobTaskForEachTaskTaskPipelineTask']:
        return pulumi.get(self, "pipeline_task")

    @_builtins.property
    @pulumi.getter(name="powerBiTask")
    def power_bi_task(self) -> Optional['outputs.JobTaskForEachTaskTaskPowerBiTask']:
        return pulumi.get(self, "power_bi_task")

    @_builtins.property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['outputs.JobTaskForEachTaskTaskPythonWheelTask']:
        return pulumi.get(self, "python_wheel_task")

    @_builtins.property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[_builtins.bool]:
        """
        (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
        """
        return pulumi.get(self, "retry_on_timeout")

    @_builtins.property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[_builtins.str]:
        """
        An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
        """
        return pulumi.get(self, "run_if")

    @_builtins.property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['outputs.JobTaskForEachTaskTaskRunJobTask']:
        return pulumi.get(self, "run_job_task")

    @_builtins.property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['outputs.JobTaskForEachTaskTaskSparkJarTask']:
        return pulumi.get(self, "spark_jar_task")

    @_builtins.property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['outputs.JobTaskForEachTaskTaskSparkPythonTask']:
        return pulumi.get(self, "spark_python_task")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['outputs.JobTaskForEachTaskTaskSparkSubmitTask']:
        return pulumi.get(self, "spark_submit_task")

    @_builtins.property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['outputs.JobTaskForEachTaskTaskSqlTask']:
        return pulumi.get(self, "sql_task")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['outputs.JobTaskForEachTaskTaskWebhookNotifications']:
        """
        (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.

        > If no `job_cluster_key`, `existing_cluster_id`, or `new_cluster` were specified in task definition, then task will executed using serverless compute.
        """
        return pulumi.get(self, "webhook_notifications")


@pulumi.output_type
class JobTaskForEachTaskTaskCleanRoomsNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanRoomName":
            suggest = "clean_room_name"
        elif key == "notebookName":
            suggest = "notebook_name"
        elif key == "notebookBaseParameters":
            suggest = "notebook_base_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskCleanRoomsNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskCleanRoomsNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskCleanRoomsNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clean_room_name: _builtins.str,
                 notebook_name: _builtins.str,
                 etag: Optional[_builtins.str] = None,
                 notebook_base_parameters: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str clean_room_name: The clean room that the notebook belongs to.
        :param _builtins.str notebook_name: Name of the notebook being run.
        :param _builtins.str etag: Checksum to validate the freshness of the notebook resource.
        :param Mapping[str, _builtins.str] notebook_base_parameters: Base parameters to be used for the clean room notebook job.
        """
        pulumi.set(__self__, "clean_room_name", clean_room_name)
        pulumi.set(__self__, "notebook_name", notebook_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if notebook_base_parameters is not None:
            pulumi.set(__self__, "notebook_base_parameters", notebook_base_parameters)

    @_builtins.property
    @pulumi.getter(name="cleanRoomName")
    def clean_room_name(self) -> _builtins.str:
        """
        The clean room that the notebook belongs to.
        """
        return pulumi.get(self, "clean_room_name")

    @_builtins.property
    @pulumi.getter(name="notebookName")
    def notebook_name(self) -> _builtins.str:
        """
        Name of the notebook being run.
        """
        return pulumi.get(self, "notebook_name")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        Checksum to validate the freshness of the notebook resource.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="notebookBaseParameters")
    def notebook_base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Base parameters to be used for the clean room notebook job.
        """
        return pulumi.get(self, "notebook_base_parameters")


@pulumi.output_type
class JobTaskForEachTaskTaskConditionTask(dict):
    def __init__(__self__, *,
                 left: _builtins.str,
                 op: _builtins.str,
                 right: _builtins.str):
        """
        :param _builtins.str left: The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        :param _builtins.str op: The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).
               
               This task does not require a cluster to execute and does not support retries or notifications.
        :param _builtins.str right: The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @_builtins.property
    @pulumi.getter
    def left(self) -> _builtins.str:
        """
        The left operand of the condition task. It could be a string value, job state, or a parameter reference.
        """
        return pulumi.get(self, "left")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The string specifying the operation used to compare operands.  Currently, following operators are supported: `EQUAL_TO`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`. (Check the [API docs](https://docs.databricks.com/api/workspace/jobs/create) for the latest information).

        This task does not require a cluster to execute and does not support retries or notifications.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def right(self) -> _builtins.str:
        """
        The right operand of the condition task. It could be a string value, job state, or parameter reference.
        """
        return pulumi.get(self, "right")


@pulumi.output_type
class JobTaskForEachTaskTaskDashboardTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDashboardTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDashboardTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDashboardTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_id: Optional[_builtins.str] = None,
                 subscription: Optional['outputs.JobTaskForEachTaskTaskDashboardTaskSubscription'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str dashboard_id: The identifier of the dashboard to refresh
        :param 'JobTaskForEachTaskTaskDashboardTaskSubscriptionArgs' subscription: Represents a subscription configuration for scheduled dashboard snapshots.
        :param _builtins.str warehouse_id: The warehouse id to execute the dashboard with for the schedule. If not specified, will use the default warehouse of dashboard
        """
        if dashboard_id is not None:
            pulumi.set(__self__, "dashboard_id", dashboard_id)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the dashboard to refresh
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.JobTaskForEachTaskTaskDashboardTaskSubscription']:
        """
        Represents a subscription configuration for scheduled dashboard snapshots.
        """
        return pulumi.get(self, "subscription")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The warehouse id to execute the dashboard with for the schedule. If not specified, will use the default warehouse of dashboard
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskForEachTaskTaskDashboardTaskSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSubject":
            suggest = "custom_subject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDashboardTaskSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDashboardTaskSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDashboardTaskSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_subject: Optional[_builtins.str] = None,
                 paused: Optional[_builtins.bool] = None,
                 subscribers: Optional[Sequence['outputs.JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber']] = None):
        """
        :param _builtins.str custom_subject: Allows users to specify a custom subject line on the email sent to subscribers.
        :param _builtins.bool paused: When true, the subscription will not send emails.
        :param Sequence['JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriberArgs'] subscribers: The list of subscribers to send the snapshot of the dashboard to.
        """
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        """
        Allows users to specify a custom subject line on the email sent to subscribers.
        """
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        When true, the subscription will not send emails.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber']]:
        """
        The list of subscribers to send the snapshot of the dashboard to.
        """
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDashboardTaskSubscriptionSubscriber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        :param _builtins.str user_name: A snapshot of the dashboard will be sent to the user's email when the `user_name` field is present.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the user's email when the `user_name` field is present.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobTaskForEachTaskTaskDbtCloudTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionResourceName":
            suggest = "connection_resource_name"
        elif key == "dbtCloudJobId":
            suggest = "dbt_cloud_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDbtCloudTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDbtCloudTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDbtCloudTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 dbt_cloud_job_id: Optional[_builtins.int] = None):
        """
        :param _builtins.str connection_resource_name: The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if dbt_cloud_job_id is not None:
            pulumi.set(__self__, "dbt_cloud_job_id", dbt_cloud_job_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        """
        The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="dbtCloudJobId")
    def dbt_cloud_job_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "dbt_cloud_job_id")


@pulumi.output_type
class JobTaskForEachTaskTaskDbtPlatformTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionResourceName":
            suggest = "connection_resource_name"
        elif key == "dbtPlatformJobId":
            suggest = "dbt_platform_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDbtPlatformTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDbtPlatformTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDbtPlatformTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 dbt_platform_job_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_resource_name: The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if dbt_platform_job_id is not None:
            pulumi.set(__self__, "dbt_platform_job_id", dbt_platform_job_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        """
        The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="dbtPlatformJobId")
    def dbt_platform_job_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dbt_platform_job_id")


@pulumi.output_type
class JobTaskForEachTaskTaskDbtTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "profilesDirectory":
            suggest = "profiles_directory"
        elif key == "projectDirectory":
            suggest = "project_directory"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDbtTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDbtTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDbtTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence[_builtins.str],
                 catalog: Optional[_builtins.str] = None,
                 profiles_directory: Optional[_builtins.str] = None,
                 project_directory: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] commands: (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        :param _builtins.str catalog: The name of the catalog to use inside Unity Catalog.
        :param _builtins.str profiles_directory: The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        :param _builtins.str project_directory: The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
               * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
               * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        :param _builtins.str schema: The name of the schema dbt should run in. Defaults to `default`.
        :param _builtins.str source: The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        :param _builtins.str warehouse_id: The ID of the SQL warehouse that dbt should execute against.
               
               You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        """
        (Array) Series of dbt commands to execute in sequence. Every command must start with "dbt".
        """
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        """
        The name of the catalog to use inside Unity Catalog.
        """
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[_builtins.str]:
        """
        The relative path to the directory in the repository specified by `git_source` where dbt should look in for the `profiles.yml` file. If not specified, defaults to the repository's root directory. Equivalent to passing `--profile-dir` to a dbt command.
        """
        return pulumi.get(self, "profiles_directory")

    @_builtins.property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[_builtins.str]:
        """
        The path where dbt should look for `dbt_project.yml`. Equivalent to passing `--project-dir` to the dbt CLI.
        * If `source` is `GIT`: Relative path to the directory in the repository specified in the `git_source` block. Defaults to the repository's root directory when not specified.
        * If `source` is `WORKSPACE`: Absolute path to the folder in the workspace.
        """
        return pulumi.get(self, "project_directory")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The name of the schema dbt should run in. Defaults to `default`.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.  Defaults to `GIT` if a `git_source` block is present in the job definition.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The ID of the SQL warehouse that dbt should execute against.

        You also need to include a `git_source` block to configure the repository that contains the dbt project.
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskForEachTaskTaskDependsOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taskKey":
            suggest = "task_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskDependsOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskDependsOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskDependsOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 task_key: _builtins.str,
                 outcome: Optional[_builtins.str] = None):
        """
        :param _builtins.str task_key: The name of the task this task depends on.
        :param _builtins.str outcome: Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.
               
               > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        """
        The name of the task this task depends on.
        """
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter
    def outcome(self) -> Optional[_builtins.str]:
        """
        Can only be specified on condition task dependencies. The outcome of the dependent task that must be met for this task to run. Possible values are `"true"` or `"false"`.

        > Similar to the tasks themselves, each dependency inside the task need to be declared in alphabetical order with respect to task_key in order to get consistent Pulumi diffs.
        """
        return pulumi.get(self, "outcome")


@pulumi.output_type
class JobTaskForEachTaskTaskEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"
        elif key == "onDurationWarningThresholdExceededs":
            suggest = "on_duration_warning_threshold_exceededs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onStreamingBacklogExceededs":
            suggest = "on_streaming_backlog_exceededs"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_failures: Optional[Sequence[_builtins.str]] = None,
                 on_starts: Optional[Sequence[_builtins.str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_successes: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        :param Sequence[_builtins.str] on_duration_warning_threshold_exceededs: (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param Sequence[_builtins.str] on_failures: (List) list of emails to notify when the run fails.
        :param Sequence[_builtins.str] on_starts: (List) list of emails to notify when the run starts.
        :param Sequence[_builtins.str] on_streaming_backlog_exceededs: (List) list of emails to notify when any streaming backlog thresholds are exceeded for any stream.
               
               The following parameter is only available for the job level configuration.
        :param Sequence[_builtins.str] on_successes: (List) list of emails to notify when the run completes successfully.
        """
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for skipped runs. (It's recommended to use the corresponding setting in the `notification_settings` configuration block).
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run fails.
        """
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run starts.
        """
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when any streaming backlog thresholds are exceeded for any stream.

        The following parameter is only available for the job level configuration.
        """
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) list of emails to notify when the run completes successfully.
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobTaskForEachTaskTaskGenAiComputeTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dlRuntimeImage":
            suggest = "dl_runtime_image"
        elif key == "mlflowExperimentName":
            suggest = "mlflow_experiment_name"
        elif key == "trainingScriptPath":
            suggest = "training_script_path"
        elif key == "yamlParameters":
            suggest = "yaml_parameters"
        elif key == "yamlParametersFilePath":
            suggest = "yaml_parameters_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskGenAiComputeTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskGenAiComputeTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskGenAiComputeTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dl_runtime_image: _builtins.str,
                 command: Optional[_builtins.str] = None,
                 compute: Optional['outputs.JobTaskForEachTaskTaskGenAiComputeTaskCompute'] = None,
                 mlflow_experiment_name: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 training_script_path: Optional[_builtins.str] = None,
                 yaml_parameters: Optional[_builtins.str] = None,
                 yaml_parameters_file_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "dl_runtime_image", dl_runtime_image)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if mlflow_experiment_name is not None:
            pulumi.set(__self__, "mlflow_experiment_name", mlflow_experiment_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if training_script_path is not None:
            pulumi.set(__self__, "training_script_path", training_script_path)
        if yaml_parameters is not None:
            pulumi.set(__self__, "yaml_parameters", yaml_parameters)
        if yaml_parameters_file_path is not None:
            pulumi.set(__self__, "yaml_parameters_file_path", yaml_parameters_file_path)

    @_builtins.property
    @pulumi.getter(name="dlRuntimeImage")
    def dl_runtime_image(self) -> _builtins.str:
        return pulumi.get(self, "dl_runtime_image")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def compute(self) -> Optional['outputs.JobTaskForEachTaskTaskGenAiComputeTaskCompute']:
        return pulumi.get(self, "compute")

    @_builtins.property
    @pulumi.getter(name="mlflowExperimentName")
    def mlflow_experiment_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mlflow_experiment_name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="trainingScriptPath")
    def training_script_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "training_script_path")

    @_builtins.property
    @pulumi.getter(name="yamlParameters")
    def yaml_parameters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "yaml_parameters")

    @_builtins.property
    @pulumi.getter(name="yamlParametersFilePath")
    def yaml_parameters_file_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "yaml_parameters_file_path")


@pulumi.output_type
class JobTaskForEachTaskTaskGenAiComputeTaskCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numGpus":
            suggest = "num_gpus"
        elif key == "gpuNodePoolId":
            suggest = "gpu_node_pool_id"
        elif key == "gpuType":
            suggest = "gpu_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskGenAiComputeTaskCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskGenAiComputeTaskCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskGenAiComputeTaskCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_gpus: _builtins.int,
                 gpu_node_pool_id: Optional[_builtins.str] = None,
                 gpu_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "num_gpus", num_gpus)
        if gpu_node_pool_id is not None:
            pulumi.set(__self__, "gpu_node_pool_id", gpu_node_pool_id)
        if gpu_type is not None:
            pulumi.set(__self__, "gpu_type", gpu_type)

    @_builtins.property
    @pulumi.getter(name="numGpus")
    def num_gpus(self) -> _builtins.int:
        return pulumi.get(self, "num_gpus")

    @_builtins.property
    @pulumi.getter(name="gpuNodePoolId")
    def gpu_node_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gpu_node_pool_id")

    @_builtins.property
    @pulumi.getter(name="gpuType")
    def gpu_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gpu_type")


@pulumi.output_type
class JobTaskForEachTaskTaskHealth(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.JobTaskForEachTaskTaskHealthRule']):
        """
        :param Sequence['JobTaskForEachTaskTaskHealthRuleArgs'] rules: list of rules that are represented as objects with the following attributes:
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.JobTaskForEachTaskTaskHealthRule']:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class JobTaskForEachTaskTaskHealthRule(dict):
    def __init__(__self__, *,
                 metric: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.str metric: string specifying the metric to check, like `RUN_DURATION_SECONDS`, `STREAMING_BACKLOG_FILES`, etc. - check the [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create#health-rules-metric) for the full list of supported metrics.
        :param _builtins.str op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param _builtins.int value: integer value used to compare to the given metric.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        string specifying the metric to check, like `RUN_DURATION_SECONDS`, `STREAMING_BACKLOG_FILES`, etc. - check the [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create#health-rules-metric) for the full list of supported metrics.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JobTaskForEachTaskTaskLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobTaskForEachTaskTaskLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobTaskForEachTaskTaskLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobTaskForEachTaskTaskLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobTaskForEachTaskTaskLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobTaskForEachTaskTaskLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobTaskForEachTaskTaskLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobTaskForEachTaskTaskLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobTaskForEachTaskTaskLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobTaskForEachTaskTaskLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobTaskForEachTaskTaskLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskForEachTaskTaskLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskForEachTaskTaskLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobTaskForEachTaskTaskLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskForEachTaskTaskNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterMountInfos":
            suggest = "cluster_mount_infos"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "isSingleNode":
            suggest = "is_single_node"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "providerConfig":
            suggest = "provider_config"
        elif key == "remoteDiskThroughput":
            suggest = "remote_disk_throughput"
        elif key == "runtimeEngine":
            suggest = "runtime_engine"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sparkVersion":
            suggest = "spark_version"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "totalInitialRemoteDiskSize":
            suggest = "total_initial_remote_disk_size"
        elif key == "useMlRuntime":
            suggest = "use_ml_runtime"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.JobTaskForEachTaskTaskNewClusterAutoscale'] = None,
                 aws_attributes: Optional['outputs.JobTaskForEachTaskTaskNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobTaskForEachTaskTaskNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConf'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.JobTaskForEachTaskTaskNewClusterClusterMountInfo']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.JobTaskForEachTaskTaskNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[_builtins.str] = None,
                 driver_node_type_id: Optional[_builtins.str] = None,
                 enable_elastic_disk: Optional[_builtins.bool] = None,
                 enable_local_disk_encryption: Optional[_builtins.bool] = None,
                 gcp_attributes: Optional['outputs.JobTaskForEachTaskTaskNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.JobTaskForEachTaskTaskNewClusterInitScript']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 is_single_node: Optional[_builtins.bool] = None,
                 kind: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.JobTaskForEachTaskTaskNewClusterLibrary']] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 provider_config: Optional['outputs.JobTaskForEachTaskTaskNewClusterProviderConfig'] = None,
                 remote_disk_throughput: Optional[_builtins.int] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 total_initial_remote_disk_size: Optional[_builtins.int] = None,
                 use_ml_runtime: Optional[_builtins.bool] = None,
                 workload_type: Optional['outputs.JobTaskForEachTaskTaskNewClusterWorkloadType'] = None):
        """
        :param Sequence['JobTaskForEachTaskTaskNewClusterLibraryArgs'] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param 'JobTaskForEachTaskTaskNewClusterProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        :param 'JobTaskForEachTaskTaskNewClusterWorkloadTypeArgs' workload_type: isn't supported
        """
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if is_single_node is not None:
            pulumi.set(__self__, "is_single_node", is_single_node)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if remote_disk_throughput is not None:
            pulumi.set(__self__, "remote_disk_throughput", remote_disk_throughput)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if total_initial_remote_disk_size is not None:
            pulumi.set(__self__, "total_initial_remote_disk_size", total_initial_remote_disk_size)
        if use_ml_runtime is not None:
            pulumi.set(__self__, "use_ml_runtime", use_ml_runtime)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskNewClusterClusterMountInfo']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="isSingleNode")
    def is_single_node(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_single_node")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskNewClusterLibrary']]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter(name="remoteDiskThroughput")
    def remote_disk_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "remote_disk_throughput")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="totalInitialRemoteDiskSize")
    def total_initial_remote_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_initial_remote_disk_size")

    @_builtins.property
    @pulumi.getter(name="useMlRuntime")
    def use_ml_runtime(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_ml_runtime")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterWorkloadType']:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeIops":
            suggest = "ebs_volume_iops"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeThroughput":
            suggest = "ebs_volume_throughput"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "logAnalyticsInfo":
            suggest = "log_analytics_info"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsPrimaryKey":
            suggest = "log_analytics_primary_key"
        elif key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConfS3'] = None,
                 volumes: Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConfVolumes'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterClusterLogConfVolumes']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterClusterLogConfVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterClusterMountInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountDirPath":
            suggest = "local_mount_dir_path"
        elif key == "networkFilesystemInfo":
            suggest = "network_filesystem_info"
        elif key == "remoteMountDirPath":
            suggest = "remote_mount_dir_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterClusterMountInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterClusterMountInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterClusterMountInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.JobTaskForEachTaskTaskNewClusterDockerImageBasicAuth'] = None):
        """
        :param _builtins.str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScript(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptAbfss'] = None,
                 dbfs: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptS3'] = None,
                 volumes: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptVolumes'] = None,
                 workspace: Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptWorkspace'] = None):
        """
        :param 'JobTaskForEachTaskTaskNewClusterInitScriptFileArgs' file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptAbfss']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptFile']:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptVolumes']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterInitScriptWorkspace']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptAbfss(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterInitScriptWorkspace(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobTaskForEachTaskTaskNewClusterLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobTaskForEachTaskTaskNewClusterLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNewClusterProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNewClusterProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNewClusterProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobTaskForEachTaskTaskNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.JobTaskForEachTaskTaskNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobTaskForEachTaskTaskNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobTaskForEachTaskTaskNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPath":
            suggest = "notebook_path"
        elif key == "baseParameters":
            suggest = "base_parameters"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_path: _builtins.str,
                 base_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param Mapping[str, _builtins.str] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job's base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param _builtins.str source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        :param _builtins.str warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> _builtins.str:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @_builtins.property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job's base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskForEachTaskTaskNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnLastAttempt":
            suggest = "alert_on_last_attempt"
        elif key == "noAlertForCanceledRuns":
            suggest = "no_alert_for_canceled_runs"
        elif key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[_builtins.bool] = None,
                 no_alert_for_canceled_runs: Optional[_builtins.bool] = None,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param _builtins.bool no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
               
               The following parameter is only available on task level.
        :param _builtins.bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @_builtins.property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[_builtins.bool]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @_builtins.property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")


@pulumi.output_type
class JobTaskForEachTaskTaskPipelineTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "fullRefresh":
            suggest = "full_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskPipelineTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskPipelineTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskPipelineTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: _builtins.str,
                 full_refresh: Optional[_builtins.bool] = None):
        """
        :param _builtins.str pipeline_id: The pipeline's unique ID.
        :param _builtins.bool full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class JobTaskForEachTaskTaskPowerBiTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionResourceName":
            suggest = "connection_resource_name"
        elif key == "powerBiModel":
            suggest = "power_bi_model"
        elif key == "refreshAfterUpdate":
            suggest = "refresh_after_update"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskPowerBiTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskPowerBiTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskPowerBiTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 power_bi_model: Optional['outputs.JobTaskForEachTaskTaskPowerBiTaskPowerBiModel'] = None,
                 refresh_after_update: Optional[_builtins.bool] = None,
                 tables: Optional[Sequence['outputs.JobTaskForEachTaskTaskPowerBiTaskTable']] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_resource_name: The resource name of the UC connection to authenticate from Databricks to Power BI
        :param 'JobTaskForEachTaskTaskPowerBiTaskPowerBiModelArgs' power_bi_model: The semantic model to update. Block consists of following fields:
        :param _builtins.bool refresh_after_update: Whether the model should be refreshed after the update. Default is false
        :param Sequence['JobTaskForEachTaskTaskPowerBiTaskTableArgs'] tables: The tables to be exported to Power BI. Block consists of following fields:
        :param _builtins.str warehouse_id: The SQL warehouse ID to use as the Power BI data source
        """
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if power_bi_model is not None:
            pulumi.set(__self__, "power_bi_model", power_bi_model)
        if refresh_after_update is not None:
            pulumi.set(__self__, "refresh_after_update", refresh_after_update)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        """
        The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="powerBiModel")
    def power_bi_model(self) -> Optional['outputs.JobTaskForEachTaskTaskPowerBiTaskPowerBiModel']:
        """
        The semantic model to update. Block consists of following fields:
        """
        return pulumi.get(self, "power_bi_model")

    @_builtins.property
    @pulumi.getter(name="refreshAfterUpdate")
    def refresh_after_update(self) -> Optional[_builtins.bool]:
        """
        Whether the model should be refreshed after the update. Default is false
        """
        return pulumi.get(self, "refresh_after_update")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskPowerBiTaskTable']]:
        """
        The tables to be exported to Power BI. Block consists of following fields:
        """
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The SQL warehouse ID to use as the Power BI data source
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskForEachTaskTaskPowerBiTaskPowerBiModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "overwriteExisting":
            suggest = "overwrite_existing"
        elif key == "storageMode":
            suggest = "storage_mode"
        elif key == "workspaceName":
            suggest = "workspace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskPowerBiTaskPowerBiModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskPowerBiTaskPowerBiModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskPowerBiTaskPowerBiModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 overwrite_existing: Optional[_builtins.bool] = None,
                 storage_mode: Optional[_builtins.str] = None,
                 workspace_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str authentication_method: How the published Power BI model authenticates to Databricks
        :param _builtins.str model_name: The name of the Power BI model
        :param _builtins.bool overwrite_existing: Whether to overwrite existing Power BI models. Default is false
        :param _builtins.str storage_mode: The default storage mode of the Power BI model
        :param _builtins.str workspace_name: The name of the Power BI workspace of the model
        """
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if overwrite_existing is not None:
            pulumi.set(__self__, "overwrite_existing", overwrite_existing)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)
        if workspace_name is not None:
            pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[_builtins.str]:
        """
        How the published Power BI model authenticates to Databricks
        """
        return pulumi.get(self, "authentication_method")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        """
        The name of the Power BI model
        """
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="overwriteExisting")
    def overwrite_existing(self) -> Optional[_builtins.bool]:
        """
        Whether to overwrite existing Power BI models. Default is false
        """
        return pulumi.get(self, "overwrite_existing")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        """
        The default storage mode of the Power BI model
        """
        return pulumi.get(self, "storage_mode")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> Optional[_builtins.str]:
        """
        The name of the Power BI workspace of the model
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class JobTaskForEachTaskTaskPowerBiTaskTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageMode":
            suggest = "storage_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskPowerBiTaskTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskPowerBiTaskTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskPowerBiTaskTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 storage_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str catalog: The catalog name in Databricks
        :param _builtins.str name: The table name in Databricks. If empty, all tables under the schema are selected.
        :param _builtins.str schema: The schema name in Databricks
        :param _builtins.str storage_mode: The Power BI storage mode of the table
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        """
        The catalog name in Databricks
        """
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The table name in Databricks. If empty, all tables under the schema are selected.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The schema name in Databricks
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        """
        The Power BI storage mode of the table
        """
        return pulumi.get(self, "storage_mode")


@pulumi.output_type
class JobTaskForEachTaskTaskPythonWheelTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "namedParameters":
            suggest = "named_parameters"
        elif key == "packageName":
            suggest = "package_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskPythonWheelTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskPythonWheelTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskPythonWheelTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point: Optional[_builtins.str] = None,
                 named_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 package_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str entry_point: Python function as entry point for the task
        :param Mapping[str, _builtins.str] named_parameters: Named parameters for the task
        :param _builtins.str package_name: Name of Python package
        :param Sequence[_builtins.str] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskForEachTaskTaskRunJobTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobId":
            suggest = "job_id"
        elif key == "dbtCommands":
            suggest = "dbt_commands"
        elif key == "jarParams":
            suggest = "jar_params"
        elif key == "jobParameters":
            suggest = "job_parameters"
        elif key == "notebookParams":
            suggest = "notebook_params"
        elif key == "pipelineParams":
            suggest = "pipeline_params"
        elif key == "pythonNamedParams":
            suggest = "python_named_params"
        elif key == "pythonParams":
            suggest = "python_params"
        elif key == "sparkSubmitParams":
            suggest = "spark_submit_params"
        elif key == "sqlParams":
            suggest = "sql_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskRunJobTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskRunJobTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskRunJobTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_id: _builtins.int,
                 dbt_commands: Optional[Sequence[_builtins.str]] = None,
                 jar_params: Optional[Sequence[_builtins.str]] = None,
                 job_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 notebook_params: Optional[Mapping[str, _builtins.str]] = None,
                 pipeline_params: Optional['outputs.JobTaskForEachTaskTaskRunJobTaskPipelineParams'] = None,
                 python_named_params: Optional[Mapping[str, _builtins.str]] = None,
                 python_params: Optional[Sequence[_builtins.str]] = None,
                 spark_submit_params: Optional[Sequence[_builtins.str]] = None,
                 sql_params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int job_id: (String) ID of the job
        :param Mapping[str, _builtins.str] job_parameters: (Map) Job parameters for the task
        """
        pulumi.set(__self__, "job_id", job_id)
        if dbt_commands is not None:
            pulumi.set(__self__, "dbt_commands", dbt_commands)
        if jar_params is not None:
            pulumi.set(__self__, "jar_params", jar_params)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)
        if notebook_params is not None:
            pulumi.set(__self__, "notebook_params", notebook_params)
        if pipeline_params is not None:
            pulumi.set(__self__, "pipeline_params", pipeline_params)
        if python_named_params is not None:
            pulumi.set(__self__, "python_named_params", python_named_params)
        if python_params is not None:
            pulumi.set(__self__, "python_params", python_params)
        if spark_submit_params is not None:
            pulumi.set(__self__, "spark_submit_params", spark_submit_params)
        if sql_params is not None:
            pulumi.set(__self__, "sql_params", sql_params)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.int:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="dbtCommands")
    def dbt_commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dbt_commands")

    @_builtins.property
    @pulumi.getter(name="jarParams")
    def jar_params(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "jar_params")

    @_builtins.property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @_builtins.property
    @pulumi.getter(name="notebookParams")
    def notebook_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "notebook_params")

    @_builtins.property
    @pulumi.getter(name="pipelineParams")
    def pipeline_params(self) -> Optional['outputs.JobTaskForEachTaskTaskRunJobTaskPipelineParams']:
        return pulumi.get(self, "pipeline_params")

    @_builtins.property
    @pulumi.getter(name="pythonNamedParams")
    def python_named_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "python_named_params")

    @_builtins.property
    @pulumi.getter(name="pythonParams")
    def python_params(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "python_params")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitParams")
    def spark_submit_params(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "spark_submit_params")

    @_builtins.property
    @pulumi.getter(name="sqlParams")
    def sql_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "sql_params")


@pulumi.output_type
class JobTaskForEachTaskTaskRunJobTaskPipelineParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullRefresh":
            suggest = "full_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskRunJobTaskPipelineParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskRunJobTaskPipelineParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskRunJobTaskPipelineParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_refresh: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class JobTaskForEachTaskTaskSparkJarTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jarUri":
            suggest = "jar_uri"
        elif key == "mainClassName":
            suggest = "main_class_name"
        elif key == "runAsRepl":
            suggest = "run_as_repl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSparkJarTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSparkJarTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSparkJarTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar_uri: Optional[_builtins.str] = None,
                 main_class_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 run_as_repl: Optional[_builtins.bool] = None):
        """
        :param _builtins.str main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param Sequence[_builtins.str] parameters: (List) Parameters passed to the main method.
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if run_as_repl is not None:
            pulumi.set(__self__, "run_as_repl", run_as_repl)

    @_builtins.property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar_uri")

    @_builtins.property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[_builtins.str]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="runAsRepl")
    def run_as_repl(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "run_as_repl")


@pulumi.output_type
class JobTaskForEachTaskTaskSparkPythonTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonFile":
            suggest = "python_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSparkPythonTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSparkPythonTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSparkPythonTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_file: _builtins.str,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str python_file: The URI of the Python file to be executed. Cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/`. For files stored in a remote repository, the path must be relative. This field is required.
        :param Sequence[_builtins.str] parameters: (List) Command line parameters passed to the Python file.
        :param _builtins.str source: Location type of the Python file. When set to `WORKSPACE` or not specified, the file will be retrieved from the local Databricks workspace or cloud location (if the python_file has a URI format). When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
               * `WORKSPACE`: The Python file is located in a Databricks workspace or at a cloud filesystem URI.
               * `GIT`: The Python file is located in a remote Git repository.
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> _builtins.str:
        """
        The URI of the Python file to be executed. Cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Location type of the Python file. When set to `WORKSPACE` or not specified, the file will be retrieved from the local Databricks workspace or cloud location (if the python_file has a URI format). When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        * `WORKSPACE`: The Python file is located in a Databricks workspace or at a cloud filesystem URI.
        * `GIT`: The Python file is located in a remote Git repository.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class JobTaskForEachTaskTaskSparkSubmitTask(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] parameters: (List) Command-line parameters passed to spark submit.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSqlTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSqlTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSqlTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 warehouse_id: _builtins.str,
                 alert: Optional['outputs.JobTaskForEachTaskTaskSqlTaskAlert'] = None,
                 dashboard: Optional['outputs.JobTaskForEachTaskTaskSqlTaskDashboard'] = None,
                 file: Optional['outputs.JobTaskForEachTaskTaskSqlTaskFile'] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 query: Optional['outputs.JobTaskForEachTaskTaskSqlTaskQuery'] = None):
        """
        :param _builtins.str warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        :param 'JobTaskForEachTaskTaskSqlTaskAlertArgs' alert: block consisting of following fields:
        :param 'JobTaskForEachTaskTaskSqlTaskDashboardArgs' dashboard: block consisting of following fields:
        :param 'JobTaskForEachTaskTaskSqlTaskFileArgs' file: block consisting of single string fields:
        :param Mapping[str, _builtins.str] parameters: (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        :param 'JobTaskForEachTaskTaskSqlTaskQueryArgs' query: block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> _builtins.str:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        return pulumi.get(self, "warehouse_id")

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional['outputs.JobTaskForEachTaskTaskSqlTaskAlert']:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "alert")

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional['outputs.JobTaskForEachTaskTaskSqlTaskDashboard']:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "dashboard")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobTaskForEachTaskTaskSqlTaskFile']:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional['outputs.JobTaskForEachTaskTaskSqlTaskQuery']:
        """
        block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTaskAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "pauseSubscriptions":
            suggest = "pause_subscriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSqlTaskAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSqlTaskAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSqlTaskAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: _builtins.str,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.JobTaskForEachTaskTaskSqlTaskAlertSubscription']] = None):
        """
        :param _builtins.str alert_id: (String) identifier of the Databricks Alert (databricks_alert).
        :param _builtins.bool pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param Sequence['JobTaskForEachTaskTaskSqlTaskAlertSubscriptionArgs'] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> _builtins.str:
        """
        (String) identifier of the Databricks Alert (databricks_alert).
        """
        return pulumi.get(self, "alert_id")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskSqlTaskAlertSubscription']]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTaskAlertSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSqlTaskAlertSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSqlTaskAlertSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSqlTaskAlertSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTaskDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "customSubject":
            suggest = "custom_subject"
        elif key == "pauseSubscriptions":
            suggest = "pause_subscriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSqlTaskDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSqlTaskDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSqlTaskDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_id: _builtins.str,
                 custom_subject: Optional[_builtins.str] = None,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.JobTaskForEachTaskTaskSqlTaskDashboardSubscription']] = None):
        """
        :param _builtins.str dashboard_id: (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        :param _builtins.str custom_subject: string specifying a custom subject of email sent.
        :param _builtins.bool pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param Sequence['JobTaskForEachTaskTaskSqlTaskDashboardSubscriptionArgs'] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        """
        string specifying a custom subject of email sent.
        """
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskSqlTaskDashboardSubscription']]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTaskDashboardSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSqlTaskDashboardSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSqlTaskDashboardSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSqlTaskDashboardSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTaskFile(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sql_aggregation_job",
                   name="Example SQL Job",
                   tasks=[
                       {
                           "task_key": "run_agg_query",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "query": {
                                   "query_id": agg_query["id"],
                               },
                           },
                       },
                       {
                           "task_key": "run_dashboard",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "dashboard": {
                                   "dashboard_id": dash["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                       {
                           "task_key": "run_alert",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "alert": {
                                   "alert_id": alert["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                   ])
               ```
        :param _builtins.str source: The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sql_aggregation_job",
            name="Example SQL Job",
            tasks=[
                {
                    "task_key": "run_agg_query",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "query": {
                            "query_id": agg_query["id"],
                        },
                    },
                },
                {
                    "task_key": "run_dashboard",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "dashboard": {
                            "dashboard_id": dash["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
                {
                    "task_key": "run_alert",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "alert": {
                            "alert_id": alert["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
            ])
        ```
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class JobTaskForEachTaskTaskSqlTaskQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskSqlTaskQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskSqlTaskQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskSqlTaskQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: _builtins.str):
        pulumi.set(__self__, "query_id", query_id)

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        return pulumi.get(self, "query_id")


@pulumi.output_type
class JobTaskForEachTaskTaskWebhookNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDurationWarningThresholdExceededs":
            suggest = "on_duration_warning_threshold_exceededs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onStreamingBacklogExceededs":
            suggest = "on_streaming_backlog_exceededs"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskForEachTaskTaskWebhookNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskForEachTaskTaskWebhookNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskForEachTaskTaskWebhookNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceeded']] = None,
                 on_failures: Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnFailure']] = None,
                 on_starts: Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnStart']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceeded']] = None,
                 on_successes: Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnSuccess']] = None):
        """
        :param Sequence['JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs'] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param Sequence['JobTaskForEachTaskTaskWebhookNotificationsOnFailureArgs'] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param Sequence['JobTaskForEachTaskTaskWebhookNotificationsOnStartArgs'] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param Sequence['JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededArgs'] on_streaming_backlog_exceededs: (List) list of notification IDs to call when any streaming backlog thresholds are exceeded for any stream.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
        :param Sequence['JobTaskForEachTaskTaskWebhookNotificationsOnSuccessArgs'] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceeded']]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnFailure']]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnStart']]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceeded']]:
        """
        (List) list of notification IDs to call when any streaming backlog thresholds are exceeded for any stream.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['outputs.JobTaskForEachTaskTaskWebhookNotificationsOnSuccess']]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceeded(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskForEachTaskTaskWebhookNotificationsOnFailure(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskForEachTaskTaskWebhookNotificationsOnStart(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceeded(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskForEachTaskTaskWebhookNotificationsOnSuccess(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskGenAiComputeTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dlRuntimeImage":
            suggest = "dl_runtime_image"
        elif key == "mlflowExperimentName":
            suggest = "mlflow_experiment_name"
        elif key == "trainingScriptPath":
            suggest = "training_script_path"
        elif key == "yamlParameters":
            suggest = "yaml_parameters"
        elif key == "yamlParametersFilePath":
            suggest = "yaml_parameters_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskGenAiComputeTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskGenAiComputeTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskGenAiComputeTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dl_runtime_image: _builtins.str,
                 command: Optional[_builtins.str] = None,
                 compute: Optional['outputs.JobTaskGenAiComputeTaskCompute'] = None,
                 mlflow_experiment_name: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 training_script_path: Optional[_builtins.str] = None,
                 yaml_parameters: Optional[_builtins.str] = None,
                 yaml_parameters_file_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "dl_runtime_image", dl_runtime_image)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if mlflow_experiment_name is not None:
            pulumi.set(__self__, "mlflow_experiment_name", mlflow_experiment_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if training_script_path is not None:
            pulumi.set(__self__, "training_script_path", training_script_path)
        if yaml_parameters is not None:
            pulumi.set(__self__, "yaml_parameters", yaml_parameters)
        if yaml_parameters_file_path is not None:
            pulumi.set(__self__, "yaml_parameters_file_path", yaml_parameters_file_path)

    @_builtins.property
    @pulumi.getter(name="dlRuntimeImage")
    def dl_runtime_image(self) -> _builtins.str:
        return pulumi.get(self, "dl_runtime_image")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def compute(self) -> Optional['outputs.JobTaskGenAiComputeTaskCompute']:
        return pulumi.get(self, "compute")

    @_builtins.property
    @pulumi.getter(name="mlflowExperimentName")
    def mlflow_experiment_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mlflow_experiment_name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="trainingScriptPath")
    def training_script_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "training_script_path")

    @_builtins.property
    @pulumi.getter(name="yamlParameters")
    def yaml_parameters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "yaml_parameters")

    @_builtins.property
    @pulumi.getter(name="yamlParametersFilePath")
    def yaml_parameters_file_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "yaml_parameters_file_path")


@pulumi.output_type
class JobTaskGenAiComputeTaskCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numGpus":
            suggest = "num_gpus"
        elif key == "gpuNodePoolId":
            suggest = "gpu_node_pool_id"
        elif key == "gpuType":
            suggest = "gpu_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskGenAiComputeTaskCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskGenAiComputeTaskCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskGenAiComputeTaskCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_gpus: _builtins.int,
                 gpu_node_pool_id: Optional[_builtins.str] = None,
                 gpu_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "num_gpus", num_gpus)
        if gpu_node_pool_id is not None:
            pulumi.set(__self__, "gpu_node_pool_id", gpu_node_pool_id)
        if gpu_type is not None:
            pulumi.set(__self__, "gpu_type", gpu_type)

    @_builtins.property
    @pulumi.getter(name="numGpus")
    def num_gpus(self) -> _builtins.int:
        return pulumi.get(self, "num_gpus")

    @_builtins.property
    @pulumi.getter(name="gpuNodePoolId")
    def gpu_node_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gpu_node_pool_id")

    @_builtins.property
    @pulumi.getter(name="gpuType")
    def gpu_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gpu_type")


@pulumi.output_type
class JobTaskHealth(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.JobTaskHealthRule']):
        """
        :param Sequence['JobTaskHealthRuleArgs'] rules: list of rules that are represented as objects with the following attributes:
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.JobTaskHealthRule']:
        """
        list of rules that are represented as objects with the following attributes:
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class JobTaskHealthRule(dict):
    def __init__(__self__, *,
                 metric: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.str metric: string specifying the metric to check, like `RUN_DURATION_SECONDS`, `STREAMING_BACKLOG_FILES`, etc. - check the [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create#health-rules-metric) for the full list of supported metrics.
        :param _builtins.str op: string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        :param _builtins.int value: integer value used to compare to the given metric.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        string specifying the metric to check, like `RUN_DURATION_SECONDS`, `STREAMING_BACKLOG_FILES`, etc. - check the [Jobs REST API documentation](https://docs.databricks.com/api/workspace/jobs/create#health-rules-metric) for the full list of supported metrics.
        """
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        string specifying the operation used to evaluate the given metric. The only supported operation is `GREATER_THAN`.
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        integer value used to compare to the given metric.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JobTaskLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobTaskLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobTaskLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobTaskLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobTaskLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobTaskLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobTaskLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobTaskLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobTaskLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobTaskLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobTaskLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobTaskLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskNewCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "__applyPolicyDefaultValuesAllowLists":
            suggest = "__apply_policy_default_values_allow_lists"
        elif key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "clusterMountInfos":
            suggest = "cluster_mount_infos"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "dataSecurityMode":
            suggest = "data_security_mode"
        elif key == "dockerImage":
            suggest = "docker_image"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableElasticDisk":
            suggest = "enable_elastic_disk"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "idempotencyToken":
            suggest = "idempotency_token"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "isSingleNode":
            suggest = "is_single_node"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "providerConfig":
            suggest = "provider_config"
        elif key == "remoteDiskThroughput":
            suggest = "remote_disk_throughput"
        elif key == "runtimeEngine":
            suggest = "runtime_engine"
        elif key == "singleUserName":
            suggest = "single_user_name"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sparkVersion":
            suggest = "spark_version"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"
        elif key == "totalInitialRemoteDiskSize":
            suggest = "total_initial_remote_disk_size"
        elif key == "useMlRuntime":
            suggest = "use_ml_runtime"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 __apply_policy_default_values_allow_lists: Optional[Sequence[_builtins.str]] = None,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.JobTaskNewClusterAutoscale'] = None,
                 aws_attributes: Optional['outputs.JobTaskNewClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.JobTaskNewClusterAzureAttributes'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.JobTaskNewClusterClusterLogConf'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.JobTaskNewClusterClusterMountInfo']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.JobTaskNewClusterDockerImage'] = None,
                 driver_instance_pool_id: Optional[_builtins.str] = None,
                 driver_node_type_id: Optional[_builtins.str] = None,
                 enable_elastic_disk: Optional[_builtins.bool] = None,
                 enable_local_disk_encryption: Optional[_builtins.bool] = None,
                 gcp_attributes: Optional['outputs.JobTaskNewClusterGcpAttributes'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.JobTaskNewClusterInitScript']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 is_single_node: Optional[_builtins.bool] = None,
                 kind: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.JobTaskNewClusterLibrary']] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 provider_config: Optional['outputs.JobTaskNewClusterProviderConfig'] = None,
                 remote_disk_throughput: Optional[_builtins.int] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 total_initial_remote_disk_size: Optional[_builtins.int] = None,
                 use_ml_runtime: Optional[_builtins.bool] = None,
                 workload_type: Optional['outputs.JobTaskNewClusterWorkloadType'] = None):
        """
        :param Sequence['JobTaskNewClusterLibraryArgs'] libraries: (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        :param 'JobTaskNewClusterProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        :param 'JobTaskNewClusterWorkloadTypeArgs' workload_type: isn't supported
        """
        if __apply_policy_default_values_allow_lists is not None:
            pulumi.set(__self__, "__apply_policy_default_values_allow_lists", __apply_policy_default_values_allow_lists)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if is_single_node is not None:
            pulumi.set(__self__, "is_single_node", is_single_node)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if remote_disk_throughput is not None:
            pulumi.set(__self__, "remote_disk_throughput", remote_disk_throughput)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if total_initial_remote_disk_size is not None:
            pulumi.set(__self__, "total_initial_remote_disk_size", total_initial_remote_disk_size)
        if use_ml_runtime is not None:
            pulumi.set(__self__, "use_ml_runtime", use_ml_runtime)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="__applyPolicyDefaultValuesAllowLists")
    def __apply_policy_default_values_allow_lists(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "__apply_policy_default_values_allow_lists")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.JobTaskNewClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.JobTaskNewClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.JobTaskNewClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.JobTaskNewClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.JobTaskNewClusterClusterMountInfo']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.JobTaskNewClusterDockerImage']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.JobTaskNewClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.JobTaskNewClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="isSingleNode")
    def is_single_node(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_single_node")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.JobTaskNewClusterLibrary']]:
        """
        (List) An optional list of libraries to be installed on the cluster that will execute the job. See library Configuration Block below.
        """
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobTaskNewClusterProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter(name="remoteDiskThroughput")
    def remote_disk_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "remote_disk_throughput")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="totalInitialRemoteDiskSize")
    def total_initial_remote_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_initial_remote_disk_size")

    @_builtins.property
    @pulumi.getter(name="useMlRuntime")
    def use_ml_runtime(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_ml_runtime")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.JobTaskNewClusterWorkloadType']:
        """
        isn't supported
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class JobTaskNewClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class JobTaskNewClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeIops":
            suggest = "ebs_volume_iops"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeThroughput":
            suggest = "ebs_volume_throughput"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobTaskNewClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "logAnalyticsInfo":
            suggest = "log_analytics_info"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.JobTaskNewClusterAzureAttributesLogAnalyticsInfo'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.JobTaskNewClusterAzureAttributesLogAnalyticsInfo']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class JobTaskNewClusterAzureAttributesLogAnalyticsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsPrimaryKey":
            suggest = "log_analytics_primary_key"
        elif key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterAzureAttributesLogAnalyticsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class JobTaskNewClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.JobTaskNewClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.JobTaskNewClusterClusterLogConfS3'] = None,
                 volumes: Optional['outputs.JobTaskNewClusterClusterLogConfVolumes'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.JobTaskNewClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobTaskNewClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobTaskNewClusterClusterLogConfVolumes']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class JobTaskNewClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobTaskNewClusterClusterLogConfVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterClusterMountInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localMountDirPath":
            suggest = "local_mount_dir_path"
        elif key == "networkFilesystemInfo":
            suggest = "network_filesystem_info"
        elif key == "remoteMountDirPath":
            suggest = "remote_mount_dir_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterClusterMountInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterClusterMountInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterClusterMountInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddress":
            suggest = "server_address"
        elif key == "mountOptions":
            suggest = "mount_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterClusterMountInfoNetworkFilesystemInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class JobTaskNewClusterDockerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterDockerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterDockerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterDockerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.JobTaskNewClusterDockerImageBasicAuth'] = None):
        """
        :param _builtins.str url: URL of the job on the given workspace
        """
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of the job on the given workspace
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.JobTaskNewClusterDockerImageBasicAuth']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class JobTaskNewClusterDockerImageBasicAuth(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class JobTaskNewClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "usePreemptibleExecutors":
            suggest = "use_preemptible_executors"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class JobTaskNewClusterInitScript(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.JobTaskNewClusterInitScriptAbfss'] = None,
                 dbfs: Optional['outputs.JobTaskNewClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.JobTaskNewClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.JobTaskNewClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.JobTaskNewClusterInitScriptS3'] = None,
                 volumes: Optional['outputs.JobTaskNewClusterInitScriptVolumes'] = None,
                 workspace: Optional['outputs.JobTaskNewClusterInitScriptWorkspace'] = None):
        """
        :param 'JobTaskNewClusterInitScriptFileArgs' file: block consisting of single string fields:
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.JobTaskNewClusterInitScriptAbfss']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.JobTaskNewClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobTaskNewClusterInitScriptFile']:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.JobTaskNewClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.JobTaskNewClusterInitScriptS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.JobTaskNewClusterInitScriptVolumes']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.JobTaskNewClusterInitScriptWorkspace']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class JobTaskNewClusterInitScriptAbfss(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class JobTaskNewClusterInitScriptVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterInitScriptWorkspace(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class JobTaskNewClusterLibrary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerConfig":
            suggest = "provider_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterLibrary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterLibrary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterLibrary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cran: Optional['outputs.JobTaskNewClusterLibraryCran'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.JobTaskNewClusterLibraryMaven'] = None,
                 provider_config: Optional['outputs.JobTaskNewClusterLibraryProviderConfig'] = None,
                 pypi: Optional['outputs.JobTaskNewClusterLibraryPypi'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'JobTaskNewClusterLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.JobTaskNewClusterLibraryCran']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.JobTaskNewClusterLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.JobTaskNewClusterLibraryProviderConfig']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.JobTaskNewClusterLibraryPypi']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class JobTaskNewClusterLibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskNewClusterLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskNewClusterLibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterLibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterLibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterLibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobTaskNewClusterLibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class JobTaskNewClusterProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNewClusterProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNewClusterProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNewClusterProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class JobTaskNewClusterWorkloadType(dict):
    def __init__(__self__, *,
                 clients: 'outputs.JobTaskNewClusterWorkloadTypeClients'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.JobTaskNewClusterWorkloadTypeClients':
        return pulumi.get(self, "clients")


@pulumi.output_type
class JobTaskNewClusterWorkloadTypeClients(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class JobTaskNotebookTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notebookPath":
            suggest = "notebook_path"
        elif key == "baseParameters":
            suggest = "base_parameters"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNotebookTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNotebookTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNotebookTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notebook_path: _builtins.str,
                 base_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str notebook_path: The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        :param Mapping[str, _builtins.str] base_parameters: (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job's base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        :param _builtins.str source: Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        :param _builtins.str warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> _builtins.str:
        """
        The path of the Notebook to be run in the Databricks workspace or remote repository. For notebooks stored in the Databricks workspace, the path must be absolute and begin with a slash. For notebooks stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "notebook_path")

    @_builtins.property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) Base parameters to be used for each run of this job. If the run is initiated by a call to run-now with parameters specified, the two parameters maps will be merged. If the same key is specified in base_parameters and in run-now, the value from run-now will be used. If the notebook takes a parameter that is not specified in the job's base_parameters or the run-now override parameters, the default value from the notebook will be used. Retrieve these parameters in a notebook using `dbutils.widgets.get`.
        """
        return pulumi.get(self, "base_parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Location type of the notebook, can only be `WORKSPACE` or `GIT`. When set to `WORKSPACE`, the notebook will be retrieved from the local Databricks workspace. When set to `GIT`, the notebook will be retrieved from a Git repository defined in `git_source`. If the value is empty, the task will use `GIT` if `git_source` is defined and `WORKSPACE` otherwise.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task with SQL notebook.
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertOnLastAttempt":
            suggest = "alert_on_last_attempt"
        elif key == "noAlertForCanceledRuns":
            suggest = "no_alert_for_canceled_runs"
        elif key == "noAlertForSkippedRuns":
            suggest = "no_alert_for_skipped_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[_builtins.bool] = None,
                 no_alert_for_canceled_runs: Optional[_builtins.bool] = None,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool alert_on_last_attempt: (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        :param _builtins.bool no_alert_for_canceled_runs: (Bool) don't send alert for cancelled runs.
               
               The following parameter is only available on task level.
        :param _builtins.bool no_alert_for_skipped_runs: (Bool) don't send alert for skipped runs.
        """
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @_builtins.property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[_builtins.bool]:
        """
        (Bool) do not send notifications to recipients specified in `on_start` for the retried runs and do not send notifications to recipients specified in `on_failure` until the last retry of the run.
        """
        return pulumi.get(self, "alert_on_last_attempt")

    @_builtins.property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for cancelled runs.

        The following parameter is only available on task level.
        """
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        """
        (Bool) don't send alert for skipped runs.
        """
        return pulumi.get(self, "no_alert_for_skipped_runs")


@pulumi.output_type
class JobTaskPipelineTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "fullRefresh":
            suggest = "full_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPipelineTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPipelineTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPipelineTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: _builtins.str,
                 full_refresh: Optional[_builtins.bool] = None):
        """
        :param _builtins.str pipeline_id: The pipeline's unique ID.
        :param _builtins.bool full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        """
        The pipeline's unique ID.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class JobTaskPowerBiTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionResourceName":
            suggest = "connection_resource_name"
        elif key == "powerBiModel":
            suggest = "power_bi_model"
        elif key == "refreshAfterUpdate":
            suggest = "refresh_after_update"
        elif key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPowerBiTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPowerBiTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPowerBiTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 power_bi_model: Optional['outputs.JobTaskPowerBiTaskPowerBiModel'] = None,
                 refresh_after_update: Optional[_builtins.bool] = None,
                 tables: Optional[Sequence['outputs.JobTaskPowerBiTaskTable']] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_resource_name: The resource name of the UC connection to authenticate from Databricks to Power BI
        :param 'JobTaskPowerBiTaskPowerBiModelArgs' power_bi_model: The semantic model to update. Block consists of following fields:
        :param _builtins.bool refresh_after_update: Whether the model should be refreshed after the update. Default is false
        :param Sequence['JobTaskPowerBiTaskTableArgs'] tables: The tables to be exported to Power BI. Block consists of following fields:
        :param _builtins.str warehouse_id: The SQL warehouse ID to use as the Power BI data source
        """
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if power_bi_model is not None:
            pulumi.set(__self__, "power_bi_model", power_bi_model)
        if refresh_after_update is not None:
            pulumi.set(__self__, "refresh_after_update", refresh_after_update)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        """
        The resource name of the UC connection to authenticate from Databricks to Power BI
        """
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="powerBiModel")
    def power_bi_model(self) -> Optional['outputs.JobTaskPowerBiTaskPowerBiModel']:
        """
        The semantic model to update. Block consists of following fields:
        """
        return pulumi.get(self, "power_bi_model")

    @_builtins.property
    @pulumi.getter(name="refreshAfterUpdate")
    def refresh_after_update(self) -> Optional[_builtins.bool]:
        """
        Whether the model should be refreshed after the update. Default is false
        """
        return pulumi.get(self, "refresh_after_update")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.JobTaskPowerBiTaskTable']]:
        """
        The tables to be exported to Power BI. Block consists of following fields:
        """
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        The SQL warehouse ID to use as the Power BI data source
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class JobTaskPowerBiTaskPowerBiModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "overwriteExisting":
            suggest = "overwrite_existing"
        elif key == "storageMode":
            suggest = "storage_mode"
        elif key == "workspaceName":
            suggest = "workspace_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPowerBiTaskPowerBiModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPowerBiTaskPowerBiModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPowerBiTaskPowerBiModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 overwrite_existing: Optional[_builtins.bool] = None,
                 storage_mode: Optional[_builtins.str] = None,
                 workspace_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str authentication_method: How the published Power BI model authenticates to Databricks
        :param _builtins.str model_name: The name of the Power BI model
        :param _builtins.bool overwrite_existing: Whether to overwrite existing Power BI models. Default is false
        :param _builtins.str storage_mode: The default storage mode of the Power BI model
        :param _builtins.str workspace_name: The name of the Power BI workspace of the model
        """
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if overwrite_existing is not None:
            pulumi.set(__self__, "overwrite_existing", overwrite_existing)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)
        if workspace_name is not None:
            pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[_builtins.str]:
        """
        How the published Power BI model authenticates to Databricks
        """
        return pulumi.get(self, "authentication_method")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        """
        The name of the Power BI model
        """
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="overwriteExisting")
    def overwrite_existing(self) -> Optional[_builtins.bool]:
        """
        Whether to overwrite existing Power BI models. Default is false
        """
        return pulumi.get(self, "overwrite_existing")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        """
        The default storage mode of the Power BI model
        """
        return pulumi.get(self, "storage_mode")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> Optional[_builtins.str]:
        """
        The name of the Power BI workspace of the model
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class JobTaskPowerBiTaskTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageMode":
            suggest = "storage_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPowerBiTaskTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPowerBiTaskTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPowerBiTaskTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 storage_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str catalog: The catalog name in Databricks
        :param _builtins.str name: The table name in Databricks. If empty, all tables under the schema are selected.
        :param _builtins.str schema: The schema name in Databricks
        :param _builtins.str storage_mode: The Power BI storage mode of the table
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        """
        The catalog name in Databricks
        """
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The table name in Databricks. If empty, all tables under the schema are selected.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The schema name in Databricks
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        """
        The Power BI storage mode of the table
        """
        return pulumi.get(self, "storage_mode")


@pulumi.output_type
class JobTaskPythonWheelTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPoint":
            suggest = "entry_point"
        elif key == "namedParameters":
            suggest = "named_parameters"
        elif key == "packageName":
            suggest = "package_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskPythonWheelTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskPythonWheelTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskPythonWheelTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_point: Optional[_builtins.str] = None,
                 named_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 package_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str entry_point: Python function as entry point for the task
        :param Mapping[str, _builtins.str] named_parameters: Named parameters for the task
        :param _builtins.str package_name: Name of Python package
        :param Sequence[_builtins.str] parameters: Parameters for the task
        """
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        """
        Python function as entry point for the task
        """
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Named parameters for the task
        """
        return pulumi.get(self, "named_parameters")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        """
        Name of Python package
        """
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameters for the task
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskRunJobTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobId":
            suggest = "job_id"
        elif key == "dbtCommands":
            suggest = "dbt_commands"
        elif key == "jarParams":
            suggest = "jar_params"
        elif key == "jobParameters":
            suggest = "job_parameters"
        elif key == "notebookParams":
            suggest = "notebook_params"
        elif key == "pipelineParams":
            suggest = "pipeline_params"
        elif key == "pythonNamedParams":
            suggest = "python_named_params"
        elif key == "pythonParams":
            suggest = "python_params"
        elif key == "sparkSubmitParams":
            suggest = "spark_submit_params"
        elif key == "sqlParams":
            suggest = "sql_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskRunJobTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskRunJobTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskRunJobTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_id: _builtins.int,
                 dbt_commands: Optional[Sequence[_builtins.str]] = None,
                 jar_params: Optional[Sequence[_builtins.str]] = None,
                 job_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 notebook_params: Optional[Mapping[str, _builtins.str]] = None,
                 pipeline_params: Optional['outputs.JobTaskRunJobTaskPipelineParams'] = None,
                 python_named_params: Optional[Mapping[str, _builtins.str]] = None,
                 python_params: Optional[Sequence[_builtins.str]] = None,
                 spark_submit_params: Optional[Sequence[_builtins.str]] = None,
                 sql_params: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.int job_id: (String) ID of the job
        :param Mapping[str, _builtins.str] job_parameters: (Map) Job parameters for the task
        """
        pulumi.set(__self__, "job_id", job_id)
        if dbt_commands is not None:
            pulumi.set(__self__, "dbt_commands", dbt_commands)
        if jar_params is not None:
            pulumi.set(__self__, "jar_params", jar_params)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)
        if notebook_params is not None:
            pulumi.set(__self__, "notebook_params", notebook_params)
        if pipeline_params is not None:
            pulumi.set(__self__, "pipeline_params", pipeline_params)
        if python_named_params is not None:
            pulumi.set(__self__, "python_named_params", python_named_params)
        if python_params is not None:
            pulumi.set(__self__, "python_params", python_params)
        if spark_submit_params is not None:
            pulumi.set(__self__, "spark_submit_params", spark_submit_params)
        if sql_params is not None:
            pulumi.set(__self__, "sql_params", sql_params)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.int:
        """
        (String) ID of the job
        """
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="dbtCommands")
    def dbt_commands(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dbt_commands")

    @_builtins.property
    @pulumi.getter(name="jarParams")
    def jar_params(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "jar_params")

    @_builtins.property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) Job parameters for the task
        """
        return pulumi.get(self, "job_parameters")

    @_builtins.property
    @pulumi.getter(name="notebookParams")
    def notebook_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "notebook_params")

    @_builtins.property
    @pulumi.getter(name="pipelineParams")
    def pipeline_params(self) -> Optional['outputs.JobTaskRunJobTaskPipelineParams']:
        return pulumi.get(self, "pipeline_params")

    @_builtins.property
    @pulumi.getter(name="pythonNamedParams")
    def python_named_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "python_named_params")

    @_builtins.property
    @pulumi.getter(name="pythonParams")
    def python_params(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "python_params")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitParams")
    def spark_submit_params(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "spark_submit_params")

    @_builtins.property
    @pulumi.getter(name="sqlParams")
    def sql_params(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "sql_params")


@pulumi.output_type
class JobTaskRunJobTaskPipelineParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullRefresh":
            suggest = "full_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskRunJobTaskPipelineParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskRunJobTaskPipelineParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskRunJobTaskPipelineParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_refresh: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool full_refresh: (Bool) Specifies if there should be full refresh of the pipeline.
               
               > The following configuration blocks are only supported inside a `task` block
        """
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        """
        (Bool) Specifies if there should be full refresh of the pipeline.

        > The following configuration blocks are only supported inside a `task` block
        """
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class JobTaskSparkJarTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jarUri":
            suggest = "jar_uri"
        elif key == "mainClassName":
            suggest = "main_class_name"
        elif key == "runAsRepl":
            suggest = "run_as_repl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSparkJarTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSparkJarTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSparkJarTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar_uri: Optional[_builtins.str] = None,
                 main_class_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 run_as_repl: Optional[_builtins.bool] = None):
        """
        :param _builtins.str main_class_name: The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        :param Sequence[_builtins.str] parameters: (List) Parameters passed to the main method.
        """
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if run_as_repl is not None:
            pulumi.set(__self__, "run_as_repl", run_as_repl)

    @_builtins.property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar_uri")

    @_builtins.property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[_builtins.str]:
        """
        The full name of the class containing the main method to be executed. This class must be contained in a JAR provided as a library. The code should use `SparkContext.getOrCreate` to obtain a Spark context; otherwise, runs of the job will fail.
        """
        return pulumi.get(self, "main_class_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Parameters passed to the main method.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="runAsRepl")
    def run_as_repl(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "run_as_repl")


@pulumi.output_type
class JobTaskSparkPythonTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonFile":
            suggest = "python_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSparkPythonTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSparkPythonTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSparkPythonTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_file: _builtins.str,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str python_file: The URI of the Python file to be executed. Cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/`. For files stored in a remote repository, the path must be relative. This field is required.
        :param Sequence[_builtins.str] parameters: (List) Command line parameters passed to the Python file.
        :param _builtins.str source: Location type of the Python file. When set to `WORKSPACE` or not specified, the file will be retrieved from the local Databricks workspace or cloud location (if the python_file has a URI format). When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
               * `WORKSPACE`: The Python file is located in a Databricks workspace or at a cloud filesystem URI.
               * `GIT`: The Python file is located in a remote Git repository.
        """
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> _builtins.str:
        """
        The URI of the Python file to be executed. Cloud file URIs (e.g. `s3:/`, `abfss:/`, `gs:/`), workspace paths and remote repository are supported. For Python files stored in the Databricks workspace, the path must be absolute and begin with `/`. For files stored in a remote repository, the path must be relative. This field is required.
        """
        return pulumi.get(self, "python_file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Command line parameters passed to the Python file.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Location type of the Python file. When set to `WORKSPACE` or not specified, the file will be retrieved from the local Databricks workspace or cloud location (if the python_file has a URI format). When set to `GIT`, the Python file will be retrieved from a Git repository defined in `git_source`.
        * `WORKSPACE`: The Python file is located in a Databricks workspace or at a cloud filesystem URI.
        * `GIT`: The Python file is located in a remote Git repository.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class JobTaskSparkSubmitTask(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] parameters: (List) Command-line parameters passed to spark submit.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (List) Command-line parameters passed to spark submit.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class JobTaskSqlTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "warehouseId":
            suggest = "warehouse_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 warehouse_id: _builtins.str,
                 alert: Optional['outputs.JobTaskSqlTaskAlert'] = None,
                 dashboard: Optional['outputs.JobTaskSqlTaskDashboard'] = None,
                 file: Optional['outputs.JobTaskSqlTaskFile'] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 query: Optional['outputs.JobTaskSqlTaskQuery'] = None):
        """
        :param _builtins.str warehouse_id: ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        :param 'JobTaskSqlTaskAlertArgs' alert: block consisting of following fields:
        :param 'JobTaskSqlTaskDashboardArgs' dashboard: block consisting of following fields:
        :param 'JobTaskSqlTaskFileArgs' file: block consisting of single string fields:
        :param Mapping[str, _builtins.str] parameters: (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        :param 'JobTaskSqlTaskQueryArgs' query: block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> _builtins.str:
        """
        ID of the (the databricks_sql_endpoint) that will be used to execute the task.  Only Serverless & Pro warehouses are supported right now.
        """
        return pulumi.get(self, "warehouse_id")

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional['outputs.JobTaskSqlTaskAlert']:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "alert")

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional['outputs.JobTaskSqlTaskDashboard']:
        """
        block consisting of following fields:
        """
        return pulumi.get(self, "dashboard")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.JobTaskSqlTaskFile']:
        """
        block consisting of single string fields:
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Map) parameters to be used for each run of this task. The SQL alert task does not support custom parameters.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional['outputs.JobTaskSqlTaskQuery']:
        """
        block consisting of single string field: `query_id` - identifier of the Databricks Query (databricks_query).
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class JobTaskSqlTaskAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "pauseSubscriptions":
            suggest = "pause_subscriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: _builtins.str,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.JobTaskSqlTaskAlertSubscription']] = None):
        """
        :param _builtins.str alert_id: (String) identifier of the Databricks Alert (databricks_alert).
        :param _builtins.bool pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param Sequence['JobTaskSqlTaskAlertSubscriptionArgs'] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> _builtins.str:
        """
        (String) identifier of the Databricks Alert (databricks_alert).
        """
        return pulumi.get(self, "alert_id")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.JobTaskSqlTaskAlertSubscription']]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class JobTaskSqlTaskAlertSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskAlertSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskAlertSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskAlertSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobTaskSqlTaskDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashboardId":
            suggest = "dashboard_id"
        elif key == "customSubject":
            suggest = "custom_subject"
        elif key == "pauseSubscriptions":
            suggest = "pause_subscriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboard_id: _builtins.str,
                 custom_subject: Optional[_builtins.str] = None,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.JobTaskSqlTaskDashboardSubscription']] = None):
        """
        :param _builtins.str dashboard_id: (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        :param _builtins.str custom_subject: string specifying a custom subject of email sent.
        :param _builtins.bool pause_subscriptions: flag that specifies if subscriptions are paused or not.
        :param Sequence['JobTaskSqlTaskDashboardSubscriptionArgs'] subscriptions: a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        """
        (String) identifier of the Databricks SQL Dashboard databricks_sql_dashboard.
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        """
        string specifying a custom subject of email sent.
        """
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        """
        flag that specifies if subscriptions are paused or not.
        """
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.JobTaskSqlTaskDashboardSubscription']]:
        """
        a list of subscription blocks consisting out of one of the required fields: `user_name` for user emails or `destination_id` - for Alert destination's identifier.
        """
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class JobTaskSqlTaskDashboardSubscription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskDashboardSubscription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskDashboardSubscription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskDashboardSubscription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        A snapshot of the dashboard will be sent to the destination when the `destination_id` field is present.
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class JobTaskSqlTaskFile(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.
               
               Example
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               sql_aggregation_job = databricks.Job("sql_aggregation_job",
                   name="Example SQL Job",
                   tasks=[
                       {
                           "task_key": "run_agg_query",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "query": {
                                   "query_id": agg_query["id"],
                               },
                           },
                       },
                       {
                           "task_key": "run_dashboard",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "dashboard": {
                                   "dashboard_id": dash["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                       {
                           "task_key": "run_alert",
                           "sql_task": {
                               "warehouse_id": sql_job_warehouse["id"],
                               "alert": {
                                   "alert_id": alert["id"],
                                   "subscriptions": [{
                                       "user_name": "user@domain.com",
                                   }],
                               },
                           },
                       },
                   ])
               ```
        :param _builtins.str source: The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        If `source` is `GIT`: Relative path to the file in the repository specified in the `git_source` block with SQL commands to execute. If `source` is `WORKSPACE`: Absolute path to the file in the workspace with SQL commands to execute.

        Example

        ```python
        import pulumi
        import pulumi_databricks as databricks

        sql_aggregation_job = databricks.Job("sql_aggregation_job",
            name="Example SQL Job",
            tasks=[
                {
                    "task_key": "run_agg_query",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "query": {
                            "query_id": agg_query["id"],
                        },
                    },
                },
                {
                    "task_key": "run_dashboard",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "dashboard": {
                            "dashboard_id": dash["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
                {
                    "task_key": "run_alert",
                    "sql_task": {
                        "warehouse_id": sql_job_warehouse["id"],
                        "alert": {
                            "alert_id": alert["id"],
                            "subscriptions": [{
                                "user_name": "user@domain.com",
                            }],
                        },
                    },
                },
            ])
        ```
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The source of the project. Possible values are `WORKSPACE` and `GIT`.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class JobTaskSqlTaskQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskSqlTaskQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskSqlTaskQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskSqlTaskQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: _builtins.str):
        pulumi.set(__self__, "query_id", query_id)

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        return pulumi.get(self, "query_id")


@pulumi.output_type
class JobTaskWebhookNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDurationWarningThresholdExceededs":
            suggest = "on_duration_warning_threshold_exceededs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onStreamingBacklogExceededs":
            suggest = "on_streaming_backlog_exceededs"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTaskWebhookNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTaskWebhookNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTaskWebhookNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['outputs.JobTaskWebhookNotificationsOnDurationWarningThresholdExceeded']] = None,
                 on_failures: Optional[Sequence['outputs.JobTaskWebhookNotificationsOnFailure']] = None,
                 on_starts: Optional[Sequence['outputs.JobTaskWebhookNotificationsOnStart']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['outputs.JobTaskWebhookNotificationsOnStreamingBacklogExceeded']] = None,
                 on_successes: Optional[Sequence['outputs.JobTaskWebhookNotificationsOnSuccess']] = None):
        """
        :param Sequence['JobTaskWebhookNotificationsOnDurationWarningThresholdExceededArgs'] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param Sequence['JobTaskWebhookNotificationsOnFailureArgs'] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param Sequence['JobTaskWebhookNotificationsOnStartArgs'] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param Sequence['JobTaskWebhookNotificationsOnStreamingBacklogExceededArgs'] on_streaming_backlog_exceededs: (List) list of notification IDs to call when any streaming backlog thresholds are exceeded for any stream.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
        :param Sequence['JobTaskWebhookNotificationsOnSuccessArgs'] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['outputs.JobTaskWebhookNotificationsOnDurationWarningThresholdExceeded']]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['outputs.JobTaskWebhookNotificationsOnFailure']]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['outputs.JobTaskWebhookNotificationsOnStart']]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['outputs.JobTaskWebhookNotificationsOnStreamingBacklogExceeded']]:
        """
        (List) list of notification IDs to call when any streaming backlog thresholds are exceeded for any stream.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['outputs.JobTaskWebhookNotificationsOnSuccess']]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobTaskWebhookNotificationsOnDurationWarningThresholdExceeded(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskWebhookNotificationsOnFailure(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskWebhookNotificationsOnStart(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskWebhookNotificationsOnStreamingBacklogExceeded(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTaskWebhookNotificationsOnSuccess(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileArrival":
            suggest = "file_arrival"
        elif key == "pauseStatus":
            suggest = "pause_status"
        elif key == "tableUpdate":
            suggest = "table_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_arrival: Optional['outputs.JobTriggerFileArrival'] = None,
                 pause_status: Optional[_builtins.str] = None,
                 periodic: Optional['outputs.JobTriggerPeriodic'] = None,
                 table_update: Optional['outputs.JobTriggerTableUpdate'] = None):
        """
        :param 'JobTriggerFileArrivalArgs' file_arrival: configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        :param _builtins.str pause_status: Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        :param 'JobTriggerPeriodicArgs' periodic: configuration block to define a trigger for Periodic Triggers consisting of the following attributes:
        :param 'JobTriggerTableUpdateArgs' table_update: configuration block to define a trigger for [Table Updates](https://docs.databricks.com/aws/en/jobs/trigger-table-update) consisting of following attributes:
        """
        if file_arrival is not None:
            pulumi.set(__self__, "file_arrival", file_arrival)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)
        if periodic is not None:
            pulumi.set(__self__, "periodic", periodic)
        if table_update is not None:
            pulumi.set(__self__, "table_update", table_update)

    @_builtins.property
    @pulumi.getter(name="fileArrival")
    def file_arrival(self) -> Optional['outputs.JobTriggerFileArrival']:
        """
        configuration block to define a trigger for [File Arrival events](https://learn.microsoft.com/en-us/azure/databricks/workflows/jobs/file-arrival-triggers) consisting of following attributes:
        """
        return pulumi.get(self, "file_arrival")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        Indicate whether this trigger is paused or not. Either `PAUSED` or `UNPAUSED`. When the `pause_status` field is omitted in the block, the server will default to using `UNPAUSED` as a value for `pause_status`.
        """
        return pulumi.get(self, "pause_status")

    @_builtins.property
    @pulumi.getter
    def periodic(self) -> Optional['outputs.JobTriggerPeriodic']:
        """
        configuration block to define a trigger for Periodic Triggers consisting of the following attributes:
        """
        return pulumi.get(self, "periodic")

    @_builtins.property
    @pulumi.getter(name="tableUpdate")
    def table_update(self) -> Optional['outputs.JobTriggerTableUpdate']:
        """
        configuration block to define a trigger for [Table Updates](https://docs.databricks.com/aws/en/jobs/trigger-table-update) consisting of following attributes:
        """
        return pulumi.get(self, "table_update")


@pulumi.output_type
class JobTriggerFileArrival(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minTimeBetweenTriggersSeconds":
            suggest = "min_time_between_triggers_seconds"
        elif key == "waitAfterLastChangeSeconds":
            suggest = "wait_after_last_change_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTriggerFileArrival. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTriggerFileArrival.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTriggerFileArrival.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 min_time_between_triggers_seconds: Optional[_builtins.int] = None,
                 wait_after_last_change_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str url: URL to be monitored for file arrivals. The path must point to the root or a subpath of the external location. Please note that the URL must have a trailing slash character (`/`).
        :param _builtins.int min_time_between_triggers_seconds: If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        :param _builtins.int wait_after_last_change_seconds: If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        pulumi.set(__self__, "url", url)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to be monitored for file arrivals. The path must point to the root or a subpath of the external location. Please note that the URL must have a trailing slash character (`/`).
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[_builtins.int]:
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @_builtins.property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[_builtins.int]:
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "wait_after_last_change_seconds")


@pulumi.output_type
class JobTriggerPeriodic(dict):
    def __init__(__self__, *,
                 interval: _builtins.int,
                 unit: _builtins.str):
        """
        :param _builtins.int interval: Specifies the interval at which the job should run.
        :param _builtins.str unit: The unit of time for the interval.  Possible values are: `DAYS`, `HOURS`, `WEEKS`.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        """
        Specifies the interval at which the job should run.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        """
        The unit of time for the interval.  Possible values are: `DAYS`, `HOURS`, `WEEKS`.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class JobTriggerTableUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableNames":
            suggest = "table_names"
        elif key == "minTimeBetweenTriggersSeconds":
            suggest = "min_time_between_triggers_seconds"
        elif key == "waitAfterLastChangeSeconds":
            suggest = "wait_after_last_change_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTriggerTableUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTriggerTableUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTriggerTableUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_names: Sequence[_builtins.str],
                 condition: Optional[_builtins.str] = None,
                 min_time_between_triggers_seconds: Optional[_builtins.int] = None,
                 wait_after_last_change_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] table_names: A non-empty list of tables to monitor for changes. The table name must be in the format `catalog_name.schema_name.table_name`.
        :param _builtins.str condition: The table(s) condition based on which to trigger a job run.  Possible values are `ANY_UPDATED`, `ALL_UPDATED`.
        :param _builtins.int min_time_between_triggers_seconds: If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        :param _builtins.int wait_after_last_change_seconds: If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        pulumi.set(__self__, "table_names", table_names)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Sequence[_builtins.str]:
        """
        A non-empty list of tables to monitor for changes. The table name must be in the format `catalog_name.schema_name.table_name`.
        """
        return pulumi.get(self, "table_names")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        The table(s) condition based on which to trigger a job run.  Possible values are `ANY_UPDATED`, `ALL_UPDATED`.
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[_builtins.int]:
        """
        If set, the trigger starts a run only after the specified amount of time passed since the last time the trigger fired. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @_builtins.property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[_builtins.int]:
        """
        If set, the trigger starts a run only after no file activity has occurred for the specified amount of time. This makes it possible to wait for a batch of incoming files to arrive before triggering a run. The minimum allowed value is 60 seconds.
        """
        return pulumi.get(self, "wait_after_last_change_seconds")


@pulumi.output_type
class JobWebhookNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDurationWarningThresholdExceededs":
            suggest = "on_duration_warning_threshold_exceededs"
        elif key == "onFailures":
            suggest = "on_failures"
        elif key == "onStarts":
            suggest = "on_starts"
        elif key == "onStreamingBacklogExceededs":
            suggest = "on_streaming_backlog_exceededs"
        elif key == "onSuccesses":
            suggest = "on_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobWebhookNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobWebhookNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobWebhookNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['outputs.JobWebhookNotificationsOnDurationWarningThresholdExceeded']] = None,
                 on_failures: Optional[Sequence['outputs.JobWebhookNotificationsOnFailure']] = None,
                 on_starts: Optional[Sequence['outputs.JobWebhookNotificationsOnStart']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['outputs.JobWebhookNotificationsOnStreamingBacklogExceeded']] = None,
                 on_successes: Optional[Sequence['outputs.JobWebhookNotificationsOnSuccess']] = None):
        """
        :param Sequence['JobWebhookNotificationsOnDurationWarningThresholdExceededArgs'] on_duration_warning_threshold_exceededs: (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        :param Sequence['JobWebhookNotificationsOnFailureArgs'] on_failures: (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        :param Sequence['JobWebhookNotificationsOnStartArgs'] on_starts: (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        :param Sequence['JobWebhookNotificationsOnStreamingBacklogExceededArgs'] on_streaming_backlog_exceededs: (List) list of notification IDs to call when any streaming backlog thresholds are exceeded for any stream.
               
               Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`
               
               Example
        :param Sequence['JobWebhookNotificationsOnSuccessArgs'] on_successes: (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['outputs.JobWebhookNotificationsOnDurationWarningThresholdExceeded']]:
        """
        (List) list of notification IDs to call when the duration of a run exceeds the threshold specified by the `RUN_DURATION_SECONDS` metric in the `health` block.
        """
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['outputs.JobWebhookNotificationsOnFailure']]:
        """
        (List) list of notification IDs to call when the run fails. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['outputs.JobWebhookNotificationsOnStart']]:
        """
        (List) list of notification IDs to call when the run starts. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['outputs.JobWebhookNotificationsOnStreamingBacklogExceeded']]:
        """
        (List) list of notification IDs to call when any streaming backlog thresholds are exceeded for any stream.

        Note that the `id` is not to be confused with the name of the alert destination. The `id` can be retrieved through the API or the URL of Databricks UI `https://<workspace host>/sql/destinations/<notification id>?o=<workspace id>`

        Example
        """
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['outputs.JobWebhookNotificationsOnSuccess']]:
        """
        (List) list of notification IDs to call when the run completes successfully. A maximum of 3 destinations can be specified.
        """
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class JobWebhookNotificationsOnDurationWarningThresholdExceeded(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobWebhookNotificationsOnFailure(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobWebhookNotificationsOnStart(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobWebhookNotificationsOnStreamingBacklogExceeded(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class JobWebhookNotificationsOnSuccess(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: ID of the job
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the job
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class LakehouseMonitorCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputColumns":
            suggest = "input_columns"
        elif key == "outputDataType":
            suggest = "output_data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: _builtins.str,
                 input_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 output_data_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str definition: [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param Sequence[_builtins.str] input_columns: Columns on the monitored table to apply the custom metrics to.
        :param _builtins.str name: Name of the custom metric.
        :param _builtins.str output_data_type: The output type of the custom metric.
        :param _builtins.str type: The type of the custom metric.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence[_builtins.str]:
        """
        Columns on the monitored table to apply the custom metrics to.
        """
        return pulumi.get(self, "input_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the custom metric.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> _builtins.str:
        """
        The output type of the custom metric.
        """
        return pulumi.get(self, "output_data_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the custom metric.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LakehouseMonitorDataClassificationConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LakehouseMonitorInferenceLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelIdCol":
            suggest = "model_id_col"
        elif key == "predictionCol":
            suggest = "prediction_col"
        elif key == "problemType":
            suggest = "problem_type"
        elif key == "timestampCol":
            suggest = "timestamp_col"
        elif key == "labelCol":
            suggest = "label_col"
        elif key == "predictionProbaCol":
            suggest = "prediction_proba_col"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorInferenceLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorInferenceLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorInferenceLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 model_id_col: _builtins.str,
                 prediction_col: _builtins.str,
                 problem_type: _builtins.str,
                 timestamp_col: _builtins.str,
                 label_col: Optional[_builtins.str] = None,
                 prediction_proba_col: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param _builtins.str model_id_col: Column of the model id or version
        :param _builtins.str prediction_col: Column of the model prediction
        :param _builtins.str problem_type: Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        :param _builtins.str timestamp_col: Column of the timestamp of predictions
        :param _builtins.str label_col: Column of the model label
        :param _builtins.str prediction_proba_col: Column of the model prediction probabilities
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_col", model_id_col)
        pulumi.set(__self__, "prediction_col", prediction_col)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_col", timestamp_col)
        if label_col is not None:
            pulumi.set(__self__, "label_col", label_col)
        if prediction_proba_col is not None:
            pulumi.set(__self__, "prediction_proba_col", prediction_proba_col)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="modelIdCol")
    def model_id_col(self) -> _builtins.str:
        """
        Column of the model id or version
        """
        return pulumi.get(self, "model_id_col")

    @_builtins.property
    @pulumi.getter(name="predictionCol")
    def prediction_col(self) -> _builtins.str:
        """
        Column of the model prediction
        """
        return pulumi.get(self, "prediction_col")

    @_builtins.property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> _builtins.str:
        """
        Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @_builtins.property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> _builtins.str:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")

    @_builtins.property
    @pulumi.getter(name="labelCol")
    def label_col(self) -> Optional[_builtins.str]:
        """
        Column of the model label
        """
        return pulumi.get(self, "label_col")

    @_builtins.property
    @pulumi.getter(name="predictionProbaCol")
    def prediction_proba_col(self) -> Optional[_builtins.str]:
        """
        Column of the model prediction probabilities
        """
        return pulumi.get(self, "prediction_proba_col")


@pulumi.output_type
class LakehouseMonitorNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"
        elif key == "onNewClassificationTagDetected":
            suggest = "on_new_classification_tag_detected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.LakehouseMonitorNotificationsOnFailure'] = None,
                 on_new_classification_tag_detected: Optional['outputs.LakehouseMonitorNotificationsOnNewClassificationTagDetected'] = None):
        """
        :param 'LakehouseMonitorNotificationsOnFailureArgs' on_failure: who to send notifications to on monitor failure.
        :param 'LakehouseMonitorNotificationsOnNewClassificationTagDetectedArgs' on_new_classification_tag_detected: Who to send notifications to when new data classification tags are detected.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_new_classification_tag_detected is not None:
            pulumi.set(__self__, "on_new_classification_tag_detected", on_new_classification_tag_detected)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.LakehouseMonitorNotificationsOnFailure']:
        """
        who to send notifications to on monitor failure.
        """
        return pulumi.get(self, "on_failure")

    @_builtins.property
    @pulumi.getter(name="onNewClassificationTagDetected")
    def on_new_classification_tag_detected(self) -> Optional['outputs.LakehouseMonitorNotificationsOnNewClassificationTagDetected']:
        """
        Who to send notifications to when new data classification tags are detected.
        """
        return pulumi.get(self, "on_new_classification_tag_detected")


@pulumi.output_type
class LakehouseMonitorNotificationsOnFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddresses":
            suggest = "email_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorNotificationsOnFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorNotificationsOnFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorNotificationsOnFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class LakehouseMonitorNotificationsOnNewClassificationTagDetected(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddresses":
            suggest = "email_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorNotificationsOnNewClassificationTagDetected. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorNotificationsOnNewClassificationTagDetected.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorNotificationsOnNewClassificationTagDetected.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class LakehouseMonitorSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronExpression":
            suggest = "quartz_cron_expression"
        elif key == "timezoneId":
            suggest = "timezone_id"
        elif key == "pauseStatus":
            suggest = "pause_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_expression: string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        :param _builtins.str timezone_id: string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        :param _builtins.str pause_status: optional string field that indicates whether a schedule is paused (`PAUSED`) or not (`UNPAUSED`).
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        """
        string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        optional string field that indicates whether a schedule is paused (`PAUSED`) or not (`UNPAUSED`).
        """
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class LakehouseMonitorSnapshot(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class LakehouseMonitorTimeSeries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timestampCol":
            suggest = "timestamp_col"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LakehouseMonitorTimeSeries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LakehouseMonitorTimeSeries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LakehouseMonitorTimeSeries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 timestamp_col: _builtins.str):
        """
        :param Sequence[_builtins.str] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param _builtins.str timestamp_col: Column of the timestamp of predictions
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_col", timestamp_col)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> _builtins.str:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")


@pulumi.output_type
class LibraryCran(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str package: The name of the CRAN package to install.
        :param _builtins.str repo: The repository where the package can be found. If not specified, the default CRAN repo is used.
        """
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        """
        The name of the CRAN package to install.
        """
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The repository where the package can be found. If not specified, the default CRAN repo is used.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class LibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str coordinates: Gradle-style Maven coordinates. For example: `org.jsoup:jsoup:1.7.2`.
        :param Sequence[_builtins.str] exclusions: List of dependencies to exclude. For example: `["slf4j:slf4j", "*:hadoop-client"]`. See [Maven dependency exclusions](https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html) for more information.
        :param _builtins.str repo: Maven repository to install the Maven package from. If omitted, both Maven Central Repository and Spark Packages are searched.
        """
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        """
        Gradle-style Maven coordinates. For example: `org.jsoup:jsoup:1.7.2`.
        """
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of dependencies to exclude. For example: `["slf4j:slf4j", "*:hadoop-client"]`. See [Maven dependency exclusions](https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html) for more information.
        """
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        Maven repository to install the Maven package from. If omitted, both Maven Central Repository and Spark Packages are searched.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class LibraryProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LibraryProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LibraryProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LibraryProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID that the resource belongs to. This workspace must be part of the account that the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID that the resource belongs to. This workspace must be part of the account that the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class LibraryPypi(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str package: The name of the PyPI package to install. An optional exact version specification is also supported. For example: `simplejson` or `simplejson==3.8.0`.
        :param _builtins.str repo: The repository where the package can be found. If not specified, the default pip index is used.
        """
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        """
        The name of the PyPI package to install. An optional exact version specification is also supported. For example: `simplejson` or `simplejson==3.8.0`.
        """
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The repository where the package can be found. If not specified, the default pip index is used.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class MetastoreDataAccessAwsIamRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "unityCatalogIamArn":
            suggest = "unity_catalog_iam_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessAwsIamRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessAwsIamRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessAwsIamRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 external_id: Optional[_builtins.str] = None,
                 unity_catalog_iam_arn: Optional[_builtins.str] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "unity_catalog_iam_arn")


@pulumi.output_type
class MetastoreDataAccessAzureManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConnectorId":
            suggest = "access_connector_id"
        elif key == "credentialId":
            suggest = "credential_id"
        elif key == "managedIdentityId":
            suggest = "managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessAzureManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessAzureManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessAzureManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_connector_id: _builtins.str,
                 credential_id: Optional[_builtins.str] = None,
                 managed_identity_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @_builtins.property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> _builtins.str:
        return pulumi.get(self, "access_connector_id")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_identity_id")


@pulumi.output_type
class MetastoreDataAccessAzureServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessAzureServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessAzureServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessAzureServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: _builtins.str,
                 client_secret: _builtins.str,
                 directory_id: _builtins.str):
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> _builtins.str:
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class MetastoreDataAccessCloudflareApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "accountId":
            suggest = "account_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessCloudflareApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessCloudflareApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessCloudflareApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 account_id: _builtins.str,
                 secret_access_key: _builtins.str):
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class MetastoreDataAccessDatabricksGcpServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialId":
            suggest = "credential_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessDatabricksGcpServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessDatabricksGcpServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessDatabricksGcpServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_id: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None):
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "email")


@pulumi.output_type
class MetastoreDataAccessGcpServiceAccountKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetastoreDataAccessGcpServiceAccountKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetastoreDataAccessGcpServiceAccountKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetastoreDataAccessGcpServiceAccountKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 private_key: _builtins.str,
                 private_key_id: _builtins.str):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> _builtins.str:
        return pulumi.get(self, "private_key_id")


@pulumi.output_type
class MlflowExperimentTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class MlflowModelTag(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class MlflowWebhookHttpUrlSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSslVerification":
            suggest = "enable_ssl_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlflowWebhookHttpUrlSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlflowWebhookHttpUrlSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlflowWebhookHttpUrlSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 authorization: Optional[_builtins.str] = None,
                 enable_ssl_verification: Optional[_builtins.bool] = None,
                 secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        :param _builtins.str authorization: Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        :param _builtins.bool enable_ssl_verification: Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        :param _builtins.str secret: Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
        pulumi.set(__self__, "url", url)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if enable_ssl_verification is not None:
            pulumi.set(__self__, "enable_ssl_verification", enable_ssl_verification)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        External HTTPS URL called on event trigger (by using a POST request). Structure of payload depends on the event type, refer to [documentation](https://docs.databricks.com/applications/mlflow/model-registry-webhooks.html) for more details.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional[_builtins.str]:
        """
        Value of the authorization header that should be sent in the request sent by the wehbook.  It should be of the form `<auth type> <credentials>`, e.g. `Bearer <access_token>`. If set to an empty string, no authorization header will be included in the request.
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="enableSslVerification")
    def enable_ssl_verification(self) -> Optional[_builtins.bool]:
        """
        Enable/disable SSL certificate validation. Default is `true`. For self-signed certificates, this field must be `false` AND the destination server must disable certificate validation as well. For security purposes, it is encouraged to perform secret validation with the HMAC-encoded portion of the payload and acknowledge the risk associated with disabling hostname validation whereby it becomes more likely that requests can be maliciously routed to an unintended host.
        """
        return pulumi.get(self, "enable_ssl_verification")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Shared secret required for HMAC encoding payload. The HMAC-encoded payload will be sent in the header as `X-Databricks-Signature: encoded_payload`.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class MlflowWebhookJobSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "jobId":
            suggest = "job_id"
        elif key == "workspaceUrl":
            suggest = "workspace_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlflowWebhookJobSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlflowWebhookJobSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlflowWebhookJobSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: _builtins.str,
                 job_id: _builtins.str,
                 workspace_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_token: The personal access token used to authorize webhook's job runs.
        :param _builtins.str job_id: ID of the Databricks job that the webhook runs.
        :param _builtins.str workspace_url: URL of the workspace containing the job that this webhook runs. If not specified, the jobs workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "job_id", job_id)
        if workspace_url is not None:
            pulumi.set(__self__, "workspace_url", workspace_url)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> _builtins.str:
        """
        The personal access token used to authorize webhook's job runs.
        """
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.str:
        """
        ID of the Databricks job that the webhook runs.
        """
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="workspaceUrl")
    def workspace_url(self) -> Optional[_builtins.str]:
        """
        URL of the workspace containing the job that this webhook runs. If not specified, the jobs workspace URL is assumed to be the same as the workspace where the webhook is created.
        """
        return pulumi.get(self, "workspace_url")


@pulumi.output_type
class ModelServingAiGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackConfig":
            suggest = "fallback_config"
        elif key == "inferenceTableConfig":
            suggest = "inference_table_config"
        elif key == "rateLimits":
            suggest = "rate_limits"
        elif key == "usageTrackingConfig":
            suggest = "usage_tracking_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingAiGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingAiGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingAiGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_config: Optional['outputs.ModelServingAiGatewayFallbackConfig'] = None,
                 guardrails: Optional['outputs.ModelServingAiGatewayGuardrails'] = None,
                 inference_table_config: Optional['outputs.ModelServingAiGatewayInferenceTableConfig'] = None,
                 rate_limits: Optional[Sequence['outputs.ModelServingAiGatewayRateLimit']] = None,
                 usage_tracking_config: Optional['outputs.ModelServingAiGatewayUsageTrackingConfig'] = None):
        """
        :param 'ModelServingAiGatewayFallbackConfigArgs' fallback_config: block with configuration for traffic fallback which auto fallbacks to other served entities if the request to a served entity fails with certain error codes, to increase availability.
        :param 'ModelServingAiGatewayGuardrailsArgs' guardrails: Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        :param 'ModelServingAiGatewayInferenceTableConfigArgs' inference_table_config: Block describing the configuration of usage tracking. Consists of the following attributes:
        :param Sequence['ModelServingAiGatewayRateLimitArgs'] rate_limits: Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        :param 'ModelServingAiGatewayUsageTrackingConfigArgs' usage_tracking_config: Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
        if fallback_config is not None:
            pulumi.set(__self__, "fallback_config", fallback_config)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if inference_table_config is not None:
            pulumi.set(__self__, "inference_table_config", inference_table_config)
        if rate_limits is not None:
            pulumi.set(__self__, "rate_limits", rate_limits)
        if usage_tracking_config is not None:
            pulumi.set(__self__, "usage_tracking_config", usage_tracking_config)

    @_builtins.property
    @pulumi.getter(name="fallbackConfig")
    def fallback_config(self) -> Optional['outputs.ModelServingAiGatewayFallbackConfig']:
        """
        block with configuration for traffic fallback which auto fallbacks to other served entities if the request to a served entity fails with certain error codes, to increase availability.
        """
        return pulumi.get(self, "fallback_config")

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional['outputs.ModelServingAiGatewayGuardrails']:
        """
        Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        """
        return pulumi.get(self, "guardrails")

    @_builtins.property
    @pulumi.getter(name="inferenceTableConfig")
    def inference_table_config(self) -> Optional['outputs.ModelServingAiGatewayInferenceTableConfig']:
        """
        Block describing the configuration of usage tracking. Consists of the following attributes:
        """
        return pulumi.get(self, "inference_table_config")

    @_builtins.property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Optional[Sequence['outputs.ModelServingAiGatewayRateLimit']]:
        """
        Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        """
        return pulumi.get(self, "rate_limits")

    @_builtins.property
    @pulumi.getter(name="usageTrackingConfig")
    def usage_tracking_config(self) -> Optional['outputs.ModelServingAiGatewayUsageTrackingConfig']:
        """
        Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
        return pulumi.get(self, "usage_tracking_config")


@pulumi.output_type
class ModelServingAiGatewayFallbackConfig(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Whether to enable traffic fallback. When a served entity in the serving endpoint returns specific error codes (e.g. 500), the request will automatically be round-robin attempted with other served entities in the same endpoint, following the order of served entity list, until a successful response is returned.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether to enable traffic fallback. When a served entity in the serving endpoint returns specific error codes (e.g. 500), the request will automatically be round-robin attempted with other served entities in the same endpoint, following the order of served entity list, until a successful response is returned.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ModelServingAiGatewayGuardrails(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.ModelServingAiGatewayGuardrailsInput'] = None,
                 output: Optional['outputs.ModelServingAiGatewayGuardrailsOutput'] = None):
        """
        :param 'ModelServingAiGatewayGuardrailsInputArgs' input: A block with configuration for input guardrail filters:
        :param 'ModelServingAiGatewayGuardrailsOutputArgs' output: A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.ModelServingAiGatewayGuardrailsInput']:
        """
        A block with configuration for input guardrail filters:
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.ModelServingAiGatewayGuardrailsOutput']:
        """
        A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class ModelServingAiGatewayGuardrailsInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invalidKeywords":
            suggest = "invalid_keywords"
        elif key == "validTopics":
            suggest = "valid_topics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingAiGatewayGuardrailsInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingAiGatewayGuardrailsInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingAiGatewayGuardrailsInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 invalid_keywords: Optional[Sequence[_builtins.str]] = None,
                 pii: Optional['outputs.ModelServingAiGatewayGuardrailsInputPii'] = None,
                 safety: Optional[_builtins.bool] = None,
                 valid_topics: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] invalid_keywords: List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        :param 'ModelServingAiGatewayGuardrailsInputPiiArgs' pii: Block with configuration for guardrail PII filter:
        :param _builtins.bool safety: the boolean flag that indicates whether the safety filter is enabled.
        :param Sequence[_builtins.str] valid_topics: The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if pii is not None:
            pulumi.set(__self__, "pii", pii)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @_builtins.property
    @pulumi.getter(name="invalidKeywords")
    @_utilities.deprecated("""Please use 'pii' and 'safety' instead.""")
    def invalid_keywords(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        return pulumi.get(self, "invalid_keywords")

    @_builtins.property
    @pulumi.getter
    def pii(self) -> Optional['outputs.ModelServingAiGatewayGuardrailsInputPii']:
        """
        Block with configuration for guardrail PII filter:
        """
        return pulumi.get(self, "pii")

    @_builtins.property
    @pulumi.getter
    def safety(self) -> Optional[_builtins.bool]:
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        return pulumi.get(self, "safety")

    @_builtins.property
    @pulumi.getter(name="validTopics")
    @_utilities.deprecated("""Please use 'pii' and 'safety' instead.""")
    def valid_topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        return pulumi.get(self, "valid_topics")


@pulumi.output_type
class ModelServingAiGatewayGuardrailsInputPii(dict):
    def __init__(__self__, *,
                 behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.str behavior: a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[_builtins.str]:
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class ModelServingAiGatewayGuardrailsOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invalidKeywords":
            suggest = "invalid_keywords"
        elif key == "validTopics":
            suggest = "valid_topics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingAiGatewayGuardrailsOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingAiGatewayGuardrailsOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingAiGatewayGuardrailsOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 invalid_keywords: Optional[Sequence[_builtins.str]] = None,
                 pii: Optional['outputs.ModelServingAiGatewayGuardrailsOutputPii'] = None,
                 safety: Optional[_builtins.bool] = None,
                 valid_topics: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] invalid_keywords: List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        :param 'ModelServingAiGatewayGuardrailsOutputPiiArgs' pii: Block with configuration for guardrail PII filter:
        :param _builtins.bool safety: the boolean flag that indicates whether the safety filter is enabled.
        :param Sequence[_builtins.str] valid_topics: The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if pii is not None:
            pulumi.set(__self__, "pii", pii)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @_builtins.property
    @pulumi.getter(name="invalidKeywords")
    @_utilities.deprecated("""Please use 'pii' and 'safety' instead.""")
    def invalid_keywords(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        return pulumi.get(self, "invalid_keywords")

    @_builtins.property
    @pulumi.getter
    def pii(self) -> Optional['outputs.ModelServingAiGatewayGuardrailsOutputPii']:
        """
        Block with configuration for guardrail PII filter:
        """
        return pulumi.get(self, "pii")

    @_builtins.property
    @pulumi.getter
    def safety(self) -> Optional[_builtins.bool]:
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        return pulumi.get(self, "safety")

    @_builtins.property
    @pulumi.getter(name="validTopics")
    @_utilities.deprecated("""Please use 'pii' and 'safety' instead.""")
    def valid_topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        return pulumi.get(self, "valid_topics")


@pulumi.output_type
class ModelServingAiGatewayGuardrailsOutputPii(dict):
    def __init__(__self__, *,
                 behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.str behavior: a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[_builtins.str]:
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class ModelServingAiGatewayInferenceTableConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogName":
            suggest = "catalog_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "tableNamePrefix":
            suggest = "table_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingAiGatewayInferenceTableConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingAiGatewayInferenceTableConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingAiGatewayInferenceTableConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 schema_name: Optional[_builtins.str] = None,
                 table_name_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str catalog_name: The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        :param _builtins.bool enabled: boolean flag specifying if usage tracking is enabled.
        :param _builtins.str schema_name: The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        :param _builtins.str table_name_prefix: The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if table_name_prefix is not None:
            pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        boolean flag specifying if usage tracking is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> Optional[_builtins.str]:
        """
        The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class ModelServingAiGatewayRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewalPeriod":
            suggest = "renewal_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingAiGatewayRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingAiGatewayRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingAiGatewayRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 renewal_period: _builtins.str,
                 calls: Optional[_builtins.int] = None,
                 key: Optional[_builtins.str] = None,
                 principal: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None):
        """
        :param _builtins.str renewal_period: Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        :param _builtins.int calls: Used to specify how many calls are allowed for a key within the renewal_period.
        :param _builtins.str key: Key field for a serving endpoint rate limit. Currently, `user`, `user_group`, `service_principal`, and `endpoint` are supported, with `endpoint` being the default if not specified.
        :param _builtins.str principal: Principal field for a user, user group, or service principal to apply rate limiting to. Accepts a user email, group name, or service principal application ID.
        :param _builtins.int tokens: Specifies how many tokens are allowed for a key within the renewal_period.
        """
        pulumi.set(__self__, "renewal_period", renewal_period)
        if calls is not None:
            pulumi.set(__self__, "calls", calls)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)

    @_builtins.property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> _builtins.str:
        """
        Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        """
        return pulumi.get(self, "renewal_period")

    @_builtins.property
    @pulumi.getter
    def calls(self) -> Optional[_builtins.int]:
        """
        Used to specify how many calls are allowed for a key within the renewal_period.
        """
        return pulumi.get(self, "calls")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key field for a serving endpoint rate limit. Currently, `user`, `user_group`, `service_principal`, and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        """
        Principal field for a user, user group, or service principal to apply rate limiting to. Accepts a user email, group name, or service principal application ID.
        """
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Specifies how many tokens are allowed for a key within the renewal_period.
        """
        return pulumi.get(self, "tokens")


@pulumi.output_type
class ModelServingAiGatewayUsageTrackingConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ModelServingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoCaptureConfig":
            suggest = "auto_capture_config"
        elif key == "servedEntities":
            suggest = "served_entities"
        elif key == "servedModels":
            suggest = "served_models"
        elif key == "trafficConfig":
            suggest = "traffic_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_capture_config: Optional['outputs.ModelServingConfigAutoCaptureConfig'] = None,
                 served_entities: Optional[Sequence['outputs.ModelServingConfigServedEntity']] = None,
                 served_models: Optional[Sequence['outputs.ModelServingConfigServedModel']] = None,
                 traffic_config: Optional['outputs.ModelServingConfigTrafficConfig'] = None):
        """
        :param 'ModelServingConfigAutoCaptureConfigArgs' auto_capture_config: Configuration for Inference Tables which automatically logs requests and responses to Unity Catalog.
        :param Sequence['ModelServingConfigServedEntityArgs'] served_entities: A list of served entities for the endpoint to serve. A serving endpoint can have up to 10 served entities.
        :param Sequence['ModelServingConfigServedModelArgs'] served_models: Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        :param 'ModelServingConfigTrafficConfigArgs' traffic_config: A single block represents the traffic split configuration amongst the served models.
        """
        if auto_capture_config is not None:
            pulumi.set(__self__, "auto_capture_config", auto_capture_config)
        if served_entities is not None:
            pulumi.set(__self__, "served_entities", served_entities)
        if served_models is not None:
            pulumi.set(__self__, "served_models", served_models)
        if traffic_config is not None:
            pulumi.set(__self__, "traffic_config", traffic_config)

    @_builtins.property
    @pulumi.getter(name="autoCaptureConfig")
    def auto_capture_config(self) -> Optional['outputs.ModelServingConfigAutoCaptureConfig']:
        """
        Configuration for Inference Tables which automatically logs requests and responses to Unity Catalog.
        """
        return pulumi.get(self, "auto_capture_config")

    @_builtins.property
    @pulumi.getter(name="servedEntities")
    def served_entities(self) -> Optional[Sequence['outputs.ModelServingConfigServedEntity']]:
        """
        A list of served entities for the endpoint to serve. A serving endpoint can have up to 10 served entities.
        """
        return pulumi.get(self, "served_entities")

    @_builtins.property
    @pulumi.getter(name="servedModels")
    @_utilities.deprecated("""Please use 'config.served_entities' instead of 'config.served_models'.""")
    def served_models(self) -> Optional[Sequence['outputs.ModelServingConfigServedModel']]:
        """
        Each block represents a served model for the endpoint to serve. A model serving endpoint can have up to 10 served models.
        """
        return pulumi.get(self, "served_models")

    @_builtins.property
    @pulumi.getter(name="trafficConfig")
    def traffic_config(self) -> Optional['outputs.ModelServingConfigTrafficConfig']:
        """
        A single block represents the traffic split configuration amongst the served models.
        """
        return pulumi.get(self, "traffic_config")


@pulumi.output_type
class ModelServingConfigAutoCaptureConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogName":
            suggest = "catalog_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "tableNamePrefix":
            suggest = "table_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigAutoCaptureConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigAutoCaptureConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigAutoCaptureConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 schema_name: Optional[_builtins.str] = None,
                 table_name_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str catalog_name: The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        :param _builtins.bool enabled: If inference tables are enabled or not. NOTE: If you have already disabled payload logging once, you cannot enable it again.
        :param _builtins.str schema_name: The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        :param _builtins.str table_name_prefix: The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if table_name_prefix is not None:
            pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog in Unity Catalog. NOTE: On update, you cannot change the catalog name if it was already set.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If inference tables are enabled or not. NOTE: If you have already disabled payload logging once, you cannot enable it again.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema in Unity Catalog. NOTE: On update, you cannot change the schema name if it was already set.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> Optional[_builtins.str]:
        """
        The prefix of the table in Unity Catalog. NOTE: On update, you cannot change the prefix name if it was already set.
        """
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class ModelServingConfigServedEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "entityVersion":
            suggest = "entity_version"
        elif key == "environmentVars":
            suggest = "environment_vars"
        elif key == "externalModel":
            suggest = "external_model"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "maxProvisionedConcurrency":
            suggest = "max_provisioned_concurrency"
        elif key == "maxProvisionedThroughput":
            suggest = "max_provisioned_throughput"
        elif key == "minProvisionedConcurrency":
            suggest = "min_provisioned_concurrency"
        elif key == "minProvisionedThroughput":
            suggest = "min_provisioned_throughput"
        elif key == "provisionedModelUnits":
            suggest = "provisioned_model_units"
        elif key == "scaleToZeroEnabled":
            suggest = "scale_to_zero_enabled"
        elif key == "workloadSize":
            suggest = "workload_size"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: Optional[_builtins.str] = None,
                 entity_version: Optional[_builtins.str] = None,
                 environment_vars: Optional[Mapping[str, _builtins.str]] = None,
                 external_model: Optional['outputs.ModelServingConfigServedEntityExternalModel'] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 max_provisioned_concurrency: Optional[_builtins.int] = None,
                 max_provisioned_throughput: Optional[_builtins.int] = None,
                 min_provisioned_concurrency: Optional[_builtins.int] = None,
                 min_provisioned_throughput: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 provisioned_model_units: Optional[_builtins.int] = None,
                 scale_to_zero_enabled: Optional[_builtins.bool] = None,
                 workload_size: Optional[_builtins.str] = None,
                 workload_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str entity_name: The name of the entity to be served. The entity may be a model in the Databricks Model Registry, a model in the Unity Catalog (UC), or a function of type `FEATURE_SPEC` in the UC. If it is a UC object, the full name of the object should be given in the form of `catalog_name.schema_name.model_name`.
        :param _builtins.str entity_version: The version of the model in Databricks Model Registry to be served or empty if the entity is a `FEATURE_SPEC`.
        :param Mapping[str, _builtins.str] environment_vars: An object containing a set of optional, user-specified environment variable key-value pairs used for serving this entity. Note: this is an experimental feature and is subject to change. Example entity environment variables that refer to Databricks secrets: ```{"OPENAI_API_KEY": "{{secrets/my_scope/my_key}}", "DATABRICKS_TOKEN": "{{secrets/my_scope2/my_key2}}"}```
        :param 'ModelServingConfigServedEntityExternalModelArgs' external_model: The external model to be served. NOTE: Only one of `external_model` and (`entity_name`, `entity_version`, `workload_size`, `workload_type`, and `scale_to_zero_enabled`) can be specified with the latter set being used for custom model serving for a Databricks registered model. When an `external_model` is present, the served entities list can only have one `served_entity` object. An existing endpoint with `external_model` can not be updated to an endpoint without `external_model`. If the endpoint is created without `external_model`, users cannot update it to add `external_model` later.
        :param _builtins.str instance_profile_arn: ARN of the instance profile that the served entity uses to access AWS resources.
        :param _builtins.int max_provisioned_concurrency: The maximum provisioned concurrency that the endpoint can scale up to. Conflicts with `workload_size`.
        :param _builtins.int max_provisioned_throughput: The maximum tokens per second that the endpoint can scale up to.
        :param _builtins.int min_provisioned_concurrency: The minimum provisioned concurrency that the endpoint can scale down to. Conflicts with `workload_size`.
        :param _builtins.int min_provisioned_throughput: The minimum tokens per second that the endpoint can scale down to.
        :param _builtins.str name: The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field defaults to `external_model.name`, with '.' and ':' replaced with '-', and if not specified for other entities, it defaults to -.
        :param _builtins.bool scale_to_zero_enabled: Whether the compute resources for the served entity should scale down to zero.
        :param _builtins.str workload_size: The workload size of the served entity. The workload size corresponds to a range of provisioned concurrency that the compute autoscales between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency). If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size is 0. Conflicts with `min_provisioned_concurrency` and `max_provisioned_concurrency`.
        :param _builtins.str workload_type: The workload type of the served entity. The workload type selects which type of compute to use in the endpoint. The default value for this parameter is `CPU`. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the available [GPU types](https://docs.databricks.com/machine-learning/model-serving/create-manage-serving-endpoints.html#gpu-workload-types).
        """
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if entity_version is not None:
            pulumi.set(__self__, "entity_version", entity_version)
        if environment_vars is not None:
            pulumi.set(__self__, "environment_vars", environment_vars)
        if external_model is not None:
            pulumi.set(__self__, "external_model", external_model)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if max_provisioned_concurrency is not None:
            pulumi.set(__self__, "max_provisioned_concurrency", max_provisioned_concurrency)
        if max_provisioned_throughput is not None:
            pulumi.set(__self__, "max_provisioned_throughput", max_provisioned_throughput)
        if min_provisioned_concurrency is not None:
            pulumi.set(__self__, "min_provisioned_concurrency", min_provisioned_concurrency)
        if min_provisioned_throughput is not None:
            pulumi.set(__self__, "min_provisioned_throughput", min_provisioned_throughput)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if provisioned_model_units is not None:
            pulumi.set(__self__, "provisioned_model_units", provisioned_model_units)
        if scale_to_zero_enabled is not None:
            pulumi.set(__self__, "scale_to_zero_enabled", scale_to_zero_enabled)
        if workload_size is not None:
            pulumi.set(__self__, "workload_size", workload_size)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[_builtins.str]:
        """
        The name of the entity to be served. The entity may be a model in the Databricks Model Registry, a model in the Unity Catalog (UC), or a function of type `FEATURE_SPEC` in the UC. If it is a UC object, the full name of the object should be given in the form of `catalog_name.schema_name.model_name`.
        """
        return pulumi.get(self, "entity_name")

    @_builtins.property
    @pulumi.getter(name="entityVersion")
    def entity_version(self) -> Optional[_builtins.str]:
        """
        The version of the model in Databricks Model Registry to be served or empty if the entity is a `FEATURE_SPEC`.
        """
        return pulumi.get(self, "entity_version")

    @_builtins.property
    @pulumi.getter(name="environmentVars")
    def environment_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        An object containing a set of optional, user-specified environment variable key-value pairs used for serving this entity. Note: this is an experimental feature and is subject to change. Example entity environment variables that refer to Databricks secrets: ```{"OPENAI_API_KEY": "{{secrets/my_scope/my_key}}", "DATABRICKS_TOKEN": "{{secrets/my_scope2/my_key2}}"}```
        """
        return pulumi.get(self, "environment_vars")

    @_builtins.property
    @pulumi.getter(name="externalModel")
    def external_model(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModel']:
        """
        The external model to be served. NOTE: Only one of `external_model` and (`entity_name`, `entity_version`, `workload_size`, `workload_type`, and `scale_to_zero_enabled`) can be specified with the latter set being used for custom model serving for a Databricks registered model. When an `external_model` is present, the served entities list can only have one `served_entity` object. An existing endpoint with `external_model` can not be updated to an endpoint without `external_model`. If the endpoint is created without `external_model`, users cannot update it to add `external_model` later.
        """
        return pulumi.get(self, "external_model")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the instance profile that the served entity uses to access AWS resources.
        """
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="maxProvisionedConcurrency")
    def max_provisioned_concurrency(self) -> Optional[_builtins.int]:
        """
        The maximum provisioned concurrency that the endpoint can scale up to. Conflicts with `workload_size`.
        """
        return pulumi.get(self, "max_provisioned_concurrency")

    @_builtins.property
    @pulumi.getter(name="maxProvisionedThroughput")
    def max_provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        The maximum tokens per second that the endpoint can scale up to.
        """
        return pulumi.get(self, "max_provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="minProvisionedConcurrency")
    def min_provisioned_concurrency(self) -> Optional[_builtins.int]:
        """
        The minimum provisioned concurrency that the endpoint can scale down to. Conflicts with `workload_size`.
        """
        return pulumi.get(self, "min_provisioned_concurrency")

    @_builtins.property
    @pulumi.getter(name="minProvisionedThroughput")
    def min_provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        The minimum tokens per second that the endpoint can scale down to.
        """
        return pulumi.get(self, "min_provisioned_throughput")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field defaults to `external_model.name`, with '.' and ':' replaced with '-', and if not specified for other entities, it defaults to -.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="provisionedModelUnits")
    def provisioned_model_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "provisioned_model_units")

    @_builtins.property
    @pulumi.getter(name="scaleToZeroEnabled")
    def scale_to_zero_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the compute resources for the served entity should scale down to zero.
        """
        return pulumi.get(self, "scale_to_zero_enabled")

    @_builtins.property
    @pulumi.getter(name="workloadSize")
    def workload_size(self) -> Optional[_builtins.str]:
        """
        The workload size of the served entity. The workload size corresponds to a range of provisioned concurrency that the compute autoscales between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency). If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size is 0. Conflicts with `min_provisioned_concurrency` and `max_provisioned_concurrency`.
        """
        return pulumi.get(self, "workload_size")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[_builtins.str]:
        """
        The workload type of the served entity. The workload type selects which type of compute to use in the endpoint. The default value for this parameter is `CPU`. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the available [GPU types](https://docs.databricks.com/machine-learning/model-serving/create-manage-serving-endpoints.html#gpu-workload-types).
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ai21labsConfig":
            suggest = "ai21labs_config"
        elif key == "amazonBedrockConfig":
            suggest = "amazon_bedrock_config"
        elif key == "anthropicConfig":
            suggest = "anthropic_config"
        elif key == "cohereConfig":
            suggest = "cohere_config"
        elif key == "customProviderConfig":
            suggest = "custom_provider_config"
        elif key == "databricksModelServingConfig":
            suggest = "databricks_model_serving_config"
        elif key == "googleCloudVertexAiConfig":
            suggest = "google_cloud_vertex_ai_config"
        elif key == "openaiConfig":
            suggest = "openai_config"
        elif key == "palmConfig":
            suggest = "palm_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 provider: _builtins.str,
                 task: _builtins.str,
                 ai21labs_config: Optional['outputs.ModelServingConfigServedEntityExternalModelAi21labsConfig'] = None,
                 amazon_bedrock_config: Optional['outputs.ModelServingConfigServedEntityExternalModelAmazonBedrockConfig'] = None,
                 anthropic_config: Optional['outputs.ModelServingConfigServedEntityExternalModelAnthropicConfig'] = None,
                 cohere_config: Optional['outputs.ModelServingConfigServedEntityExternalModelCohereConfig'] = None,
                 custom_provider_config: Optional['outputs.ModelServingConfigServedEntityExternalModelCustomProviderConfig'] = None,
                 databricks_model_serving_config: Optional['outputs.ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig'] = None,
                 google_cloud_vertex_ai_config: Optional['outputs.ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig'] = None,
                 openai_config: Optional['outputs.ModelServingConfigServedEntityExternalModelOpenaiConfig'] = None,
                 palm_config: Optional['outputs.ModelServingConfigServedEntityExternalModelPalmConfig'] = None):
        """
        :param _builtins.str name: The name of the external model.
        :param _builtins.str provider: The name of the provider for the external model. Currently, the supported providers are `ai21labs`, `anthropic`, `amazon-bedrock`, `cohere`, `databricks-model-serving`, `google-cloud-vertex-ai`, `openai`, and `palm`.
        :param _builtins.str task: The task type of the external model.
        :param 'ModelServingConfigServedEntityExternalModelAi21labsConfigArgs' ai21labs_config: AI21Labs Config
        :param 'ModelServingConfigServedEntityExternalModelAmazonBedrockConfigArgs' amazon_bedrock_config: Amazon Bedrock Config
        :param 'ModelServingConfigServedEntityExternalModelAnthropicConfigArgs' anthropic_config: Anthropic Config
        :param 'ModelServingConfigServedEntityExternalModelCohereConfigArgs' cohere_config: Cohere Config
        :param 'ModelServingConfigServedEntityExternalModelCustomProviderConfigArgs' custom_provider_config: Custom Provider Config. Only required if the provider is 'custom'.
        :param 'ModelServingConfigServedEntityExternalModelDatabricksModelServingConfigArgs' databricks_model_serving_config: Databricks Model Serving Config
        :param 'ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfigArgs' google_cloud_vertex_ai_config: Google Cloud Vertex AI Config.
        :param 'ModelServingConfigServedEntityExternalModelOpenaiConfigArgs' openai_config: OpenAI Config
        :param 'ModelServingConfigServedEntityExternalModelPalmConfigArgs' palm_config: PaLM Config
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "task", task)
        if ai21labs_config is not None:
            pulumi.set(__self__, "ai21labs_config", ai21labs_config)
        if amazon_bedrock_config is not None:
            pulumi.set(__self__, "amazon_bedrock_config", amazon_bedrock_config)
        if anthropic_config is not None:
            pulumi.set(__self__, "anthropic_config", anthropic_config)
        if cohere_config is not None:
            pulumi.set(__self__, "cohere_config", cohere_config)
        if custom_provider_config is not None:
            pulumi.set(__self__, "custom_provider_config", custom_provider_config)
        if databricks_model_serving_config is not None:
            pulumi.set(__self__, "databricks_model_serving_config", databricks_model_serving_config)
        if google_cloud_vertex_ai_config is not None:
            pulumi.set(__self__, "google_cloud_vertex_ai_config", google_cloud_vertex_ai_config)
        if openai_config is not None:
            pulumi.set(__self__, "openai_config", openai_config)
        if palm_config is not None:
            pulumi.set(__self__, "palm_config", palm_config)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the external model.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        The name of the provider for the external model. Currently, the supported providers are `ai21labs`, `anthropic`, `amazon-bedrock`, `cohere`, `databricks-model-serving`, `google-cloud-vertex-ai`, `openai`, and `palm`.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def task(self) -> _builtins.str:
        """
        The task type of the external model.
        """
        return pulumi.get(self, "task")

    @_builtins.property
    @pulumi.getter(name="ai21labsConfig")
    def ai21labs_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelAi21labsConfig']:
        """
        AI21Labs Config
        """
        return pulumi.get(self, "ai21labs_config")

    @_builtins.property
    @pulumi.getter(name="amazonBedrockConfig")
    def amazon_bedrock_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelAmazonBedrockConfig']:
        """
        Amazon Bedrock Config
        """
        return pulumi.get(self, "amazon_bedrock_config")

    @_builtins.property
    @pulumi.getter(name="anthropicConfig")
    def anthropic_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelAnthropicConfig']:
        """
        Anthropic Config
        """
        return pulumi.get(self, "anthropic_config")

    @_builtins.property
    @pulumi.getter(name="cohereConfig")
    def cohere_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelCohereConfig']:
        """
        Cohere Config
        """
        return pulumi.get(self, "cohere_config")

    @_builtins.property
    @pulumi.getter(name="customProviderConfig")
    def custom_provider_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelCustomProviderConfig']:
        """
        Custom Provider Config. Only required if the provider is 'custom'.
        """
        return pulumi.get(self, "custom_provider_config")

    @_builtins.property
    @pulumi.getter(name="databricksModelServingConfig")
    def databricks_model_serving_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig']:
        """
        Databricks Model Serving Config
        """
        return pulumi.get(self, "databricks_model_serving_config")

    @_builtins.property
    @pulumi.getter(name="googleCloudVertexAiConfig")
    def google_cloud_vertex_ai_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig']:
        """
        Google Cloud Vertex AI Config.
        """
        return pulumi.get(self, "google_cloud_vertex_ai_config")

    @_builtins.property
    @pulumi.getter(name="openaiConfig")
    def openai_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelOpenaiConfig']:
        """
        OpenAI Config
        """
        return pulumi.get(self, "openai_config")

    @_builtins.property
    @pulumi.getter(name="palmConfig")
    def palm_config(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelPalmConfig']:
        """
        PaLM Config
        """
        return pulumi.get(self, "palm_config")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelAi21labsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ai21labsApiKey":
            suggest = "ai21labs_api_key"
        elif key == "ai21labsApiKeyPlaintext":
            suggest = "ai21labs_api_key_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelAi21labsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelAi21labsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelAi21labsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ai21labs_api_key: Optional[_builtins.str] = None,
                 ai21labs_api_key_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str ai21labs_api_key: The Databricks secret key reference for an AI21Labs API key.
        :param _builtins.str ai21labs_api_key_plaintext: An AI21 Labs API key provided as a plaintext string.
        """
        if ai21labs_api_key is not None:
            pulumi.set(__self__, "ai21labs_api_key", ai21labs_api_key)
        if ai21labs_api_key_plaintext is not None:
            pulumi.set(__self__, "ai21labs_api_key_plaintext", ai21labs_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="ai21labsApiKey")
    def ai21labs_api_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for an AI21Labs API key.
        """
        return pulumi.get(self, "ai21labs_api_key")

    @_builtins.property
    @pulumi.getter(name="ai21labsApiKeyPlaintext")
    def ai21labs_api_key_plaintext(self) -> Optional[_builtins.str]:
        """
        An AI21 Labs API key provided as a plaintext string.
        """
        return pulumi.get(self, "ai21labs_api_key_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelAmazonBedrockConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsRegion":
            suggest = "aws_region"
        elif key == "bedrockProvider":
            suggest = "bedrock_provider"
        elif key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsAccessKeyIdPlaintext":
            suggest = "aws_access_key_id_plaintext"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "awsSecretAccessKeyPlaintext":
            suggest = "aws_secret_access_key_plaintext"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelAmazonBedrockConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelAmazonBedrockConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelAmazonBedrockConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_region: _builtins.str,
                 bedrock_provider: _builtins.str,
                 aws_access_key_id: Optional[_builtins.str] = None,
                 aws_access_key_id_plaintext: Optional[_builtins.str] = None,
                 aws_secret_access_key: Optional[_builtins.str] = None,
                 aws_secret_access_key_plaintext: Optional[_builtins.str] = None,
                 instance_profile_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str aws_region: The AWS region to use. Bedrock has to be enabled there.
        :param _builtins.str bedrock_provider: The underlying provider in Amazon Bedrock. Supported values (case insensitive) include: `Anthropic`, `Cohere`, `AI21Labs`, `Amazon`.
        :param _builtins.str aws_access_key_id: The Databricks secret key reference for an AWS Access Key ID with permissions to interact with Bedrock services.
        :param _builtins.str aws_access_key_id_plaintext: An AWS access key ID with permissions to interact with Bedrock services provided as a plaintext string.
        :param _builtins.str aws_secret_access_key: The Databricks secret key reference for an AWS Secret Access Key paired with the access key ID, with permissions to interact with Bedrock services.
        :param _builtins.str aws_secret_access_key_plaintext: An AWS secret access key paired with the access key ID, with permissions to interact with Bedrock services provided as a plaintext string.
        """
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "bedrock_provider", bedrock_provider)
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_access_key_id_plaintext is not None:
            pulumi.set(__self__, "aws_access_key_id_plaintext", aws_access_key_id_plaintext)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_secret_access_key_plaintext is not None:
            pulumi.set(__self__, "aws_secret_access_key_plaintext", aws_secret_access_key_plaintext)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> _builtins.str:
        """
        The AWS region to use. Bedrock has to be enabled there.
        """
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter(name="bedrockProvider")
    def bedrock_provider(self) -> _builtins.str:
        """
        The underlying provider in Amazon Bedrock. Supported values (case insensitive) include: `Anthropic`, `Cohere`, `AI21Labs`, `Amazon`.
        """
        return pulumi.get(self, "bedrock_provider")

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for an AWS Access Key ID with permissions to interact with Bedrock services.
        """
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyIdPlaintext")
    def aws_access_key_id_plaintext(self) -> Optional[_builtins.str]:
        """
        An AWS access key ID with permissions to interact with Bedrock services provided as a plaintext string.
        """
        return pulumi.get(self, "aws_access_key_id_plaintext")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for an AWS Secret Access Key paired with the access key ID, with permissions to interact with Bedrock services.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKeyPlaintext")
    def aws_secret_access_key_plaintext(self) -> Optional[_builtins.str]:
        """
        An AWS secret access key paired with the access key ID, with permissions to interact with Bedrock services provided as a plaintext string.
        """
        return pulumi.get(self, "aws_secret_access_key_plaintext")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelAnthropicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anthropicApiKey":
            suggest = "anthropic_api_key"
        elif key == "anthropicApiKeyPlaintext":
            suggest = "anthropic_api_key_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelAnthropicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelAnthropicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelAnthropicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anthropic_api_key: Optional[_builtins.str] = None,
                 anthropic_api_key_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str anthropic_api_key: The Databricks secret key reference for an Anthropic API key.
        :param _builtins.str anthropic_api_key_plaintext: The Anthropic API key provided as a plaintext string.
        """
        if anthropic_api_key is not None:
            pulumi.set(__self__, "anthropic_api_key", anthropic_api_key)
        if anthropic_api_key_plaintext is not None:
            pulumi.set(__self__, "anthropic_api_key_plaintext", anthropic_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="anthropicApiKey")
    def anthropic_api_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for an Anthropic API key.
        """
        return pulumi.get(self, "anthropic_api_key")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeyPlaintext")
    def anthropic_api_key_plaintext(self) -> Optional[_builtins.str]:
        """
        The Anthropic API key provided as a plaintext string.
        """
        return pulumi.get(self, "anthropic_api_key_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelCohereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereApiBase":
            suggest = "cohere_api_base"
        elif key == "cohereApiKey":
            suggest = "cohere_api_key"
        elif key == "cohereApiKeyPlaintext":
            suggest = "cohere_api_key_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelCohereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelCohereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelCohereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_api_base: Optional[_builtins.str] = None,
                 cohere_api_key: Optional[_builtins.str] = None,
                 cohere_api_key_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str cohere_api_key: The Databricks secret key reference for a Cohere API key.
        :param _builtins.str cohere_api_key_plaintext: The Cohere API key provided as a plaintext string.
        """
        if cohere_api_base is not None:
            pulumi.set(__self__, "cohere_api_base", cohere_api_base)
        if cohere_api_key is not None:
            pulumi.set(__self__, "cohere_api_key", cohere_api_key)
        if cohere_api_key_plaintext is not None:
            pulumi.set(__self__, "cohere_api_key_plaintext", cohere_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="cohereApiBase")
    def cohere_api_base(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cohere_api_base")

    @_builtins.property
    @pulumi.getter(name="cohereApiKey")
    def cohere_api_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for a Cohere API key.
        """
        return pulumi.get(self, "cohere_api_key")

    @_builtins.property
    @pulumi.getter(name="cohereApiKeyPlaintext")
    def cohere_api_key_plaintext(self) -> Optional[_builtins.str]:
        """
        The Cohere API key provided as a plaintext string.
        """
        return pulumi.get(self, "cohere_api_key_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelCustomProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProviderUrl":
            suggest = "custom_provider_url"
        elif key == "apiKeyAuth":
            suggest = "api_key_auth"
        elif key == "bearerTokenAuth":
            suggest = "bearer_token_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelCustomProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelCustomProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelCustomProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_provider_url: _builtins.str,
                 api_key_auth: Optional['outputs.ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth'] = None,
                 bearer_token_auth: Optional['outputs.ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth'] = None):
        """
        :param _builtins.str custom_provider_url: URL of the custom provider API.
        :param 'ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuthArgs' api_key_auth: API key authentication for the custom provider API. Conflicts with `bearer_token_auth`.
        :param 'ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuthArgs' bearer_token_auth: bearer token authentication for the custom provider API.  Conflicts with `api_key_auth`.
        """
        pulumi.set(__self__, "custom_provider_url", custom_provider_url)
        if api_key_auth is not None:
            pulumi.set(__self__, "api_key_auth", api_key_auth)
        if bearer_token_auth is not None:
            pulumi.set(__self__, "bearer_token_auth", bearer_token_auth)

    @_builtins.property
    @pulumi.getter(name="customProviderUrl")
    def custom_provider_url(self) -> _builtins.str:
        """
        URL of the custom provider API.
        """
        return pulumi.get(self, "custom_provider_url")

    @_builtins.property
    @pulumi.getter(name="apiKeyAuth")
    def api_key_auth(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth']:
        """
        API key authentication for the custom provider API. Conflicts with `bearer_token_auth`.
        """
        return pulumi.get(self, "api_key_auth")

    @_builtins.property
    @pulumi.getter(name="bearerTokenAuth")
    def bearer_token_auth(self) -> Optional['outputs.ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth']:
        """
        bearer token authentication for the custom provider API.  Conflicts with `api_key_auth`.
        """
        return pulumi.get(self, "bearer_token_auth")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valuePlaintext":
            suggest = "value_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelCustomProviderConfigApiKeyAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None,
                 value_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str value_plaintext: The API Key provided as a plaintext string.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_plaintext is not None:
            pulumi.set(__self__, "value_plaintext", value_plaintext)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valuePlaintext")
    def value_plaintext(self) -> Optional[_builtins.str]:
        """
        The API Key provided as a plaintext string.
        """
        return pulumi.get(self, "value_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenPlaintext":
            suggest = "token_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token: Optional[_builtins.str] = None,
                 token_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str token: The Databricks secret key reference for a token.
        :param _builtins.str token_plaintext: The token provided as a plaintext string.
        """
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_plaintext is not None:
            pulumi.set(__self__, "token_plaintext", token_plaintext)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for a token.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="tokenPlaintext")
    def token_plaintext(self) -> Optional[_builtins.str]:
        """
        The token provided as a plaintext string.
        """
        return pulumi.get(self, "token_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databricksWorkspaceUrl":
            suggest = "databricks_workspace_url"
        elif key == "databricksApiToken":
            suggest = "databricks_api_token"
        elif key == "databricksApiTokenPlaintext":
            suggest = "databricks_api_token_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelDatabricksModelServingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 databricks_workspace_url: _builtins.str,
                 databricks_api_token: Optional[_builtins.str] = None,
                 databricks_api_token_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str databricks_workspace_url: The URL of the Databricks workspace containing the model serving endpoint pointed to by this external model.
        :param _builtins.str databricks_api_token: The Databricks secret key reference for a Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model.
        :param _builtins.str databricks_api_token_plaintext: The Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model provided as a plaintext string.
        """
        pulumi.set(__self__, "databricks_workspace_url", databricks_workspace_url)
        if databricks_api_token is not None:
            pulumi.set(__self__, "databricks_api_token", databricks_api_token)
        if databricks_api_token_plaintext is not None:
            pulumi.set(__self__, "databricks_api_token_plaintext", databricks_api_token_plaintext)

    @_builtins.property
    @pulumi.getter(name="databricksWorkspaceUrl")
    def databricks_workspace_url(self) -> _builtins.str:
        """
        The URL of the Databricks workspace containing the model serving endpoint pointed to by this external model.
        """
        return pulumi.get(self, "databricks_workspace_url")

    @_builtins.property
    @pulumi.getter(name="databricksApiToken")
    def databricks_api_token(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for a Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model.
        """
        return pulumi.get(self, "databricks_api_token")

    @_builtins.property
    @pulumi.getter(name="databricksApiTokenPlaintext")
    def databricks_api_token_plaintext(self) -> Optional[_builtins.str]:
        """
        The Databricks API token that corresponds to a user or service principal with Can Query access to the model serving endpoint pointed to by this external model provided as a plaintext string.
        """
        return pulumi.get(self, "databricks_api_token_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyPlaintext":
            suggest = "private_key_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelGoogleCloudVertexAiConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 private_key: Optional[_builtins.str] = None,
                 private_key_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str project_id: This is the Google Cloud project id that the service account is associated with.
        :param _builtins.str region: This is the region for the Google Cloud Vertex AI Service.
        :param _builtins.str private_key: The Databricks secret key reference for a private key for the service account that has access to the Google Cloud Vertex AI Service.
        :param _builtins.str private_key_plaintext: The private key for the service account that has access to the Google Cloud Vertex AI Service is provided as a plaintext secret.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_plaintext is not None:
            pulumi.set(__self__, "private_key_plaintext", private_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        This is the Google Cloud project id that the service account is associated with.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        This is the region for the Google Cloud Vertex AI Service.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for a private key for the service account that has access to the Google Cloud Vertex AI Service.
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyPlaintext")
    def private_key_plaintext(self) -> Optional[_builtins.str]:
        """
        The private key for the service account that has access to the Google Cloud Vertex AI Service is provided as a plaintext secret.
        """
        return pulumi.get(self, "private_key_plaintext")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelOpenaiConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "microsoftEntraClientId":
            suggest = "microsoft_entra_client_id"
        elif key == "microsoftEntraClientSecret":
            suggest = "microsoft_entra_client_secret"
        elif key == "microsoftEntraClientSecretPlaintext":
            suggest = "microsoft_entra_client_secret_plaintext"
        elif key == "microsoftEntraTenantId":
            suggest = "microsoft_entra_tenant_id"
        elif key == "openaiApiBase":
            suggest = "openai_api_base"
        elif key == "openaiApiKey":
            suggest = "openai_api_key"
        elif key == "openaiApiKeyPlaintext":
            suggest = "openai_api_key_plaintext"
        elif key == "openaiApiType":
            suggest = "openai_api_type"
        elif key == "openaiApiVersion":
            suggest = "openai_api_version"
        elif key == "openaiDeploymentName":
            suggest = "openai_deployment_name"
        elif key == "openaiOrganization":
            suggest = "openai_organization"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelOpenaiConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelOpenaiConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelOpenaiConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 microsoft_entra_client_id: Optional[_builtins.str] = None,
                 microsoft_entra_client_secret: Optional[_builtins.str] = None,
                 microsoft_entra_client_secret_plaintext: Optional[_builtins.str] = None,
                 microsoft_entra_tenant_id: Optional[_builtins.str] = None,
                 openai_api_base: Optional[_builtins.str] = None,
                 openai_api_key: Optional[_builtins.str] = None,
                 openai_api_key_plaintext: Optional[_builtins.str] = None,
                 openai_api_type: Optional[_builtins.str] = None,
                 openai_api_version: Optional[_builtins.str] = None,
                 openai_deployment_name: Optional[_builtins.str] = None,
                 openai_organization: Optional[_builtins.str] = None):
        """
        :param _builtins.str microsoft_entra_client_id: This field is only required for Azure AD OpenAI and is the Microsoft Entra Client ID.
        :param _builtins.str microsoft_entra_client_secret: The Databricks secret key reference for a client secret used for Microsoft Entra ID authentication.
        :param _builtins.str microsoft_entra_client_secret_plaintext: The client secret used for Microsoft Entra ID authentication provided as a plaintext string.
        :param _builtins.str microsoft_entra_tenant_id: This field is only required for Azure AD OpenAI and is the Microsoft Entra Tenant ID.
        :param _builtins.str openai_api_base: This is the base URL for the OpenAI API (default: "<https://api.openai.com/v1>"). For Azure OpenAI, this field is required and is the base URL for the Azure OpenAI API service provided by Azure.
        :param _builtins.str openai_api_key: The Databricks secret key reference for an OpenAI or Azure OpenAI API key.
        :param _builtins.str openai_api_key_plaintext: The OpenAI API key using the OpenAI or Azure service provided as a plaintext string.
        :param _builtins.str openai_api_type: This is an optional field to specify the type of OpenAI API to use. For Azure OpenAI, this field is required, and this parameter represents the preferred security access validation protocol. For access token validation, use `azure`. For authentication using Azure Active Directory (Azure AD) use, `azuread`.
        :param _builtins.str openai_api_version: This is an optional field to specify the OpenAI API version. For Azure OpenAI, this field is required and is the version of the Azure OpenAI service to utilize, specified by a date.
        :param _builtins.str openai_deployment_name: This field is only required for Azure OpenAI and is the name of the deployment resource for the Azure OpenAI service.
        :param _builtins.str openai_organization: This is an optional field to specify the organization in OpenAI or Azure OpenAI.
        """
        if microsoft_entra_client_id is not None:
            pulumi.set(__self__, "microsoft_entra_client_id", microsoft_entra_client_id)
        if microsoft_entra_client_secret is not None:
            pulumi.set(__self__, "microsoft_entra_client_secret", microsoft_entra_client_secret)
        if microsoft_entra_client_secret_plaintext is not None:
            pulumi.set(__self__, "microsoft_entra_client_secret_plaintext", microsoft_entra_client_secret_plaintext)
        if microsoft_entra_tenant_id is not None:
            pulumi.set(__self__, "microsoft_entra_tenant_id", microsoft_entra_tenant_id)
        if openai_api_base is not None:
            pulumi.set(__self__, "openai_api_base", openai_api_base)
        if openai_api_key is not None:
            pulumi.set(__self__, "openai_api_key", openai_api_key)
        if openai_api_key_plaintext is not None:
            pulumi.set(__self__, "openai_api_key_plaintext", openai_api_key_plaintext)
        if openai_api_type is not None:
            pulumi.set(__self__, "openai_api_type", openai_api_type)
        if openai_api_version is not None:
            pulumi.set(__self__, "openai_api_version", openai_api_version)
        if openai_deployment_name is not None:
            pulumi.set(__self__, "openai_deployment_name", openai_deployment_name)
        if openai_organization is not None:
            pulumi.set(__self__, "openai_organization", openai_organization)

    @_builtins.property
    @pulumi.getter(name="microsoftEntraClientId")
    def microsoft_entra_client_id(self) -> Optional[_builtins.str]:
        """
        This field is only required for Azure AD OpenAI and is the Microsoft Entra Client ID.
        """
        return pulumi.get(self, "microsoft_entra_client_id")

    @_builtins.property
    @pulumi.getter(name="microsoftEntraClientSecret")
    def microsoft_entra_client_secret(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for a client secret used for Microsoft Entra ID authentication.
        """
        return pulumi.get(self, "microsoft_entra_client_secret")

    @_builtins.property
    @pulumi.getter(name="microsoftEntraClientSecretPlaintext")
    def microsoft_entra_client_secret_plaintext(self) -> Optional[_builtins.str]:
        """
        The client secret used for Microsoft Entra ID authentication provided as a plaintext string.
        """
        return pulumi.get(self, "microsoft_entra_client_secret_plaintext")

    @_builtins.property
    @pulumi.getter(name="microsoftEntraTenantId")
    def microsoft_entra_tenant_id(self) -> Optional[_builtins.str]:
        """
        This field is only required for Azure AD OpenAI and is the Microsoft Entra Tenant ID.
        """
        return pulumi.get(self, "microsoft_entra_tenant_id")

    @_builtins.property
    @pulumi.getter(name="openaiApiBase")
    def openai_api_base(self) -> Optional[_builtins.str]:
        """
        This is the base URL for the OpenAI API (default: "<https://api.openai.com/v1>"). For Azure OpenAI, this field is required and is the base URL for the Azure OpenAI API service provided by Azure.
        """
        return pulumi.get(self, "openai_api_base")

    @_builtins.property
    @pulumi.getter(name="openaiApiKey")
    def openai_api_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for an OpenAI or Azure OpenAI API key.
        """
        return pulumi.get(self, "openai_api_key")

    @_builtins.property
    @pulumi.getter(name="openaiApiKeyPlaintext")
    def openai_api_key_plaintext(self) -> Optional[_builtins.str]:
        """
        The OpenAI API key using the OpenAI or Azure service provided as a plaintext string.
        """
        return pulumi.get(self, "openai_api_key_plaintext")

    @_builtins.property
    @pulumi.getter(name="openaiApiType")
    def openai_api_type(self) -> Optional[_builtins.str]:
        """
        This is an optional field to specify the type of OpenAI API to use. For Azure OpenAI, this field is required, and this parameter represents the preferred security access validation protocol. For access token validation, use `azure`. For authentication using Azure Active Directory (Azure AD) use, `azuread`.
        """
        return pulumi.get(self, "openai_api_type")

    @_builtins.property
    @pulumi.getter(name="openaiApiVersion")
    def openai_api_version(self) -> Optional[_builtins.str]:
        """
        This is an optional field to specify the OpenAI API version. For Azure OpenAI, this field is required and is the version of the Azure OpenAI service to utilize, specified by a date.
        """
        return pulumi.get(self, "openai_api_version")

    @_builtins.property
    @pulumi.getter(name="openaiDeploymentName")
    def openai_deployment_name(self) -> Optional[_builtins.str]:
        """
        This field is only required for Azure OpenAI and is the name of the deployment resource for the Azure OpenAI service.
        """
        return pulumi.get(self, "openai_deployment_name")

    @_builtins.property
    @pulumi.getter(name="openaiOrganization")
    def openai_organization(self) -> Optional[_builtins.str]:
        """
        This is an optional field to specify the organization in OpenAI or Azure OpenAI.
        """
        return pulumi.get(self, "openai_organization")


@pulumi.output_type
class ModelServingConfigServedEntityExternalModelPalmConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "palmApiKey":
            suggest = "palm_api_key"
        elif key == "palmApiKeyPlaintext":
            suggest = "palm_api_key_plaintext"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedEntityExternalModelPalmConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedEntityExternalModelPalmConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedEntityExternalModelPalmConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palm_api_key: Optional[_builtins.str] = None,
                 palm_api_key_plaintext: Optional[_builtins.str] = None):
        """
        :param _builtins.str palm_api_key: The Databricks secret key reference for a PaLM API key.
        :param _builtins.str palm_api_key_plaintext: The PaLM API key provided as a plaintext string.
        """
        if palm_api_key is not None:
            pulumi.set(__self__, "palm_api_key", palm_api_key)
        if palm_api_key_plaintext is not None:
            pulumi.set(__self__, "palm_api_key_plaintext", palm_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="palmApiKey")
    def palm_api_key(self) -> Optional[_builtins.str]:
        """
        The Databricks secret key reference for a PaLM API key.
        """
        return pulumi.get(self, "palm_api_key")

    @_builtins.property
    @pulumi.getter(name="palmApiKeyPlaintext")
    def palm_api_key_plaintext(self) -> Optional[_builtins.str]:
        """
        The PaLM API key provided as a plaintext string.
        """
        return pulumi.get(self, "palm_api_key_plaintext")


@pulumi.output_type
class ModelServingConfigServedModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelName":
            suggest = "model_name"
        elif key == "modelVersion":
            suggest = "model_version"
        elif key == "environmentVars":
            suggest = "environment_vars"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "maxProvisionedConcurrency":
            suggest = "max_provisioned_concurrency"
        elif key == "maxProvisionedThroughput":
            suggest = "max_provisioned_throughput"
        elif key == "minProvisionedConcurrency":
            suggest = "min_provisioned_concurrency"
        elif key == "minProvisionedThroughput":
            suggest = "min_provisioned_throughput"
        elif key == "provisionedModelUnits":
            suggest = "provisioned_model_units"
        elif key == "scaleToZeroEnabled":
            suggest = "scale_to_zero_enabled"
        elif key == "workloadSize":
            suggest = "workload_size"
        elif key == "workloadType":
            suggest = "workload_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigServedModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigServedModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigServedModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_name: _builtins.str,
                 model_version: _builtins.str,
                 environment_vars: Optional[Mapping[str, _builtins.str]] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 max_provisioned_concurrency: Optional[_builtins.int] = None,
                 max_provisioned_throughput: Optional[_builtins.int] = None,
                 min_provisioned_concurrency: Optional[_builtins.int] = None,
                 min_provisioned_throughput: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 provisioned_model_units: Optional[_builtins.int] = None,
                 scale_to_zero_enabled: Optional[_builtins.bool] = None,
                 workload_size: Optional[_builtins.str] = None,
                 workload_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str model_name: The name of the model in Databricks Model Registry to be served.
        :param _builtins.str model_version: The version of the model in Databricks Model Registry to be served.
        :param Mapping[str, _builtins.str] environment_vars: a map of environment variable names/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        :param _builtins.str instance_profile_arn: ARN of the instance profile that the served model will use to access AWS resources.
        :param _builtins.int max_provisioned_concurrency: The maximum provisioned concurrency that the endpoint can scale up to. Conflicts with `workload_size`.
        :param _builtins.int max_provisioned_throughput: The maximum tokens per second that the endpoint can scale up to.
        :param _builtins.int min_provisioned_concurrency: The minimum provisioned concurrency that the endpoint can scale down to. Conflicts with `workload_size`.
        :param _builtins.int min_provisioned_throughput: The minimum tokens per second that the endpoint can scale down to.
        :param _builtins.str name: The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        :param _builtins.bool scale_to_zero_enabled: Whether the compute resources for the served model should scale down to zero. If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        :param _builtins.str workload_size: The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency).
        :param _builtins.str workload_type: The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the documentation for all options. The default value is `CPU`.
        """
        pulumi.set(__self__, "model_name", model_name)
        pulumi.set(__self__, "model_version", model_version)
        if environment_vars is not None:
            pulumi.set(__self__, "environment_vars", environment_vars)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if max_provisioned_concurrency is not None:
            pulumi.set(__self__, "max_provisioned_concurrency", max_provisioned_concurrency)
        if max_provisioned_throughput is not None:
            pulumi.set(__self__, "max_provisioned_throughput", max_provisioned_throughput)
        if min_provisioned_concurrency is not None:
            pulumi.set(__self__, "min_provisioned_concurrency", min_provisioned_concurrency)
        if min_provisioned_throughput is not None:
            pulumi.set(__self__, "min_provisioned_throughput", min_provisioned_throughput)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if provisioned_model_units is not None:
            pulumi.set(__self__, "provisioned_model_units", provisioned_model_units)
        if scale_to_zero_enabled is not None:
            pulumi.set(__self__, "scale_to_zero_enabled", scale_to_zero_enabled)
        if workload_size is not None:
            pulumi.set(__self__, "workload_size", workload_size)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> _builtins.str:
        """
        The name of the model in Databricks Model Registry to be served.
        """
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> _builtins.str:
        """
        The version of the model in Databricks Model Registry to be served.
        """
        return pulumi.get(self, "model_version")

    @_builtins.property
    @pulumi.getter(name="environmentVars")
    def environment_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        a map of environment variable names/values that will be used for serving this model.  Environment variables may refer to Databricks secrets using the standard syntax: `{{secrets/secret_scope/secret_key}}`.
        """
        return pulumi.get(self, "environment_vars")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the instance profile that the served model will use to access AWS resources.
        """
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="maxProvisionedConcurrency")
    def max_provisioned_concurrency(self) -> Optional[_builtins.int]:
        """
        The maximum provisioned concurrency that the endpoint can scale up to. Conflicts with `workload_size`.
        """
        return pulumi.get(self, "max_provisioned_concurrency")

    @_builtins.property
    @pulumi.getter(name="maxProvisionedThroughput")
    def max_provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        The maximum tokens per second that the endpoint can scale up to.
        """
        return pulumi.get(self, "max_provisioned_throughput")

    @_builtins.property
    @pulumi.getter(name="minProvisionedConcurrency")
    def min_provisioned_concurrency(self) -> Optional[_builtins.int]:
        """
        The minimum provisioned concurrency that the endpoint can scale down to. Conflicts with `workload_size`.
        """
        return pulumi.get(self, "min_provisioned_concurrency")

    @_builtins.property
    @pulumi.getter(name="minProvisionedThroughput")
    def min_provisioned_throughput(self) -> Optional[_builtins.int]:
        """
        The minimum tokens per second that the endpoint can scale down to.
        """
        return pulumi.get(self, "min_provisioned_throughput")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a served model. It must be unique across an endpoint. If not specified, this field will default to `modelname-modelversion`. A served model name can consist of alphanumeric characters, dashes, and underscores.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="provisionedModelUnits")
    def provisioned_model_units(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "provisioned_model_units")

    @_builtins.property
    @pulumi.getter(name="scaleToZeroEnabled")
    def scale_to_zero_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether the compute resources for the served model should scale down to zero. If `scale-to-zero` is enabled, the lower bound of the provisioned concurrency for each workload size will be 0. The default value is `true`.
        """
        return pulumi.get(self, "scale_to_zero_enabled")

    @_builtins.property
    @pulumi.getter(name="workloadSize")
    def workload_size(self) -> Optional[_builtins.str]:
        """
        The workload size of the served model. The workload size corresponds to a range of provisioned concurrency that the compute will autoscale between. A single unit of provisioned concurrency can process one request at a time. Valid workload sizes are `Small` (4 - 4 provisioned concurrency), `Medium` (8 - 16 provisioned concurrency), and `Large` (16 - 64 provisioned concurrency).
        """
        return pulumi.get(self, "workload_size")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[_builtins.str]:
        """
        The workload type of the served model. The workload type selects which type of compute to use in the endpoint. For deep learning workloads, GPU acceleration is available by selecting workload types like `GPU_SMALL` and others. See the documentation for all options. The default value is `CPU`.
        """
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class ModelServingConfigTrafficConfig(dict):
    def __init__(__self__, *,
                 routes: Optional[Sequence['outputs.ModelServingConfigTrafficConfigRoute']] = None):
        """
        :param Sequence['ModelServingConfigTrafficConfigRouteArgs'] routes: Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.ModelServingConfigTrafficConfigRoute']]:
        """
        Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class ModelServingConfigTrafficConfigRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficPercentage":
            suggest = "traffic_percentage"
        elif key == "servedEntityName":
            suggest = "served_entity_name"
        elif key == "servedModelName":
            suggest = "served_model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingConfigTrafficConfigRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingConfigTrafficConfigRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingConfigTrafficConfigRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 traffic_percentage: _builtins.int,
                 served_entity_name: Optional[_builtins.str] = None,
                 served_model_name: Optional[_builtins.str] = None):
        """
        :param _builtins.int traffic_percentage: The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        :param _builtins.str served_entity_name: The name of the served entity this route configures traffic for. This needs to match the name of a `served_entity` block.
        """
        pulumi.set(__self__, "traffic_percentage", traffic_percentage)
        if served_entity_name is not None:
            pulumi.set(__self__, "served_entity_name", served_entity_name)
        if served_model_name is not None:
            pulumi.set(__self__, "served_model_name", served_model_name)

    @_builtins.property
    @pulumi.getter(name="trafficPercentage")
    def traffic_percentage(self) -> _builtins.int:
        """
        The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
        return pulumi.get(self, "traffic_percentage")

    @_builtins.property
    @pulumi.getter(name="servedEntityName")
    def served_entity_name(self) -> Optional[_builtins.str]:
        """
        The name of the served entity this route configures traffic for. This needs to match the name of a `served_entity` block.
        """
        return pulumi.get(self, "served_entity_name")

    @_builtins.property
    @pulumi.getter(name="servedModelName")
    def served_model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "served_model_name")


@pulumi.output_type
class ModelServingEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onUpdateFailures":
            suggest = "on_update_failures"
        elif key == "onUpdateSuccesses":
            suggest = "on_update_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_update_failures: Optional[Sequence[_builtins.str]] = None,
                 on_update_successes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] on_update_failures: a list of email addresses to be notified when an endpoint fails to update its configuration or state.
        :param Sequence[_builtins.str] on_update_successes: a list of email addresses to be notified when an endpoint successfully updates its configuration or state.
        """
        if on_update_failures is not None:
            pulumi.set(__self__, "on_update_failures", on_update_failures)
        if on_update_successes is not None:
            pulumi.set(__self__, "on_update_successes", on_update_successes)

    @_builtins.property
    @pulumi.getter(name="onUpdateFailures")
    def on_update_failures(self) -> Optional[Sequence[_builtins.str]]:
        """
        a list of email addresses to be notified when an endpoint fails to update its configuration or state.
        """
        return pulumi.get(self, "on_update_failures")

    @_builtins.property
    @pulumi.getter(name="onUpdateSuccesses")
    def on_update_successes(self) -> Optional[Sequence[_builtins.str]]:
        """
        a list of email addresses to be notified when an endpoint successfully updates its configuration or state.
        """
        return pulumi.get(self, "on_update_successes")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fallbackConfig":
            suggest = "fallback_config"
        elif key == "inferenceTableConfig":
            suggest = "inference_table_config"
        elif key == "rateLimits":
            suggest = "rate_limits"
        elif key == "usageTrackingConfig":
            suggest = "usage_tracking_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputAiGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputAiGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputAiGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fallback_config: Optional['outputs.ModelServingProvisionedThroughputAiGatewayFallbackConfig'] = None,
                 guardrails: Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrails'] = None,
                 inference_table_config: Optional['outputs.ModelServingProvisionedThroughputAiGatewayInferenceTableConfig'] = None,
                 rate_limits: Optional[Sequence['outputs.ModelServingProvisionedThroughputAiGatewayRateLimit']] = None,
                 usage_tracking_config: Optional['outputs.ModelServingProvisionedThroughputAiGatewayUsageTrackingConfig'] = None):
        """
        :param 'ModelServingProvisionedThroughputAiGatewayGuardrailsArgs' guardrails: Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        :param 'ModelServingProvisionedThroughputAiGatewayInferenceTableConfigArgs' inference_table_config: Block describing the configuration of usage tracking. Consists of the following attributes:
        :param Sequence['ModelServingProvisionedThroughputAiGatewayRateLimitArgs'] rate_limits: Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        :param 'ModelServingProvisionedThroughputAiGatewayUsageTrackingConfigArgs' usage_tracking_config: Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
        if fallback_config is not None:
            pulumi.set(__self__, "fallback_config", fallback_config)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if inference_table_config is not None:
            pulumi.set(__self__, "inference_table_config", inference_table_config)
        if rate_limits is not None:
            pulumi.set(__self__, "rate_limits", rate_limits)
        if usage_tracking_config is not None:
            pulumi.set(__self__, "usage_tracking_config", usage_tracking_config)

    @_builtins.property
    @pulumi.getter(name="fallbackConfig")
    def fallback_config(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayFallbackConfig']:
        return pulumi.get(self, "fallback_config")

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrails']:
        """
        Block with configuration for AI Guardrails to prevent unwanted data and unsafe data in requests and responses. Consists of the following attributes:
        """
        return pulumi.get(self, "guardrails")

    @_builtins.property
    @pulumi.getter(name="inferenceTableConfig")
    def inference_table_config(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayInferenceTableConfig']:
        """
        Block describing the configuration of usage tracking. Consists of the following attributes:
        """
        return pulumi.get(self, "inference_table_config")

    @_builtins.property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Optional[Sequence['outputs.ModelServingProvisionedThroughputAiGatewayRateLimit']]:
        """
        Block describing rate limits for AI gateway. For details see the description of `rate_limits` block above.
        """
        return pulumi.get(self, "rate_limits")

    @_builtins.property
    @pulumi.getter(name="usageTrackingConfig")
    def usage_tracking_config(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayUsageTrackingConfig']:
        """
        Block with configuration for payload logging using inference tables. For details see the description of `auto_capture_config` block above.
        """
        return pulumi.get(self, "usage_tracking_config")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayFallbackConfig(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: boolean flag specifying if usage tracking is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        boolean flag specifying if usage tracking is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayGuardrails(dict):
    def __init__(__self__, *,
                 input: Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsInput'] = None,
                 output: Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsOutput'] = None):
        """
        :param 'ModelServingProvisionedThroughputAiGatewayGuardrailsInputArgs' input: A block with configuration for input guardrail filters:
        :param 'ModelServingProvisionedThroughputAiGatewayGuardrailsOutputArgs' output: A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsInput']:
        """
        A block with configuration for input guardrail filters:
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsOutput']:
        """
        A block with configuration for output guardrail filters.  Has the same structure as `input` block.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayGuardrailsInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invalidKeywords":
            suggest = "invalid_keywords"
        elif key == "validTopics":
            suggest = "valid_topics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputAiGatewayGuardrailsInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputAiGatewayGuardrailsInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputAiGatewayGuardrailsInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 invalid_keywords: Optional[Sequence[_builtins.str]] = None,
                 pii: Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsInputPii'] = None,
                 safety: Optional[_builtins.bool] = None,
                 valid_topics: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] invalid_keywords: List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        :param 'ModelServingProvisionedThroughputAiGatewayGuardrailsInputPiiArgs' pii: Block with configuration for guardrail PII filter:
        :param _builtins.bool safety: the boolean flag that indicates whether the safety filter is enabled.
        :param Sequence[_builtins.str] valid_topics: The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if pii is not None:
            pulumi.set(__self__, "pii", pii)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @_builtins.property
    @pulumi.getter(name="invalidKeywords")
    def invalid_keywords(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        return pulumi.get(self, "invalid_keywords")

    @_builtins.property
    @pulumi.getter
    def pii(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsInputPii']:
        """
        Block with configuration for guardrail PII filter:
        """
        return pulumi.get(self, "pii")

    @_builtins.property
    @pulumi.getter
    def safety(self) -> Optional[_builtins.bool]:
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        return pulumi.get(self, "safety")

    @_builtins.property
    @pulumi.getter(name="validTopics")
    def valid_topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        return pulumi.get(self, "valid_topics")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayGuardrailsInputPii(dict):
    def __init__(__self__, *,
                 behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.str behavior: a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[_builtins.str]:
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayGuardrailsOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invalidKeywords":
            suggest = "invalid_keywords"
        elif key == "validTopics":
            suggest = "valid_topics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputAiGatewayGuardrailsOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputAiGatewayGuardrailsOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputAiGatewayGuardrailsOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 invalid_keywords: Optional[Sequence[_builtins.str]] = None,
                 pii: Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsOutputPii'] = None,
                 safety: Optional[_builtins.bool] = None,
                 valid_topics: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] invalid_keywords: List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        :param 'ModelServingProvisionedThroughputAiGatewayGuardrailsOutputPiiArgs' pii: Block with configuration for guardrail PII filter:
        :param _builtins.bool safety: the boolean flag that indicates whether the safety filter is enabled.
        :param Sequence[_builtins.str] valid_topics: The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if pii is not None:
            pulumi.set(__self__, "pii", pii)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @_builtins.property
    @pulumi.getter(name="invalidKeywords")
    def invalid_keywords(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of invalid keywords. AI guardrail uses keyword or string matching to decide if the keyword exists in the request or response content.
        """
        return pulumi.get(self, "invalid_keywords")

    @_builtins.property
    @pulumi.getter
    def pii(self) -> Optional['outputs.ModelServingProvisionedThroughputAiGatewayGuardrailsOutputPii']:
        """
        Block with configuration for guardrail PII filter:
        """
        return pulumi.get(self, "pii")

    @_builtins.property
    @pulumi.getter
    def safety(self) -> Optional[_builtins.bool]:
        """
        the boolean flag that indicates whether the safety filter is enabled.
        """
        return pulumi.get(self, "safety")

    @_builtins.property
    @pulumi.getter(name="validTopics")
    def valid_topics(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of allowed topics. Given a chat request, this guardrail flags the request if its topic is not in the allowed topics.
        """
        return pulumi.get(self, "valid_topics")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayGuardrailsOutputPii(dict):
    def __init__(__self__, *,
                 behavior: Optional[_builtins.str] = None):
        """
        :param _builtins.str behavior: a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[_builtins.str]:
        """
        a string that describes the behavior for PII filter. Currently only `BLOCK` value is supported.
        """
        return pulumi.get(self, "behavior")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayInferenceTableConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogName":
            suggest = "catalog_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "tableNamePrefix":
            suggest = "table_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputAiGatewayInferenceTableConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputAiGatewayInferenceTableConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputAiGatewayInferenceTableConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 schema_name: Optional[_builtins.str] = None,
                 table_name_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: boolean flag specifying if usage tracking is enabled.
        """
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if table_name_prefix is not None:
            pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        boolean flag specifying if usage tracking is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewalPeriod":
            suggest = "renewal_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputAiGatewayRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputAiGatewayRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputAiGatewayRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 renewal_period: _builtins.str,
                 calls: Optional[_builtins.int] = None,
                 key: Optional[_builtins.str] = None,
                 principal: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None):
        """
        :param _builtins.str key: The key field for a tag.
        """
        pulumi.set(__self__, "renewal_period", renewal_period)
        if calls is not None:
            pulumi.set(__self__, "calls", calls)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)

    @_builtins.property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> _builtins.str:
        return pulumi.get(self, "renewal_period")

    @_builtins.property
    @pulumi.getter
    def calls(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "calls")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key field for a tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "tokens")


@pulumi.output_type
class ModelServingProvisionedThroughputAiGatewayUsageTrackingConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: boolean flag specifying if usage tracking is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        boolean flag specifying if usage tracking is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ModelServingProvisionedThroughputConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "servedEntities":
            suggest = "served_entities"
        elif key == "trafficConfig":
            suggest = "traffic_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 served_entities: Optional[Sequence['outputs.ModelServingProvisionedThroughputConfigServedEntity']] = None,
                 traffic_config: Optional['outputs.ModelServingProvisionedThroughputConfigTrafficConfig'] = None):
        """
        :param Sequence['ModelServingProvisionedThroughputConfigServedEntityArgs'] served_entities: A list of served entities for the endpoint to serve.
        :param 'ModelServingProvisionedThroughputConfigTrafficConfigArgs' traffic_config: A single block represents the traffic split configuration amongst the served models.
        """
        if served_entities is not None:
            pulumi.set(__self__, "served_entities", served_entities)
        if traffic_config is not None:
            pulumi.set(__self__, "traffic_config", traffic_config)

    @_builtins.property
    @pulumi.getter(name="servedEntities")
    def served_entities(self) -> Optional[Sequence['outputs.ModelServingProvisionedThroughputConfigServedEntity']]:
        """
        A list of served entities for the endpoint to serve.
        """
        return pulumi.get(self, "served_entities")

    @_builtins.property
    @pulumi.getter(name="trafficConfig")
    def traffic_config(self) -> Optional['outputs.ModelServingProvisionedThroughputConfigTrafficConfig']:
        """
        A single block represents the traffic split configuration amongst the served models.
        """
        return pulumi.get(self, "traffic_config")


@pulumi.output_type
class ModelServingProvisionedThroughputConfigServedEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityName":
            suggest = "entity_name"
        elif key == "entityVersion":
            suggest = "entity_version"
        elif key == "provisionedModelUnits":
            suggest = "provisioned_model_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputConfigServedEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputConfigServedEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputConfigServedEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_name: _builtins.str,
                 entity_version: _builtins.str,
                 provisioned_model_units: _builtins.int,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str entity_name: The full path of the UC model to be served, given in the form of `catalog_name.schema_name.model_name`.
        :param _builtins.str entity_version: The version of the model in UC to be served.
        :param _builtins.int provisioned_model_units: The number of model units to be provisioned.
        :param _builtins.str name: The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field will be created from the `entity_name` and `entity_version`
        """
        pulumi.set(__self__, "entity_name", entity_name)
        pulumi.set(__self__, "entity_version", entity_version)
        pulumi.set(__self__, "provisioned_model_units", provisioned_model_units)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> _builtins.str:
        """
        The full path of the UC model to be served, given in the form of `catalog_name.schema_name.model_name`.
        """
        return pulumi.get(self, "entity_name")

    @_builtins.property
    @pulumi.getter(name="entityVersion")
    def entity_version(self) -> _builtins.str:
        """
        The version of the model in UC to be served.
        """
        return pulumi.get(self, "entity_version")

    @_builtins.property
    @pulumi.getter(name="provisionedModelUnits")
    def provisioned_model_units(self) -> _builtins.int:
        """
        The number of model units to be provisioned.
        """
        return pulumi.get(self, "provisioned_model_units")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a served entity. It must be unique across an endpoint. A served entity name can consist of alphanumeric characters, dashes, and underscores. If not specified for an external model, this field will be created from the `entity_name` and `entity_version`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ModelServingProvisionedThroughputConfigTrafficConfig(dict):
    def __init__(__self__, *,
                 routes: Optional[Sequence['outputs.ModelServingProvisionedThroughputConfigTrafficConfigRoute']] = None):
        """
        :param Sequence['ModelServingProvisionedThroughputConfigTrafficConfigRouteArgs'] routes: Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.ModelServingProvisionedThroughputConfigTrafficConfigRoute']]:
        """
        Each block represents a route that defines traffic to each served entity. Each `served_entity` block needs to have a corresponding `routes` block.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class ModelServingProvisionedThroughputConfigTrafficConfigRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficPercentage":
            suggest = "traffic_percentage"
        elif key == "servedEntityName":
            suggest = "served_entity_name"
        elif key == "servedModelName":
            suggest = "served_model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputConfigTrafficConfigRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputConfigTrafficConfigRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputConfigTrafficConfigRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 traffic_percentage: _builtins.int,
                 served_entity_name: Optional[_builtins.str] = None,
                 served_model_name: Optional[_builtins.str] = None):
        """
        :param _builtins.int traffic_percentage: The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        :param _builtins.str served_entity_name: The name of the served entity this route configures traffic for. This needs to match the name of a `served_entity` block.
        """
        pulumi.set(__self__, "traffic_percentage", traffic_percentage)
        if served_entity_name is not None:
            pulumi.set(__self__, "served_entity_name", served_entity_name)
        if served_model_name is not None:
            pulumi.set(__self__, "served_model_name", served_model_name)

    @_builtins.property
    @pulumi.getter(name="trafficPercentage")
    def traffic_percentage(self) -> _builtins.int:
        """
        The percentage of endpoint traffic to send to this route. It must be an integer between 0 and 100 inclusive.
        """
        return pulumi.get(self, "traffic_percentage")

    @_builtins.property
    @pulumi.getter(name="servedEntityName")
    def served_entity_name(self) -> Optional[_builtins.str]:
        """
        The name of the served entity this route configures traffic for. This needs to match the name of a `served_entity` block.
        """
        return pulumi.get(self, "served_entity_name")

    @_builtins.property
    @pulumi.getter(name="servedModelName")
    def served_model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "served_model_name")


@pulumi.output_type
class ModelServingProvisionedThroughputEmailNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onUpdateFailures":
            suggest = "on_update_failures"
        elif key == "onUpdateSuccesses":
            suggest = "on_update_successes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingProvisionedThroughputEmailNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingProvisionedThroughputEmailNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingProvisionedThroughputEmailNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_update_failures: Optional[Sequence[_builtins.str]] = None,
                 on_update_successes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] on_update_failures: a list of email addresses to be notified when an endpoint fails to update its configuration or state.
        :param Sequence[_builtins.str] on_update_successes: a list of email addresses to be notified when an endpoint successfully updates its configuration or state.
        """
        if on_update_failures is not None:
            pulumi.set(__self__, "on_update_failures", on_update_failures)
        if on_update_successes is not None:
            pulumi.set(__self__, "on_update_successes", on_update_successes)

    @_builtins.property
    @pulumi.getter(name="onUpdateFailures")
    def on_update_failures(self) -> Optional[Sequence[_builtins.str]]:
        """
        a list of email addresses to be notified when an endpoint fails to update its configuration or state.
        """
        return pulumi.get(self, "on_update_failures")

    @_builtins.property
    @pulumi.getter(name="onUpdateSuccesses")
    def on_update_successes(self) -> Optional[Sequence[_builtins.str]]:
        """
        a list of email addresses to be notified when an endpoint successfully updates its configuration or state.
        """
        return pulumi.get(self, "on_update_successes")


@pulumi.output_type
class ModelServingProvisionedThroughputTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key field for a tag.
        :param _builtins.str value: The value field for a tag.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field for a tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value field for a tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ModelServingRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renewalPeriod":
            suggest = "renewal_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ModelServingRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ModelServingRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ModelServingRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 calls: _builtins.int,
                 renewal_period: _builtins.str,
                 key: Optional[_builtins.str] = None):
        """
        :param _builtins.int calls: Used to specify how many calls are allowed for a key within the renewal_period.
        :param _builtins.str renewal_period: Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        :param _builtins.str key: Key field for a serving endpoint rate limit. Currently, `user`, `user_group`, `service_principal`, and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        pulumi.set(__self__, "calls", calls)
        pulumi.set(__self__, "renewal_period", renewal_period)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def calls(self) -> _builtins.int:
        """
        Used to specify how many calls are allowed for a key within the renewal_period.
        """
        return pulumi.get(self, "calls")

    @_builtins.property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> _builtins.str:
        """
        Renewal period field for a serving endpoint rate limit. Currently, only `minute` is supported.
        """
        return pulumi.get(self, "renewal_period")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Key field for a serving endpoint rate limit. Currently, `user`, `user_group`, `service_principal`, and `endpoint` are supported, with `endpoint` being the default if not specified.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class ModelServingTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key field for a tag.
        :param _builtins.str value: The value field for a tag.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key field for a tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value field for a tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MountAbfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretKey":
            suggest = "client_secret_key"
        elif key == "clientSecretScope":
            suggest = "client_secret_scope"
        elif key == "initializeFileSystem":
            suggest = "initialize_file_system"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountAbfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountAbfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountAbfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret_key: _builtins.str,
                 client_secret_scope: _builtins.str,
                 initialize_file_system: _builtins.bool,
                 container_name: Optional[_builtins.str] = None,
                 directory: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_key", client_secret_key)
        pulumi.set(__self__, "client_secret_scope", client_secret_scope)
        pulumi.set(__self__, "initialize_file_system", initialize_file_system)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> _builtins.str:
        return pulumi.get(self, "client_secret_key")

    @_builtins.property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> _builtins.str:
        return pulumi.get(self, "client_secret_scope")

    @_builtins.property
    @pulumi.getter(name="initializeFileSystem")
    def initialize_file_system(self) -> _builtins.bool:
        return pulumi.get(self, "initialize_file_system")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter
    def directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "directory")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_account_name")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class MountAdl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretKey":
            suggest = "client_secret_key"
        elif key == "clientSecretScope":
            suggest = "client_secret_scope"
        elif key == "sparkConfPrefix":
            suggest = "spark_conf_prefix"
        elif key == "storageResourceName":
            suggest = "storage_resource_name"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountAdl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountAdl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountAdl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret_key: _builtins.str,
                 client_secret_scope: _builtins.str,
                 directory: Optional[_builtins.str] = None,
                 spark_conf_prefix: Optional[_builtins.str] = None,
                 storage_resource_name: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_key", client_secret_key)
        pulumi.set(__self__, "client_secret_scope", client_secret_scope)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if spark_conf_prefix is not None:
            pulumi.set(__self__, "spark_conf_prefix", spark_conf_prefix)
        if storage_resource_name is not None:
            pulumi.set(__self__, "storage_resource_name", storage_resource_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretKey")
    def client_secret_key(self) -> _builtins.str:
        return pulumi.get(self, "client_secret_key")

    @_builtins.property
    @pulumi.getter(name="clientSecretScope")
    def client_secret_scope(self) -> _builtins.str:
        return pulumi.get(self, "client_secret_scope")

    @_builtins.property
    @pulumi.getter
    def directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "directory")

    @_builtins.property
    @pulumi.getter(name="sparkConfPrefix")
    def spark_conf_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_conf_prefix")

    @_builtins.property
    @pulumi.getter(name="storageResourceName")
    def storage_resource_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_resource_name")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class MountGs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountGs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountGs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountGs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 service_account: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_account")


@pulumi.output_type
class MountS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "instanceProfile":
            suggest = "instance_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 instance_profile: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if instance_profile is not None:
            pulumi.set(__self__, "instance_profile", instance_profile)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="instanceProfile")
    def instance_profile(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile")


@pulumi.output_type
class MountWasb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "tokenSecretKey":
            suggest = "token_secret_key"
        elif key == "tokenSecretScope":
            suggest = "token_secret_scope"
        elif key == "containerName":
            suggest = "container_name"
        elif key == "storageAccountName":
            suggest = "storage_account_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountWasb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountWasb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountWasb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: _builtins.str,
                 token_secret_key: _builtins.str,
                 token_secret_scope: _builtins.str,
                 container_name: Optional[_builtins.str] = None,
                 directory: Optional[_builtins.str] = None,
                 storage_account_name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "token_secret_key", token_secret_key)
        pulumi.set(__self__, "token_secret_scope", token_secret_scope)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if directory is not None:
            pulumi.set(__self__, "directory", directory)
        if storage_account_name is not None:
            pulumi.set(__self__, "storage_account_name", storage_account_name)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> _builtins.str:
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="tokenSecretKey")
    def token_secret_key(self) -> _builtins.str:
        return pulumi.get(self, "token_secret_key")

    @_builtins.property
    @pulumi.getter(name="tokenSecretScope")
    def token_secret_scope(self) -> _builtins.str:
        return pulumi.get(self, "token_secret_scope")

    @_builtins.property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "container_name")

    @_builtins.property
    @pulumi.getter
    def directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "directory")

    @_builtins.property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_account_name")


@pulumi.output_type
class MwsCustomerManagedKeysAwsKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"
        elif key == "keyAlias":
            suggest = "key_alias"
        elif key == "keyRegion":
            suggest = "key_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsCustomerManagedKeysAwsKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsCustomerManagedKeysAwsKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsCustomerManagedKeysAwsKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_arn: _builtins.str,
                 key_alias: Optional[_builtins.str] = None,
                 key_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str key_arn: The AWS KMS key's Amazon Resource Name (ARN).
        :param _builtins.str key_alias: The AWS KMS key alias.
        :param _builtins.str key_region: (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        pulumi.set(__self__, "key_arn", key_arn)
        if key_alias is not None:
            pulumi.set(__self__, "key_alias", key_alias)
        if key_region is not None:
            pulumi.set(__self__, "key_region", key_region)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> _builtins.str:
        """
        The AWS KMS key's Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "key_arn")

    @_builtins.property
    @pulumi.getter(name="keyAlias")
    def key_alias(self) -> Optional[_builtins.str]:
        """
        The AWS KMS key alias.
        """
        return pulumi.get(self, "key_alias")

    @_builtins.property
    @pulumi.getter(name="keyRegion")
    def key_region(self) -> Optional[_builtins.str]:
        """
        (Computed) The AWS region in which KMS key is deployed to. This is not required.
        """
        return pulumi.get(self, "key_region")


@pulumi.output_type
class MwsCustomerManagedKeysGcpKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsCustomerManagedKeysGcpKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsCustomerManagedKeysGcpKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsCustomerManagedKeysGcpKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: _builtins.str):
        """
        :param _builtins.str kms_key_id: The GCP KMS key's resource name.
        """
        pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> _builtins.str:
        """
        The GCP KMS key's resource name.
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRules":
            suggest = "default_rules"
        elif key == "targetRules":
            suggest = "target_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_rules: Optional['outputs.MwsNetworkConnectivityConfigEgressConfigDefaultRules'] = None,
                 target_rules: Optional['outputs.MwsNetworkConnectivityConfigEgressConfigTargetRules'] = None):
        """
        :param 'MwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs' default_rules: block describing network connectivity rules that are applied by default without resource specific configurations.  Consists of the following fields:
        :param 'MwsNetworkConnectivityConfigEgressConfigTargetRulesArgs' target_rules: block describing network connectivity rules that configured for each destinations. These rules override default rules.  Consists of the following fields:
        """
        if default_rules is not None:
            pulumi.set(__self__, "default_rules", default_rules)
        if target_rules is not None:
            pulumi.set(__self__, "target_rules", target_rules)

    @_builtins.property
    @pulumi.getter(name="defaultRules")
    def default_rules(self) -> Optional['outputs.MwsNetworkConnectivityConfigEgressConfigDefaultRules']:
        """
        block describing network connectivity rules that are applied by default without resource specific configurations.  Consists of the following fields:
        """
        return pulumi.get(self, "default_rules")

    @_builtins.property
    @pulumi.getter(name="targetRules")
    def target_rules(self) -> Optional['outputs.MwsNetworkConnectivityConfigEgressConfigTargetRules']:
        """
        block describing network connectivity rules that configured for each destinations. These rules override default rules.  Consists of the following fields:
        """
        return pulumi.get(self, "target_rules")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfigDefaultRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsStableIpRule":
            suggest = "aws_stable_ip_rule"
        elif key == "azureServiceEndpointRule":
            suggest = "azure_service_endpoint_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfigDefaultRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfigDefaultRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfigDefaultRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_stable_ip_rule: Optional['outputs.MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule'] = None,
                 azure_service_endpoint_rule: Optional['outputs.MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule'] = None):
        """
        :param 'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs' aws_stable_ip_rule: (AWS only) - block with information about stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.  Consists of the following fields:
        :param 'MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs' azure_service_endpoint_rule: (Azure only) - block with information about stable Azure service endpoints. You can configure the firewall of your Azure resources to allow traffic from your Databricks serverless compute resources.  Consists of the following fields:
        """
        if aws_stable_ip_rule is not None:
            pulumi.set(__self__, "aws_stable_ip_rule", aws_stable_ip_rule)
        if azure_service_endpoint_rule is not None:
            pulumi.set(__self__, "azure_service_endpoint_rule", azure_service_endpoint_rule)

    @_builtins.property
    @pulumi.getter(name="awsStableIpRule")
    def aws_stable_ip_rule(self) -> Optional['outputs.MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule']:
        """
        (AWS only) - block with information about stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.  Consists of the following fields:
        """
        return pulumi.get(self, "aws_stable_ip_rule")

    @_builtins.property
    @pulumi.getter(name="azureServiceEndpointRule")
    def azure_service_endpoint_rule(self) -> Optional['outputs.MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule']:
        """
        (Azure only) - block with information about stable Azure service endpoints. You can configure the firewall of your Azure resources to allow traffic from your Databricks serverless compute resources.  Consists of the following fields:
        """
        return pulumi.get(self, "azure_service_endpoint_rule")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlocks":
            suggest = "cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] cidr_blocks: list of IP CIDR blocks.
        """
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of IP CIDR blocks.
        """
        return pulumi.get(self, "cidr_blocks")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetRegion":
            suggest = "target_region"
        elif key == "targetServices":
            suggest = "target_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnets: Optional[Sequence[_builtins.str]] = None,
                 target_region: Optional[_builtins.str] = None,
                 target_services: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] subnets: list of subnets from which Databricks network traffic originates when accessing your Azure resources.
        :param _builtins.str target_region: the Azure region in which this service endpoint rule applies.
        :param Sequence[_builtins.str] target_services: the Azure services to which this service endpoint rule applies to.
        """
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if target_region is not None:
            pulumi.set(__self__, "target_region", target_region)
        if target_services is not None:
            pulumi.set(__self__, "target_services", target_services)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of subnets from which Databricks network traffic originates when accessing your Azure resources.
        """
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> Optional[_builtins.str]:
        """
        the Azure region in which this service endpoint rule applies.
        """
        return pulumi.get(self, "target_region")

    @_builtins.property
    @pulumi.getter(name="targetServices")
    def target_services(self) -> Optional[Sequence[_builtins.str]]:
        """
        the Azure services to which this service endpoint rule applies to.
        """
        return pulumi.get(self, "target_services")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfigTargetRules(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPrivateEndpointRules":
            suggest = "aws_private_endpoint_rules"
        elif key == "azurePrivateEndpointRules":
            suggest = "azure_private_endpoint_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfigTargetRules. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfigTargetRules.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfigTargetRules.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_private_endpoint_rules: Optional[Sequence['outputs.MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule']] = None,
                 azure_private_endpoint_rules: Optional[Sequence['outputs.MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule']] = None):
        """
        :param Sequence['MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRuleArgs'] aws_private_endpoint_rules: (AWS only) - list containing information about configure AWS Private Endpoints.
        :param Sequence['MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs'] azure_private_endpoint_rules: (Azure only) - list containing information about configure Azure Private Endpoints.
        """
        if aws_private_endpoint_rules is not None:
            pulumi.set(__self__, "aws_private_endpoint_rules", aws_private_endpoint_rules)
        if azure_private_endpoint_rules is not None:
            pulumi.set(__self__, "azure_private_endpoint_rules", azure_private_endpoint_rules)

    @_builtins.property
    @pulumi.getter(name="awsPrivateEndpointRules")
    def aws_private_endpoint_rules(self) -> Optional[Sequence['outputs.MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule']]:
        """
        (AWS only) - list containing information about configure AWS Private Endpoints.
        """
        return pulumi.get(self, "aws_private_endpoint_rules")

    @_builtins.property
    @pulumi.getter(name="azurePrivateEndpointRules")
    def azure_private_endpoint_rules(self) -> Optional[Sequence['outputs.MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule']]:
        """
        (Azure only) - list containing information about configure Azure Private Endpoints.
        """
        return pulumi.get(self, "azure_private_endpoint_rules")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "connectionState":
            suggest = "connection_state"
        elif key == "creationTime":
            suggest = "creation_time"
        elif key == "deactivatedAt":
            suggest = "deactivated_at"
        elif key == "domainNames":
            suggest = "domain_names"
        elif key == "endpointService":
            suggest = "endpoint_service"
        elif key == "networkConnectivityConfigId":
            suggest = "network_connectivity_config_id"
        elif key == "resourceNames":
            suggest = "resource_names"
        elif key == "ruleId":
            suggest = "rule_id"
        elif key == "updatedTime":
            suggest = "updated_time"
        elif key == "vpcEndpointId":
            suggest = "vpc_endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 connection_state: Optional[_builtins.str] = None,
                 creation_time: Optional[_builtins.int] = None,
                 deactivated: Optional[_builtins.bool] = None,
                 deactivated_at: Optional[_builtins.int] = None,
                 domain_names: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 endpoint_service: Optional[_builtins.str] = None,
                 network_connectivity_config_id: Optional[_builtins.str] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 rule_id: Optional[_builtins.str] = None,
                 updated_time: Optional[_builtins.int] = None,
                 vpc_endpoint_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int creation_time: time in epoch milliseconds when this object was created.
        :param _builtins.str network_connectivity_config_id: Canonical unique identifier of Network Connectivity Config in Databricks Account
        :param _builtins.int updated_time: time in epoch milliseconds when this object was updated.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if deactivated is not None:
            pulumi.set(__self__, "deactivated", deactivated)
        if deactivated_at is not None:
            pulumi.set(__self__, "deactivated_at", deactivated_at)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if endpoint_service is not None:
            pulumi.set(__self__, "endpoint_service", endpoint_service)
        if network_connectivity_config_id is not None:
            pulumi.set(__self__, "network_connectivity_config_id", network_connectivity_config_id)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if updated_time is not None:
            pulumi.set(__self__, "updated_time", updated_time)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_state")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.int]:
        """
        time in epoch milliseconds when this object was created.
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def deactivated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "deactivated")

    @_builtins.property
    @pulumi.getter(name="deactivatedAt")
    def deactivated_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "deactivated_at")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="endpointService")
    def endpoint_service(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_service")

    @_builtins.property
    @pulumi.getter(name="networkConnectivityConfigId")
    def network_connectivity_config_id(self) -> Optional[_builtins.str]:
        """
        Canonical unique identifier of Network Connectivity Config in Databricks Account
        """
        return pulumi.get(self, "network_connectivity_config_id")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="updatedTime")
    def updated_time(self) -> Optional[_builtins.int]:
        """
        time in epoch milliseconds when this object was updated.
        """
        return pulumi.get(self, "updated_time")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_id")


@pulumi.output_type
class MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionState":
            suggest = "connection_state"
        elif key == "creationTime":
            suggest = "creation_time"
        elif key == "deactivatedAt":
            suggest = "deactivated_at"
        elif key == "domainNames":
            suggest = "domain_names"
        elif key == "endpointName":
            suggest = "endpoint_name"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "networkConnectivityConfigId":
            suggest = "network_connectivity_config_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "ruleId":
            suggest = "rule_id"
        elif key == "updatedTime":
            suggest = "updated_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_state: Optional[_builtins.str] = None,
                 creation_time: Optional[_builtins.int] = None,
                 deactivated: Optional[_builtins.bool] = None,
                 deactivated_at: Optional[_builtins.int] = None,
                 domain_names: Optional[Sequence[_builtins.str]] = None,
                 endpoint_name: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.str] = None,
                 network_connectivity_config_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 rule_id: Optional[_builtins.str] = None,
                 updated_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int creation_time: time in epoch milliseconds when this object was created.
        :param _builtins.str network_connectivity_config_id: Canonical unique identifier of Network Connectivity Config in Databricks Account
        :param _builtins.int updated_time: time in epoch milliseconds when this object was updated.
        """
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if deactivated is not None:
            pulumi.set(__self__, "deactivated", deactivated)
        if deactivated_at is not None:
            pulumi.set(__self__, "deactivated_at", deactivated_at)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if network_connectivity_config_id is not None:
            pulumi.set(__self__, "network_connectivity_config_id", network_connectivity_config_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if updated_time is not None:
            pulumi.set(__self__, "updated_time", updated_time)

    @_builtins.property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_state")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.int]:
        """
        time in epoch milliseconds when this object was created.
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def deactivated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "deactivated")

    @_builtins.property
    @pulumi.getter(name="deactivatedAt")
    def deactivated_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "deactivated_at")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_name")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="networkConnectivityConfigId")
    def network_connectivity_config_id(self) -> Optional[_builtins.str]:
        """
        Canonical unique identifier of Network Connectivity Config in Databricks Account
        """
        return pulumi.get(self, "network_connectivity_config_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="updatedTime")
    def updated_time(self) -> Optional[_builtins.int]:
        """
        time in epoch milliseconds when this object was updated.
        """
        return pulumi.get(self, "updated_time")


@pulumi.output_type
class MwsNetworksErrorMessage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"
        elif key == "errorType":
            suggest = "error_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworksErrorMessage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworksErrorMessage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworksErrorMessage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[_builtins.str] = None,
                 error_type: Optional[_builtins.str] = None):
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if error_type is not None:
            pulumi.set(__self__, "error_type", error_type)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter(name="errorType")
    def error_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error_type")


@pulumi.output_type
class MwsNetworksGcpNetworkInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkProjectId":
            suggest = "network_project_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "subnetRegion":
            suggest = "subnet_region"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "podIpRangeName":
            suggest = "pod_ip_range_name"
        elif key == "serviceIpRangeName":
            suggest = "service_ip_range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworksGcpNetworkInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworksGcpNetworkInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworksGcpNetworkInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_project_id: _builtins.str,
                 subnet_id: _builtins.str,
                 subnet_region: _builtins.str,
                 vpc_id: _builtins.str,
                 pod_ip_range_name: Optional[_builtins.str] = None,
                 service_ip_range_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str network_project_id: The Google Cloud project ID of the VPC network.
        :param _builtins.str subnet_id: The ID of the subnet associated with this network.
        :param _builtins.str subnet_region: The Google Cloud region of the workspace data plane. For example, `us-east4`.
        :param _builtins.str vpc_id: The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
        pulumi.set(__self__, "network_project_id", network_project_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "subnet_region", subnet_region)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if pod_ip_range_name is not None:
            pulumi.set(__self__, "pod_ip_range_name", pod_ip_range_name)
        if service_ip_range_name is not None:
            pulumi.set(__self__, "service_ip_range_name", service_ip_range_name)

    @_builtins.property
    @pulumi.getter(name="networkProjectId")
    def network_project_id(self) -> _builtins.str:
        """
        The Google Cloud project ID of the VPC network.
        """
        return pulumi.get(self, "network_project_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        The ID of the subnet associated with this network.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="subnetRegion")
    def subnet_region(self) -> _builtins.str:
        """
        The Google Cloud region of the workspace data plane. For example, `us-east4`.
        """
        return pulumi.get(self, "subnet_region")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        The ID of the VPC associated with this network. VPC IDs can be used in multiple network configurations.
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter(name="podIpRangeName")
    @_utilities.deprecated("""gcp_network_info.pod_ip_range_name is deprecated and will be removed in a future release. For more information, review the documentation at https://registry.terraform.io/providers/databricks/databricks/1.97.0/docs/guides/gcp-workspace#creating-a-vpc""")
    def pod_ip_range_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pod_ip_range_name")

    @_builtins.property
    @pulumi.getter(name="serviceIpRangeName")
    @_utilities.deprecated("""gcp_network_info.service_ip_range_name is deprecated and will be removed in a future release. For more information, review the documentation at https://registry.terraform.io/providers/databricks/databricks/1.97.0/docs/guides/gcp-workspace#creating-a-vpc""")
    def service_ip_range_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_ip_range_name")


@pulumi.output_type
class MwsNetworksVpcEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataplaneRelays":
            suggest = "dataplane_relays"
        elif key == "restApis":
            suggest = "rest_apis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsNetworksVpcEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsNetworksVpcEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsNetworksVpcEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataplane_relays: Sequence[_builtins.str],
                 rest_apis: Sequence[_builtins.str]):
        pulumi.set(__self__, "dataplane_relays", dataplane_relays)
        pulumi.set(__self__, "rest_apis", rest_apis)

    @_builtins.property
    @pulumi.getter(name="dataplaneRelays")
    def dataplane_relays(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "dataplane_relays")

    @_builtins.property
    @pulumi.getter(name="restApis")
    def rest_apis(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "rest_apis")


@pulumi.output_type
class MwsVpcEndpointGcpVpcEndpointInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointRegion":
            suggest = "endpoint_region"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "pscEndpointName":
            suggest = "psc_endpoint_name"
        elif key == "pscConnectionId":
            suggest = "psc_connection_id"
        elif key == "serviceAttachmentId":
            suggest = "service_attachment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsVpcEndpointGcpVpcEndpointInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsVpcEndpointGcpVpcEndpointInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsVpcEndpointGcpVpcEndpointInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_region: _builtins.str,
                 project_id: _builtins.str,
                 psc_endpoint_name: _builtins.str,
                 psc_connection_id: Optional[_builtins.str] = None,
                 service_attachment_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint_region: Region of the PSC endpoint.
        :param _builtins.str project_id: The Google Cloud project ID of the VPC network where the PSC connection resides.
        :param _builtins.str psc_endpoint_name: The name of the PSC endpoint in the Google Cloud project.
        :param _builtins.str psc_connection_id: The unique ID of this PSC connection.
        :param _builtins.str service_attachment_id: The service attachment this PSC connection connects to.
        """
        pulumi.set(__self__, "endpoint_region", endpoint_region)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "psc_endpoint_name", psc_endpoint_name)
        if psc_connection_id is not None:
            pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        if service_attachment_id is not None:
            pulumi.set(__self__, "service_attachment_id", service_attachment_id)

    @_builtins.property
    @pulumi.getter(name="endpointRegion")
    def endpoint_region(self) -> _builtins.str:
        """
        Region of the PSC endpoint.
        """
        return pulumi.get(self, "endpoint_region")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The Google Cloud project ID of the VPC network where the PSC connection resides.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="pscEndpointName")
    def psc_endpoint_name(self) -> _builtins.str:
        """
        The name of the PSC endpoint in the Google Cloud project.
        """
        return pulumi.get(self, "psc_endpoint_name")

    @_builtins.property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[_builtins.str]:
        """
        The unique ID of this PSC connection.
        """
        return pulumi.get(self, "psc_connection_id")

    @_builtins.property
    @pulumi.getter(name="serviceAttachmentId")
    def service_attachment_id(self) -> Optional[_builtins.str]:
        """
        The service attachment this PSC connection connects to.
        """
        return pulumi.get(self, "service_attachment_id")


@pulumi.output_type
class MwsWorkspacesCloudResourceContainer(dict):
    def __init__(__self__, *,
                 gcp: 'outputs.MwsWorkspacesCloudResourceContainerGcp'):
        """
        :param 'MwsWorkspacesCloudResourceContainerGcpArgs' gcp: A block that consists of the following field:
        """
        pulumi.set(__self__, "gcp", gcp)

    @_builtins.property
    @pulumi.getter
    def gcp(self) -> 'outputs.MwsWorkspacesCloudResourceContainerGcp':
        """
        A block that consists of the following field:
        """
        return pulumi.get(self, "gcp")


@pulumi.output_type
class MwsWorkspacesCloudResourceContainerGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesCloudResourceContainerGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesCloudResourceContainerGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesCloudResourceContainerGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: _builtins.str):
        """
        :param _builtins.str project_id: The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The Google Cloud project ID, which the workspace uses to instantiate cloud resources for your workspace.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class MwsWorkspacesExternalCustomerInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authoritativeUserEmail":
            suggest = "authoritative_user_email"
        elif key == "authoritativeUserFullName":
            suggest = "authoritative_user_full_name"
        elif key == "customerName":
            suggest = "customer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesExternalCustomerInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesExternalCustomerInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesExternalCustomerInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authoritative_user_email: _builtins.str,
                 authoritative_user_full_name: _builtins.str,
                 customer_name: _builtins.str):
        pulumi.set(__self__, "authoritative_user_email", authoritative_user_email)
        pulumi.set(__self__, "authoritative_user_full_name", authoritative_user_full_name)
        pulumi.set(__self__, "customer_name", customer_name)

    @_builtins.property
    @pulumi.getter(name="authoritativeUserEmail")
    def authoritative_user_email(self) -> _builtins.str:
        return pulumi.get(self, "authoritative_user_email")

    @_builtins.property
    @pulumi.getter(name="authoritativeUserFullName")
    def authoritative_user_full_name(self) -> _builtins.str:
        return pulumi.get(self, "authoritative_user_full_name")

    @_builtins.property
    @pulumi.getter(name="customerName")
    def customer_name(self) -> _builtins.str:
        return pulumi.get(self, "customer_name")


@pulumi.output_type
class MwsWorkspacesGcpManagedNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetCidr":
            suggest = "subnet_cidr"
        elif key == "gkeClusterPodIpRange":
            suggest = "gke_cluster_pod_ip_range"
        elif key == "gkeClusterServiceIpRange":
            suggest = "gke_cluster_service_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesGcpManagedNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesGcpManagedNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesGcpManagedNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_cidr: _builtins.str,
                 gke_cluster_pod_ip_range: Optional[_builtins.str] = None,
                 gke_cluster_service_ip_range: Optional[_builtins.str] = None):
        pulumi.set(__self__, "subnet_cidr", subnet_cidr)
        if gke_cluster_pod_ip_range is not None:
            pulumi.set(__self__, "gke_cluster_pod_ip_range", gke_cluster_pod_ip_range)
        if gke_cluster_service_ip_range is not None:
            pulumi.set(__self__, "gke_cluster_service_ip_range", gke_cluster_service_ip_range)

    @_builtins.property
    @pulumi.getter(name="subnetCidr")
    def subnet_cidr(self) -> _builtins.str:
        return pulumi.get(self, "subnet_cidr")

    @_builtins.property
    @pulumi.getter(name="gkeClusterPodIpRange")
    @_utilities.deprecated("""gcp_managed_network_config.gke_cluster_pod_ip_range is deprecated and will be removed in a future release. For more information, review the documentation at https://registry.terraform.io/providers/databricks/databricks/1.97.0/docs/guides/gcp-workspace#creating-a-databricks-workspace""")
    def gke_cluster_pod_ip_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gke_cluster_pod_ip_range")

    @_builtins.property
    @pulumi.getter(name="gkeClusterServiceIpRange")
    @_utilities.deprecated("""gcp_managed_network_config.gke_cluster_service_ip_range is deprecated and will be removed in a future release. For more information, review the documentation at https://registry.terraform.io/providers/databricks/databricks/1.97.0/docs/guides/gcp-workspace#creating-a-databricks-workspace""")
    def gke_cluster_service_ip_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gke_cluster_service_ip_range")


@pulumi.output_type
class MwsWorkspacesGkeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityType":
            suggest = "connectivity_type"
        elif key == "masterIpRange":
            suggest = "master_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesGkeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesGkeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesGkeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity_type: Optional[_builtins.str] = None,
                 master_ip_range: Optional[_builtins.str] = None):
        if connectivity_type is not None:
            pulumi.set(__self__, "connectivity_type", connectivity_type)
        if master_ip_range is not None:
            pulumi.set(__self__, "master_ip_range", master_ip_range)

    @_builtins.property
    @pulumi.getter(name="connectivityType")
    def connectivity_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connectivity_type")

    @_builtins.property
    @pulumi.getter(name="masterIpRange")
    def master_ip_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "master_ip_range")


@pulumi.output_type
class MwsWorkspacesToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifetimeSeconds":
            suggest = "lifetime_seconds"
        elif key == "tokenId":
            suggest = "token_id"
        elif key == "tokenValue":
            suggest = "token_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MwsWorkspacesToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MwsWorkspacesToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MwsWorkspacesToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 lifetime_seconds: Optional[_builtins.int] = None,
                 token_id: Optional[_builtins.str] = None,
                 token_value: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Comment, that will appear in "User Settings / Access Tokens" page on Workspace UI. By default it's "Pulumi PAT".
        :param _builtins.int lifetime_seconds: Token expiry lifetime. By default its 2592000 (30 days).
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if token_id is not None:
            pulumi.set(__self__, "token_id", token_id)
        if token_value is not None:
            pulumi.set(__self__, "token_value", token_value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Comment, that will appear in "User Settings / Access Tokens" page on Workspace UI. By default it's "Pulumi PAT".
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[_builtins.int]:
        """
        Token expiry lifetime. By default its 2592000 (30 days).
        """
        return pulumi.get(self, "lifetime_seconds")

    @_builtins.property
    @pulumi.getter(name="tokenId")
    def token_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token_id")

    @_builtins.property
    @pulumi.getter(name="tokenValue")
    def token_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token_value")


@pulumi.output_type
class NotebookProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotebookProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotebookProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotebookProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class NotificationDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "genericWebhook":
            suggest = "generic_webhook"
        elif key == "microsoftTeams":
            suggest = "microsoft_teams"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional['outputs.NotificationDestinationConfigEmail'] = None,
                 generic_webhook: Optional['outputs.NotificationDestinationConfigGenericWebhook'] = None,
                 microsoft_teams: Optional['outputs.NotificationDestinationConfigMicrosoftTeams'] = None,
                 pagerduty: Optional['outputs.NotificationDestinationConfigPagerduty'] = None,
                 slack: Optional['outputs.NotificationDestinationConfigSlack'] = None):
        """
        :param 'NotificationDestinationConfigEmailArgs' email: The email configuration of the Notification Destination. It must contain the following:
        :param 'NotificationDestinationConfigGenericWebhookArgs' generic_webhook: The Generic Webhook configuration of the Notification Destination. It must contain the following:
        :param 'NotificationDestinationConfigMicrosoftTeamsArgs' microsoft_teams: The Microsoft Teams configuration of the Notification Destination. It must contain the following:
        :param 'NotificationDestinationConfigPagerdutyArgs' pagerduty: The PagerDuty configuration of the Notification Destination. It must contain the following:
        :param 'NotificationDestinationConfigSlackArgs' slack: The Slack configuration of the Notification Destination. It must contain the following:
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if generic_webhook is not None:
            pulumi.set(__self__, "generic_webhook", generic_webhook)
        if microsoft_teams is not None:
            pulumi.set(__self__, "microsoft_teams", microsoft_teams)
        if pagerduty is not None:
            pulumi.set(__self__, "pagerduty", pagerduty)
        if slack is not None:
            pulumi.set(__self__, "slack", slack)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional['outputs.NotificationDestinationConfigEmail']:
        """
        The email configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="genericWebhook")
    def generic_webhook(self) -> Optional['outputs.NotificationDestinationConfigGenericWebhook']:
        """
        The Generic Webhook configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "generic_webhook")

    @_builtins.property
    @pulumi.getter(name="microsoftTeams")
    def microsoft_teams(self) -> Optional['outputs.NotificationDestinationConfigMicrosoftTeams']:
        """
        The Microsoft Teams configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "microsoft_teams")

    @_builtins.property
    @pulumi.getter
    def pagerduty(self) -> Optional['outputs.NotificationDestinationConfigPagerduty']:
        """
        The PagerDuty configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "pagerduty")

    @_builtins.property
    @pulumi.getter
    def slack(self) -> Optional['outputs.NotificationDestinationConfigSlack']:
        """
        The Slack configuration of the Notification Destination. It must contain the following:
        """
        return pulumi.get(self, "slack")


@pulumi.output_type
class NotificationDestinationConfigEmail(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] addresses: The list of email addresses to send notifications to.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of email addresses to send notifications to.
        """
        return pulumi.get(self, "addresses")


@pulumi.output_type
class NotificationDestinationConfigGenericWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSet":
            suggest = "password_set"
        elif key == "urlSet":
            suggest = "url_set"
        elif key == "usernameSet":
            suggest = "username_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationDestinationConfigGenericWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationDestinationConfigGenericWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationDestinationConfigGenericWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 password_set: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 url_set: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None,
                 username_set: Optional[_builtins.bool] = None):
        """
        :param _builtins.str password: The password for basic authentication.
               
               > **NOTE** If the type of notification destination is changed, the existing notification destination will be deleted and a new notification destination will be created with the new type.
        :param _builtins.str url: The Generic Webhook URL.
        :param _builtins.str username: The username for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if password_set is not None:
            pulumi.set(__self__, "password_set", password_set)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_set is not None:
            pulumi.set(__self__, "url_set", url_set)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_set is not None:
            pulumi.set(__self__, "username_set", username_set)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password for basic authentication.

        > **NOTE** If the type of notification destination is changed, the existing notification destination will be deleted and a new notification destination will be created with the new type.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="passwordSet")
    def password_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "password_set")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The Generic Webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="urlSet")
    def url_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "url_set")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username for basic authentication.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="usernameSet")
    def username_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "username_set")


@pulumi.output_type
class NotificationDestinationConfigMicrosoftTeams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appIdSet":
            suggest = "app_id_set"
        elif key == "authSecret":
            suggest = "auth_secret"
        elif key == "authSecretSet":
            suggest = "auth_secret_set"
        elif key == "channelUrl":
            suggest = "channel_url"
        elif key == "channelUrlSet":
            suggest = "channel_url_set"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantIdSet":
            suggest = "tenant_id_set"
        elif key == "urlSet":
            suggest = "url_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationDestinationConfigMicrosoftTeams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationDestinationConfigMicrosoftTeams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationDestinationConfigMicrosoftTeams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 app_id_set: Optional[_builtins.bool] = None,
                 auth_secret: Optional[_builtins.str] = None,
                 auth_secret_set: Optional[_builtins.bool] = None,
                 channel_url: Optional[_builtins.str] = None,
                 channel_url_set: Optional[_builtins.bool] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 tenant_id_set: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 url_set: Optional[_builtins.bool] = None):
        """
        :param _builtins.str app_id: App ID for Microsoft Teams App.
        :param _builtins.str auth_secret: Secret for Microsoft Teams App authentication.
        :param _builtins.str channel_url: Channel URL for Microsoft Teams App.
        :param _builtins.str tenant_id: Tenant ID for Microsoft Teams App.
        :param _builtins.str url: The Microsoft Teams webhook URL.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_id_set is not None:
            pulumi.set(__self__, "app_id_set", app_id_set)
        if auth_secret is not None:
            pulumi.set(__self__, "auth_secret", auth_secret)
        if auth_secret_set is not None:
            pulumi.set(__self__, "auth_secret_set", auth_secret_set)
        if channel_url is not None:
            pulumi.set(__self__, "channel_url", channel_url)
        if channel_url_set is not None:
            pulumi.set(__self__, "channel_url_set", channel_url_set)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_id_set is not None:
            pulumi.set(__self__, "tenant_id_set", tenant_id_set)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_set is not None:
            pulumi.set(__self__, "url_set", url_set)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        App ID for Microsoft Teams App.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appIdSet")
    def app_id_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "app_id_set")

    @_builtins.property
    @pulumi.getter(name="authSecret")
    def auth_secret(self) -> Optional[_builtins.str]:
        """
        Secret for Microsoft Teams App authentication.
        """
        return pulumi.get(self, "auth_secret")

    @_builtins.property
    @pulumi.getter(name="authSecretSet")
    def auth_secret_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auth_secret_set")

    @_builtins.property
    @pulumi.getter(name="channelUrl")
    def channel_url(self) -> Optional[_builtins.str]:
        """
        Channel URL for Microsoft Teams App.
        """
        return pulumi.get(self, "channel_url")

    @_builtins.property
    @pulumi.getter(name="channelUrlSet")
    def channel_url_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "channel_url_set")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Tenant ID for Microsoft Teams App.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantIdSet")
    def tenant_id_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "tenant_id_set")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The Microsoft Teams webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="urlSet")
    def url_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "url_set")


@pulumi.output_type
class NotificationDestinationConfigPagerduty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationKey":
            suggest = "integration_key"
        elif key == "integrationKeySet":
            suggest = "integration_key_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationDestinationConfigPagerduty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationDestinationConfigPagerduty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationDestinationConfigPagerduty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_key: Optional[_builtins.str] = None,
                 integration_key_set: Optional[_builtins.bool] = None):
        """
        :param _builtins.str integration_key: The PagerDuty integration key.
        """
        if integration_key is not None:
            pulumi.set(__self__, "integration_key", integration_key)
        if integration_key_set is not None:
            pulumi.set(__self__, "integration_key_set", integration_key_set)

    @_builtins.property
    @pulumi.getter(name="integrationKey")
    def integration_key(self) -> Optional[_builtins.str]:
        """
        The PagerDuty integration key.
        """
        return pulumi.get(self, "integration_key")

    @_builtins.property
    @pulumi.getter(name="integrationKeySet")
    def integration_key_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "integration_key_set")


@pulumi.output_type
class NotificationDestinationConfigSlack(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"
        elif key == "channelIdSet":
            suggest = "channel_id_set"
        elif key == "oauthToken":
            suggest = "oauth_token"
        elif key == "oauthTokenSet":
            suggest = "oauth_token_set"
        elif key == "urlSet":
            suggest = "url_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationDestinationConfigSlack. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationDestinationConfigSlack.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationDestinationConfigSlack.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[_builtins.str] = None,
                 channel_id_set: Optional[_builtins.bool] = None,
                 oauth_token: Optional[_builtins.str] = None,
                 oauth_token_set: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 url_set: Optional[_builtins.bool] = None):
        """
        :param _builtins.str channel_id: Slack channel ID for notifications.
        :param _builtins.str oauth_token: OAuth token for Slack authentication.
        :param _builtins.str url: The Slack webhook URL.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if channel_id_set is not None:
            pulumi.set(__self__, "channel_id_set", channel_id_set)
        if oauth_token is not None:
            pulumi.set(__self__, "oauth_token", oauth_token)
        if oauth_token_set is not None:
            pulumi.set(__self__, "oauth_token_set", oauth_token_set)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if url_set is not None:
            pulumi.set(__self__, "url_set", url_set)

    @_builtins.property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[_builtins.str]:
        """
        Slack channel ID for notifications.
        """
        return pulumi.get(self, "channel_id")

    @_builtins.property
    @pulumi.getter(name="channelIdSet")
    def channel_id_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "channel_id_set")

    @_builtins.property
    @pulumi.getter(name="oauthToken")
    def oauth_token(self) -> Optional[_builtins.str]:
        """
        OAuth token for Slack authentication.
        """
        return pulumi.get(self, "oauth_token")

    @_builtins.property
    @pulumi.getter(name="oauthTokenSet")
    def oauth_token_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "oauth_token_set")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="urlSet")
    def url_set(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "url_set")


@pulumi.output_type
class OnlineTableSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "performFullCopy":
            suggest = "perform_full_copy"
        elif key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "primaryKeyColumns":
            suggest = "primary_key_columns"
        elif key == "runContinuously":
            suggest = "run_continuously"
        elif key == "runTriggered":
            suggest = "run_triggered"
        elif key == "sourceTableFullName":
            suggest = "source_table_full_name"
        elif key == "timeseriesKey":
            suggest = "timeseries_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 perform_full_copy: Optional[_builtins.bool] = None,
                 pipeline_id: Optional[_builtins.str] = None,
                 primary_key_columns: Optional[Sequence[_builtins.str]] = None,
                 run_continuously: Optional['outputs.OnlineTableSpecRunContinuously'] = None,
                 run_triggered: Optional['outputs.OnlineTableSpecRunTriggered'] = None,
                 source_table_full_name: Optional[_builtins.str] = None,
                 timeseries_key: Optional[_builtins.str] = None):
        """
        :param _builtins.bool perform_full_copy: Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports "triggered" scheduling policy.
        :param _builtins.str pipeline_id: ID of the associated Delta Live Table pipeline.
        :param Sequence[_builtins.str] primary_key_columns: list of the columns comprising the primary key.
        :param 'OnlineTableSpecRunContinuouslyArgs' run_continuously: empty block that specifies that pipeline runs continuously after generating the initial data.  Conflicts with `run_triggered`.
        :param 'OnlineTableSpecRunTriggeredArgs' run_triggered: empty block that specifies that pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers).
        :param _builtins.str source_table_full_name: full name of the source table.
        :param _builtins.str timeseries_key: Time series key to deduplicate (tie-break) rows with the same primary key.
        """
        if perform_full_copy is not None:
            pulumi.set(__self__, "perform_full_copy", perform_full_copy)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if primary_key_columns is not None:
            pulumi.set(__self__, "primary_key_columns", primary_key_columns)
        if run_continuously is not None:
            pulumi.set(__self__, "run_continuously", run_continuously)
        if run_triggered is not None:
            pulumi.set(__self__, "run_triggered", run_triggered)
        if source_table_full_name is not None:
            pulumi.set(__self__, "source_table_full_name", source_table_full_name)
        if timeseries_key is not None:
            pulumi.set(__self__, "timeseries_key", timeseries_key)

    @_builtins.property
    @pulumi.getter(name="performFullCopy")
    def perform_full_copy(self) -> Optional[_builtins.bool]:
        """
        Whether to create a full-copy pipeline -- a pipeline that stops after creates a full copy of the source table upon initialization and does not process any change data feeds (CDFs) afterwards. The pipeline can still be manually triggered afterwards, but it always perform a full copy of the source table and there are no incremental updates. This mode is useful for syncing views or tables without CDFs to online tables. Note that the full-copy pipeline only supports "triggered" scheduling policy.
        """
        return pulumi.get(self, "perform_full_copy")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        ID of the associated Delta Live Table pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="primaryKeyColumns")
    def primary_key_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of the columns comprising the primary key.
        """
        return pulumi.get(self, "primary_key_columns")

    @_builtins.property
    @pulumi.getter(name="runContinuously")
    def run_continuously(self) -> Optional['outputs.OnlineTableSpecRunContinuously']:
        """
        empty block that specifies that pipeline runs continuously after generating the initial data.  Conflicts with `run_triggered`.
        """
        return pulumi.get(self, "run_continuously")

    @_builtins.property
    @pulumi.getter(name="runTriggered")
    def run_triggered(self) -> Optional['outputs.OnlineTableSpecRunTriggered']:
        """
        empty block that specifies that pipeline stops after generating the initial data and can be triggered later (manually, through a cron job or through data triggers).
        """
        return pulumi.get(self, "run_triggered")

    @_builtins.property
    @pulumi.getter(name="sourceTableFullName")
    def source_table_full_name(self) -> Optional[_builtins.str]:
        """
        full name of the source table.
        """
        return pulumi.get(self, "source_table_full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesKey")
    def timeseries_key(self) -> Optional[_builtins.str]:
        """
        Time series key to deduplicate (tie-break) rows with the same primary key.
        """
        return pulumi.get(self, "timeseries_key")


@pulumi.output_type
class OnlineTableSpecRunContinuously(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class OnlineTableSpecRunTriggered(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class OnlineTableStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continuousUpdateStatus":
            suggest = "continuous_update_status"
        elif key == "detailedState":
            suggest = "detailed_state"
        elif key == "failedStatus":
            suggest = "failed_status"
        elif key == "provisioningStatus":
            suggest = "provisioning_status"
        elif key == "triggeredUpdateStatus":
            suggest = "triggered_update_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continuous_update_status: Optional['outputs.OnlineTableStatusContinuousUpdateStatus'] = None,
                 detailed_state: Optional[_builtins.str] = None,
                 failed_status: Optional['outputs.OnlineTableStatusFailedStatus'] = None,
                 message: Optional[_builtins.str] = None,
                 provisioning_status: Optional['outputs.OnlineTableStatusProvisioningStatus'] = None,
                 triggered_update_status: Optional['outputs.OnlineTableStatusTriggeredUpdateStatus'] = None):
        """
        :param _builtins.str detailed_state: The state of the online table.
        :param _builtins.str message: A text description of the current state of the online table.
        """
        if continuous_update_status is not None:
            pulumi.set(__self__, "continuous_update_status", continuous_update_status)
        if detailed_state is not None:
            pulumi.set(__self__, "detailed_state", detailed_state)
        if failed_status is not None:
            pulumi.set(__self__, "failed_status", failed_status)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if triggered_update_status is not None:
            pulumi.set(__self__, "triggered_update_status", triggered_update_status)

    @_builtins.property
    @pulumi.getter(name="continuousUpdateStatus")
    def continuous_update_status(self) -> Optional['outputs.OnlineTableStatusContinuousUpdateStatus']:
        return pulumi.get(self, "continuous_update_status")

    @_builtins.property
    @pulumi.getter(name="detailedState")
    def detailed_state(self) -> Optional[_builtins.str]:
        """
        The state of the online table.
        """
        return pulumi.get(self, "detailed_state")

    @_builtins.property
    @pulumi.getter(name="failedStatus")
    def failed_status(self) -> Optional['outputs.OnlineTableStatusFailedStatus']:
        return pulumi.get(self, "failed_status")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        A text description of the current state of the online table.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional['outputs.OnlineTableStatusProvisioningStatus']:
        return pulumi.get(self, "provisioning_status")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateStatus")
    def triggered_update_status(self) -> Optional['outputs.OnlineTableStatusTriggeredUpdateStatus']:
        return pulumi.get(self, "triggered_update_status")


@pulumi.output_type
class OnlineTableStatusContinuousUpdateStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialPipelineSyncProgress":
            suggest = "initial_pipeline_sync_progress"
        elif key == "lastProcessedCommitVersion":
            suggest = "last_processed_commit_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusContinuousUpdateStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusContinuousUpdateStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusContinuousUpdateStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_pipeline_sync_progress: Optional['outputs.OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress'] = None,
                 last_processed_commit_version: Optional[_builtins.int] = None,
                 timestamp: Optional[_builtins.str] = None):
        if initial_pipeline_sync_progress is not None:
            pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> Optional['outputs.OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress']:
        return pulumi.get(self, "initial_pipeline_sync_progress")

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedCompletionTimeSeconds":
            suggest = "estimated_completion_time_seconds"
        elif key == "latestVersionCurrentlyProcessing":
            suggest = "latest_version_currently_processing"
        elif key == "syncProgressCompletion":
            suggest = "sync_progress_completion"
        elif key == "syncedRowCount":
            suggest = "synced_row_count"
        elif key == "totalRowCount":
            suggest = "total_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusContinuousUpdateStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[_builtins.float] = None,
                 latest_version_currently_processing: Optional[_builtins.int] = None,
                 sync_progress_completion: Optional[_builtins.float] = None,
                 synced_row_count: Optional[_builtins.int] = None,
                 total_row_count: Optional[_builtins.int] = None):
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class OnlineTableStatusFailedStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastProcessedCommitVersion":
            suggest = "last_processed_commit_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusFailedStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusFailedStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusFailedStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_processed_commit_version: Optional[_builtins.int] = None,
                 timestamp: Optional[_builtins.str] = None):
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class OnlineTableStatusProvisioningStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialPipelineSyncProgress":
            suggest = "initial_pipeline_sync_progress"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusProvisioningStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusProvisioningStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusProvisioningStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_pipeline_sync_progress: Optional['outputs.OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress'] = None):
        if initial_pipeline_sync_progress is not None:
            pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> Optional['outputs.OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress']:
        return pulumi.get(self, "initial_pipeline_sync_progress")


@pulumi.output_type
class OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedCompletionTimeSeconds":
            suggest = "estimated_completion_time_seconds"
        elif key == "latestVersionCurrentlyProcessing":
            suggest = "latest_version_currently_processing"
        elif key == "syncProgressCompletion":
            suggest = "sync_progress_completion"
        elif key == "syncedRowCount":
            suggest = "synced_row_count"
        elif key == "totalRowCount":
            suggest = "total_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusProvisioningStatusInitialPipelineSyncProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[_builtins.float] = None,
                 latest_version_currently_processing: Optional[_builtins.int] = None,
                 sync_progress_completion: Optional[_builtins.float] = None,
                 synced_row_count: Optional[_builtins.int] = None,
                 total_row_count: Optional[_builtins.int] = None):
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class OnlineTableStatusTriggeredUpdateStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastProcessedCommitVersion":
            suggest = "last_processed_commit_version"
        elif key == "triggeredUpdateProgress":
            suggest = "triggered_update_progress"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusTriggeredUpdateStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusTriggeredUpdateStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusTriggeredUpdateStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_processed_commit_version: Optional[_builtins.int] = None,
                 timestamp: Optional[_builtins.str] = None,
                 triggered_update_progress: Optional['outputs.OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress'] = None):
        if last_processed_commit_version is not None:
            pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)
        if triggered_update_progress is not None:
            pulumi.set(__self__, "triggered_update_progress", triggered_update_progress)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateProgress")
    def triggered_update_progress(self) -> Optional['outputs.OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress']:
        return pulumi.get(self, "triggered_update_progress")


@pulumi.output_type
class OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "estimatedCompletionTimeSeconds":
            suggest = "estimated_completion_time_seconds"
        elif key == "latestVersionCurrentlyProcessing":
            suggest = "latest_version_currently_processing"
        elif key == "syncProgressCompletion":
            suggest = "sync_progress_completion"
        elif key == "syncedRowCount":
            suggest = "synced_row_count"
        elif key == "totalRowCount":
            suggest = "total_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineTableStatusTriggeredUpdateStatusTriggeredUpdateProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 estimated_completion_time_seconds: Optional[_builtins.float] = None,
                 latest_version_currently_processing: Optional[_builtins.int] = None,
                 sync_progress_completion: Optional[_builtins.float] = None,
                 synced_row_count: Optional[_builtins.int] = None,
                 total_row_count: Optional[_builtins.int] = None):
        if estimated_completion_time_seconds is not None:
            pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        if latest_version_currently_processing is not None:
            pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        if sync_progress_completion is not None:
            pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        if synced_row_count is not None:
            pulumi.set(__self__, "synced_row_count", synced_row_count)
        if total_row_count is not None:
            pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class PermissionAssignmentProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionAssignmentProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionAssignmentProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionAssignmentProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class PermissionsAccessControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "permissionLevel":
            suggest = "permission_level"
        elif key == "servicePrincipalName":
            suggest = "service_principal_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionsAccessControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionsAccessControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionsAccessControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: Optional[_builtins.str] = None,
                 permission_level: Optional[_builtins.str] = None,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str group_name: name of the group. We recommend setting permissions on groups.
        :param _builtins.str permission_level: permission level according to specific resource. See examples above for the reference.
               
               Exactly one of the below arguments is required:
        :param _builtins.str service_principal_name: Application ID (**not service principal name!**) of the service_principal.
        :param _builtins.str user_name: name of the user.
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if permission_level is not None:
            pulumi.set(__self__, "permission_level", permission_level)
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        name of the group. We recommend setting permissions on groups.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="permissionLevel")
    def permission_level(self) -> Optional[_builtins.str]:
        """
        permission level according to specific resource. See examples above for the reference.

        Exactly one of the below arguments is required:
        """
        return pulumi.get(self, "permission_level")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        Application ID (**not service principal name!**) of the service_principal.
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        name of the user.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class PipelineCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applyPolicyDefaultValues":
            suggest = "apply_policy_default_values"
        elif key == "awsAttributes":
            suggest = "aws_attributes"
        elif key == "azureAttributes":
            suggest = "azure_attributes"
        elif key == "clusterLogConf":
            suggest = "cluster_log_conf"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "driverInstancePoolId":
            suggest = "driver_instance_pool_id"
        elif key == "driverNodeTypeId":
            suggest = "driver_node_type_id"
        elif key == "enableLocalDiskEncryption":
            suggest = "enable_local_disk_encryption"
        elif key == "gcpAttributes":
            suggest = "gcp_attributes"
        elif key == "initScripts":
            suggest = "init_scripts"
        elif key == "instancePoolId":
            suggest = "instance_pool_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "sparkConf":
            suggest = "spark_conf"
        elif key == "sparkEnvVars":
            suggest = "spark_env_vars"
        elif key == "sshPublicKeys":
            suggest = "ssh_public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.PipelineClusterAutoscale'] = None,
                 aws_attributes: Optional['outputs.PipelineClusterAwsAttributes'] = None,
                 azure_attributes: Optional['outputs.PipelineClusterAzureAttributes'] = None,
                 cluster_log_conf: Optional['outputs.PipelineClusterClusterLogConf'] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 driver_instance_pool_id: Optional[_builtins.str] = None,
                 driver_node_type_id: Optional[_builtins.str] = None,
                 enable_local_disk_encryption: Optional[_builtins.bool] = None,
                 gcp_attributes: Optional['outputs.PipelineClusterGcpAttributes'] = None,
                 init_scripts: Optional[Sequence['outputs.PipelineClusterInitScript']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None):
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.PipelineClusterAutoscale']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.PipelineClusterAwsAttributes']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.PipelineClusterAzureAttributes']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.PipelineClusterClusterLogConf']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.PipelineClusterGcpAttributes']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.PipelineClusterInitScript']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")


@pulumi.output_type
class PipelineClusterAutoscale(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWorkers":
            suggest = "max_workers"
        elif key == "minWorkers":
            suggest = "min_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterAutoscale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterAutoscale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterAutoscale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_workers: _builtins.int,
                 min_workers: _builtins.int,
                 mode: Optional[_builtins.str] = None):
        pulumi.set(__self__, "max_workers", max_workers)
        pulumi.set(__self__, "min_workers", min_workers)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> _builtins.int:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> _builtins.int:
        return pulumi.get(self, "min_workers")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class PipelineClusterAwsAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsVolumeCount":
            suggest = "ebs_volume_count"
        elif key == "ebsVolumeIops":
            suggest = "ebs_volume_iops"
        elif key == "ebsVolumeSize":
            suggest = "ebs_volume_size"
        elif key == "ebsVolumeThroughput":
            suggest = "ebs_volume_throughput"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "instanceProfileArn":
            suggest = "instance_profile_arn"
        elif key == "spotBidPricePercent":
            suggest = "spot_bid_price_percent"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterAwsAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterAwsAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterAwsAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class PipelineClusterAzureAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "logAnalyticsInfo":
            suggest = "log_analytics_info"
        elif key == "spotBidMaxPrice":
            suggest = "spot_bid_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterAzureAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterAzureAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterAzureAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.PipelineClusterAzureAttributesLogAnalyticsInfo'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.PipelineClusterAzureAttributesLogAnalyticsInfo']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class PipelineClusterAzureAttributesLogAnalyticsInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsPrimaryKey":
            suggest = "log_analytics_primary_key"
        elif key == "logAnalyticsWorkspaceId":
            suggest = "log_analytics_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterAzureAttributesLogAnalyticsInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterAzureAttributesLogAnalyticsInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class PipelineClusterClusterLogConf(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.PipelineClusterClusterLogConfDbfs'] = None,
                 s3: Optional['outputs.PipelineClusterClusterLogConfS3'] = None,
                 volumes: Optional['outputs.PipelineClusterClusterLogConfVolumes'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.PipelineClusterClusterLogConfDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.PipelineClusterClusterLogConfS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.PipelineClusterClusterLogConfVolumes']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class PipelineClusterClusterLogConfDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterClusterLogConfS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterClusterLogConfS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterClusterLogConfS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterClusterLogConfS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PipelineClusterClusterLogConfVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterGcpAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstOnDemand":
            suggest = "first_on_demand"
        elif key == "googleServiceAccount":
            suggest = "google_service_account"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterGcpAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterGcpAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterGcpAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class PipelineClusterInitScript(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.PipelineClusterInitScriptAbfss'] = None,
                 dbfs: Optional['outputs.PipelineClusterInitScriptDbfs'] = None,
                 file: Optional['outputs.PipelineClusterInitScriptFile'] = None,
                 gcs: Optional['outputs.PipelineClusterInitScriptGcs'] = None,
                 s3: Optional['outputs.PipelineClusterInitScriptS3'] = None,
                 volumes: Optional['outputs.PipelineClusterInitScriptVolumes'] = None,
                 workspace: Optional['outputs.PipelineClusterInitScriptWorkspace'] = None):
        """
        :param 'PipelineClusterInitScriptFileArgs' file: specifies path to a file in Databricks Workspace to include as source. Actual path is specified as `path` attribute inside the block.
        """
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.PipelineClusterInitScriptAbfss']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.PipelineClusterInitScriptDbfs']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.PipelineClusterInitScriptFile']:
        """
        specifies path to a file in Databricks Workspace to include as source. Actual path is specified as `path` attribute inside the block.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.PipelineClusterInitScriptGcs']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.PipelineClusterInitScriptS3']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.PipelineClusterInitScriptVolumes']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.PipelineClusterInitScriptWorkspace']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class PipelineClusterInitScriptAbfss(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptDbfs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptFile(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptGcs(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "enableEncryption":
            suggest = "enable_encryption"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineClusterInitScriptS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineClusterInitScriptS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineClusterInitScriptS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class PipelineClusterInitScriptVolumes(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineClusterInitScriptWorkspace(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class PipelineDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataFilePath":
            suggest = "metadata_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: _builtins.str,
                 metadata_file_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: The deployment method that manages the pipeline.
        :param _builtins.str metadata_file_path: The path to the file containing metadata about the deployment.
        """
        pulumi.set(__self__, "kind", kind)
        if metadata_file_path is not None:
            pulumi.set(__self__, "metadata_file_path", metadata_file_path)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The deployment method that manages the pipeline.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[_builtins.str]:
        """
        The path to the file containing metadata about the deployment.
        """
        return pulumi.get(self, "metadata_file_path")


@pulumi.output_type
class PipelineEnvironment(dict):
    def __init__(__self__, *,
                 dependencies: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] dependencies: a list of pip dependencies, as supported by the version of pip in this environment. Each dependency is a [pip requirement file line](https://pip.pypa.io/en/stable/reference/requirements-file-format/).  See [API docs](https://docs.databricks.com/api/azure/workspace/pipelines/create#environment-dependencies) for more information.
               
               Example:
               
               ```python
               import pulumi
               import pulumi_databricks as databricks
               
               this = databricks.Pipeline("this",
                   name="Serverless demo",
                   serverless=True,
                   catalog="main",
                   schema="ldp_demo",
                   environment={
                       "dependencies": [
                           "foo==0.0.1",
                           "-r /Workspace/Users/user.name/my-pipeline/requirements.txt",
                           "/Volumes/main/default/libs/my_lib.whl",
                       ],
                   })
               ```
        """
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence[_builtins.str]]:
        """
        a list of pip dependencies, as supported by the version of pip in this environment. Each dependency is a [pip requirement file line](https://pip.pypa.io/en/stable/reference/requirements-file-format/).  See [API docs](https://docs.databricks.com/api/azure/workspace/pipelines/create#environment-dependencies) for more information.

        Example:

        ```python
        import pulumi
        import pulumi_databricks as databricks

        this = databricks.Pipeline("this",
            name="Serverless demo",
            serverless=True,
            catalog="main",
            schema="ldp_demo",
            environment={
                "dependencies": [
                    "foo==0.0.1",
                    "-r /Workspace/Users/user.name/my-pipeline/requirements.txt",
                    "/Volumes/main/default/libs/my_lib.whl",
                ],
            })
        ```
        """
        return pulumi.get(self, "dependencies")


@pulumi.output_type
class PipelineEventLog(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 catalog: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The table name the event log is published to in UC.
        :param _builtins.str catalog: The UC catalog the event log is published under.
        :param _builtins.str schema: The UC schema the event log is published under.
        """
        pulumi.set(__self__, "name", name)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The table name the event log is published to in UC.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        """
        The UC catalog the event log is published under.
        """
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The UC schema the event log is published under.
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class PipelineFilters(dict):
    def __init__(__self__, *,
                 excludes: Optional[Sequence[_builtins.str]] = None,
                 includes: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] excludes: Paths to exclude.
        :param Sequence[_builtins.str] includes: Paths to include.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @_builtins.property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Paths to exclude.
        """
        return pulumi.get(self, "excludes")

    @_builtins.property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Paths to include.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class PipelineGatewayDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "gatewayStorageCatalog":
            suggest = "gateway_storage_catalog"
        elif key == "gatewayStorageSchema":
            suggest = "gateway_storage_schema"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "gatewayStorageName":
            suggest = "gateway_storage_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineGatewayDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineGatewayDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineGatewayDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: _builtins.str,
                 gateway_storage_catalog: _builtins.str,
                 gateway_storage_schema: _builtins.str,
                 connection_id: Optional[_builtins.str] = None,
                 gateway_storage_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str gateway_storage_catalog: Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
        :param _builtins.str gateway_storage_schema: Required, Immutable. The name of the schema for the gateway pipelines's storage location.
        :param _builtins.str connection_id: Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
        :param _builtins.str gateway_storage_name: Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Lakeflow Declarative Pipelines system will automatically create the storage location under the catalog and schema.
        """
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "gateway_storage_catalog", gateway_storage_catalog)
        pulumi.set(__self__, "gateway_storage_schema", gateway_storage_schema)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if gateway_storage_name is not None:
            pulumi.set(__self__, "gateway_storage_name", gateway_storage_name)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="gatewayStorageCatalog")
    def gateway_storage_catalog(self) -> _builtins.str:
        """
        Required, Immutable. The name of the catalog for the gateway pipeline's storage location.
        """
        return pulumi.get(self, "gateway_storage_catalog")

    @_builtins.property
    @pulumi.getter(name="gatewayStorageSchema")
    def gateway_storage_schema(self) -> _builtins.str:
        """
        Required, Immutable. The name of the schema for the gateway pipelines's storage location.
        """
        return pulumi.get(self, "gateway_storage_schema")

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[_builtins.str]:
        """
        Immutable. The Unity Catalog connection this gateway pipeline uses to communicate with the source.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="gatewayStorageName")
    def gateway_storage_name(self) -> Optional[_builtins.str]:
        """
        Required. The Unity Catalog-compatible naming for the gateway storage location. This is the destination to use for the data that is extracted by the gateway. Lakeflow Declarative Pipelines system will automatically create the storage location under the catalog and schema.
        """
        return pulumi.get(self, "gateway_storage_name")


@pulumi.output_type
class PipelineIngestionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "ingestionGatewayId":
            suggest = "ingestion_gateway_id"
        elif key == "netsuiteJarPath":
            suggest = "netsuite_jar_path"
        elif key == "sourceConfigurations":
            suggest = "source_configurations"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "tableConfiguration":
            suggest = "table_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[_builtins.str] = None,
                 ingestion_gateway_id: Optional[_builtins.str] = None,
                 netsuite_jar_path: Optional[_builtins.str] = None,
                 objects: Optional[Sequence['outputs.PipelineIngestionDefinitionObject']] = None,
                 source_configurations: Optional[Sequence['outputs.PipelineIngestionDefinitionSourceConfiguration']] = None,
                 source_type: Optional[_builtins.str] = None,
                 table_configuration: Optional['outputs.PipelineIngestionDefinitionTableConfiguration'] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if ingestion_gateway_id is not None:
            pulumi.set(__self__, "ingestion_gateway_id", ingestion_gateway_id)
        if netsuite_jar_path is not None:
            pulumi.set(__self__, "netsuite_jar_path", netsuite_jar_path)
        if objects is not None:
            pulumi.set(__self__, "objects", objects)
        if source_configurations is not None:
            pulumi.set(__self__, "source_configurations", source_configurations)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="ingestionGatewayId")
    def ingestion_gateway_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ingestion_gateway_id")

    @_builtins.property
    @pulumi.getter(name="netsuiteJarPath")
    def netsuite_jar_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "netsuite_jar_path")

    @_builtins.property
    @pulumi.getter
    def objects(self) -> Optional[Sequence['outputs.PipelineIngestionDefinitionObject']]:
        return pulumi.get(self, "objects")

    @_builtins.property
    @pulumi.getter(name="sourceConfigurations")
    def source_configurations(self) -> Optional[Sequence['outputs.PipelineIngestionDefinitionSourceConfiguration']]:
        return pulumi.get(self, "source_configurations")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional['outputs.PipelineIngestionDefinitionTableConfiguration']:
        return pulumi.get(self, "table_configuration")


@pulumi.output_type
class PipelineIngestionDefinitionObject(dict):
    def __init__(__self__, *,
                 report: Optional['outputs.PipelineIngestionDefinitionObjectReport'] = None,
                 schema: Optional['outputs.PipelineIngestionDefinitionObjectSchema'] = None,
                 table: Optional['outputs.PipelineIngestionDefinitionObjectTable'] = None):
        """
        :param 'PipelineIngestionDefinitionObjectSchemaArgs' schema: The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
        """
        if report is not None:
            pulumi.set(__self__, "report", report)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @_builtins.property
    @pulumi.getter
    def report(self) -> Optional['outputs.PipelineIngestionDefinitionObjectReport']:
        return pulumi.get(self, "report")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional['outputs.PipelineIngestionDefinitionObjectSchema']:
        """
        The default schema (database) where tables are read from or published to. The presence of this attribute implies that the pipeline is in direct publishing mode.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def table(self) -> Optional['outputs.PipelineIngestionDefinitionObjectTable']:
        return pulumi.get(self, "table")


@pulumi.output_type
class PipelineIngestionDefinitionObjectReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCatalog":
            suggest = "destination_catalog"
        elif key == "destinationSchema":
            suggest = "destination_schema"
        elif key == "sourceUrl":
            suggest = "source_url"
        elif key == "destinationTable":
            suggest = "destination_table"
        elif key == "tableConfiguration":
            suggest = "table_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_catalog: _builtins.str,
                 destination_schema: _builtins.str,
                 source_url: _builtins.str,
                 destination_table: Optional[_builtins.str] = None,
                 table_configuration: Optional['outputs.PipelineIngestionDefinitionObjectReportTableConfiguration'] = None):
        pulumi.set(__self__, "destination_catalog", destination_catalog)
        pulumi.set(__self__, "destination_schema", destination_schema)
        pulumi.set(__self__, "source_url", source_url)
        if destination_table is not None:
            pulumi.set(__self__, "destination_table", destination_table)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @_builtins.property
    @pulumi.getter(name="destinationCatalog")
    def destination_catalog(self) -> _builtins.str:
        return pulumi.get(self, "destination_catalog")

    @_builtins.property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> _builtins.str:
        return pulumi.get(self, "destination_schema")

    @_builtins.property
    @pulumi.getter(name="sourceUrl")
    def source_url(self) -> _builtins.str:
        return pulumi.get(self, "source_url")

    @_builtins.property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_table")

    @_builtins.property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional['outputs.PipelineIngestionDefinitionObjectReportTableConfiguration']:
        return pulumi.get(self, "table_configuration")


@pulumi.output_type
class PipelineIngestionDefinitionObjectReportTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"
        elif key == "primaryKeys":
            suggest = "primary_keys"
        elif key == "queryBasedConnectorConfig":
            suggest = "query_based_connector_config"
        elif key == "salesforceIncludeFormulaFields":
            suggest = "salesforce_include_formula_fields"
        elif key == "scdType":
            suggest = "scd_type"
        elif key == "sequenceBies":
            suggest = "sequence_bies"
        elif key == "workdayReportParameters":
            suggest = "workday_report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectReportTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectReportTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectReportTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None,
                 primary_keys: Optional[Sequence[_builtins.str]] = None,
                 query_based_connector_config: Optional['outputs.PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig'] = None,
                 salesforce_include_formula_fields: Optional[_builtins.bool] = None,
                 scd_type: Optional[_builtins.str] = None,
                 sequence_bies: Optional[Sequence[_builtins.str]] = None,
                 workday_report_parameters: Optional['outputs.PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters'] = None):
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if query_based_connector_config is not None:
            pulumi.set(__self__, "query_based_connector_config", query_based_connector_config)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)
        if workday_report_parameters is not None:
            pulumi.set(__self__, "workday_report_parameters", workday_report_parameters)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_columns")

    @_builtins.property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "primary_keys")

    @_builtins.property
    @pulumi.getter(name="queryBasedConnectorConfig")
    def query_based_connector_config(self) -> Optional['outputs.PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig']:
        return pulumi.get(self, "query_based_connector_config")

    @_builtins.property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @_builtins.property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scd_type")

    @_builtins.property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sequence_bies")

    @_builtins.property
    @pulumi.getter(name="workdayReportParameters")
    def workday_report_parameters(self) -> Optional['outputs.PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters']:
        return pulumi.get(self, "workday_report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cursorColumns":
            suggest = "cursor_columns"
        elif key == "deletionCondition":
            suggest = "deletion_condition"
        elif key == "hardDeletionSyncMinIntervalInSeconds":
            suggest = "hard_deletion_sync_min_interval_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectReportTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cursor_columns: Optional[Sequence[_builtins.str]] = None,
                 deletion_condition: Optional[_builtins.str] = None,
                 hard_deletion_sync_min_interval_in_seconds: Optional[_builtins.int] = None):
        if cursor_columns is not None:
            pulumi.set(__self__, "cursor_columns", cursor_columns)
        if deletion_condition is not None:
            pulumi.set(__self__, "deletion_condition", deletion_condition)
        if hard_deletion_sync_min_interval_in_seconds is not None:
            pulumi.set(__self__, "hard_deletion_sync_min_interval_in_seconds", hard_deletion_sync_min_interval_in_seconds)

    @_builtins.property
    @pulumi.getter(name="cursorColumns")
    def cursor_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cursor_columns")

    @_builtins.property
    @pulumi.getter(name="deletionCondition")
    def deletion_condition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deletion_condition")

    @_builtins.property
    @pulumi.getter(name="hardDeletionSyncMinIntervalInSeconds")
    def hard_deletion_sync_min_interval_in_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hard_deletion_sync_min_interval_in_seconds")


@pulumi.output_type
class PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportParameters":
            suggest = "report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incremental: Optional[_builtins.bool] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 report_parameters: Optional[Sequence['outputs.PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParametersReportParameter']] = None):
        if incremental is not None:
            pulumi.set(__self__, "incremental", incremental)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if report_parameters is not None:
            pulumi.set(__self__, "report_parameters", report_parameters)

    @_builtins.property
    @pulumi.getter
    def incremental(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "incremental")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="reportParameters")
    def report_parameters(self) -> Optional[Sequence['outputs.PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParametersReportParameter']]:
        return pulumi.get(self, "report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionObjectReportTableConfigurationWorkdayReportParametersReportParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class PipelineIngestionDefinitionObjectSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCatalog":
            suggest = "destination_catalog"
        elif key == "destinationSchema":
            suggest = "destination_schema"
        elif key == "sourceSchema":
            suggest = "source_schema"
        elif key == "sourceCatalog":
            suggest = "source_catalog"
        elif key == "tableConfiguration":
            suggest = "table_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_catalog: _builtins.str,
                 destination_schema: _builtins.str,
                 source_schema: _builtins.str,
                 source_catalog: Optional[_builtins.str] = None,
                 table_configuration: Optional['outputs.PipelineIngestionDefinitionObjectSchemaTableConfiguration'] = None):
        pulumi.set(__self__, "destination_catalog", destination_catalog)
        pulumi.set(__self__, "destination_schema", destination_schema)
        pulumi.set(__self__, "source_schema", source_schema)
        if source_catalog is not None:
            pulumi.set(__self__, "source_catalog", source_catalog)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @_builtins.property
    @pulumi.getter(name="destinationCatalog")
    def destination_catalog(self) -> _builtins.str:
        return pulumi.get(self, "destination_catalog")

    @_builtins.property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> _builtins.str:
        return pulumi.get(self, "destination_schema")

    @_builtins.property
    @pulumi.getter(name="sourceSchema")
    def source_schema(self) -> _builtins.str:
        return pulumi.get(self, "source_schema")

    @_builtins.property
    @pulumi.getter(name="sourceCatalog")
    def source_catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_catalog")

    @_builtins.property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional['outputs.PipelineIngestionDefinitionObjectSchemaTableConfiguration']:
        return pulumi.get(self, "table_configuration")


@pulumi.output_type
class PipelineIngestionDefinitionObjectSchemaTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"
        elif key == "primaryKeys":
            suggest = "primary_keys"
        elif key == "queryBasedConnectorConfig":
            suggest = "query_based_connector_config"
        elif key == "salesforceIncludeFormulaFields":
            suggest = "salesforce_include_formula_fields"
        elif key == "scdType":
            suggest = "scd_type"
        elif key == "sequenceBies":
            suggest = "sequence_bies"
        elif key == "workdayReportParameters":
            suggest = "workday_report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectSchemaTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectSchemaTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectSchemaTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None,
                 primary_keys: Optional[Sequence[_builtins.str]] = None,
                 query_based_connector_config: Optional['outputs.PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig'] = None,
                 salesforce_include_formula_fields: Optional[_builtins.bool] = None,
                 scd_type: Optional[_builtins.str] = None,
                 sequence_bies: Optional[Sequence[_builtins.str]] = None,
                 workday_report_parameters: Optional['outputs.PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters'] = None):
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if query_based_connector_config is not None:
            pulumi.set(__self__, "query_based_connector_config", query_based_connector_config)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)
        if workday_report_parameters is not None:
            pulumi.set(__self__, "workday_report_parameters", workday_report_parameters)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_columns")

    @_builtins.property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "primary_keys")

    @_builtins.property
    @pulumi.getter(name="queryBasedConnectorConfig")
    def query_based_connector_config(self) -> Optional['outputs.PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig']:
        return pulumi.get(self, "query_based_connector_config")

    @_builtins.property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @_builtins.property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scd_type")

    @_builtins.property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sequence_bies")

    @_builtins.property
    @pulumi.getter(name="workdayReportParameters")
    def workday_report_parameters(self) -> Optional['outputs.PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters']:
        return pulumi.get(self, "workday_report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cursorColumns":
            suggest = "cursor_columns"
        elif key == "deletionCondition":
            suggest = "deletion_condition"
        elif key == "hardDeletionSyncMinIntervalInSeconds":
            suggest = "hard_deletion_sync_min_interval_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectSchemaTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cursor_columns: Optional[Sequence[_builtins.str]] = None,
                 deletion_condition: Optional[_builtins.str] = None,
                 hard_deletion_sync_min_interval_in_seconds: Optional[_builtins.int] = None):
        if cursor_columns is not None:
            pulumi.set(__self__, "cursor_columns", cursor_columns)
        if deletion_condition is not None:
            pulumi.set(__self__, "deletion_condition", deletion_condition)
        if hard_deletion_sync_min_interval_in_seconds is not None:
            pulumi.set(__self__, "hard_deletion_sync_min_interval_in_seconds", hard_deletion_sync_min_interval_in_seconds)

    @_builtins.property
    @pulumi.getter(name="cursorColumns")
    def cursor_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cursor_columns")

    @_builtins.property
    @pulumi.getter(name="deletionCondition")
    def deletion_condition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deletion_condition")

    @_builtins.property
    @pulumi.getter(name="hardDeletionSyncMinIntervalInSeconds")
    def hard_deletion_sync_min_interval_in_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hard_deletion_sync_min_interval_in_seconds")


@pulumi.output_type
class PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportParameters":
            suggest = "report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incremental: Optional[_builtins.bool] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 report_parameters: Optional[Sequence['outputs.PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParametersReportParameter']] = None):
        if incremental is not None:
            pulumi.set(__self__, "incremental", incremental)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if report_parameters is not None:
            pulumi.set(__self__, "report_parameters", report_parameters)

    @_builtins.property
    @pulumi.getter
    def incremental(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "incremental")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="reportParameters")
    def report_parameters(self) -> Optional[Sequence['outputs.PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParametersReportParameter']]:
        return pulumi.get(self, "report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionObjectSchemaTableConfigurationWorkdayReportParametersReportParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class PipelineIngestionDefinitionObjectTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCatalog":
            suggest = "destination_catalog"
        elif key == "destinationSchema":
            suggest = "destination_schema"
        elif key == "sourceTable":
            suggest = "source_table"
        elif key == "destinationTable":
            suggest = "destination_table"
        elif key == "sourceCatalog":
            suggest = "source_catalog"
        elif key == "sourceSchema":
            suggest = "source_schema"
        elif key == "tableConfiguration":
            suggest = "table_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_catalog: _builtins.str,
                 destination_schema: _builtins.str,
                 source_table: _builtins.str,
                 destination_table: Optional[_builtins.str] = None,
                 source_catalog: Optional[_builtins.str] = None,
                 source_schema: Optional[_builtins.str] = None,
                 table_configuration: Optional['outputs.PipelineIngestionDefinitionObjectTableTableConfiguration'] = None):
        pulumi.set(__self__, "destination_catalog", destination_catalog)
        pulumi.set(__self__, "destination_schema", destination_schema)
        pulumi.set(__self__, "source_table", source_table)
        if destination_table is not None:
            pulumi.set(__self__, "destination_table", destination_table)
        if source_catalog is not None:
            pulumi.set(__self__, "source_catalog", source_catalog)
        if source_schema is not None:
            pulumi.set(__self__, "source_schema", source_schema)
        if table_configuration is not None:
            pulumi.set(__self__, "table_configuration", table_configuration)

    @_builtins.property
    @pulumi.getter(name="destinationCatalog")
    def destination_catalog(self) -> _builtins.str:
        return pulumi.get(self, "destination_catalog")

    @_builtins.property
    @pulumi.getter(name="destinationSchema")
    def destination_schema(self) -> _builtins.str:
        return pulumi.get(self, "destination_schema")

    @_builtins.property
    @pulumi.getter(name="sourceTable")
    def source_table(self) -> _builtins.str:
        return pulumi.get(self, "source_table")

    @_builtins.property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_table")

    @_builtins.property
    @pulumi.getter(name="sourceCatalog")
    def source_catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_catalog")

    @_builtins.property
    @pulumi.getter(name="sourceSchema")
    def source_schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_schema")

    @_builtins.property
    @pulumi.getter(name="tableConfiguration")
    def table_configuration(self) -> Optional['outputs.PipelineIngestionDefinitionObjectTableTableConfiguration']:
        return pulumi.get(self, "table_configuration")


@pulumi.output_type
class PipelineIngestionDefinitionObjectTableTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"
        elif key == "primaryKeys":
            suggest = "primary_keys"
        elif key == "queryBasedConnectorConfig":
            suggest = "query_based_connector_config"
        elif key == "salesforceIncludeFormulaFields":
            suggest = "salesforce_include_formula_fields"
        elif key == "scdType":
            suggest = "scd_type"
        elif key == "sequenceBies":
            suggest = "sequence_bies"
        elif key == "workdayReportParameters":
            suggest = "workday_report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectTableTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectTableTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectTableTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None,
                 primary_keys: Optional[Sequence[_builtins.str]] = None,
                 query_based_connector_config: Optional['outputs.PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig'] = None,
                 salesforce_include_formula_fields: Optional[_builtins.bool] = None,
                 scd_type: Optional[_builtins.str] = None,
                 sequence_bies: Optional[Sequence[_builtins.str]] = None,
                 workday_report_parameters: Optional['outputs.PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters'] = None):
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if query_based_connector_config is not None:
            pulumi.set(__self__, "query_based_connector_config", query_based_connector_config)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)
        if workday_report_parameters is not None:
            pulumi.set(__self__, "workday_report_parameters", workday_report_parameters)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_columns")

    @_builtins.property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "primary_keys")

    @_builtins.property
    @pulumi.getter(name="queryBasedConnectorConfig")
    def query_based_connector_config(self) -> Optional['outputs.PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig']:
        return pulumi.get(self, "query_based_connector_config")

    @_builtins.property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @_builtins.property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scd_type")

    @_builtins.property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sequence_bies")

    @_builtins.property
    @pulumi.getter(name="workdayReportParameters")
    def workday_report_parameters(self) -> Optional['outputs.PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters']:
        return pulumi.get(self, "workday_report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cursorColumns":
            suggest = "cursor_columns"
        elif key == "deletionCondition":
            suggest = "deletion_condition"
        elif key == "hardDeletionSyncMinIntervalInSeconds":
            suggest = "hard_deletion_sync_min_interval_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectTableTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cursor_columns: Optional[Sequence[_builtins.str]] = None,
                 deletion_condition: Optional[_builtins.str] = None,
                 hard_deletion_sync_min_interval_in_seconds: Optional[_builtins.int] = None):
        if cursor_columns is not None:
            pulumi.set(__self__, "cursor_columns", cursor_columns)
        if deletion_condition is not None:
            pulumi.set(__self__, "deletion_condition", deletion_condition)
        if hard_deletion_sync_min_interval_in_seconds is not None:
            pulumi.set(__self__, "hard_deletion_sync_min_interval_in_seconds", hard_deletion_sync_min_interval_in_seconds)

    @_builtins.property
    @pulumi.getter(name="cursorColumns")
    def cursor_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cursor_columns")

    @_builtins.property
    @pulumi.getter(name="deletionCondition")
    def deletion_condition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deletion_condition")

    @_builtins.property
    @pulumi.getter(name="hardDeletionSyncMinIntervalInSeconds")
    def hard_deletion_sync_min_interval_in_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hard_deletion_sync_min_interval_in_seconds")


@pulumi.output_type
class PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportParameters":
            suggest = "report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incremental: Optional[_builtins.bool] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 report_parameters: Optional[Sequence['outputs.PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParametersReportParameter']] = None):
        if incremental is not None:
            pulumi.set(__self__, "incremental", incremental)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if report_parameters is not None:
            pulumi.set(__self__, "report_parameters", report_parameters)

    @_builtins.property
    @pulumi.getter
    def incremental(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "incremental")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="reportParameters")
    def report_parameters(self) -> Optional[Sequence['outputs.PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParametersReportParameter']]:
        return pulumi.get(self, "report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionObjectTableTableConfigurationWorkdayReportParametersReportParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class PipelineIngestionDefinitionSourceConfiguration(dict):
    def __init__(__self__, *,
                 catalog: Optional['outputs.PipelineIngestionDefinitionSourceConfigurationCatalog'] = None):
        """
        :param 'PipelineIngestionDefinitionSourceConfigurationCatalogArgs' catalog: The name of catalog in Unity Catalog. *Change of this parameter forces recreation of the pipeline.* (Conflicts with `storage`).
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional['outputs.PipelineIngestionDefinitionSourceConfigurationCatalog']:
        """
        The name of catalog in Unity Catalog. *Change of this parameter forces recreation of the pipeline.* (Conflicts with `storage`).
        """
        return pulumi.get(self, "catalog")


@pulumi.output_type
class PipelineIngestionDefinitionSourceConfigurationCatalog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCatalog":
            suggest = "source_catalog"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionSourceConfigurationCatalog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionSourceConfigurationCatalog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionSourceConfigurationCatalog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 postgres: Optional['outputs.PipelineIngestionDefinitionSourceConfigurationCatalogPostgres'] = None,
                 source_catalog: Optional[_builtins.str] = None):
        if postgres is not None:
            pulumi.set(__self__, "postgres", postgres)
        if source_catalog is not None:
            pulumi.set(__self__, "source_catalog", source_catalog)

    @_builtins.property
    @pulumi.getter
    def postgres(self) -> Optional['outputs.PipelineIngestionDefinitionSourceConfigurationCatalogPostgres']:
        return pulumi.get(self, "postgres")

    @_builtins.property
    @pulumi.getter(name="sourceCatalog")
    def source_catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_catalog")


@pulumi.output_type
class PipelineIngestionDefinitionSourceConfigurationCatalogPostgres(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slotConfig":
            suggest = "slot_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionSourceConfigurationCatalogPostgres. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionSourceConfigurationCatalogPostgres.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionSourceConfigurationCatalogPostgres.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slot_config: Optional['outputs.PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig'] = None):
        if slot_config is not None:
            pulumi.set(__self__, "slot_config", slot_config)

    @_builtins.property
    @pulumi.getter(name="slotConfig")
    def slot_config(self) -> Optional['outputs.PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig']:
        return pulumi.get(self, "slot_config")


@pulumi.output_type
class PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicationName":
            suggest = "publication_name"
        elif key == "slotName":
            suggest = "slot_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionSourceConfigurationCatalogPostgresSlotConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publication_name: Optional[_builtins.str] = None,
                 slot_name: Optional[_builtins.str] = None):
        if publication_name is not None:
            pulumi.set(__self__, "publication_name", publication_name)
        if slot_name is not None:
            pulumi.set(__self__, "slot_name", slot_name)

    @_builtins.property
    @pulumi.getter(name="publicationName")
    def publication_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "publication_name")

    @_builtins.property
    @pulumi.getter(name="slotName")
    def slot_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "slot_name")


@pulumi.output_type
class PipelineIngestionDefinitionTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeColumns":
            suggest = "exclude_columns"
        elif key == "includeColumns":
            suggest = "include_columns"
        elif key == "primaryKeys":
            suggest = "primary_keys"
        elif key == "queryBasedConnectorConfig":
            suggest = "query_based_connector_config"
        elif key == "salesforceIncludeFormulaFields":
            suggest = "salesforce_include_formula_fields"
        elif key == "scdType":
            suggest = "scd_type"
        elif key == "sequenceBies":
            suggest = "sequence_bies"
        elif key == "workdayReportParameters":
            suggest = "workday_report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_columns: Optional[Sequence[_builtins.str]] = None,
                 include_columns: Optional[Sequence[_builtins.str]] = None,
                 primary_keys: Optional[Sequence[_builtins.str]] = None,
                 query_based_connector_config: Optional['outputs.PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig'] = None,
                 salesforce_include_formula_fields: Optional[_builtins.bool] = None,
                 scd_type: Optional[_builtins.str] = None,
                 sequence_bies: Optional[Sequence[_builtins.str]] = None,
                 workday_report_parameters: Optional['outputs.PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters'] = None):
        if exclude_columns is not None:
            pulumi.set(__self__, "exclude_columns", exclude_columns)
        if include_columns is not None:
            pulumi.set(__self__, "include_columns", include_columns)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if query_based_connector_config is not None:
            pulumi.set(__self__, "query_based_connector_config", query_based_connector_config)
        if salesforce_include_formula_fields is not None:
            pulumi.set(__self__, "salesforce_include_formula_fields", salesforce_include_formula_fields)
        if scd_type is not None:
            pulumi.set(__self__, "scd_type", scd_type)
        if sequence_bies is not None:
            pulumi.set(__self__, "sequence_bies", sequence_bies)
        if workday_report_parameters is not None:
            pulumi.set(__self__, "workday_report_parameters", workday_report_parameters)

    @_builtins.property
    @pulumi.getter(name="excludeColumns")
    def exclude_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_columns")

    @_builtins.property
    @pulumi.getter(name="includeColumns")
    def include_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_columns")

    @_builtins.property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "primary_keys")

    @_builtins.property
    @pulumi.getter(name="queryBasedConnectorConfig")
    def query_based_connector_config(self) -> Optional['outputs.PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig']:
        return pulumi.get(self, "query_based_connector_config")

    @_builtins.property
    @pulumi.getter(name="salesforceIncludeFormulaFields")
    def salesforce_include_formula_fields(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "salesforce_include_formula_fields")

    @_builtins.property
    @pulumi.getter(name="scdType")
    def scd_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scd_type")

    @_builtins.property
    @pulumi.getter(name="sequenceBies")
    def sequence_bies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sequence_bies")

    @_builtins.property
    @pulumi.getter(name="workdayReportParameters")
    def workday_report_parameters(self) -> Optional['outputs.PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters']:
        return pulumi.get(self, "workday_report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cursorColumns":
            suggest = "cursor_columns"
        elif key == "deletionCondition":
            suggest = "deletion_condition"
        elif key == "hardDeletionSyncMinIntervalInSeconds":
            suggest = "hard_deletion_sync_min_interval_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionTableConfigurationQueryBasedConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cursor_columns: Optional[Sequence[_builtins.str]] = None,
                 deletion_condition: Optional[_builtins.str] = None,
                 hard_deletion_sync_min_interval_in_seconds: Optional[_builtins.int] = None):
        if cursor_columns is not None:
            pulumi.set(__self__, "cursor_columns", cursor_columns)
        if deletion_condition is not None:
            pulumi.set(__self__, "deletion_condition", deletion_condition)
        if hard_deletion_sync_min_interval_in_seconds is not None:
            pulumi.set(__self__, "hard_deletion_sync_min_interval_in_seconds", hard_deletion_sync_min_interval_in_seconds)

    @_builtins.property
    @pulumi.getter(name="cursorColumns")
    def cursor_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "cursor_columns")

    @_builtins.property
    @pulumi.getter(name="deletionCondition")
    def deletion_condition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deletion_condition")

    @_builtins.property
    @pulumi.getter(name="hardDeletionSyncMinIntervalInSeconds")
    def hard_deletion_sync_min_interval_in_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hard_deletion_sync_min_interval_in_seconds")


@pulumi.output_type
class PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportParameters":
            suggest = "report_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineIngestionDefinitionTableConfigurationWorkdayReportParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incremental: Optional[_builtins.bool] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 report_parameters: Optional[Sequence['outputs.PipelineIngestionDefinitionTableConfigurationWorkdayReportParametersReportParameter']] = None):
        if incremental is not None:
            pulumi.set(__self__, "incremental", incremental)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if report_parameters is not None:
            pulumi.set(__self__, "report_parameters", report_parameters)

    @_builtins.property
    @pulumi.getter
    def incremental(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "incremental")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="reportParameters")
    def report_parameters(self) -> Optional[Sequence['outputs.PipelineIngestionDefinitionTableConfigurationWorkdayReportParametersReportParameter']]:
        return pulumi.get(self, "report_parameters")


@pulumi.output_type
class PipelineIngestionDefinitionTableConfigurationWorkdayReportParametersReportParameter(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class PipelineLatestUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationTime":
            suggest = "creation_time"
        elif key == "updateId":
            suggest = "update_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineLatestUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineLatestUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineLatestUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_time: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 update_id: Optional[_builtins.str] = None):
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if update_id is not None:
            pulumi.set(__self__, "update_id", update_id)

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="updateId")
    def update_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "update_id")


@pulumi.output_type
class PipelineLibrary(dict):
    def __init__(__self__, *,
                 file: Optional['outputs.PipelineLibraryFile'] = None,
                 glob: Optional['outputs.PipelineLibraryGlob'] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.PipelineLibraryMaven'] = None,
                 notebook: Optional['outputs.PipelineLibraryNotebook'] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'PipelineLibraryFileArgs' file: specifies path to a file in Databricks Workspace to include as source. Actual path is specified as `path` attribute inside the block.
        :param 'PipelineLibraryGlobArgs' glob: The unified field to include source code. Each entry should have the `include` attribute that can specify a notebook path, a file path, or a folder path that ends `/**` (to include everything from that folder). This field cannot be used together with `notebook` or `file`.
        :param 'PipelineLibraryNotebookArgs' notebook: specifies path to a Databricks Notebook to include as source. Actual path is specified as `path` attribute inside the block.
        """
        if file is not None:
            pulumi.set(__self__, "file", file)
        if glob is not None:
            pulumi.set(__self__, "glob", glob)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if notebook is not None:
            pulumi.set(__self__, "notebook", notebook)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.PipelineLibraryFile']:
        """
        specifies path to a file in Databricks Workspace to include as source. Actual path is specified as `path` attribute inside the block.
        """
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def glob(self) -> Optional['outputs.PipelineLibraryGlob']:
        """
        The unified field to include source code. Each entry should have the `include` attribute that can specify a notebook path, a file path, or a folder path that ends `/**` (to include everything from that folder). This field cannot be used together with `notebook` or `file`.
        """
        return pulumi.get(self, "glob")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.PipelineLibraryMaven']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter
    def notebook(self) -> Optional['outputs.PipelineLibraryNotebook']:
        """
        specifies path to a Databricks Notebook to include as source. Actual path is specified as `path` attribute inside the block.
        """
        return pulumi.get(self, "notebook")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'whl' field is deprecated""")
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class PipelineLibraryFile(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")


@pulumi.output_type
class PipelineLibraryGlob(dict):
    def __init__(__self__, *,
                 include: _builtins.str):
        """
        :param _builtins.str include: Paths to include.
        """
        pulumi.set(__self__, "include", include)

    @_builtins.property
    @pulumi.getter
    def include(self) -> _builtins.str:
        """
        Paths to include.
        """
        return pulumi.get(self, "include")


@pulumi.output_type
class PipelineLibraryMaven(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class PipelineLibraryNotebook(dict):
    def __init__(__self__, *,
                 path: _builtins.str):
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")


@pulumi.output_type
class PipelineNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailRecipients":
            suggest = "email_recipients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alerts: Optional[Sequence[_builtins.str]] = None,
                 email_recipients: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] alerts: non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
               * `on-update-success` - a pipeline update completes successfully.
               * `on-update-failure` - a pipeline update fails with a retryable error.
               * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
               * `on-flow-failure` - a single data flow fails.
        :param Sequence[_builtins.str] email_recipients: non-empty list of emails to notify.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if email_recipients is not None:
            pulumi.set(__self__, "email_recipients", email_recipients)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence[_builtins.str]]:
        """
        non-empty list of alert types. Right now following alert types are supported, consult documentation for actual list
        * `on-update-success` - a pipeline update completes successfully.
        * `on-update-failure` - a pipeline update fails with a retryable error.
        * `on-update-fatal-failure` - a pipeline update fails with a non-retryable (fatal) error.
        * `on-flow-failure` - a single data flow fails.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter(name="emailRecipients")
    def email_recipients(self) -> Optional[Sequence[_builtins.str]]:
        """
        non-empty list of emails to notify.
        """
        return pulumi.get(self, "email_recipients")


@pulumi.output_type
class PipelineRestartWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startHour":
            suggest = "start_hour"
        elif key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "timeZoneId":
            suggest = "time_zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineRestartWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineRestartWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineRestartWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_hour: _builtins.int,
                 days_of_weeks: Optional[Sequence[_builtins.str]] = None,
                 time_zone_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "start_hour", start_hour)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if time_zone_id is not None:
            pulumi.set(__self__, "time_zone_id", time_zone_id)

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> _builtins.int:
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="timeZoneId")
    def time_zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "time_zone_id")


@pulumi.output_type
class PipelineRunAs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "servicePrincipalName":
            suggest = "service_principal_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineRunAs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineRunAs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineRunAs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class PipelineTrigger(dict):
    def __init__(__self__, *,
                 cron: Optional['outputs.PipelineTriggerCron'] = None,
                 manual: Optional['outputs.PipelineTriggerManual'] = None):
        if cron is not None:
            pulumi.set(__self__, "cron", cron)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @_builtins.property
    @pulumi.getter
    def cron(self) -> Optional['outputs.PipelineTriggerCron']:
        return pulumi.get(self, "cron")

    @_builtins.property
    @pulumi.getter
    def manual(self) -> Optional['outputs.PipelineTriggerManual']:
        return pulumi.get(self, "manual")


@pulumi.output_type
class PipelineTriggerCron(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronSchedule":
            suggest = "quartz_cron_schedule"
        elif key == "timezoneId":
            suggest = "timezone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineTriggerCron. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineTriggerCron.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineTriggerCron.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_schedule: Optional[_builtins.str] = None,
                 timezone_id: Optional[_builtins.str] = None):
        if quartz_cron_schedule is not None:
            pulumi.set(__self__, "quartz_cron_schedule", quartz_cron_schedule)
        if timezone_id is not None:
            pulumi.set(__self__, "timezone_id", timezone_id)

    @_builtins.property
    @pulumi.getter(name="quartzCronSchedule")
    def quartz_cron_schedule(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "quartz_cron_schedule")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "timezone_id")


@pulumi.output_type
class PipelineTriggerManual(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class PolicyInfoColumnMask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionName":
            suggest = "function_name"
        elif key == "onColumn":
            suggest = "on_column"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyInfoColumnMask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyInfoColumnMask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyInfoColumnMask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_name: _builtins.str,
                 on_column: _builtins.str,
                 usings: Optional[Sequence['outputs.PolicyInfoColumnMaskUsing']] = None):
        """
        :param _builtins.str on_column: The alias of the column to be masked. The alias must refer to one of matched columns.
               The values of the column is passed to the column mask function as the first argument.
               Required on create and update
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "on_column", on_column)
        if usings is not None:
            pulumi.set(__self__, "usings", usings)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="onColumn")
    def on_column(self) -> _builtins.str:
        """
        The alias of the column to be masked. The alias must refer to one of matched columns.
        The values of the column is passed to the column mask function as the first argument.
        Required on create and update
        """
        return pulumi.get(self, "on_column")

    @_builtins.property
    @pulumi.getter
    def usings(self) -> Optional[Sequence['outputs.PolicyInfoColumnMaskUsing']]:
        return pulumi.get(self, "usings")


@pulumi.output_type
class PolicyInfoColumnMaskUsing(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 constant: Optional[_builtins.str] = None):
        """
        :param _builtins.str constant: A constant literal
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if constant is not None:
            pulumi.set(__self__, "constant", constant)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def constant(self) -> Optional[_builtins.str]:
        """
        A constant literal
        """
        return pulumi.get(self, "constant")


@pulumi.output_type
class PolicyInfoMatchColumn(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 condition: Optional[_builtins.str] = None):
        """
        :param _builtins.str condition: The condition expression used to match a table column
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        The condition expression used to match a table column
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class PolicyInfoRowFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionName":
            suggest = "function_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyInfoRowFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyInfoRowFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyInfoRowFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_name: _builtins.str,
                 usings: Optional[Sequence['outputs.PolicyInfoRowFilterUsing']] = None):
        pulumi.set(__self__, "function_name", function_name)
        if usings is not None:
            pulumi.set(__self__, "usings", usings)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter
    def usings(self) -> Optional[Sequence['outputs.PolicyInfoRowFilterUsing']]:
        return pulumi.get(self, "usings")


@pulumi.output_type
class PolicyInfoRowFilterUsing(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 constant: Optional[_builtins.str] = None):
        """
        :param _builtins.str constant: A constant literal
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if constant is not None:
            pulumi.set(__self__, "constant", constant)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def constant(self) -> Optional[_builtins.str]:
        """
        A constant literal
        """
        return pulumi.get(self, "constant")


@pulumi.output_type
class QualityMonitorCustomMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputColumns":
            suggest = "input_columns"
        elif key == "outputDataType":
            suggest = "output_data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorCustomMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorCustomMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorCustomMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: _builtins.str,
                 input_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 output_data_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str definition: [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param Sequence[_builtins.str] input_columns: Columns on the monitored table to apply the custom metrics to.
        :param _builtins.str name: Name of the custom metric.
        :param _builtins.str output_data_type: The output type of the custom metric.
        :param _builtins.str type: The type of the custom metric.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence[_builtins.str]:
        """
        Columns on the monitored table to apply the custom metrics to.
        """
        return pulumi.get(self, "input_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the custom metric.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> _builtins.str:
        """
        The output type of the custom metric.
        """
        return pulumi.get(self, "output_data_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the custom metric.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class QualityMonitorDataClassificationConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to enable data classification
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable data classification
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class QualityMonitorInferenceLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelIdCol":
            suggest = "model_id_col"
        elif key == "predictionCol":
            suggest = "prediction_col"
        elif key == "problemType":
            suggest = "problem_type"
        elif key == "timestampCol":
            suggest = "timestamp_col"
        elif key == "labelCol":
            suggest = "label_col"
        elif key == "predictionProbaCol":
            suggest = "prediction_proba_col"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorInferenceLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorInferenceLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorInferenceLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 model_id_col: _builtins.str,
                 prediction_col: _builtins.str,
                 problem_type: _builtins.str,
                 timestamp_col: _builtins.str,
                 label_col: Optional[_builtins.str] = None,
                 prediction_proba_col: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param _builtins.str model_id_col: Column of the model id or version
        :param _builtins.str prediction_col: Column of the model prediction
        :param _builtins.str problem_type: Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        :param _builtins.str timestamp_col: Column of the timestamp of predictions
        :param _builtins.str label_col: Column of the model label
        :param _builtins.str prediction_proba_col: Column of the model prediction probabilities
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_col", model_id_col)
        pulumi.set(__self__, "prediction_col", prediction_col)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_col", timestamp_col)
        if label_col is not None:
            pulumi.set(__self__, "label_col", label_col)
        if prediction_proba_col is not None:
            pulumi.set(__self__, "prediction_proba_col", prediction_proba_col)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="modelIdCol")
    def model_id_col(self) -> _builtins.str:
        """
        Column of the model id or version
        """
        return pulumi.get(self, "model_id_col")

    @_builtins.property
    @pulumi.getter(name="predictionCol")
    def prediction_col(self) -> _builtins.str:
        """
        Column of the model prediction
        """
        return pulumi.get(self, "prediction_col")

    @_builtins.property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> _builtins.str:
        """
        Problem type the model aims to solve. Either `PROBLEM_TYPE_CLASSIFICATION` or `PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @_builtins.property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> _builtins.str:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")

    @_builtins.property
    @pulumi.getter(name="labelCol")
    def label_col(self) -> Optional[_builtins.str]:
        """
        Column of the model label
        """
        return pulumi.get(self, "label_col")

    @_builtins.property
    @pulumi.getter(name="predictionProbaCol")
    def prediction_proba_col(self) -> Optional[_builtins.str]:
        """
        Column of the model prediction probabilities
        """
        return pulumi.get(self, "prediction_proba_col")


@pulumi.output_type
class QualityMonitorNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onFailure":
            suggest = "on_failure"
        elif key == "onNewClassificationTagDetected":
            suggest = "on_new_classification_tag_detected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_failure: Optional['outputs.QualityMonitorNotificationsOnFailure'] = None,
                 on_new_classification_tag_detected: Optional['outputs.QualityMonitorNotificationsOnNewClassificationTagDetected'] = None):
        """
        :param 'QualityMonitorNotificationsOnFailureArgs' on_failure: who to send notifications to on monitor failure.
        :param 'QualityMonitorNotificationsOnNewClassificationTagDetectedArgs' on_new_classification_tag_detected: Who to send notifications to when new data classification tags are detected.
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)
        if on_new_classification_tag_detected is not None:
            pulumi.set(__self__, "on_new_classification_tag_detected", on_new_classification_tag_detected)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.QualityMonitorNotificationsOnFailure']:
        """
        who to send notifications to on monitor failure.
        """
        return pulumi.get(self, "on_failure")

    @_builtins.property
    @pulumi.getter(name="onNewClassificationTagDetected")
    def on_new_classification_tag_detected(self) -> Optional['outputs.QualityMonitorNotificationsOnNewClassificationTagDetected']:
        """
        Who to send notifications to when new data classification tags are detected.
        """
        return pulumi.get(self, "on_new_classification_tag_detected")


@pulumi.output_type
class QualityMonitorNotificationsOnFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddresses":
            suggest = "email_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorNotificationsOnFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorNotificationsOnFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorNotificationsOnFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class QualityMonitorNotificationsOnNewClassificationTagDetected(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddresses":
            suggest = "email_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorNotificationsOnNewClassificationTagDetected. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorNotificationsOnNewClassificationTagDetected.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorNotificationsOnNewClassificationTagDetected.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class QualityMonitorProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class QualityMonitorSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quartzCronExpression":
            suggest = "quartz_cron_expression"
        elif key == "timezoneId":
            suggest = "timezone_id"
        elif key == "pauseStatus":
            suggest = "pause_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_expression: string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        :param _builtins.str timezone_id: string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        """
        string expression that determines when to run the monitor. See [Quartz documentation](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) for examples.
        """
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        string with timezone id (e.g., `PST`) in which to evaluate the Quartz expression.
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class QualityMonitorSnapshot(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class QualityMonitorTimeSeries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timestampCol":
            suggest = "timestamp_col"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorTimeSeries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorTimeSeries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorTimeSeries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 timestamp_col: _builtins.str):
        """
        :param Sequence[_builtins.str] granularities: List of granularities to use when aggregating data into time windows based on their timestamp.
        :param _builtins.str timestamp_col: Column of the timestamp of predictions
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_col", timestamp_col)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        List of granularities to use when aggregating data into time windows based on their timestamp.
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="timestampCol")
    def timestamp_col(self) -> _builtins.str:
        """
        Column of the timestamp of predictions
        """
        return pulumi.get(self, "timestamp_col")


@pulumi.output_type
class QualityMonitorV2AnomalyDetectionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastRunId":
            suggest = "last_run_id"
        elif key == "latestRunStatus":
            suggest = "latest_run_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QualityMonitorV2AnomalyDetectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QualityMonitorV2AnomalyDetectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QualityMonitorV2AnomalyDetectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_run_id: Optional[_builtins.str] = None,
                 latest_run_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str last_run_id: (string) - Run id of the last run of the workflow
        :param _builtins.str latest_run_status: (string) - The status of the last run of the workflow. Possible values are: `ANOMALY_DETECTION_RUN_STATUS_CANCELED`, `ANOMALY_DETECTION_RUN_STATUS_FAILED`, `ANOMALY_DETECTION_RUN_STATUS_JOB_DELETED`, `ANOMALY_DETECTION_RUN_STATUS_PENDING`, `ANOMALY_DETECTION_RUN_STATUS_RUNNING`, `ANOMALY_DETECTION_RUN_STATUS_SUCCESS`, `ANOMALY_DETECTION_RUN_STATUS_UNKNOWN`, `ANOMALY_DETECTION_RUN_STATUS_WORKSPACE_MISMATCH_ERROR`
        """
        if last_run_id is not None:
            pulumi.set(__self__, "last_run_id", last_run_id)
        if latest_run_status is not None:
            pulumi.set(__self__, "latest_run_status", latest_run_status)

    @_builtins.property
    @pulumi.getter(name="lastRunId")
    def last_run_id(self) -> Optional[_builtins.str]:
        """
        (string) - Run id of the last run of the workflow
        """
        return pulumi.get(self, "last_run_id")

    @_builtins.property
    @pulumi.getter(name="latestRunStatus")
    def latest_run_status(self) -> Optional[_builtins.str]:
        """
        (string) - The status of the last run of the workflow. Possible values are: `ANOMALY_DETECTION_RUN_STATUS_CANCELED`, `ANOMALY_DETECTION_RUN_STATUS_FAILED`, `ANOMALY_DETECTION_RUN_STATUS_JOB_DELETED`, `ANOMALY_DETECTION_RUN_STATUS_PENDING`, `ANOMALY_DETECTION_RUN_STATUS_RUNNING`, `ANOMALY_DETECTION_RUN_STATUS_SUCCESS`, `ANOMALY_DETECTION_RUN_STATUS_UNKNOWN`, `ANOMALY_DETECTION_RUN_STATUS_WORKSPACE_MISMATCH_ERROR`
        """
        return pulumi.get(self, "latest_run_status")


@pulumi.output_type
class QueryParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRangeValue":
            suggest = "date_range_value"
        elif key == "dateValue":
            suggest = "date_value"
        elif key == "enumValue":
            suggest = "enum_value"
        elif key == "numericValue":
            suggest = "numeric_value"
        elif key == "queryBackedValue":
            suggest = "query_backed_value"
        elif key == "textValue":
            suggest = "text_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 date_range_value: Optional['outputs.QueryParameterDateRangeValue'] = None,
                 date_value: Optional['outputs.QueryParameterDateValue'] = None,
                 enum_value: Optional['outputs.QueryParameterEnumValue'] = None,
                 numeric_value: Optional['outputs.QueryParameterNumericValue'] = None,
                 query_backed_value: Optional['outputs.QueryParameterQueryBackedValue'] = None,
                 text_value: Optional['outputs.QueryParameterTextValue'] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Literal parameter marker that appears between double curly braces in the query text.
        :param 'QueryParameterDateRangeValueArgs' date_range_value: Date-range query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_range_value` or `date_range_value`):
        :param 'QueryParameterDateValueArgs' date_value: Date query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_value` or `date_value`):
        :param 'QueryParameterEnumValueArgs' enum_value: Dropdown parameter value. Consists of following attributes:
        :param 'QueryParameterNumericValueArgs' numeric_value: Numeric parameter value. Consists of following attributes:
        :param 'QueryParameterQueryBackedValueArgs' query_backed_value: Query-based dropdown parameter value. Consists of following attributes:
        :param 'QueryParameterTextValueArgs' text_value: Text parameter value. Consists of following attributes:
        :param _builtins.str title: Text displayed in the user-facing parameter widget in the UI.
        """
        pulumi.set(__self__, "name", name)
        if date_range_value is not None:
            pulumi.set(__self__, "date_range_value", date_range_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if enum_value is not None:
            pulumi.set(__self__, "enum_value", enum_value)
        if numeric_value is not None:
            pulumi.set(__self__, "numeric_value", numeric_value)
        if query_backed_value is not None:
            pulumi.set(__self__, "query_backed_value", query_backed_value)
        if text_value is not None:
            pulumi.set(__self__, "text_value", text_value)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Literal parameter marker that appears between double curly braces in the query text.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="dateRangeValue")
    def date_range_value(self) -> Optional['outputs.QueryParameterDateRangeValue']:
        """
        Date-range query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_range_value` or `date_range_value`):
        """
        return pulumi.get(self, "date_range_value")

    @_builtins.property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional['outputs.QueryParameterDateValue']:
        """
        Date query parameter value. Consists of following attributes (Can only specify one of `dynamic_date_value` or `date_value`):
        """
        return pulumi.get(self, "date_value")

    @_builtins.property
    @pulumi.getter(name="enumValue")
    def enum_value(self) -> Optional['outputs.QueryParameterEnumValue']:
        """
        Dropdown parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "enum_value")

    @_builtins.property
    @pulumi.getter(name="numericValue")
    def numeric_value(self) -> Optional['outputs.QueryParameterNumericValue']:
        """
        Numeric parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "numeric_value")

    @_builtins.property
    @pulumi.getter(name="queryBackedValue")
    def query_backed_value(self) -> Optional['outputs.QueryParameterQueryBackedValue']:
        """
        Query-based dropdown parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "query_backed_value")

    @_builtins.property
    @pulumi.getter(name="textValue")
    def text_value(self) -> Optional['outputs.QueryParameterTextValue']:
        """
        Text parameter value. Consists of following attributes:
        """
        return pulumi.get(self, "text_value")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Text displayed in the user-facing parameter widget in the UI.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class QueryParameterDateRangeValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRangeValue":
            suggest = "date_range_value"
        elif key == "dynamicDateRangeValue":
            suggest = "dynamic_date_range_value"
        elif key == "startDayOfWeek":
            suggest = "start_day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryParameterDateRangeValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryParameterDateRangeValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryParameterDateRangeValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_range_value: Optional['outputs.QueryParameterDateRangeValueDateRangeValue'] = None,
                 dynamic_date_range_value: Optional[_builtins.str] = None,
                 precision: Optional[_builtins.str] = None,
                 start_day_of_week: Optional[_builtins.int] = None):
        """
        :param 'QueryParameterDateRangeValueDateRangeValueArgs' date_range_value: Manually specified date-time range value.  Consists of the following attributes:
        :param _builtins.str dynamic_date_range_value: Dynamic date-time range value based on current date-time.  Possible values are `TODAY`, `YESTERDAY`, `THIS_WEEK`, `THIS_MONTH`, `THIS_YEAR`, `LAST_WEEK`, `LAST_MONTH`, `LAST_YEAR`, `LAST_HOUR`, `LAST_8_HOURS`, `LAST_24_HOURS`, `LAST_7_DAYS`, `LAST_14_DAYS`, `LAST_30_DAYS`, `LAST_60_DAYS`, `LAST_90_DAYS`, `LAST_12_MONTHS`.
        :param _builtins.str precision: Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        :param _builtins.int start_day_of_week: Specify what day that starts the week.
        """
        if date_range_value is not None:
            pulumi.set(__self__, "date_range_value", date_range_value)
        if dynamic_date_range_value is not None:
            pulumi.set(__self__, "dynamic_date_range_value", dynamic_date_range_value)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @_builtins.property
    @pulumi.getter(name="dateRangeValue")
    def date_range_value(self) -> Optional['outputs.QueryParameterDateRangeValueDateRangeValue']:
        """
        Manually specified date-time range value.  Consists of the following attributes:
        """
        return pulumi.get(self, "date_range_value")

    @_builtins.property
    @pulumi.getter(name="dynamicDateRangeValue")
    def dynamic_date_range_value(self) -> Optional[_builtins.str]:
        """
        Dynamic date-time range value based on current date-time.  Possible values are `TODAY`, `YESTERDAY`, `THIS_WEEK`, `THIS_MONTH`, `THIS_YEAR`, `LAST_WEEK`, `LAST_MONTH`, `LAST_YEAR`, `LAST_HOUR`, `LAST_8_HOURS`, `LAST_24_HOURS`, `LAST_7_DAYS`, `LAST_14_DAYS`, `LAST_30_DAYS`, `LAST_60_DAYS`, `LAST_90_DAYS`, `LAST_12_MONTHS`.
        """
        return pulumi.get(self, "dynamic_date_range_value")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.str]:
        """
        Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[_builtins.int]:
        """
        Specify what day that starts the week.
        """
        return pulumi.get(self, "start_day_of_week")


@pulumi.output_type
class QueryParameterDateRangeValueDateRangeValue(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        """
        :param _builtins.str end: end of the date range.
        :param _builtins.str start: begin of the date range.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        """
        end of the date range.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        begin of the date range.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class QueryParameterDateValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateValue":
            suggest = "date_value"
        elif key == "dynamicDateValue":
            suggest = "dynamic_date_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryParameterDateValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryParameterDateValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryParameterDateValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_value: Optional[_builtins.str] = None,
                 dynamic_date_value: Optional[_builtins.str] = None,
                 precision: Optional[_builtins.str] = None):
        """
        :param _builtins.str date_value: Manually specified date-time value
        :param _builtins.str dynamic_date_value: Dynamic date-time value based on current date-time.  Possible values are `NOW`, `YESTERDAY`.
        :param _builtins.str precision: Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if dynamic_date_value is not None:
            pulumi.set(__self__, "dynamic_date_value", dynamic_date_value)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)

    @_builtins.property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[_builtins.str]:
        """
        Manually specified date-time value
        """
        return pulumi.get(self, "date_value")

    @_builtins.property
    @pulumi.getter(name="dynamicDateValue")
    def dynamic_date_value(self) -> Optional[_builtins.str]:
        """
        Dynamic date-time value based on current date-time.  Possible values are `NOW`, `YESTERDAY`.
        """
        return pulumi.get(self, "dynamic_date_value")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.str]:
        """
        Date-time precision to format the value into when the query is run.  Possible values are `DAY_PRECISION`, `MINUTE_PRECISION`, `SECOND_PRECISION`.  Defaults to `DAY_PRECISION` (`YYYY-MM-DD`).
        """
        return pulumi.get(self, "precision")


@pulumi.output_type
class QueryParameterEnumValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enumOptions":
            suggest = "enum_options"
        elif key == "multiValuesOptions":
            suggest = "multi_values_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryParameterEnumValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryParameterEnumValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryParameterEnumValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enum_options: Optional[_builtins.str] = None,
                 multi_values_options: Optional['outputs.QueryParameterEnumValueMultiValuesOptions'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str enum_options: List of valid query parameter values, newline delimited.
        :param 'QueryParameterEnumValueMultiValuesOptionsArgs' multi_values_options: If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        :param Sequence[_builtins.str] values: List of selected query parameter values.
        """
        if enum_options is not None:
            pulumi.set(__self__, "enum_options", enum_options)
        if multi_values_options is not None:
            pulumi.set(__self__, "multi_values_options", multi_values_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="enumOptions")
    def enum_options(self) -> Optional[_builtins.str]:
        """
        List of valid query parameter values, newline delimited.
        """
        return pulumi.get(self, "enum_options")

    @_builtins.property
    @pulumi.getter(name="multiValuesOptions")
    def multi_values_options(self) -> Optional['outputs.QueryParameterEnumValueMultiValuesOptions']:
        """
        If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        """
        return pulumi.get(self, "multi_values_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of selected query parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class QueryParameterEnumValueMultiValuesOptions(dict):
    def __init__(__self__, *,
                 prefix: Optional[_builtins.str] = None,
                 separator: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None):
        """
        :param _builtins.str prefix: Character that prefixes each selected parameter value.
        :param _builtins.str separator: Character that separates each selected parameter value. Defaults to a comma.
        :param _builtins.str suffix: Character that suffixes each selected parameter value.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Character that prefixes each selected parameter value.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[_builtins.str]:
        """
        Character that separates each selected parameter value. Defaults to a comma.
        """
        return pulumi.get(self, "separator")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        """
        Character that suffixes each selected parameter value.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class QueryParameterNumericValue(dict):
    def __init__(__self__, *,
                 value: _builtins.float):
        """
        :param _builtins.float value: actual numeric value.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        actual numeric value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class QueryParameterQueryBackedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"
        elif key == "multiValuesOptions":
            suggest = "multi_values_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryParameterQueryBackedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryParameterQueryBackedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryParameterQueryBackedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: _builtins.str,
                 multi_values_options: Optional['outputs.QueryParameterQueryBackedValueMultiValuesOptions'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str query_id: ID of the query that provides the parameter values.
        :param 'QueryParameterQueryBackedValueMultiValuesOptionsArgs' multi_values_options: If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        :param Sequence[_builtins.str] values: List of selected query parameter values.
        """
        pulumi.set(__self__, "query_id", query_id)
        if multi_values_options is not None:
            pulumi.set(__self__, "multi_values_options", multi_values_options)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        """
        ID of the query that provides the parameter values.
        """
        return pulumi.get(self, "query_id")

    @_builtins.property
    @pulumi.getter(name="multiValuesOptions")
    def multi_values_options(self) -> Optional['outputs.QueryParameterQueryBackedValueMultiValuesOptions']:
        """
        If specified, allows multiple values to be selected for this parameter. Consists of following attributes:
        """
        return pulumi.get(self, "multi_values_options")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of selected query parameter values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class QueryParameterQueryBackedValueMultiValuesOptions(dict):
    def __init__(__self__, *,
                 prefix: Optional[_builtins.str] = None,
                 separator: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None):
        """
        :param _builtins.str prefix: Character that prefixes each selected parameter value.
        :param _builtins.str separator: Character that separates each selected parameter value. Defaults to a comma.
        :param _builtins.str suffix: Character that suffixes each selected parameter value.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Character that prefixes each selected parameter value.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def separator(self) -> Optional[_builtins.str]:
        """
        Character that separates each selected parameter value. Defaults to a comma.
        """
        return pulumi.get(self, "separator")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        """
        Character that suffixes each selected parameter value.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class QueryParameterTextValue(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: actual text value.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        actual text value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RecipientIpAccessList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedIpAddresses":
            suggest = "allowed_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipientIpAccessList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipientIpAccessList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipientIpAccessList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_ip_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allowed_ip_addresses: Allowed IP Addresses in CIDR notation. Limit of 100.
        """
        if allowed_ip_addresses is not None:
            pulumi.set(__self__, "allowed_ip_addresses", allowed_ip_addresses)

    @_builtins.property
    @pulumi.getter(name="allowedIpAddresses")
    def allowed_ip_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        Allowed IP Addresses in CIDR notation. Limit of 100.
        """
        return pulumi.get(self, "allowed_ip_addresses")


@pulumi.output_type
class RecipientPropertiesKvpairs(dict):
    def __init__(__self__, *,
                 properties: Mapping[str, _builtins.str]):
        """
        :param Mapping[str, _builtins.str] properties: a map of string key-value pairs with recipient's properties.  Properties with name starting with `databricks.` are reserved.
        """
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        a map of string key-value pairs with recipient's properties.  Properties with name starting with `databricks.` are reserved.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class RecipientToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activationUrl":
            suggest = "activation_url"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "expirationTime":
            suggest = "expiration_time"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "updatedBy":
            suggest = "updated_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecipientToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecipientToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecipientToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activation_url: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 expiration_time: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str activation_url: Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        :param _builtins.int created_at: Time at which this recipient was created, in epoch milliseconds.
        :param _builtins.str created_by: Username of recipient creator.
        :param _builtins.int expiration_time: Expiration timestamp of the token in epoch milliseconds.
        :param _builtins.str id: Unique ID of the recipient token.
        :param _builtins.int updated_at: Time at which this recipient was updated, in epoch milliseconds.
        :param _builtins.str updated_by: Username of recipient Token updater.
        """
        if activation_url is not None:
            pulumi.set(__self__, "activation_url", activation_url)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter(name="activationUrl")
    def activation_url(self) -> Optional[_builtins.str]:
        """
        Full activation URL to retrieve the access token. It will be empty if the token is already retrieved.
        """
        return pulumi.get(self, "activation_url")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        Time at which this recipient was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Username of recipient creator.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[_builtins.int]:
        """
        Expiration timestamp of the token in epoch milliseconds.
        """
        return pulumi.get(self, "expiration_time")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique ID of the recipient token.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        Time at which this recipient was updated, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        Username of recipient Token updater.
        """
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class RegisteredModelAlias(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"
        elif key == "catalogName":
            suggest = "catalog_name"
        elif key == "modelName":
            suggest = "model_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "versionNum":
            suggest = "version_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegisteredModelAlias. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegisteredModelAlias.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegisteredModelAlias.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_name: Optional[_builtins.str] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 version_num: Optional[_builtins.int] = None):
        """
        :param _builtins.str catalog_name: The name of the catalog where the schema and the registered model reside. *Change of this parameter forces recreation of the resource.*
        :param _builtins.str id: Equal to the full name of the model (`catalog_name.schema_name.name`) and used to identify the model uniquely across the metastore.
        :param _builtins.str schema_name: The name of the schema where the registered model resides. *Change of this parameter forces recreation of the resource.*
        """
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if version_num is not None:
            pulumi.set(__self__, "version_num", version_num)

    @_builtins.property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alias_name")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog where the schema and the registered model reside. *Change of this parameter forces recreation of the resource.*
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Equal to the full name of the model (`catalog_name.schema_name.name`) and used to identify the model uniquely across the metastore.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema where the registered model resides. *Change of this parameter forces recreation of the resource.*
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="versionNum")
    def version_num(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "version_num")


@pulumi.output_type
class RepoSparseCheckout(dict):
    def __init__(__self__, *,
                 patterns: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] patterns: array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.
               
               Addition or removal of the `sparse_checkout` configuration block will lead to recreation of the Git folder.
        """
        pulumi.set(__self__, "patterns", patterns)

    @_builtins.property
    @pulumi.getter
    def patterns(self) -> Sequence[_builtins.str]:
        """
        array of paths (directories) that will be used for sparse checkout.  List of patterns could be updated in-place.

        Addition or removal of the `sparse_checkout` configuration block will lead to recreation of the Git folder.
        """
        return pulumi.get(self, "patterns")


@pulumi.output_type
class RestrictWorkspaceAdminsSettingRestrictWorkspaceAdmins(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: The restrict workspace admins status for the workspace.
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The restrict workspace admins status for the workspace.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RfaAccessRequestDestinationsDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationId":
            suggest = "destination_id"
        elif key == "destinationType":
            suggest = "destination_type"
        elif key == "specialDestination":
            suggest = "special_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RfaAccessRequestDestinationsDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RfaAccessRequestDestinationsDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RfaAccessRequestDestinationsDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 destination_type: Optional[_builtins.str] = None,
                 special_destination: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: The identifier for the destination. This is the email address for EMAIL destinations, the URL for URL destinations,
               or the unique Databricks notification destination ID for all other external destinations
        :param _builtins.str destination_type: The type of the destination. Possible values are: `EMAIL`, `GENERIC_WEBHOOK`, `MICROSOFT_TEAMS`, `SLACK`, `URL`
        :param _builtins.str special_destination: This field is used to denote whether the destination is the email of the owner of the securable object.
               The special destination cannot be assigned to a securable and only represents the default destination of the securable.
               The securable types that support default special destinations are: "catalog", "external_location", "connection", "credential", and "metastore".
               The **destination_type** of a **special_destination** is always EMAIL. Possible values are: `SPECIAL_DESTINATION_CATALOG_OWNER`, `SPECIAL_DESTINATION_CONNECTION_OWNER`, `SPECIAL_DESTINATION_CREDENTIAL_OWNER`, `SPECIAL_DESTINATION_EXTERNAL_LOCATION_OWNER`, `SPECIAL_DESTINATION_METASTORE_OWNER`
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if special_destination is not None:
            pulumi.set(__self__, "special_destination", special_destination)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        The identifier for the destination. This is the email address for EMAIL destinations, the URL for URL destinations,
        or the unique Databricks notification destination ID for all other external destinations
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        The type of the destination. Possible values are: `EMAIL`, `GENERIC_WEBHOOK`, `MICROSOFT_TEAMS`, `SLACK`, `URL`
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="specialDestination")
    def special_destination(self) -> Optional[_builtins.str]:
        """
        This field is used to denote whether the destination is the email of the owner of the securable object.
        The special destination cannot be assigned to a securable and only represents the default destination of the securable.
        The securable types that support default special destinations are: "catalog", "external_location", "connection", "credential", and "metastore".
        The **destination_type** of a **special_destination** is always EMAIL. Possible values are: `SPECIAL_DESTINATION_CATALOG_OWNER`, `SPECIAL_DESTINATION_CONNECTION_OWNER`, `SPECIAL_DESTINATION_CREDENTIAL_OWNER`, `SPECIAL_DESTINATION_EXTERNAL_LOCATION_OWNER`, `SPECIAL_DESTINATION_METASTORE_OWNER`
        """
        return pulumi.get(self, "special_destination")


@pulumi.output_type
class RfaAccessRequestDestinationsSecurable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullName":
            suggest = "full_name"
        elif key == "providerShare":
            suggest = "provider_share"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RfaAccessRequestDestinationsSecurable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RfaAccessRequestDestinationsSecurable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RfaAccessRequestDestinationsSecurable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_name: Optional[_builtins.str] = None,
                 provider_share: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str full_name: Required. The full name of the catalog/schema/table.
               Optional if resource_name is present
        :param _builtins.str provider_share: Optional. The name of the Share object that contains the securable when the securable is
               getting shared in D2D Delta Sharing
        :param _builtins.str type: Required. The type of securable (catalog/schema/table).
               Optional if resource_name is present. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        """
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if provider_share is not None:
            pulumi.set(__self__, "provider_share", provider_share)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        Required. The full name of the catalog/schema/table.
        Optional if resource_name is present
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="providerShare")
    def provider_share(self) -> Optional[_builtins.str]:
        """
        Optional. The name of the Share object that contains the securable when the securable is
        getting shared in D2D Delta Sharing
        """
        return pulumi.get(self, "provider_share")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Required. The type of securable (catalog/schema/table).
        Optional if resource_name is present. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SecretScopeKeyvaultMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretScopeKeyvaultMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretScopeKeyvaultMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretScopeKeyvaultMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: _builtins.str,
                 resource_id: _builtins.str):
        pulumi.set(__self__, "dns_name", dns_name)
        pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> _builtins.str:
        return pulumi.get(self, "dns_name")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class ServicePrincipalFederationPolicyOidcPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jwksJson":
            suggest = "jwks_json"
        elif key == "jwksUri":
            suggest = "jwks_uri"
        elif key == "subjectClaim":
            suggest = "subject_claim"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServicePrincipalFederationPolicyOidcPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServicePrincipalFederationPolicyOidcPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServicePrincipalFederationPolicyOidcPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_json: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 subject_claim: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] audiences: The allowed token audiences, as specified in the 'aud' claim of federated tokens.
               The audience identifier is intended to represent the recipient of the token.
               Can be any non-empty string value. As long as the audience in the token matches
               at least one audience in the policy, the token is considered a match. If audiences
               is unspecified, defaults to your Databricks account id
        :param _builtins.str issuer: The required token issuer, as specified in the 'iss' claim of federated tokens
        :param _builtins.str jwks_json: The public keys used to validate the signature of federated tokens, in JWKS format.
               Most use cases should not need to specify this field. If jwks_uri and jwks_json
               are both unspecified (recommended), Databricks automatically fetches the public
               keys from your issuers well known endpoint. Databricks strongly recommends
               relying on your issuers well known endpoint for discovering public keys
        :param _builtins.str jwks_uri: URL of the public keys used to validate the signature of federated tokens, in
               JWKS format. Most use cases should not need to specify this field. If jwks_uri
               and jwks_json are both unspecified (recommended), Databricks automatically
               fetches the public keys from your issuers well known endpoint. Databricks
               strongly recommends relying on your issuers well known endpoint for discovering
               public keys
        :param _builtins.str subject: The required token subject, as specified in the subject claim of federated tokens.
               Must be specified for service principal federation policies. Must not be specified
               for account federation policies
        :param _builtins.str subject_claim: The claim that contains the subject of the token. If unspecified, the default value
               is 'sub'
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_json is not None:
            pulumi.set(__self__, "jwks_json", jwks_json)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_claim is not None:
            pulumi.set(__self__, "subject_claim", subject_claim)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        The allowed token audiences, as specified in the 'aud' claim of federated tokens.
        The audience identifier is intended to represent the recipient of the token.
        Can be any non-empty string value. As long as the audience in the token matches
        at least one audience in the policy, the token is considered a match. If audiences
        is unspecified, defaults to your Databricks account id
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The required token issuer, as specified in the 'iss' claim of federated tokens
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksJson")
    def jwks_json(self) -> Optional[_builtins.str]:
        """
        The public keys used to validate the signature of federated tokens, in JWKS format.
        Most use cases should not need to specify this field. If jwks_uri and jwks_json
        are both unspecified (recommended), Databricks automatically fetches the public
        keys from your issuers well known endpoint. Databricks strongly recommends
        relying on your issuers well known endpoint for discovering public keys
        """
        return pulumi.get(self, "jwks_json")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        URL of the public keys used to validate the signature of federated tokens, in
        JWKS format. Most use cases should not need to specify this field. If jwks_uri
        and jwks_json are both unspecified (recommended), Databricks automatically
        fetches the public keys from your issuers well known endpoint. Databricks
        strongly recommends relying on your issuers well known endpoint for discovering
        public keys
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        The required token subject, as specified in the subject claim of federated tokens.
        Must be specified for service principal federation policies. Must not be specified
        for account federation policies
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="subjectClaim")
    def subject_claim(self) -> Optional[_builtins.str]:
        """
        The claim that contains the subject of the token. If unspecified, the default value
        is 'sub'
        """
        return pulumi.get(self, "subject_claim")


@pulumi.output_type
class ShareObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataObjectType":
            suggest = "data_object_type"
        elif key == "addedAt":
            suggest = "added_at"
        elif key == "addedBy":
            suggest = "added_by"
        elif key == "cdfEnabled":
            suggest = "cdf_enabled"
        elif key == "effectiveCdfEnabled":
            suggest = "effective_cdf_enabled"
        elif key == "effectiveHistoryDataSharingStatus":
            suggest = "effective_history_data_sharing_status"
        elif key == "effectiveSharedAs":
            suggest = "effective_shared_as"
        elif key == "effectiveStartVersion":
            suggest = "effective_start_version"
        elif key == "effectiveStringSharedAs":
            suggest = "effective_string_shared_as"
        elif key == "historyDataSharingStatus":
            suggest = "history_data_sharing_status"
        elif key == "sharedAs":
            suggest = "shared_as"
        elif key == "startVersion":
            suggest = "start_version"
        elif key == "stringSharedAs":
            suggest = "string_shared_as"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShareObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShareObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShareObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_object_type: _builtins.str,
                 name: _builtins.str,
                 added_at: Optional[_builtins.int] = None,
                 added_by: Optional[_builtins.str] = None,
                 cdf_enabled: Optional[_builtins.bool] = None,
                 comment: Optional[_builtins.str] = None,
                 content: Optional[_builtins.str] = None,
                 effective_cdf_enabled: Optional[_builtins.bool] = None,
                 effective_history_data_sharing_status: Optional[_builtins.str] = None,
                 effective_shared_as: Optional[_builtins.str] = None,
                 effective_start_version: Optional[_builtins.int] = None,
                 effective_string_shared_as: Optional[_builtins.str] = None,
                 history_data_sharing_status: Optional[_builtins.str] = None,
                 partitions: Optional[Sequence['outputs.ShareObjectPartition']] = None,
                 shared_as: Optional[_builtins.str] = None,
                 start_version: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None,
                 string_shared_as: Optional[_builtins.str] = None):
        """
        :param _builtins.str data_object_type: Type of the data object, currently `TABLE`, `VIEW`, `SCHEMA`, `VOLUME`, and `MODEL` are supported.
        :param _builtins.str name: Full name of the object, e.g. `catalog.schema.name` for a tables, views, volumes and models, or `catalog.schema` for schemas.
        :param _builtins.bool cdf_enabled: Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        :param _builtins.str comment: Description about the object.
        :param _builtins.str history_data_sharing_status: Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.
               
               To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        :param _builtins.str shared_as: A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        :param _builtins.int start_version: The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        :param _builtins.str status: Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        pulumi.set(__self__, "data_object_type", data_object_type)
        pulumi.set(__self__, "name", name)
        if added_at is not None:
            pulumi.set(__self__, "added_at", added_at)
        if added_by is not None:
            pulumi.set(__self__, "added_by", added_by)
        if cdf_enabled is not None:
            pulumi.set(__self__, "cdf_enabled", cdf_enabled)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if effective_cdf_enabled is not None:
            pulumi.set(__self__, "effective_cdf_enabled", effective_cdf_enabled)
        if effective_history_data_sharing_status is not None:
            pulumi.set(__self__, "effective_history_data_sharing_status", effective_history_data_sharing_status)
        if effective_shared_as is not None:
            pulumi.set(__self__, "effective_shared_as", effective_shared_as)
        if effective_start_version is not None:
            pulumi.set(__self__, "effective_start_version", effective_start_version)
        if effective_string_shared_as is not None:
            pulumi.set(__self__, "effective_string_shared_as", effective_string_shared_as)
        if history_data_sharing_status is not None:
            pulumi.set(__self__, "history_data_sharing_status", history_data_sharing_status)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if shared_as is not None:
            pulumi.set(__self__, "shared_as", shared_as)
        if start_version is not None:
            pulumi.set(__self__, "start_version", start_version)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if string_shared_as is not None:
            pulumi.set(__self__, "string_shared_as", string_shared_as)

    @_builtins.property
    @pulumi.getter(name="dataObjectType")
    def data_object_type(self) -> _builtins.str:
        """
        Type of the data object, currently `TABLE`, `VIEW`, `SCHEMA`, `VOLUME`, and `MODEL` are supported.
        """
        return pulumi.get(self, "data_object_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Full name of the object, e.g. `catalog.schema.name` for a tables, views, volumes and models, or `catalog.schema` for schemas.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "added_at")

    @_builtins.property
    @pulumi.getter(name="addedBy")
    def added_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "added_by")

    @_builtins.property
    @pulumi.getter(name="cdfEnabled")
    def cdf_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Change Data Feed (cdf) on the shared object. When this field is set, field `history_data_sharing_status` can not be set.
        """
        return pulumi.get(self, "cdf_enabled")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description about the object.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="effectiveCdfEnabled")
    def effective_cdf_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "effective_cdf_enabled")

    @_builtins.property
    @pulumi.getter(name="effectiveHistoryDataSharingStatus")
    def effective_history_data_sharing_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effective_history_data_sharing_status")

    @_builtins.property
    @pulumi.getter(name="effectiveSharedAs")
    def effective_shared_as(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effective_shared_as")

    @_builtins.property
    @pulumi.getter(name="effectiveStartVersion")
    def effective_start_version(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "effective_start_version")

    @_builtins.property
    @pulumi.getter(name="effectiveStringSharedAs")
    def effective_string_shared_as(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effective_string_shared_as")

    @_builtins.property
    @pulumi.getter(name="historyDataSharingStatus")
    def history_data_sharing_status(self) -> Optional[_builtins.str]:
        """
        Whether to enable history sharing, one of: `ENABLED`, `DISABLED`. When a table has history sharing enabled, recipients can query table data by version, starting from the current table version. If not specified, clients can only query starting from the version of the object at the time it was added to the share. *NOTE*: The start_version should be less than or equal the current version of the object. When this field is set, field `cdf_enabled` can not be set.

        To share only part of a table when you add the table to a share, you can provide partition specifications. This is specified by a number of `partition` blocks. Each entry in `partition` block takes a list of `value` blocks. The field is documented below.
        """
        return pulumi.get(self, "history_data_sharing_status")

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.ShareObjectPartition']]:
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter(name="sharedAs")
    def shared_as(self) -> Optional[_builtins.str]:
        """
        A user-provided new name for the data object within the share. If this new name is not provided, the object's original name will be used as the `shared_as` name. The `shared_as` name must be unique within a Share. Change forces creation of a new resource.
        """
        return pulumi.get(self, "shared_as")

    @_builtins.property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> Optional[_builtins.int]:
        """
        The start version associated with the object for cdf. This allows data providers to control the lowest object version that is accessible by clients.
        """
        return pulumi.get(self, "start_version")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the object, one of: `ACTIVE`, `PERMISSION_DENIED`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="stringSharedAs")
    def string_shared_as(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "string_shared_as")


@pulumi.output_type
class ShareObjectPartition(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.ShareObjectPartitionValue']] = None):
        """
        :param Sequence['ShareObjectPartitionValueArgs'] values: The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.ShareObjectPartitionValue']]:
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ShareObjectPartitionValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recipientPropertyKey":
            suggest = "recipient_property_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShareObjectPartitionValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShareObjectPartitionValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShareObjectPartitionValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 op: _builtins.str,
                 recipient_property_key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the partition column.
        :param _builtins.str op: The operator to apply for the value, one of: `EQUAL`, `LIKE`
        :param _builtins.str recipient_property_key: The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        :param _builtins.str value: The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "op", op)
        if recipient_property_key is not None:
            pulumi.set(__self__, "recipient_property_key", recipient_property_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the partition column.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        The operator to apply for the value, one of: `EQUAL`, `LIKE`
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter(name="recipientPropertyKey")
    def recipient_property_key(self) -> Optional[_builtins.str]:
        """
        The key of a Delta Sharing recipient's property. For example `databricks-account-id`. When this field is set, field `value` can not be set.
        """
        return pulumi.get(self, "recipient_property_key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the partition column. When this value is not set, it means null value. When this field is set, field `recipient_property_key` can not be set.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ShareProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShareProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShareProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShareProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class SqlAlertOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBody":
            suggest = "custom_body"
        elif key == "customSubject":
            suggest = "custom_subject"
        elif key == "emptyResultState":
            suggest = "empty_result_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAlertOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAlertOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAlertOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.str,
                 custom_body: Optional[_builtins.str] = None,
                 custom_subject: Optional[_builtins.str] = None,
                 empty_result_state: Optional[_builtins.str] = None,
                 muted: Optional[_builtins.bool] = None):
        """
        :param _builtins.str column: Name of column in the query result to compare in alert evaluation.
        :param _builtins.str op: Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        :param _builtins.str value: Value used to compare in alert evaluation.
        :param _builtins.str custom_body: Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        :param _builtins.str custom_subject: Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        :param _builtins.str empty_result_state: State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        :param _builtins.bool muted: Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if custom_body is not None:
            pulumi.set(__self__, "custom_body", custom_body)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if muted is not None:
            pulumi.set(__self__, "muted", muted)

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        """
        Name of column in the query result to compare in alert evaluation.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        Operator used to compare in alert evaluation. (Enum: `>`, `>=`, `<`, `<=`, `==`, `!=`)
        """
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value used to compare in alert evaluation.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="customBody")
    def custom_body(self) -> Optional[_builtins.str]:
        """
        Custom body of alert notification, if it exists. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        return pulumi.get(self, "custom_body")

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        """
        Custom subject of alert notification, if it exists. This includes email subject, Slack notification header, etc. See [Alerts API reference](https://docs.databricks.com/sql/user/alerts/index.html) for custom templating instructions.
        """
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[_builtins.str]:
        """
        State that alert evaluates to when query result is empty.  Currently supported values are `unknown`, `triggered`, `ok` - check [API documentation](https://docs.databricks.com/api/workspace/alerts/create) for full list of supported values.
        """
        return pulumi.get(self, "empty_result_state")

    @_builtins.property
    @pulumi.getter
    def muted(self) -> Optional[_builtins.bool]:
        """
        Whether or not the alert is muted. If an alert is muted, it will not notify users and alert destinations when triggered.
        """
        return pulumi.get(self, "muted")


@pulumi.output_type
class SqlEndpointChannel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbsqlVersion":
            suggest = "dbsql_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlEndpointChannel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlEndpointChannel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlEndpointChannel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dbsql_version: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        if dbsql_version is not None:
            pulumi.set(__self__, "dbsql_version", dbsql_version)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dbsqlVersion")
    def dbsql_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dbsql_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Databricks SQL release channel. Possible values are: `CHANNEL_NAME_PREVIEW` and `CHANNEL_NAME_CURRENT`. Default is `CHANNEL_NAME_CURRENT`.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SqlEndpointHealth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureReason":
            suggest = "failure_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlEndpointHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlEndpointHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlEndpointHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 details: Optional[_builtins.str] = None,
                 failure_reason: Optional['outputs.SqlEndpointHealthFailureReason'] = None,
                 message: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 summary: Optional[_builtins.str] = None):
        if details is not None:
            pulumi.set(__self__, "details", details)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.SqlEndpointHealthFailureReason']:
        return pulumi.get(self, "failure_reason")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "summary")


@pulumi.output_type
class SqlEndpointHealthFailureReason(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SqlEndpointOdbcParams(dict):
    def __init__(__self__, *,
                 hostname: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class SqlEndpointTags(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlEndpointTags. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlEndpointTags.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlEndpointTags.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_tags: Optional[Sequence['outputs.SqlEndpointTagsCustomTag']] = None):
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence['outputs.SqlEndpointTagsCustomTag']]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class SqlEndpointTagsCustomTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlPermissionsPrivilegeAssignment(dict):
    def __init__(__self__, *,
                 principal: _builtins.str,
                 privileges: Sequence[_builtins.str]):
        """
        :param _builtins.str principal: `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        :param Sequence[_builtins.str] privileges: set of available privilege names in upper case.
               
               
               [Available](https://docs.databricks.com/security/access-control/table-acls/object-privileges.html) privilege names are:
               [Available](https://docs.databricks.com/security/access-control/table-acls/object-privileges.html) privilege names are:
               
               
               * `SELECT` - gives read access to an object.
               * `SELECT` - gives read access to an object.
               * `CREATE` - gives the ability to create an object (for example, a table in a database).
               * `CREATE` - gives the ability to create an object (for example, a table in a database).
               * `MODIFY` - gives the ability to add, delete, and modify data to or from an object.
               * `MODIFY` - gives the ability to add, delete, and modify data to or from an object.
               * `USAGE` - do not give any abilities, but is an additional requirement to perform any action on a database object.
               * `USAGE` - do not give any abilities, but is an additional requirement to perform any action on a database object.
               * `READ_METADATA` - gives the ability to view an object and its metadata.
               * `READ_METADATA` - gives the ability to view an object and its metadata.
               * `CREATE_NAMED_FUNCTION` - gives the ability to create a named UDF in an existing catalog or database.
               * `CREATE_NAMED_FUNCTION` - gives the ability to create a named UDF in an existing catalog or database.
               * `MODIFY_CLASSPATH` - gives the ability to add files to the Spark classpath.
               * `MODIFY_CLASSPATH` - gives the ability to add files to the Spark classpath.
               
               
               > Even though the value `ALL PRIVILEGES` is mentioned in Table ACL documentation, it's not recommended to use it from Pulumi, as it may result in unnecessary state updates.
               > Even though the value `ALL PRIVILEGES` is mentioned in Table ACL documentation, it's not recommended to use it from Pulumi, as it may result in unnecessary state updates.
        """
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "privileges", privileges)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> _builtins.str:
        """
        `display_name` for a Group or databricks_user, `application_id` for a databricks_service_principal.
        """
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def privileges(self) -> Sequence[_builtins.str]:
        """
        set of available privilege names in upper case.


        [Available](https://docs.databricks.com/security/access-control/table-acls/object-privileges.html) privilege names are:
        [Available](https://docs.databricks.com/security/access-control/table-acls/object-privileges.html) privilege names are:


        * `SELECT` - gives read access to an object.
        * `SELECT` - gives read access to an object.
        * `CREATE` - gives the ability to create an object (for example, a table in a database).
        * `CREATE` - gives the ability to create an object (for example, a table in a database).
        * `MODIFY` - gives the ability to add, delete, and modify data to or from an object.
        * `MODIFY` - gives the ability to add, delete, and modify data to or from an object.
        * `USAGE` - do not give any abilities, but is an additional requirement to perform any action on a database object.
        * `USAGE` - do not give any abilities, but is an additional requirement to perform any action on a database object.
        * `READ_METADATA` - gives the ability to view an object and its metadata.
        * `READ_METADATA` - gives the ability to view an object and its metadata.
        * `CREATE_NAMED_FUNCTION` - gives the ability to create a named UDF in an existing catalog or database.
        * `CREATE_NAMED_FUNCTION` - gives the ability to create a named UDF in an existing catalog or database.
        * `MODIFY_CLASSPATH` - gives the ability to add files to the Spark classpath.
        * `MODIFY_CLASSPATH` - gives the ability to add files to the Spark classpath.


        > Even though the value `ALL PRIVILEGES` is mentioned in Table ACL documentation, it's not recommended to use it from Pulumi, as it may result in unnecessary state updates.
        > Even though the value `ALL PRIVILEGES` is mentioned in Table ACL documentation, it's not recommended to use it from Pulumi, as it may result in unnecessary state updates.
        """
        return pulumi.get(self, "privileges")


@pulumi.output_type
class SqlQueryParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRange":
            suggest = "date_range"
        elif key == "datetimeRange":
            suggest = "datetime_range"
        elif key == "datetimesecRange":
            suggest = "datetimesec_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 date: Optional['outputs.SqlQueryParameterDate'] = None,
                 date_range: Optional['outputs.SqlQueryParameterDateRange'] = None,
                 datetime: Optional['outputs.SqlQueryParameterDatetime'] = None,
                 datetime_range: Optional['outputs.SqlQueryParameterDatetimeRange'] = None,
                 datetimesec: Optional['outputs.SqlQueryParameterDatetimesec'] = None,
                 datetimesec_range: Optional['outputs.SqlQueryParameterDatetimesecRange'] = None,
                 enum: Optional['outputs.SqlQueryParameterEnum'] = None,
                 number: Optional['outputs.SqlQueryParameterNumber'] = None,
                 query: Optional['outputs.SqlQueryParameterQuery'] = None,
                 text: Optional['outputs.SqlQueryParameterText'] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The literal parameter marker that appears between double curly braces in the query text.
               Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.
               
               For `text`, `number`, `date`, `datetime`, `datetimesec` block
        :param 'SqlQueryParameterQueryArgs' query: The text of the query to be run.
        :param _builtins.str title: The text displayed in a parameter picking widget.
        """
        pulumi.set(__self__, "name", name)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if date_range is not None:
            pulumi.set(__self__, "date_range", date_range)
        if datetime is not None:
            pulumi.set(__self__, "datetime", datetime)
        if datetime_range is not None:
            pulumi.set(__self__, "datetime_range", datetime_range)
        if datetimesec is not None:
            pulumi.set(__self__, "datetimesec", datetimesec)
        if datetimesec_range is not None:
            pulumi.set(__self__, "datetimesec_range", datetimesec_range)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The literal parameter marker that appears between double curly braces in the query text.
        Parameters can have several different types. Type is specified using one of the following configuration blocks: `text`, `number`, `enum`, `query`, `date`, `datetime`, `datetimesec`, `date_range`, `datetime_range`, `datetimesec_range`.

        For `text`, `number`, `date`, `datetime`, `datetimesec` block
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional['outputs.SqlQueryParameterDate']:
        return pulumi.get(self, "date")

    @_builtins.property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> Optional['outputs.SqlQueryParameterDateRange']:
        return pulumi.get(self, "date_range")

    @_builtins.property
    @pulumi.getter
    def datetime(self) -> Optional['outputs.SqlQueryParameterDatetime']:
        return pulumi.get(self, "datetime")

    @_builtins.property
    @pulumi.getter(name="datetimeRange")
    def datetime_range(self) -> Optional['outputs.SqlQueryParameterDatetimeRange']:
        return pulumi.get(self, "datetime_range")

    @_builtins.property
    @pulumi.getter
    def datetimesec(self) -> Optional['outputs.SqlQueryParameterDatetimesec']:
        return pulumi.get(self, "datetimesec")

    @_builtins.property
    @pulumi.getter(name="datetimesecRange")
    def datetimesec_range(self) -> Optional['outputs.SqlQueryParameterDatetimesecRange']:
        return pulumi.get(self, "datetimesec_range")

    @_builtins.property
    @pulumi.getter
    def enum(self) -> Optional['outputs.SqlQueryParameterEnum']:
        return pulumi.get(self, "enum")

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional['outputs.SqlQueryParameterNumber']:
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional['outputs.SqlQueryParameterQuery']:
        """
        The text of the query to be run.
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional['outputs.SqlQueryParameterText']:
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The text displayed in a parameter picking widget.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class SqlQueryParameterDate(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDateRange(dict):
    def __init__(__self__, *,
                 range: Optional['outputs.SqlQueryParameterDateRangeRange'] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def range(self) -> Optional['outputs.SqlQueryParameterDateRangeRange']:
        return pulumi.get(self, "range")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDateRangeRange(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        return pulumi.get(self, "start")


@pulumi.output_type
class SqlQueryParameterDatetime(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimeRange(dict):
    def __init__(__self__, *,
                 range: Optional['outputs.SqlQueryParameterDatetimeRangeRange'] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def range(self) -> Optional['outputs.SqlQueryParameterDatetimeRangeRange']:
        return pulumi.get(self, "range")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimeRangeRange(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        return pulumi.get(self, "start")


@pulumi.output_type
class SqlQueryParameterDatetimesec(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimesecRange(dict):
    def __init__(__self__, *,
                 range: Optional['outputs.SqlQueryParameterDatetimesecRangeRange'] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def range(self) -> Optional['outputs.SqlQueryParameterDatetimesecRangeRange']:
        return pulumi.get(self, "range")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterDatetimesecRangeRange(dict):
    def __init__(__self__, *,
                 end: _builtins.str,
                 start: _builtins.str):
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.str:
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        return pulumi.get(self, "start")


@pulumi.output_type
class SqlQueryParameterEnum(dict):
    def __init__(__self__, *,
                 options: Sequence[_builtins.str],
                 multiple: Optional['outputs.SqlQueryParameterEnumMultiple'] = None,
                 value: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        pulumi.set(__self__, "options", options)
        if multiple is not None:
            pulumi.set(__self__, "multiple", multiple)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def multiple(self) -> Optional['outputs.SqlQueryParameterEnumMultiple']:
        return pulumi.get(self, "multiple")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SqlQueryParameterEnumMultiple(dict):
    def __init__(__self__, *,
                 separator: _builtins.str,
                 prefix: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "separator", separator)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def separator(self) -> _builtins.str:
        return pulumi.get(self, "separator")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class SqlQueryParameterNumber(dict):
    def __init__(__self__, *,
                 value: _builtins.float):
        """
        :param _builtins.float value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQueryParameterQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryParameterQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryParameterQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryParameterQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: _builtins.str,
                 multiple: Optional['outputs.SqlQueryParameterQueryMultiple'] = None,
                 value: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        pulumi.set(__self__, "query_id", query_id)
        if multiple is not None:
            pulumi.set(__self__, "multiple", multiple)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        return pulumi.get(self, "query_id")

    @_builtins.property
    @pulumi.getter
    def multiple(self) -> Optional['outputs.SqlQueryParameterQueryMultiple']:
        return pulumi.get(self, "multiple")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SqlQueryParameterQueryMultiple(dict):
    def __init__(__self__, *,
                 separator: _builtins.str,
                 prefix: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "separator", separator)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def separator(self) -> _builtins.str:
        return pulumi.get(self, "separator")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class SqlQueryParameterText(dict):
    def __init__(__self__, *,
                 value: _builtins.str):
        """
        :param _builtins.str value: The default value for this parameter.
        """
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The default value for this parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlQuerySchedule(dict):
    def __init__(__self__, *,
                 continuous: Optional['outputs.SqlQueryScheduleContinuous'] = None,
                 daily: Optional['outputs.SqlQueryScheduleDaily'] = None,
                 weekly: Optional['outputs.SqlQueryScheduleWeekly'] = None):
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def continuous(self) -> Optional['outputs.SqlQueryScheduleContinuous']:
        return pulumi.get(self, "continuous")

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional['outputs.SqlQueryScheduleDaily']:
        return pulumi.get(self, "daily")

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional['outputs.SqlQueryScheduleWeekly']:
        return pulumi.get(self, "weekly")


@pulumi.output_type
class SqlQueryScheduleContinuous(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalSeconds":
            suggest = "interval_seconds"
        elif key == "untilDate":
            suggest = "until_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryScheduleContinuous. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryScheduleContinuous.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryScheduleContinuous.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_seconds: _builtins.int,
                 until_date: Optional[_builtins.str] = None):
        pulumi.set(__self__, "interval_seconds", interval_seconds)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @_builtins.property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> _builtins.int:
        return pulumi.get(self, "interval_seconds")

    @_builtins.property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "until_date")


@pulumi.output_type
class SqlQueryScheduleDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalDays":
            suggest = "interval_days"
        elif key == "timeOfDay":
            suggest = "time_of_day"
        elif key == "untilDate":
            suggest = "until_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryScheduleDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryScheduleDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryScheduleDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interval_days: _builtins.int,
                 time_of_day: _builtins.str,
                 until_date: Optional[_builtins.str] = None):
        pulumi.set(__self__, "interval_days", interval_days)
        pulumi.set(__self__, "time_of_day", time_of_day)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @_builtins.property
    @pulumi.getter(name="intervalDays")
    def interval_days(self) -> _builtins.int:
        return pulumi.get(self, "interval_days")

    @_builtins.property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> _builtins.str:
        return pulumi.get(self, "time_of_day")

    @_builtins.property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "until_date")


@pulumi.output_type
class SqlQueryScheduleWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "intervalWeeks":
            suggest = "interval_weeks"
        elif key == "timeOfDay":
            suggest = "time_of_day"
        elif key == "untilDate":
            suggest = "until_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlQueryScheduleWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlQueryScheduleWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlQueryScheduleWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 interval_weeks: _builtins.int,
                 time_of_day: _builtins.str,
                 until_date: Optional[_builtins.str] = None):
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "interval_weeks", interval_weeks)
        pulumi.set(__self__, "time_of_day", time_of_day)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="intervalWeeks")
    def interval_weeks(self) -> _builtins.int:
        return pulumi.get(self, "interval_weeks")

    @_builtins.property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> _builtins.str:
        return pulumi.get(self, "time_of_day")

    @_builtins.property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "until_date")


@pulumi.output_type
class SqlTableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeJson":
            suggest = "type_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlTableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlTableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlTableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 identity: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None,
                 type_json: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: User-visible name of column
        :param _builtins.str comment: User-supplied free-form text.
        :param _builtins.str identity: Whether the field is an identity column. Can be `default`, `always`, or unset. It is unset by default.
        :param _builtins.bool nullable: Whether field is nullable (Default: `true`)
        :param _builtins.str type: Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        User-visible name of column
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        User-supplied free-form text.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        Whether the field is an identity column. Can be `default`, `always`, or unset. It is unset by default.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether field is nullable (Default: `true`)
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Column type spec (with metadata) as SQL text. Not supported for `VIEW` table_type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_json")


@pulumi.output_type
class SqlWidgetParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mapTo":
            suggest = "map_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlWidgetParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlWidgetParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlWidgetParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 map_to: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if map_to is not None:
            pulumi.set(__self__, "map_to", map_to)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="mapTo")
    def map_to(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "map_to")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SqlWidgetPosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeX":
            suggest = "size_x"
        elif key == "sizeY":
            suggest = "size_y"
        elif key == "autoHeight":
            suggest = "auto_height"
        elif key == "posX":
            suggest = "pos_x"
        elif key == "posY":
            suggest = "pos_y"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlWidgetPosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlWidgetPosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlWidgetPosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_x: _builtins.int,
                 size_y: _builtins.int,
                 auto_height: Optional[_builtins.bool] = None,
                 pos_x: Optional[_builtins.int] = None,
                 pos_y: Optional[_builtins.int] = None):
        pulumi.set(__self__, "size_x", size_x)
        pulumi.set(__self__, "size_y", size_y)
        if auto_height is not None:
            pulumi.set(__self__, "auto_height", auto_height)
        if pos_x is not None:
            pulumi.set(__self__, "pos_x", pos_x)
        if pos_y is not None:
            pulumi.set(__self__, "pos_y", pos_y)

    @_builtins.property
    @pulumi.getter(name="sizeX")
    def size_x(self) -> _builtins.int:
        return pulumi.get(self, "size_x")

    @_builtins.property
    @pulumi.getter(name="sizeY")
    def size_y(self) -> _builtins.int:
        return pulumi.get(self, "size_y")

    @_builtins.property
    @pulumi.getter(name="autoHeight")
    def auto_height(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "auto_height")

    @_builtins.property
    @pulumi.getter(name="posX")
    def pos_x(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "pos_x")

    @_builtins.property
    @pulumi.getter(name="posY")
    def pos_y(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "pos_y")


@pulumi.output_type
class StorageCredentialAwsIamRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "unityCatalogIamArn":
            suggest = "unity_catalog_iam_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialAwsIamRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialAwsIamRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialAwsIamRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 external_id: Optional[_builtins.str] = None,
                 unity_catalog_iam_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`.
               
               `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        :param _builtins.str external_id: The external ID used in role assumption to prevent the confused deputy problem.
        :param _builtins.str unity_catalog_iam_arn: The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`.

        `azure_managed_identity` optional configuration block for using managed identity as credential details for Azure (recommended over service principal):
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        The external ID used in role assumption to prevent the confused deputy problem.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
        return pulumi.get(self, "unity_catalog_iam_arn")


@pulumi.output_type
class StorageCredentialAzureManagedIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessConnectorId":
            suggest = "access_connector_id"
        elif key == "credentialId":
            suggest = "credential_id"
        elif key == "managedIdentityId":
            suggest = "managed_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialAzureManagedIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialAzureManagedIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialAzureManagedIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_connector_id: _builtins.str,
                 credential_id: Optional[_builtins.str] = None,
                 managed_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param _builtins.str managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
               
               `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @_builtins.property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> _builtins.str:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[_builtins.str]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.

        `databricks_gcp_service_account` optional configuration block for creating a Databricks-managed GCP Service Account:
        """
        return pulumi.get(self, "managed_identity_id")


@pulumi.output_type
class StorageCredentialAzureServicePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialAzureServicePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialAzureServicePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialAzureServicePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: _builtins.str,
                 client_secret: _builtins.str,
                 directory_id: _builtins.str):
        """
        :param _builtins.str application_id: The application ID of the application registration within the referenced AAD tenant
        :param _builtins.str client_secret: The client secret generated for the above app ID in AAD. **This field is redacted on output**
        :param _builtins.str directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The client secret generated for the above app ID in AAD. **This field is redacted on output**
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> _builtins.str:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class StorageCredentialCloudflareApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "accountId":
            suggest = "account_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialCloudflareApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialCloudflareApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialCloudflareApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 account_id: _builtins.str,
                 secret_access_key: _builtins.str):
        """
        :param _builtins.str access_key_id: R2 API token access key ID
        :param _builtins.str account_id: R2 account ID
        :param _builtins.str secret_access_key: R2 API token secret access key
               
               `azure_service_principal` optional configuration block to use service principal as credential details for Azure (Legacy):
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        R2 API token access key ID
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        R2 account ID
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        R2 API token secret access key

        `azure_service_principal` optional configuration block to use service principal as credential details for Azure (Legacy):
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class StorageCredentialDatabricksGcpServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialId":
            suggest = "credential_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialDatabricksGcpServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialDatabricksGcpServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialDatabricksGcpServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_id: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email of the GCP service account created, to be granted access to relevant buckets.
               
               `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class StorageCredentialGcpServiceAccountKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageCredentialGcpServiceAccountKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageCredentialGcpServiceAccountKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageCredentialGcpServiceAccountKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 private_key: _builtins.str,
                 private_key_id: _builtins.str):
        """
        :param _builtins.str email: The email of the GCP service account created, to be granted access to relevant buckets.
               
               `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "private_key_id", private_key_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.

        `cloudflare_api_token` optional configuration block for using a Cloudflare API Token as credential details. This requires account admin access:
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> _builtins.str:
        return pulumi.get(self, "private_key_id")


@pulumi.output_type
class TableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "typeText":
            suggest = "type_text"
        elif key == "partitionIndex":
            suggest = "partition_index"
        elif key == "typeIntervalType":
            suggest = "type_interval_type"
        elif key == "typeJson":
            suggest = "type_json"
        elif key == "typePrecision":
            suggest = "type_precision"
        elif key == "typeScale":
            suggest = "type_scale"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 position: _builtins.int,
                 type_name: _builtins.str,
                 type_text: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 partition_index: Optional[_builtins.int] = None,
                 type_interval_type: Optional[_builtins.str] = None,
                 type_json: Optional[_builtins.str] = None,
                 type_precision: Optional[_builtins.int] = None,
                 type_scale: Optional[_builtins.int] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if partition_index is not None:
            pulumi.set(__self__, "partition_index", partition_index)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.int:
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter(name="typeText")
    def type_text(self) -> _builtins.str:
        return pulumi.get(self, "type_text")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="partitionIndex")
    def partition_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "partition_index")

    @_builtins.property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_interval_type")

    @_builtins.property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_json")

    @_builtins.property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "type_precision")

    @_builtins.property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "type_scale")


@pulumi.output_type
class TagPolicyValue(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class VectorSearchEndpointEndpointStatus(dict):
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str message: Additional status message.
        :param _builtins.str state: Current state of the endpoint. Currently following values are supported: `PROVISIONING`, `ONLINE`, and `OFFLINE`.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Additional status message.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Current state of the endpoint. Currently following values are supported: `PROVISIONING`, `ONLINE`, and `OFFLINE`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VectorSearchIndexDeltaSyncIndexSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingSourceColumns":
            suggest = "embedding_source_columns"
        elif key == "embeddingVectorColumns":
            suggest = "embedding_vector_columns"
        elif key == "embeddingWritebackTable":
            suggest = "embedding_writeback_table"
        elif key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "pipelineType":
            suggest = "pipeline_type"
        elif key == "sourceTable":
            suggest = "source_table"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexDeltaSyncIndexSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexDeltaSyncIndexSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexDeltaSyncIndexSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_source_columns: Optional[Sequence['outputs.VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn']] = None,
                 embedding_vector_columns: Optional[Sequence['outputs.VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn']] = None,
                 embedding_writeback_table: Optional[_builtins.str] = None,
                 pipeline_id: Optional[_builtins.str] = None,
                 pipeline_type: Optional[_builtins.str] = None,
                 source_table: Optional[_builtins.str] = None):
        """
        :param Sequence['VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumnArgs'] embedding_source_columns: array of objects representing columns that contain the embedding source.  Each entry consists of:
        :param Sequence['VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumnArgs'] embedding_vector_columns: array of objects representing columns that contain the embedding vectors. Each entry consists of:
        :param _builtins.str embedding_writeback_table: Automatically sync the vector index contents and computed embeddings to the specified Delta table. The only supported table name is the index name with the suffix `_writeback_table`.
        :param _builtins.str pipeline_id: ID of the associated Delta Live Table pipeline.
        :param _builtins.str pipeline_type: Pipeline execution mode. Possible values are:
               * `TRIGGERED`: If the pipeline uses the triggered execution mode, the system stops processing after successfully refreshing the source table in the pipeline once, ensuring the table is updated based on the data available when the update started.
               * `CONTINUOUS`: If the pipeline uses continuous execution, the pipeline processes new data as it arrives in the source table to keep the vector index fresh.
        :param _builtins.str source_table: The name of the source table.
        """
        if embedding_source_columns is not None:
            pulumi.set(__self__, "embedding_source_columns", embedding_source_columns)
        if embedding_vector_columns is not None:
            pulumi.set(__self__, "embedding_vector_columns", embedding_vector_columns)
        if embedding_writeback_table is not None:
            pulumi.set(__self__, "embedding_writeback_table", embedding_writeback_table)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if pipeline_type is not None:
            pulumi.set(__self__, "pipeline_type", pipeline_type)
        if source_table is not None:
            pulumi.set(__self__, "source_table", source_table)

    @_builtins.property
    @pulumi.getter(name="embeddingSourceColumns")
    def embedding_source_columns(self) -> Optional[Sequence['outputs.VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn']]:
        """
        array of objects representing columns that contain the embedding source.  Each entry consists of:
        """
        return pulumi.get(self, "embedding_source_columns")

    @_builtins.property
    @pulumi.getter(name="embeddingVectorColumns")
    def embedding_vector_columns(self) -> Optional[Sequence['outputs.VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn']]:
        """
        array of objects representing columns that contain the embedding vectors. Each entry consists of:
        """
        return pulumi.get(self, "embedding_vector_columns")

    @_builtins.property
    @pulumi.getter(name="embeddingWritebackTable")
    def embedding_writeback_table(self) -> Optional[_builtins.str]:
        """
        Automatically sync the vector index contents and computed embeddings to the specified Delta table. The only supported table name is the index name with the suffix `_writeback_table`.
        """
        return pulumi.get(self, "embedding_writeback_table")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        ID of the associated Delta Live Table pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="pipelineType")
    def pipeline_type(self) -> Optional[_builtins.str]:
        """
        Pipeline execution mode. Possible values are:
        * `TRIGGERED`: If the pipeline uses the triggered execution mode, the system stops processing after successfully refreshing the source table in the pipeline once, ensuring the table is updated based on the data available when the update started.
        * `CONTINUOUS`: If the pipeline uses continuous execution, the pipeline processes new data as it arrives in the source table to keep the vector index fresh.
        """
        return pulumi.get(self, "pipeline_type")

    @_builtins.property
    @pulumi.getter(name="sourceTable")
    def source_table(self) -> Optional[_builtins.str]:
        """
        The name of the source table.
        """
        return pulumi.get(self, "source_table")


@pulumi.output_type
class VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingModelEndpointName":
            suggest = "embedding_model_endpoint_name"
        elif key == "modelEndpointNameForQuery":
            suggest = "model_endpoint_name_for_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexDeltaSyncIndexSpecEmbeddingSourceColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_model_endpoint_name: Optional[_builtins.str] = None,
                 model_endpoint_name_for_query: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str embedding_model_endpoint_name: The name of the embedding model endpoint, used by default for both ingestion and querying.
        :param _builtins.str model_endpoint_name_for_query: The name of the embedding model endpoint which, if specified, is used for querying (not ingestion).
        :param _builtins.str name: The name of the column
        """
        if embedding_model_endpoint_name is not None:
            pulumi.set(__self__, "embedding_model_endpoint_name", embedding_model_endpoint_name)
        if model_endpoint_name_for_query is not None:
            pulumi.set(__self__, "model_endpoint_name_for_query", model_endpoint_name_for_query)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="embeddingModelEndpointName")
    def embedding_model_endpoint_name(self) -> Optional[_builtins.str]:
        """
        The name of the embedding model endpoint, used by default for both ingestion and querying.
        """
        return pulumi.get(self, "embedding_model_endpoint_name")

    @_builtins.property
    @pulumi.getter(name="modelEndpointNameForQuery")
    def model_endpoint_name_for_query(self) -> Optional[_builtins.str]:
        """
        The name of the embedding model endpoint which, if specified, is used for querying (not ingestion).
        """
        return pulumi.get(self, "model_endpoint_name_for_query")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the column
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingDimension":
            suggest = "embedding_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexDeltaSyncIndexSpecEmbeddingVectorColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_dimension: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.int embedding_dimension: Dimension of the embedding vector.
        :param _builtins.str name: The name of the column.
        """
        if embedding_dimension is not None:
            pulumi.set(__self__, "embedding_dimension", embedding_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="embeddingDimension")
    def embedding_dimension(self) -> Optional[_builtins.int]:
        """
        Dimension of the embedding vector.
        """
        return pulumi.get(self, "embedding_dimension")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VectorSearchIndexDirectAccessIndexSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingSourceColumns":
            suggest = "embedding_source_columns"
        elif key == "embeddingVectorColumns":
            suggest = "embedding_vector_columns"
        elif key == "schemaJson":
            suggest = "schema_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexDirectAccessIndexSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexDirectAccessIndexSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexDirectAccessIndexSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_source_columns: Optional[Sequence['outputs.VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn']] = None,
                 embedding_vector_columns: Optional[Sequence['outputs.VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn']] = None,
                 schema_json: Optional[_builtins.str] = None):
        """
        :param Sequence['VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumnArgs'] embedding_source_columns: array of objects representing columns that contain the embedding source.  Each entry consists of:
        :param Sequence['VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumnArgs'] embedding_vector_columns: array of objects representing columns that contain the embedding vectors. Each entry consists of:
        :param _builtins.str schema_json: The schema of the index in JSON format.  Check the [API documentation](https://docs.databricks.com/api/workspace/vectorsearchindexes/createindex#direct_access_index_spec-schema_json) for a list of supported data types.
        """
        if embedding_source_columns is not None:
            pulumi.set(__self__, "embedding_source_columns", embedding_source_columns)
        if embedding_vector_columns is not None:
            pulumi.set(__self__, "embedding_vector_columns", embedding_vector_columns)
        if schema_json is not None:
            pulumi.set(__self__, "schema_json", schema_json)

    @_builtins.property
    @pulumi.getter(name="embeddingSourceColumns")
    def embedding_source_columns(self) -> Optional[Sequence['outputs.VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn']]:
        """
        array of objects representing columns that contain the embedding source.  Each entry consists of:
        """
        return pulumi.get(self, "embedding_source_columns")

    @_builtins.property
    @pulumi.getter(name="embeddingVectorColumns")
    def embedding_vector_columns(self) -> Optional[Sequence['outputs.VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn']]:
        """
        array of objects representing columns that contain the embedding vectors. Each entry consists of:
        """
        return pulumi.get(self, "embedding_vector_columns")

    @_builtins.property
    @pulumi.getter(name="schemaJson")
    def schema_json(self) -> Optional[_builtins.str]:
        """
        The schema of the index in JSON format.  Check the [API documentation](https://docs.databricks.com/api/workspace/vectorsearchindexes/createindex#direct_access_index_spec-schema_json) for a list of supported data types.
        """
        return pulumi.get(self, "schema_json")


@pulumi.output_type
class VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingModelEndpointName":
            suggest = "embedding_model_endpoint_name"
        elif key == "modelEndpointNameForQuery":
            suggest = "model_endpoint_name_for_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexDirectAccessIndexSpecEmbeddingSourceColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_model_endpoint_name: Optional[_builtins.str] = None,
                 model_endpoint_name_for_query: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str embedding_model_endpoint_name: The name of the embedding model endpoint
        :param _builtins.str model_endpoint_name_for_query: The name of the embedding model endpoint which, if specified, is used for querying (not ingestion).
        :param _builtins.str name: The name of the column
        """
        if embedding_model_endpoint_name is not None:
            pulumi.set(__self__, "embedding_model_endpoint_name", embedding_model_endpoint_name)
        if model_endpoint_name_for_query is not None:
            pulumi.set(__self__, "model_endpoint_name_for_query", model_endpoint_name_for_query)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="embeddingModelEndpointName")
    def embedding_model_endpoint_name(self) -> Optional[_builtins.str]:
        """
        The name of the embedding model endpoint
        """
        return pulumi.get(self, "embedding_model_endpoint_name")

    @_builtins.property
    @pulumi.getter(name="modelEndpointNameForQuery")
    def model_endpoint_name_for_query(self) -> Optional[_builtins.str]:
        """
        The name of the embedding model endpoint which, if specified, is used for querying (not ingestion).
        """
        return pulumi.get(self, "model_endpoint_name_for_query")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the column
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingDimension":
            suggest = "embedding_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexDirectAccessIndexSpecEmbeddingVectorColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_dimension: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.int embedding_dimension: Dimension of the embedding vector.
        :param _builtins.str name: The name of the column.
        """
        if embedding_dimension is not None:
            pulumi.set(__self__, "embedding_dimension", embedding_dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="embeddingDimension")
    def embedding_dimension(self) -> Optional[_builtins.int]:
        """
        Dimension of the embedding vector.
        """
        return pulumi.get(self, "embedding_dimension")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the column.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VectorSearchIndexStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexUrl":
            suggest = "index_url"
        elif key == "indexedRowCount":
            suggest = "indexed_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorSearchIndexStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorSearchIndexStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorSearchIndexStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_url: Optional[_builtins.str] = None,
                 indexed_row_count: Optional[_builtins.int] = None,
                 message: Optional[_builtins.str] = None,
                 ready: Optional[_builtins.bool] = None):
        """
        :param _builtins.str index_url: Index API Url to be used to perform operations on the index
        :param _builtins.int indexed_row_count: Number of rows indexed
        :param _builtins.str message: Message associated with the index status
        :param _builtins.bool ready: Whether the index is ready for search
        """
        if index_url is not None:
            pulumi.set(__self__, "index_url", index_url)
        if indexed_row_count is not None:
            pulumi.set(__self__, "indexed_row_count", indexed_row_count)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if ready is not None:
            pulumi.set(__self__, "ready", ready)

    @_builtins.property
    @pulumi.getter(name="indexUrl")
    def index_url(self) -> Optional[_builtins.str]:
        """
        Index API Url to be used to perform operations on the index
        """
        return pulumi.get(self, "index_url")

    @_builtins.property
    @pulumi.getter(name="indexedRowCount")
    def indexed_row_count(self) -> Optional[_builtins.int]:
        """
        Number of rows indexed
        """
        return pulumi.get(self, "indexed_row_count")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Message associated with the index status
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def ready(self) -> Optional[_builtins.bool]:
        """
        Whether the index is ready for search
        """
        return pulumi.get(self, "ready")


@pulumi.output_type
class WorkspaceSettingV2AibiDashboardEmbeddingAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicyType":
            suggest = "access_policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2AibiDashboardEmbeddingAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2AibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2AibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class WorkspaceSettingV2AibiDashboardEmbeddingApprovedDomains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvedDomains":
            suggest = "approved_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2AibiDashboardEmbeddingApprovedDomains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2AibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2AibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class WorkspaceSettingV2AutomaticClusterUpdateWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canToggle":
            suggest = "can_toggle"
        elif key == "enablementDetails":
            suggest = "enablement_details"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "restartEvenIfNoUpdatesAvailable":
            suggest = "restart_even_if_no_updates_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2AutomaticClusterUpdateWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails'] = None,
                 maintenance_window: Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails']:
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow']:
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forcedForComplianceMode":
            suggest = "forced_for_compliance_mode"
        elif key == "unavailableForDisabledEntitlement":
            suggest = "unavailable_for_disabled_entitlement"
        elif key == "unavailableForNonEnterpriseTier":
            suggest = "unavailable_for_non_enterprise_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weekDayBasedSchedule":
            suggest = "week_day_based_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule'] = None):
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule']:
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime'] = None):
        """
        :param _builtins.str day_of_week: Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime']:
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class WorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class WorkspaceSettingV2BooleanVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicyType":
            suggest = "access_policy_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvedDomains":
            suggest = "approved_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomains.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canToggle":
            suggest = "can_toggle"
        elif key == "enablementDetails":
            suggest = "enablement_details"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "restartEvenIfNoUpdatesAvailable":
            suggest = "restart_even_if_no_updates_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails'] = None,
                 maintenance_window: Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails']:
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow']:
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forcedForComplianceMode":
            suggest = "forced_for_compliance_mode"
        elif key == "unavailableForDisabledEntitlement":
            suggest = "unavailable_for_disabled_entitlement"
        elif key == "unavailableForNonEnterpriseTier":
            suggest = "unavailable_for_non_enterprise_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "weekDayBasedSchedule":
            suggest = "week_day_based_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule'] = None):
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule']:
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "windowStartTime":
            suggest = "window_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime'] = None):
        """
        :param _builtins.str day_of_week: Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime']:
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class WorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTime(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class WorkspaceSettingV2EffectiveBooleanVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2EffectiveIntegerVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2EffectivePersonalCompute(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2EffectiveRestrictWorkspaceAdmins(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class WorkspaceSettingV2EffectiveStringVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2IntegerVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2PersonalCompute(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceSettingV2RestrictWorkspaceAdmins(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class WorkspaceSettingV2StringVal(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountFederationPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 oidc_policy: 'outputs.GetAccountFederationPoliciesPolicyOidcPolicyResult',
                 policy_id: _builtins.str,
                 service_principal_id: _builtins.int,
                 uid: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str create_time: (string) - Creation time of the federation policy
        :param _builtins.str description: (string) - Description of the federation policy
        :param _builtins.str name: (string) - Resource name for the federation policy. Example values include
               `accounts/<account-id>/federationPolicies/my-federation-policy` for Account Federation Policies, and
               `accounts/<account-id>/servicePrincipals/<service-principal-id>/federationPolicies/my-federation-policy`
               for Service Principal Federation Policies. Typically an output parameter, which does not need to be
               specified in create or update requests. If specified in a request, must match the value in the
               request URL
        :param 'GetAccountFederationPoliciesPolicyOidcPolicyArgs' oidc_policy: (OidcFederationPolicy)
        :param _builtins.str policy_id: (string) - The ID of the federation policy. Output only
        :param _builtins.int service_principal_id: (integer) - The service principal ID that this federation policy applies to. Output only. Only set for service principal federation policies
        :param _builtins.str uid: (string) - Unique, immutable id of the federation policy
        :param _builtins.str update_time: (string) - Last update time of the federation policy
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oidc_policy", oidc_policy)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        (string) - Creation time of the federation policy
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (string) - Description of the federation policy
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Resource name for the federation policy. Example values include
        `accounts/<account-id>/federationPolicies/my-federation-policy` for Account Federation Policies, and
        `accounts/<account-id>/servicePrincipals/<service-principal-id>/federationPolicies/my-federation-policy`
        for Service Principal Federation Policies. Typically an output parameter, which does not need to be
        specified in create or update requests. If specified in a request, must match the value in the
        request URL
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oidcPolicy")
    def oidc_policy(self) -> 'outputs.GetAccountFederationPoliciesPolicyOidcPolicyResult':
        """
        (OidcFederationPolicy)
        """
        return pulumi.get(self, "oidc_policy")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        (string) - The ID of the federation policy. Output only
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.int:
        """
        (integer) - The service principal ID that this federation policy applies to. Output only. Only set for service principal federation policies
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Unique, immutable id of the federation policy
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        (string) - Last update time of the federation policy
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetAccountFederationPoliciesPolicyOidcPolicyResult(dict):
    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_json: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 subject_claim: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] audiences: (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
               The audience identifier is intended to represent the recipient of the token.
               Can be any non-empty string value. As long as the audience in the token matches
               at least one audience in the policy, the token is considered a match. If audiences
               is unspecified, defaults to your Databricks account id
        :param _builtins.str issuer: (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        :param _builtins.str jwks_json: (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
               Most use cases should not need to specify this field. If jwks_uri and jwks_json
               are both unspecified (recommended), Databricks automatically fetches the public
               keys from your issuers well known endpoint. Databricks strongly recommends
               relying on your issuers well known endpoint for discovering public keys
        :param _builtins.str jwks_uri: (string) - URL of the public keys used to validate the signature of federated tokens, in
               JWKS format. Most use cases should not need to specify this field. If jwks_uri
               and jwks_json are both unspecified (recommended), Databricks automatically
               fetches the public keys from your issuers well known endpoint. Databricks
               strongly recommends relying on your issuers well known endpoint for discovering
               public keys
        :param _builtins.str subject: (string) - The required token subject, as specified in the subject claim of federated tokens.
               Must be specified for service principal federation policies. Must not be specified
               for account federation policies
        :param _builtins.str subject_claim: (string) - The claim that contains the subject of the token. If unspecified, the default value
               is 'sub'
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_json is not None:
            pulumi.set(__self__, "jwks_json", jwks_json)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_claim is not None:
            pulumi.set(__self__, "subject_claim", subject_claim)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
        The audience identifier is intended to represent the recipient of the token.
        Can be any non-empty string value. As long as the audience in the token matches
        at least one audience in the policy, the token is considered a match. If audiences
        is unspecified, defaults to your Databricks account id
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksJson")
    def jwks_json(self) -> Optional[_builtins.str]:
        """
        (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
        Most use cases should not need to specify this field. If jwks_uri and jwks_json
        are both unspecified (recommended), Databricks automatically fetches the public
        keys from your issuers well known endpoint. Databricks strongly recommends
        relying on your issuers well known endpoint for discovering public keys
        """
        return pulumi.get(self, "jwks_json")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        (string) - URL of the public keys used to validate the signature of federated tokens, in
        JWKS format. Most use cases should not need to specify this field. If jwks_uri
        and jwks_json are both unspecified (recommended), Databricks automatically
        fetches the public keys from your issuers well known endpoint. Databricks
        strongly recommends relying on your issuers well known endpoint for discovering
        public keys
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        (string) - The required token subject, as specified in the subject claim of federated tokens.
        Must be specified for service principal federation policies. Must not be specified
        for account federation policies
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="subjectClaim")
    def subject_claim(self) -> Optional[_builtins.str]:
        """
        (string) - The claim that contains the subject of the token. If unspecified, the default value
        is 'sub'
        """
        return pulumi.get(self, "subject_claim")


@pulumi.output_type
class GetAccountFederationPolicyOidcPolicyResult(dict):
    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_json: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 subject_claim: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] audiences: (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
               The audience identifier is intended to represent the recipient of the token.
               Can be any non-empty string value. As long as the audience in the token matches
               at least one audience in the policy, the token is considered a match. If audiences
               is unspecified, defaults to your Databricks account id
        :param _builtins.str issuer: (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        :param _builtins.str jwks_json: (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
               Most use cases should not need to specify this field. If jwks_uri and jwks_json
               are both unspecified (recommended), Databricks automatically fetches the public
               keys from your issuers well known endpoint. Databricks strongly recommends
               relying on your issuers well known endpoint for discovering public keys
        :param _builtins.str jwks_uri: (string) - URL of the public keys used to validate the signature of federated tokens, in
               JWKS format. Most use cases should not need to specify this field. If jwks_uri
               and jwks_json are both unspecified (recommended), Databricks automatically
               fetches the public keys from your issuers well known endpoint. Databricks
               strongly recommends relying on your issuers well known endpoint for discovering
               public keys
        :param _builtins.str subject: (string) - The required token subject, as specified in the subject claim of federated tokens.
               Must be specified for service principal federation policies. Must not be specified
               for account federation policies
        :param _builtins.str subject_claim: (string) - The claim that contains the subject of the token. If unspecified, the default value
               is 'sub'
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_json is not None:
            pulumi.set(__self__, "jwks_json", jwks_json)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_claim is not None:
            pulumi.set(__self__, "subject_claim", subject_claim)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
        The audience identifier is intended to represent the recipient of the token.
        Can be any non-empty string value. As long as the audience in the token matches
        at least one audience in the policy, the token is considered a match. If audiences
        is unspecified, defaults to your Databricks account id
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksJson")
    def jwks_json(self) -> Optional[_builtins.str]:
        """
        (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
        Most use cases should not need to specify this field. If jwks_uri and jwks_json
        are both unspecified (recommended), Databricks automatically fetches the public
        keys from your issuers well known endpoint. Databricks strongly recommends
        relying on your issuers well known endpoint for discovering public keys
        """
        return pulumi.get(self, "jwks_json")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        (string) - URL of the public keys used to validate the signature of federated tokens, in
        JWKS format. Most use cases should not need to specify this field. If jwks_uri
        and jwks_json are both unspecified (recommended), Databricks automatically
        fetches the public keys from your issuers well known endpoint. Databricks
        strongly recommends relying on your issuers well known endpoint for discovering
        public keys
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        (string) - The required token subject, as specified in the subject claim of federated tokens.
        Must be specified for service principal federation policies. Must not be specified
        for account federation policies
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="subjectClaim")
    def subject_claim(self) -> Optional[_builtins.str]:
        """
        (string) - The claim that contains the subject of the token. If unspecified, the default value
        is 'sub'
        """
        return pulumi.get(self, "subject_claim")


@pulumi.output_type
class GetAccountNetworkPoliciesItemResult(dict):
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 egress: 'outputs.GetAccountNetworkPoliciesItemEgressResult',
                 network_policy_id: _builtins.str):
        """
        :param _builtins.str account_id: (string) - The associated account ID for this Network Policy object
        :param 'GetAccountNetworkPoliciesItemEgressArgs' egress: (NetworkPolicyEgress) - The network policies applying for egress traffic
        :param _builtins.str network_policy_id: (string) - The unique identifier for the network policy
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "egress", egress)
        pulumi.set(__self__, "network_policy_id", network_policy_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        (string) - The associated account ID for this Network Policy object
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> 'outputs.GetAccountNetworkPoliciesItemEgressResult':
        """
        (NetworkPolicyEgress) - The network policies applying for egress traffic
        """
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="networkPolicyId")
    def network_policy_id(self) -> _builtins.str:
        """
        (string) - The unique identifier for the network policy
        """
        return pulumi.get(self, "network_policy_id")


@pulumi.output_type
class GetAccountNetworkPoliciesItemEgressResult(dict):
    def __init__(__self__, *,
                 network_access: Optional['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessResult'] = None):
        """
        :param 'GetAccountNetworkPoliciesItemEgressNetworkAccessArgs' network_access: (EgressNetworkPolicyNetworkAccessPolicy) - The access policy enforced for egress traffic to the internet
        """
        if network_access is not None:
            pulumi.set(__self__, "network_access", network_access)

    @_builtins.property
    @pulumi.getter(name="networkAccess")
    def network_access(self) -> Optional['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessResult']:
        """
        (EgressNetworkPolicyNetworkAccessPolicy) - The access policy enforced for egress traffic to the internet
        """
        return pulumi.get(self, "network_access")


@pulumi.output_type
class GetAccountNetworkPoliciesItemEgressNetworkAccessResult(dict):
    def __init__(__self__, *,
                 restriction_mode: _builtins.str,
                 allowed_internet_destinations: Optional[Sequence['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedInternetDestinationResult']] = None,
                 allowed_storage_destinations: Optional[Sequence['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedStorageDestinationResult']] = None,
                 policy_enforcement: Optional['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessPolicyEnforcementResult'] = None):
        """
        :param _builtins.str restriction_mode: (string) - The restriction mode that controls how serverless workloads can access the internet. Possible values are: `FULL_ACCESS`, `RESTRICTED_ACCESS`
        :param Sequence['GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedInternetDestinationArgs'] allowed_internet_destinations: (list of EgressNetworkPolicyNetworkAccessPolicyInternetDestination) - List of internet destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        :param Sequence['GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedStorageDestinationArgs'] allowed_storage_destinations: (list of EgressNetworkPolicyNetworkAccessPolicyStorageDestination) - List of storage destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        :param 'GetAccountNetworkPoliciesItemEgressNetworkAccessPolicyEnforcementArgs' policy_enforcement: (EgressNetworkPolicyNetworkAccessPolicyPolicyEnforcement) - Optional. When policy_enforcement is not provided, we default to ENFORCE_MODE_ALL_SERVICES
        """
        pulumi.set(__self__, "restriction_mode", restriction_mode)
        if allowed_internet_destinations is not None:
            pulumi.set(__self__, "allowed_internet_destinations", allowed_internet_destinations)
        if allowed_storage_destinations is not None:
            pulumi.set(__self__, "allowed_storage_destinations", allowed_storage_destinations)
        if policy_enforcement is not None:
            pulumi.set(__self__, "policy_enforcement", policy_enforcement)

    @_builtins.property
    @pulumi.getter(name="restrictionMode")
    def restriction_mode(self) -> _builtins.str:
        """
        (string) - The restriction mode that controls how serverless workloads can access the internet. Possible values are: `FULL_ACCESS`, `RESTRICTED_ACCESS`
        """
        return pulumi.get(self, "restriction_mode")

    @_builtins.property
    @pulumi.getter(name="allowedInternetDestinations")
    def allowed_internet_destinations(self) -> Optional[Sequence['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedInternetDestinationResult']]:
        """
        (list of EgressNetworkPolicyNetworkAccessPolicyInternetDestination) - List of internet destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        """
        return pulumi.get(self, "allowed_internet_destinations")

    @_builtins.property
    @pulumi.getter(name="allowedStorageDestinations")
    def allowed_storage_destinations(self) -> Optional[Sequence['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedStorageDestinationResult']]:
        """
        (list of EgressNetworkPolicyNetworkAccessPolicyStorageDestination) - List of storage destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        """
        return pulumi.get(self, "allowed_storage_destinations")

    @_builtins.property
    @pulumi.getter(name="policyEnforcement")
    def policy_enforcement(self) -> Optional['outputs.GetAccountNetworkPoliciesItemEgressNetworkAccessPolicyEnforcementResult']:
        """
        (EgressNetworkPolicyNetworkAccessPolicyPolicyEnforcement) - Optional. When policy_enforcement is not provided, we default to ENFORCE_MODE_ALL_SERVICES
        """
        return pulumi.get(self, "policy_enforcement")


@pulumi.output_type
class GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedInternetDestinationResult(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 internet_destination_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: (string) - The internet destination to which access will be allowed. Format dependent on the destination type
        :param _builtins.str internet_destination_type: (string) - The type of internet destination. Currently only DNS_NAME is supported. Possible values are: `DNS_NAME`
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if internet_destination_type is not None:
            pulumi.set(__self__, "internet_destination_type", internet_destination_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        (string) - The internet destination to which access will be allowed. Format dependent on the destination type
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="internetDestinationType")
    def internet_destination_type(self) -> Optional[_builtins.str]:
        """
        (string) - The type of internet destination. Currently only DNS_NAME is supported. Possible values are: `DNS_NAME`
        """
        return pulumi.get(self, "internet_destination_type")


@pulumi.output_type
class GetAccountNetworkPoliciesItemEgressNetworkAccessAllowedStorageDestinationResult(dict):
    def __init__(__self__, *,
                 azure_storage_account: Optional[_builtins.str] = None,
                 azure_storage_service: Optional[_builtins.str] = None,
                 bucket_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 storage_destination_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str azure_storage_account: (string) - The Azure storage account name
        :param _builtins.str azure_storage_service: (string) - The Azure storage service type (blob, dfs, etc.)
        :param _builtins.str bucket_name: (string)
        :param _builtins.str region: (string)
        :param _builtins.str storage_destination_type: (string) - The type of storage destination. Possible values are: `AWS_S3`, `AZURE_STORAGE`, `GOOGLE_CLOUD_STORAGE`
        """
        if azure_storage_account is not None:
            pulumi.set(__self__, "azure_storage_account", azure_storage_account)
        if azure_storage_service is not None:
            pulumi.set(__self__, "azure_storage_service", azure_storage_service)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_destination_type is not None:
            pulumi.set(__self__, "storage_destination_type", storage_destination_type)

    @_builtins.property
    @pulumi.getter(name="azureStorageAccount")
    def azure_storage_account(self) -> Optional[_builtins.str]:
        """
        (string) - The Azure storage account name
        """
        return pulumi.get(self, "azure_storage_account")

    @_builtins.property
    @pulumi.getter(name="azureStorageService")
    def azure_storage_service(self) -> Optional[_builtins.str]:
        """
        (string) - The Azure storage service type (blob, dfs, etc.)
        """
        return pulumi.get(self, "azure_storage_service")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="storageDestinationType")
    def storage_destination_type(self) -> Optional[_builtins.str]:
        """
        (string) - The type of storage destination. Possible values are: `AWS_S3`, `AZURE_STORAGE`, `GOOGLE_CLOUD_STORAGE`
        """
        return pulumi.get(self, "storage_destination_type")


@pulumi.output_type
class GetAccountNetworkPoliciesItemEgressNetworkAccessPolicyEnforcementResult(dict):
    def __init__(__self__, *,
                 dry_run_mode_product_filters: Optional[Sequence[_builtins.str]] = None,
                 enforcement_mode: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dry_run_mode_product_filters: (list of string) - When empty, it means dry run for all products.
               When non-empty, it means dry run for specific products and for the other products, they will run in enforced mode
        :param _builtins.str enforcement_mode: (string) - The mode of policy enforcement. ENFORCED blocks traffic that violates policy,
               while DRY_RUN only logs violations without blocking. When not specified,
               defaults to ENFORCED. Possible values are: `DRY_RUN`, `ENFORCED`
        """
        if dry_run_mode_product_filters is not None:
            pulumi.set(__self__, "dry_run_mode_product_filters", dry_run_mode_product_filters)
        if enforcement_mode is not None:
            pulumi.set(__self__, "enforcement_mode", enforcement_mode)

    @_builtins.property
    @pulumi.getter(name="dryRunModeProductFilters")
    def dry_run_mode_product_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - When empty, it means dry run for all products.
        When non-empty, it means dry run for specific products and for the other products, they will run in enforced mode
        """
        return pulumi.get(self, "dry_run_mode_product_filters")

    @_builtins.property
    @pulumi.getter(name="enforcementMode")
    def enforcement_mode(self) -> Optional[_builtins.str]:
        """
        (string) - The mode of policy enforcement. ENFORCED blocks traffic that violates policy,
        while DRY_RUN only logs violations without blocking. When not specified,
        defaults to ENFORCED. Possible values are: `DRY_RUN`, `ENFORCED`
        """
        return pulumi.get(self, "enforcement_mode")


@pulumi.output_type
class GetAccountNetworkPolicyEgressResult(dict):
    def __init__(__self__, *,
                 network_access: Optional['outputs.GetAccountNetworkPolicyEgressNetworkAccessResult'] = None):
        """
        :param 'GetAccountNetworkPolicyEgressNetworkAccessArgs' network_access: (EgressNetworkPolicyNetworkAccessPolicy) - The access policy enforced for egress traffic to the internet
        """
        if network_access is not None:
            pulumi.set(__self__, "network_access", network_access)

    @_builtins.property
    @pulumi.getter(name="networkAccess")
    def network_access(self) -> Optional['outputs.GetAccountNetworkPolicyEgressNetworkAccessResult']:
        """
        (EgressNetworkPolicyNetworkAccessPolicy) - The access policy enforced for egress traffic to the internet
        """
        return pulumi.get(self, "network_access")


@pulumi.output_type
class GetAccountNetworkPolicyEgressNetworkAccessResult(dict):
    def __init__(__self__, *,
                 restriction_mode: _builtins.str,
                 allowed_internet_destinations: Optional[Sequence['outputs.GetAccountNetworkPolicyEgressNetworkAccessAllowedInternetDestinationResult']] = None,
                 allowed_storage_destinations: Optional[Sequence['outputs.GetAccountNetworkPolicyEgressNetworkAccessAllowedStorageDestinationResult']] = None,
                 policy_enforcement: Optional['outputs.GetAccountNetworkPolicyEgressNetworkAccessPolicyEnforcementResult'] = None):
        """
        :param _builtins.str restriction_mode: (string) - The restriction mode that controls how serverless workloads can access the internet. Possible values are: `FULL_ACCESS`, `RESTRICTED_ACCESS`
        :param Sequence['GetAccountNetworkPolicyEgressNetworkAccessAllowedInternetDestinationArgs'] allowed_internet_destinations: (list of EgressNetworkPolicyNetworkAccessPolicyInternetDestination) - List of internet destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        :param Sequence['GetAccountNetworkPolicyEgressNetworkAccessAllowedStorageDestinationArgs'] allowed_storage_destinations: (list of EgressNetworkPolicyNetworkAccessPolicyStorageDestination) - List of storage destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        :param 'GetAccountNetworkPolicyEgressNetworkAccessPolicyEnforcementArgs' policy_enforcement: (EgressNetworkPolicyNetworkAccessPolicyPolicyEnforcement) - Optional. When policy_enforcement is not provided, we default to ENFORCE_MODE_ALL_SERVICES
        """
        pulumi.set(__self__, "restriction_mode", restriction_mode)
        if allowed_internet_destinations is not None:
            pulumi.set(__self__, "allowed_internet_destinations", allowed_internet_destinations)
        if allowed_storage_destinations is not None:
            pulumi.set(__self__, "allowed_storage_destinations", allowed_storage_destinations)
        if policy_enforcement is not None:
            pulumi.set(__self__, "policy_enforcement", policy_enforcement)

    @_builtins.property
    @pulumi.getter(name="restrictionMode")
    def restriction_mode(self) -> _builtins.str:
        """
        (string) - The restriction mode that controls how serverless workloads can access the internet. Possible values are: `FULL_ACCESS`, `RESTRICTED_ACCESS`
        """
        return pulumi.get(self, "restriction_mode")

    @_builtins.property
    @pulumi.getter(name="allowedInternetDestinations")
    def allowed_internet_destinations(self) -> Optional[Sequence['outputs.GetAccountNetworkPolicyEgressNetworkAccessAllowedInternetDestinationResult']]:
        """
        (list of EgressNetworkPolicyNetworkAccessPolicyInternetDestination) - List of internet destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        """
        return pulumi.get(self, "allowed_internet_destinations")

    @_builtins.property
    @pulumi.getter(name="allowedStorageDestinations")
    def allowed_storage_destinations(self) -> Optional[Sequence['outputs.GetAccountNetworkPolicyEgressNetworkAccessAllowedStorageDestinationResult']]:
        """
        (list of EgressNetworkPolicyNetworkAccessPolicyStorageDestination) - List of storage destinations that serverless workloads are allowed to access when in RESTRICTED_ACCESS mode
        """
        return pulumi.get(self, "allowed_storage_destinations")

    @_builtins.property
    @pulumi.getter(name="policyEnforcement")
    def policy_enforcement(self) -> Optional['outputs.GetAccountNetworkPolicyEgressNetworkAccessPolicyEnforcementResult']:
        """
        (EgressNetworkPolicyNetworkAccessPolicyPolicyEnforcement) - Optional. When policy_enforcement is not provided, we default to ENFORCE_MODE_ALL_SERVICES
        """
        return pulumi.get(self, "policy_enforcement")


@pulumi.output_type
class GetAccountNetworkPolicyEgressNetworkAccessAllowedInternetDestinationResult(dict):
    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 internet_destination_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination: (string) - The internet destination to which access will be allowed. Format dependent on the destination type
        :param _builtins.str internet_destination_type: (string) - The type of internet destination. Currently only DNS_NAME is supported. Possible values are: `DNS_NAME`
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if internet_destination_type is not None:
            pulumi.set(__self__, "internet_destination_type", internet_destination_type)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        (string) - The internet destination to which access will be allowed. Format dependent on the destination type
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="internetDestinationType")
    def internet_destination_type(self) -> Optional[_builtins.str]:
        """
        (string) - The type of internet destination. Currently only DNS_NAME is supported. Possible values are: `DNS_NAME`
        """
        return pulumi.get(self, "internet_destination_type")


@pulumi.output_type
class GetAccountNetworkPolicyEgressNetworkAccessAllowedStorageDestinationResult(dict):
    def __init__(__self__, *,
                 azure_storage_account: Optional[_builtins.str] = None,
                 azure_storage_service: Optional[_builtins.str] = None,
                 bucket_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 storage_destination_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str azure_storage_account: (string) - The Azure storage account name
        :param _builtins.str azure_storage_service: (string) - The Azure storage service type (blob, dfs, etc.)
        :param _builtins.str bucket_name: (string)
        :param _builtins.str region: (string)
        :param _builtins.str storage_destination_type: (string) - The type of storage destination. Possible values are: `AWS_S3`, `AZURE_STORAGE`, `GOOGLE_CLOUD_STORAGE`
        """
        if azure_storage_account is not None:
            pulumi.set(__self__, "azure_storage_account", azure_storage_account)
        if azure_storage_service is not None:
            pulumi.set(__self__, "azure_storage_service", azure_storage_service)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_destination_type is not None:
            pulumi.set(__self__, "storage_destination_type", storage_destination_type)

    @_builtins.property
    @pulumi.getter(name="azureStorageAccount")
    def azure_storage_account(self) -> Optional[_builtins.str]:
        """
        (string) - The Azure storage account name
        """
        return pulumi.get(self, "azure_storage_account")

    @_builtins.property
    @pulumi.getter(name="azureStorageService")
    def azure_storage_service(self) -> Optional[_builtins.str]:
        """
        (string) - The Azure storage service type (blob, dfs, etc.)
        """
        return pulumi.get(self, "azure_storage_service")

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="storageDestinationType")
    def storage_destination_type(self) -> Optional[_builtins.str]:
        """
        (string) - The type of storage destination. Possible values are: `AWS_S3`, `AZURE_STORAGE`, `GOOGLE_CLOUD_STORAGE`
        """
        return pulumi.get(self, "storage_destination_type")


@pulumi.output_type
class GetAccountNetworkPolicyEgressNetworkAccessPolicyEnforcementResult(dict):
    def __init__(__self__, *,
                 dry_run_mode_product_filters: Optional[Sequence[_builtins.str]] = None,
                 enforcement_mode: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] dry_run_mode_product_filters: (list of string) - When empty, it means dry run for all products.
               When non-empty, it means dry run for specific products and for the other products, they will run in enforced mode
        :param _builtins.str enforcement_mode: (string) - The mode of policy enforcement. ENFORCED blocks traffic that violates policy,
               while DRY_RUN only logs violations without blocking. When not specified,
               defaults to ENFORCED. Possible values are: `DRY_RUN`, `ENFORCED`
        """
        if dry_run_mode_product_filters is not None:
            pulumi.set(__self__, "dry_run_mode_product_filters", dry_run_mode_product_filters)
        if enforcement_mode is not None:
            pulumi.set(__self__, "enforcement_mode", enforcement_mode)

    @_builtins.property
    @pulumi.getter(name="dryRunModeProductFilters")
    def dry_run_mode_product_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - When empty, it means dry run for all products.
        When non-empty, it means dry run for specific products and for the other products, they will run in enforced mode
        """
        return pulumi.get(self, "dry_run_mode_product_filters")

    @_builtins.property
    @pulumi.getter(name="enforcementMode")
    def enforcement_mode(self) -> Optional[_builtins.str]:
        """
        (string) - The mode of policy enforcement. ENFORCED blocks traffic that violates policy,
        while DRY_RUN only logs violations without blocking. When not specified,
        defaults to ENFORCED. Possible values are: `DRY_RUN`, `ENFORCED`
        """
        return pulumi.get(self, "enforcement_mode")


@pulumi.output_type
class GetAccountSettingV2AibiDashboardEmbeddingAccessPolicyResult(dict):
    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class GetAccountSettingV2AibiDashboardEmbeddingApprovedDomainsResult(dict):
    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] approved_domains: (list of string)
        """
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string)
        """
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class GetAccountSettingV2AutomaticClusterUpdateWorkspaceResult(dict):
    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult'] = None,
                 maintenance_window: Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool can_toggle: (boolean)
        :param _builtins.bool enabled: (boolean)
        :param 'GetAccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsArgs' enablement_details: (ClusterAutoRestartMessageEnablementDetails)
        :param 'GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowArgs' maintenance_window: (ClusterAutoRestartMessageMaintenanceWindow)
        :param _builtins.bool restart_even_if_no_updates_available: (boolean)
        """
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult']:
        """
        (ClusterAutoRestartMessageEnablementDetails)
        """
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindow)
        """
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class GetAccountSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult(dict):
    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: (boolean) - The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult'] = None):
        """
        :param 'GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs' week_day_based_schedule: (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult(dict):
    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult'] = None):
        """
        :param _builtins.str day_of_week: (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        :param 'GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs' window_start_time: (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetAccountSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: (integer)
        :param _builtins.int minutes: (integer)
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetAccountSettingV2BooleanValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2EffectiveAibiDashboardEmbeddingAccessPolicyResult(dict):
    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class GetAccountSettingV2EffectiveAibiDashboardEmbeddingApprovedDomainsResult(dict):
    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] approved_domains: (list of string)
        """
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string)
        """
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceResult(dict):
    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult'] = None,
                 maintenance_window: Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool can_toggle: (boolean)
        :param _builtins.bool enabled: (boolean)
        :param 'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsArgs' enablement_details: (ClusterAutoRestartMessageEnablementDetails)
        :param 'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs' maintenance_window: (ClusterAutoRestartMessageMaintenanceWindow)
        :param _builtins.bool restart_even_if_no_updates_available: (boolean)
        """
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult']:
        """
        (ClusterAutoRestartMessageEnablementDetails)
        """
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindow)
        """
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult(dict):
    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: (boolean) - The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult'] = None):
        """
        :param 'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs' week_day_based_schedule: (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult(dict):
    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult'] = None):
        """
        :param _builtins.str day_of_week: (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        :param 'GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs' window_start_time: (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetAccountSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: (integer)
        :param _builtins.int minutes: (integer)
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetAccountSettingV2EffectiveBooleanValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2EffectiveIntegerValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2EffectivePersonalComputeResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2EffectiveRestrictWorkspaceAdminsResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAccountSettingV2EffectiveStringValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2IntegerValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2PersonalComputeResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAccountSettingV2RestrictWorkspaceAdminsResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAccountSettingV2StringValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertV2EffectiveRunAsResult(dict):
    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        :param _builtins.str user_name: (string) - The email of an active workspace user. Can only set this field to their own email
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        (string) - The email of an active workspace user. Can only set this field to their own email
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetAlertV2EvaluationResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 last_evaluated_at: _builtins.str,
                 source: 'outputs.GetAlertV2EvaluationSourceResult',
                 state: _builtins.str,
                 empty_result_state: Optional[_builtins.str] = None,
                 notification: Optional['outputs.GetAlertV2EvaluationNotificationResult'] = None,
                 threshold: Optional['outputs.GetAlertV2EvaluationThresholdResult'] = None):
        """
        :param _builtins.str comparison_operator: (string) - Operator used for comparison in alert evaluation. Possible values are: `EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`
        :param _builtins.str last_evaluated_at: (string) - Timestamp of the last evaluation
        :param 'GetAlertV2EvaluationSourceArgs' source: (AlertV2OperandColumn) - Source column from result to use to evaluate alert
        :param _builtins.str state: (string) - Latest state of alert evaluation. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        :param _builtins.str empty_result_state: (string) - Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        :param 'GetAlertV2EvaluationNotificationArgs' notification: (AlertV2Notification) - User or Notification Destination to notify when alert is triggered
        :param 'GetAlertV2EvaluationThresholdArgs' threshold: (AlertV2Operand) - Threshold to user for alert evaluation, can be a column or a value
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "last_evaluated_at", last_evaluated_at)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "state", state)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        (string) - Operator used for comparison in alert evaluation. Possible values are: `EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter(name="lastEvaluatedAt")
    def last_evaluated_at(self) -> _builtins.str:
        """
        (string) - Timestamp of the last evaluation
        """
        return pulumi.get(self, "last_evaluated_at")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.GetAlertV2EvaluationSourceResult':
        """
        (AlertV2OperandColumn) - Source column from result to use to evaluate alert
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - Latest state of alert evaluation. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[_builtins.str]:
        """
        (string) - Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        """
        return pulumi.get(self, "empty_result_state")

    @_builtins.property
    @pulumi.getter
    def notification(self) -> Optional['outputs.GetAlertV2EvaluationNotificationResult']:
        """
        (AlertV2Notification) - User or Notification Destination to notify when alert is triggered
        """
        return pulumi.get(self, "notification")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.GetAlertV2EvaluationThresholdResult']:
        """
        (AlertV2Operand) - Threshold to user for alert evaluation, can be a column or a value
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetAlertV2EvaluationNotificationResult(dict):
    def __init__(__self__, *,
                 effective_notify_on_ok: _builtins.bool,
                 effective_retrigger_seconds: _builtins.int,
                 notify_on_ok: Optional[_builtins.bool] = None,
                 retrigger_seconds: Optional[_builtins.int] = None,
                 subscriptions: Optional[Sequence['outputs.GetAlertV2EvaluationNotificationSubscriptionResult']] = None):
        """
        :param _builtins.bool notify_on_ok: (boolean) - Whether to notify alert subscribers when alert returns back to normal
        :param _builtins.int retrigger_seconds: (integer) - Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again
        :param Sequence['GetAlertV2EvaluationNotificationSubscriptionArgs'] subscriptions: (list of AlertV2Subscription)
        """
        pulumi.set(__self__, "effective_notify_on_ok", effective_notify_on_ok)
        pulumi.set(__self__, "effective_retrigger_seconds", effective_retrigger_seconds)
        if notify_on_ok is not None:
            pulumi.set(__self__, "notify_on_ok", notify_on_ok)
        if retrigger_seconds is not None:
            pulumi.set(__self__, "retrigger_seconds", retrigger_seconds)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="effectiveNotifyOnOk")
    def effective_notify_on_ok(self) -> _builtins.bool:
        return pulumi.get(self, "effective_notify_on_ok")

    @_builtins.property
    @pulumi.getter(name="effectiveRetriggerSeconds")
    def effective_retrigger_seconds(self) -> _builtins.int:
        return pulumi.get(self, "effective_retrigger_seconds")

    @_builtins.property
    @pulumi.getter(name="notifyOnOk")
    def notify_on_ok(self) -> Optional[_builtins.bool]:
        """
        (boolean) - Whether to notify alert subscribers when alert returns back to normal
        """
        return pulumi.get(self, "notify_on_ok")

    @_builtins.property
    @pulumi.getter(name="retriggerSeconds")
    def retrigger_seconds(self) -> Optional[_builtins.int]:
        """
        (integer) - Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again
        """
        return pulumi.get(self, "retrigger_seconds")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.GetAlertV2EvaluationNotificationSubscriptionResult']]:
        """
        (list of AlertV2Subscription)
        """
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class GetAlertV2EvaluationNotificationSubscriptionResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_email: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: (string)
        :param _builtins.str user_email: (string)
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "user_email")


@pulumi.output_type
class GetAlertV2EvaluationSourceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 aggregation: Optional[_builtins.str] = None,
                 display: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (string)
        :param _builtins.str aggregation: (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        :param _builtins.str display: (string)
        """
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if display is not None:
            pulumi.set(__self__, "display", display)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "display")


@pulumi.output_type
class GetAlertV2EvaluationThresholdResult(dict):
    def __init__(__self__, *,
                 column: Optional['outputs.GetAlertV2EvaluationThresholdColumnResult'] = None,
                 value: Optional['outputs.GetAlertV2EvaluationThresholdValueResult'] = None):
        """
        :param 'GetAlertV2EvaluationThresholdColumnArgs' column: (AlertV2OperandColumn)
        :param 'GetAlertV2EvaluationThresholdValueArgs' value: (AlertV2OperandValue)
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional['outputs.GetAlertV2EvaluationThresholdColumnResult']:
        """
        (AlertV2OperandColumn)
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.GetAlertV2EvaluationThresholdValueResult']:
        """
        (AlertV2OperandValue)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertV2EvaluationThresholdColumnResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 aggregation: Optional[_builtins.str] = None,
                 display: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (string)
        :param _builtins.str aggregation: (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        :param _builtins.str display: (string)
        """
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if display is not None:
            pulumi.set(__self__, "display", display)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "display")


@pulumi.output_type
class GetAlertV2EvaluationThresholdValueResult(dict):
    def __init__(__self__, *,
                 bool_value: Optional[_builtins.bool] = None,
                 double_value: Optional[_builtins.float] = None,
                 string_value: Optional[_builtins.str] = None):
        """
        :param _builtins.bool bool_value: (boolean)
        :param _builtins.float double_value: (number)
        :param _builtins.str string_value: (string)
        """
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "bool_value")

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[_builtins.float]:
        """
        (number)
        """
        return pulumi.get(self, "double_value")

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class GetAlertV2RunAsResult(dict):
    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        :param _builtins.str user_name: (string) - The email of an active workspace user. Can only set this field to their own email
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        (string) - The email of an active workspace user. Can only set this field to their own email
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetAlertV2ScheduleResult(dict):
    def __init__(__self__, *,
                 quartz_cron_schedule: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_schedule: (string) - A cron expression using quartz syntax that specifies the schedule for this pipeline.
               Should use the quartz format described here: http://www.quartz-scheduler.org/documentation/quartz-2.1.7/tutorials/tutorial-lesson-06.html
        :param _builtins.str timezone_id: (string) - A Java timezone id. The schedule will be resolved using this timezone.
               This will be combined with the quartz_cron_schedule to determine the schedule.
               See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details
        :param _builtins.str pause_status: (string) - Indicate whether this schedule is paused or not. Possible values are: `PAUSED`, `UNPAUSED`
        """
        pulumi.set(__self__, "quartz_cron_schedule", quartz_cron_schedule)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronSchedule")
    def quartz_cron_schedule(self) -> _builtins.str:
        """
        (string) - A cron expression using quartz syntax that specifies the schedule for this pipeline.
        Should use the quartz format described here: http://www.quartz-scheduler.org/documentation/quartz-2.1.7/tutorials/tutorial-lesson-06.html
        """
        return pulumi.get(self, "quartz_cron_schedule")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        (string) - A Java timezone id. The schedule will be resolved using this timezone.
        This will be combined with the quartz_cron_schedule to determine the schedule.
        See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        (string) - Indicate whether this schedule is paused or not. Possible values are: `PAUSED`, `UNPAUSED`
        """
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class GetAlertsV2AlertResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 custom_description: _builtins.str,
                 custom_summary: _builtins.str,
                 display_name: _builtins.str,
                 effective_run_as: 'outputs.GetAlertsV2AlertEffectiveRunAsResult',
                 evaluation: 'outputs.GetAlertsV2AlertEvaluationResult',
                 id: _builtins.str,
                 lifecycle_state: _builtins.str,
                 owner_user_name: _builtins.str,
                 parent_path: _builtins.str,
                 query_text: _builtins.str,
                 run_as: 'outputs.GetAlertsV2AlertRunAsResult',
                 run_as_user_name: _builtins.str,
                 schedule: 'outputs.GetAlertsV2AlertScheduleResult',
                 update_time: _builtins.str,
                 warehouse_id: _builtins.str):
        """
        :param _builtins.str create_time: (string) - The timestamp indicating when the alert was created
        :param _builtins.str custom_description: (string) - Custom description for the alert. support mustache template
        :param _builtins.str custom_summary: (string) - Custom summary for the alert. support mustache template
        :param _builtins.str display_name: (string) - The display name of the alert
        :param 'GetAlertsV2AlertEffectiveRunAsArgs' effective_run_as: (AlertV2RunAs) - The actual identity that will be used to execute the alert.
               This is an output-only field that shows the resolved run-as identity after applying
               permissions and defaults
        :param 'GetAlertsV2AlertEvaluationArgs' evaluation: (AlertV2Evaluation)
        :param _builtins.str id: (string) - UUID identifying the alert
        :param _builtins.str lifecycle_state: (string) - Indicates whether the query is trashed. Possible values are: `ACTIVE`, `DELETED`
        :param _builtins.str owner_user_name: (string) - The owner's username. This field is set to "Unavailable" if the user has been deleted
        :param _builtins.str parent_path: (string) - The workspace path of the folder containing the alert. Can only be set on create, and cannot be updated
        :param _builtins.str query_text: (string) - Text of the query to be run
        :param 'GetAlertsV2AlertRunAsArgs' run_as: (AlertV2RunAs) - Specifies the identity that will be used to run the alert.
               This field allows you to configure alerts to run as a specific user or service principal.
               - For user identity: Set `user_name` to the email of an active workspace user. Users can only set this to their own email.
               - For service principal: Set `service_principal_name` to the application ID. Requires the `servicePrincipal/user` role.
               If not specified, the alert will run as the request user
        :param _builtins.str run_as_user_name: (string, deprecated) - The run as username or application ID of service principal.
               On Create and Update, this field can be set to application ID of an active service principal. Setting this field requires the servicePrincipal/user role.
               Deprecated: Use `run_as` field instead. This field will be removed in a future release
        :param 'GetAlertsV2AlertScheduleArgs' schedule: (CronSchedule)
        :param _builtins.str update_time: (string) - The timestamp indicating when the alert was updated
        :param _builtins.str warehouse_id: (string) - ID of the SQL warehouse attached to the alert
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "custom_description", custom_description)
        pulumi.set(__self__, "custom_summary", custom_summary)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "effective_run_as", effective_run_as)
        pulumi.set(__self__, "evaluation", evaluation)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "lifecycle_state", lifecycle_state)
        pulumi.set(__self__, "owner_user_name", owner_user_name)
        pulumi.set(__self__, "parent_path", parent_path)
        pulumi.set(__self__, "query_text", query_text)
        pulumi.set(__self__, "run_as", run_as)
        pulumi.set(__self__, "run_as_user_name", run_as_user_name)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        (string) - The timestamp indicating when the alert was created
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="customDescription")
    def custom_description(self) -> _builtins.str:
        """
        (string) - Custom description for the alert. support mustache template
        """
        return pulumi.get(self, "custom_description")

    @_builtins.property
    @pulumi.getter(name="customSummary")
    def custom_summary(self) -> _builtins.str:
        """
        (string) - Custom summary for the alert. support mustache template
        """
        return pulumi.get(self, "custom_summary")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        (string) - The display name of the alert
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="effectiveRunAs")
    def effective_run_as(self) -> 'outputs.GetAlertsV2AlertEffectiveRunAsResult':
        """
        (AlertV2RunAs) - The actual identity that will be used to execute the alert.
        This is an output-only field that shows the resolved run-as identity after applying
        permissions and defaults
        """
        return pulumi.get(self, "effective_run_as")

    @_builtins.property
    @pulumi.getter
    def evaluation(self) -> 'outputs.GetAlertsV2AlertEvaluationResult':
        """
        (AlertV2Evaluation)
        """
        return pulumi.get(self, "evaluation")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (string) - UUID identifying the alert
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> _builtins.str:
        """
        (string) - Indicates whether the query is trashed. Possible values are: `ACTIVE`, `DELETED`
        """
        return pulumi.get(self, "lifecycle_state")

    @_builtins.property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> _builtins.str:
        """
        (string) - The owner's username. This field is set to "Unavailable" if the user has been deleted
        """
        return pulumi.get(self, "owner_user_name")

    @_builtins.property
    @pulumi.getter(name="parentPath")
    def parent_path(self) -> _builtins.str:
        """
        (string) - The workspace path of the folder containing the alert. Can only be set on create, and cannot be updated
        """
        return pulumi.get(self, "parent_path")

    @_builtins.property
    @pulumi.getter(name="queryText")
    def query_text(self) -> _builtins.str:
        """
        (string) - Text of the query to be run
        """
        return pulumi.get(self, "query_text")

    @_builtins.property
    @pulumi.getter(name="runAs")
    def run_as(self) -> 'outputs.GetAlertsV2AlertRunAsResult':
        """
        (AlertV2RunAs) - Specifies the identity that will be used to run the alert.
        This field allows you to configure alerts to run as a specific user or service principal.
        - For user identity: Set `user_name` to the email of an active workspace user. Users can only set this to their own email.
        - For service principal: Set `service_principal_name` to the application ID. Requires the `servicePrincipal/user` role.
        If not specified, the alert will run as the request user
        """
        return pulumi.get(self, "run_as")

    @_builtins.property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> _builtins.str:
        """
        (string, deprecated) - The run as username or application ID of service principal.
        On Create and Update, this field can be set to application ID of an active service principal. Setting this field requires the servicePrincipal/user role.
        Deprecated: Use `run_as` field instead. This field will be removed in a future release
        """
        return pulumi.get(self, "run_as_user_name")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.GetAlertsV2AlertScheduleResult':
        """
        (CronSchedule)
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        (string) - The timestamp indicating when the alert was updated
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> _builtins.str:
        """
        (string) - ID of the SQL warehouse attached to the alert
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetAlertsV2AlertEffectiveRunAsResult(dict):
    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        :param _builtins.str user_name: (string) - The email of an active workspace user. Can only set this field to their own email
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        (string) - The email of an active workspace user. Can only set this field to their own email
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetAlertsV2AlertEvaluationResult(dict):
    def __init__(__self__, *,
                 comparison_operator: _builtins.str,
                 last_evaluated_at: _builtins.str,
                 source: 'outputs.GetAlertsV2AlertEvaluationSourceResult',
                 state: _builtins.str,
                 empty_result_state: Optional[_builtins.str] = None,
                 notification: Optional['outputs.GetAlertsV2AlertEvaluationNotificationResult'] = None,
                 threshold: Optional['outputs.GetAlertsV2AlertEvaluationThresholdResult'] = None):
        """
        :param _builtins.str comparison_operator: (string) - Operator used for comparison in alert evaluation. Possible values are: `EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`
        :param _builtins.str last_evaluated_at: (string) - Timestamp of the last evaluation
        :param 'GetAlertsV2AlertEvaluationSourceArgs' source: (AlertV2OperandColumn) - Source column from result to use to evaluate alert
        :param _builtins.str state: (string) - Latest state of alert evaluation. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        :param _builtins.str empty_result_state: (string) - Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        :param 'GetAlertsV2AlertEvaluationNotificationArgs' notification: (AlertV2Notification) - User or Notification Destination to notify when alert is triggered
        :param 'GetAlertsV2AlertEvaluationThresholdArgs' threshold: (AlertV2Operand) - Threshold to user for alert evaluation, can be a column or a value
        """
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "last_evaluated_at", last_evaluated_at)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "state", state)
        if empty_result_state is not None:
            pulumi.set(__self__, "empty_result_state", empty_result_state)
        if notification is not None:
            pulumi.set(__self__, "notification", notification)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> _builtins.str:
        """
        (string) - Operator used for comparison in alert evaluation. Possible values are: `EQUAL`, `GREATER_THAN`, `GREATER_THAN_OR_EQUAL`, `IS_NOT_NULL`, `IS_NULL`, `LESS_THAN`, `LESS_THAN_OR_EQUAL`, `NOT_EQUAL`
        """
        return pulumi.get(self, "comparison_operator")

    @_builtins.property
    @pulumi.getter(name="lastEvaluatedAt")
    def last_evaluated_at(self) -> _builtins.str:
        """
        (string) - Timestamp of the last evaluation
        """
        return pulumi.get(self, "last_evaluated_at")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.GetAlertsV2AlertEvaluationSourceResult':
        """
        (AlertV2OperandColumn) - Source column from result to use to evaluate alert
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - Latest state of alert evaluation. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="emptyResultState")
    def empty_result_state(self) -> Optional[_builtins.str]:
        """
        (string) - Alert state if result is empty. Please avoid setting this field to be `UNKNOWN` because `UNKNOWN` state is planned to be deprecated. Possible values are: `ERROR`, `OK`, `TRIGGERED`, `UNKNOWN`
        """
        return pulumi.get(self, "empty_result_state")

    @_builtins.property
    @pulumi.getter
    def notification(self) -> Optional['outputs.GetAlertsV2AlertEvaluationNotificationResult']:
        """
        (AlertV2Notification) - User or Notification Destination to notify when alert is triggered
        """
        return pulumi.get(self, "notification")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.GetAlertsV2AlertEvaluationThresholdResult']:
        """
        (AlertV2Operand) - Threshold to user for alert evaluation, can be a column or a value
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetAlertsV2AlertEvaluationNotificationResult(dict):
    def __init__(__self__, *,
                 effective_notify_on_ok: _builtins.bool,
                 effective_retrigger_seconds: _builtins.int,
                 notify_on_ok: Optional[_builtins.bool] = None,
                 retrigger_seconds: Optional[_builtins.int] = None,
                 subscriptions: Optional[Sequence['outputs.GetAlertsV2AlertEvaluationNotificationSubscriptionResult']] = None):
        """
        :param _builtins.bool notify_on_ok: (boolean) - Whether to notify alert subscribers when alert returns back to normal
        :param _builtins.int retrigger_seconds: (integer) - Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again
        :param Sequence['GetAlertsV2AlertEvaluationNotificationSubscriptionArgs'] subscriptions: (list of AlertV2Subscription)
        """
        pulumi.set(__self__, "effective_notify_on_ok", effective_notify_on_ok)
        pulumi.set(__self__, "effective_retrigger_seconds", effective_retrigger_seconds)
        if notify_on_ok is not None:
            pulumi.set(__self__, "notify_on_ok", notify_on_ok)
        if retrigger_seconds is not None:
            pulumi.set(__self__, "retrigger_seconds", retrigger_seconds)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="effectiveNotifyOnOk")
    def effective_notify_on_ok(self) -> _builtins.bool:
        return pulumi.get(self, "effective_notify_on_ok")

    @_builtins.property
    @pulumi.getter(name="effectiveRetriggerSeconds")
    def effective_retrigger_seconds(self) -> _builtins.int:
        return pulumi.get(self, "effective_retrigger_seconds")

    @_builtins.property
    @pulumi.getter(name="notifyOnOk")
    def notify_on_ok(self) -> Optional[_builtins.bool]:
        """
        (boolean) - Whether to notify alert subscribers when alert returns back to normal
        """
        return pulumi.get(self, "notify_on_ok")

    @_builtins.property
    @pulumi.getter(name="retriggerSeconds")
    def retrigger_seconds(self) -> Optional[_builtins.int]:
        """
        (integer) - Number of seconds an alert must wait after being triggered to rearm itself. After rearming, it can be triggered again. If 0 or not specified, the alert will not be triggered again
        """
        return pulumi.get(self, "retrigger_seconds")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.GetAlertsV2AlertEvaluationNotificationSubscriptionResult']]:
        """
        (list of AlertV2Subscription)
        """
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class GetAlertsV2AlertEvaluationNotificationSubscriptionResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_email: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: (string)
        :param _builtins.str user_email: (string)
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_email is not None:
            pulumi.set(__self__, "user_email", user_email)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userEmail")
    def user_email(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "user_email")


@pulumi.output_type
class GetAlertsV2AlertEvaluationSourceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 aggregation: Optional[_builtins.str] = None,
                 display: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (string)
        :param _builtins.str aggregation: (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        :param _builtins.str display: (string)
        """
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if display is not None:
            pulumi.set(__self__, "display", display)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "display")


@pulumi.output_type
class GetAlertsV2AlertEvaluationThresholdResult(dict):
    def __init__(__self__, *,
                 column: Optional['outputs.GetAlertsV2AlertEvaluationThresholdColumnResult'] = None,
                 value: Optional['outputs.GetAlertsV2AlertEvaluationThresholdValueResult'] = None):
        """
        :param 'GetAlertsV2AlertEvaluationThresholdColumnArgs' column: (AlertV2OperandColumn)
        :param 'GetAlertsV2AlertEvaluationThresholdValueArgs' value: (AlertV2OperandValue)
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional['outputs.GetAlertsV2AlertEvaluationThresholdColumnResult']:
        """
        (AlertV2OperandColumn)
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['outputs.GetAlertsV2AlertEvaluationThresholdValueResult']:
        """
        (AlertV2OperandValue)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertsV2AlertEvaluationThresholdColumnResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 aggregation: Optional[_builtins.str] = None,
                 display: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (string)
        :param _builtins.str aggregation: (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        :param _builtins.str display: (string)
        """
        pulumi.set(__self__, "name", name)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if display is not None:
            pulumi.set(__self__, "display", display)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def aggregation(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `AVG`, `COUNT`, `COUNT_DISTINCT`, `MAX`, `MEDIAN`, `MIN`, `STDDEV`, `SUM`
        """
        return pulumi.get(self, "aggregation")

    @_builtins.property
    @pulumi.getter
    def display(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "display")


@pulumi.output_type
class GetAlertsV2AlertEvaluationThresholdValueResult(dict):
    def __init__(__self__, *,
                 bool_value: Optional[_builtins.bool] = None,
                 double_value: Optional[_builtins.float] = None,
                 string_value: Optional[_builtins.str] = None):
        """
        :param _builtins.bool bool_value: (boolean)
        :param _builtins.float double_value: (number)
        :param _builtins.str string_value: (string)
        """
        if bool_value is not None:
            pulumi.set(__self__, "bool_value", bool_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="boolValue")
    def bool_value(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "bool_value")

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[_builtins.float]:
        """
        (number)
        """
        return pulumi.get(self, "double_value")

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class GetAlertsV2AlertRunAsResult(dict):
    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_name: (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        :param _builtins.str user_name: (string) - The email of an active workspace user. Can only set this field to their own email
        """
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        """
        (string) - Application ID of an active service principal. Setting this field requires the `servicePrincipal/user` role
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        """
        (string) - The email of an active workspace user. Can only set this field to their own email
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetAlertsV2AlertScheduleResult(dict):
    def __init__(__self__, *,
                 quartz_cron_schedule: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        """
        :param _builtins.str quartz_cron_schedule: (string) - A cron expression using quartz syntax that specifies the schedule for this pipeline.
               Should use the quartz format described here: http://www.quartz-scheduler.org/documentation/quartz-2.1.7/tutorials/tutorial-lesson-06.html
        :param _builtins.str timezone_id: (string) - A Java timezone id. The schedule will be resolved using this timezone.
               This will be combined with the quartz_cron_schedule to determine the schedule.
               See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details
        :param _builtins.str pause_status: (string) - Indicate whether this schedule is paused or not. Possible values are: `PAUSED`, `UNPAUSED`
        """
        pulumi.set(__self__, "quartz_cron_schedule", quartz_cron_schedule)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronSchedule")
    def quartz_cron_schedule(self) -> _builtins.str:
        """
        (string) - A cron expression using quartz syntax that specifies the schedule for this pipeline.
        Should use the quartz format described here: http://www.quartz-scheduler.org/documentation/quartz-2.1.7/tutorials/tutorial-lesson-06.html
        """
        return pulumi.get(self, "quartz_cron_schedule")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        (string) - A Java timezone id. The schedule will be resolved using this timezone.
        This will be combined with the quartz_cron_schedule to determine the schedule.
        See https://docs.databricks.com/sql/language-manual/sql-ref-syntax-aux-conf-mgmt-set-timezone.html for details
        """
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        """
        (string) - Indicate whether this schedule is paused or not. Possible values are: `PAUSED`, `UNPAUSED`
        """
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class GetAppAppResult(dict):
    def __init__(__self__, *,
                 active_deployment: 'outputs.GetAppAppActiveDeploymentResult',
                 app_status: 'outputs.GetAppAppAppStatusResult',
                 compute_status: 'outputs.GetAppAppComputeStatusResult',
                 create_time: _builtins.str,
                 creator: _builtins.str,
                 default_source_code_path: _builtins.str,
                 effective_budget_policy_id: _builtins.str,
                 effective_user_api_scopes: Sequence[_builtins.str],
                 id: _builtins.str,
                 name: _builtins.str,
                 oauth2_app_client_id: _builtins.str,
                 oauth2_app_integration_id: _builtins.str,
                 pending_deployment: 'outputs.GetAppAppPendingDeploymentResult',
                 service_principal_client_id: _builtins.str,
                 service_principal_id: _builtins.int,
                 service_principal_name: _builtins.str,
                 update_time: _builtins.str,
                 updater: _builtins.str,
                 url: _builtins.str,
                 budget_policy_id: Optional[_builtins.str] = None,
                 compute_size: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 resources: Optional[Sequence['outputs.GetAppAppResourceResult']] = None,
                 user_api_scopes: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'GetAppAppAppStatusArgs' app_status: attribute
        :param 'GetAppAppComputeStatusArgs' compute_status: attribute
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str default_source_code_path: The default workspace file system path of the source code from which app deployment are created. This field tracks the workspace source code path of the last active deployment.
        :param _builtins.str effective_budget_policy_id: The effective budget policy ID.
        :param Sequence[_builtins.str] effective_user_api_scopes: A list of effective api scopes granted to the user access token.
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str name: The name of the app.
        :param _builtins.str service_principal_client_id: client_id (application_id) of the app service principal
        :param _builtins.int service_principal_id: id of the app service principal
        :param _builtins.str service_principal_name: name of the app service principal
        :param _builtins.str update_time: The update time of the app.
        :param _builtins.str updater: The email of the user that last updated the app.
        :param _builtins.str url: The URL of the app once it is deployed.
        :param _builtins.str budget_policy_id: The Budget Policy ID set for this resource.
        :param _builtins.str compute_size: (Optional) A string specifying compute size for the App.
        :param _builtins.str description: The description of the resource.
        :param Sequence['GetAppAppResourceArgs'] resources: A list of resources that the app have access to.
        """
        pulumi.set(__self__, "active_deployment", active_deployment)
        pulumi.set(__self__, "app_status", app_status)
        pulumi.set(__self__, "compute_status", compute_status)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "default_source_code_path", default_source_code_path)
        pulumi.set(__self__, "effective_budget_policy_id", effective_budget_policy_id)
        pulumi.set(__self__, "effective_user_api_scopes", effective_user_api_scopes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oauth2_app_client_id", oauth2_app_client_id)
        pulumi.set(__self__, "oauth2_app_integration_id", oauth2_app_integration_id)
        pulumi.set(__self__, "pending_deployment", pending_deployment)
        pulumi.set(__self__, "service_principal_client_id", service_principal_client_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_name", service_principal_name)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "updater", updater)
        pulumi.set(__self__, "url", url)
        if budget_policy_id is not None:
            pulumi.set(__self__, "budget_policy_id", budget_policy_id)
        if compute_size is not None:
            pulumi.set(__self__, "compute_size", compute_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if user_api_scopes is not None:
            pulumi.set(__self__, "user_api_scopes", user_api_scopes)

    @_builtins.property
    @pulumi.getter(name="activeDeployment")
    def active_deployment(self) -> 'outputs.GetAppAppActiveDeploymentResult':
        return pulumi.get(self, "active_deployment")

    @_builtins.property
    @pulumi.getter(name="appStatus")
    def app_status(self) -> 'outputs.GetAppAppAppStatusResult':
        """
        attribute
        """
        return pulumi.get(self, "app_status")

    @_builtins.property
    @pulumi.getter(name="computeStatus")
    def compute_status(self) -> 'outputs.GetAppAppComputeStatusResult':
        """
        attribute
        """
        return pulumi.get(self, "compute_status")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="defaultSourceCodePath")
    def default_source_code_path(self) -> _builtins.str:
        """
        The default workspace file system path of the source code from which app deployment are created. This field tracks the workspace source code path of the last active deployment.
        """
        return pulumi.get(self, "default_source_code_path")

    @_builtins.property
    @pulumi.getter(name="effectiveBudgetPolicyId")
    def effective_budget_policy_id(self) -> _builtins.str:
        """
        The effective budget policy ID.
        """
        return pulumi.get(self, "effective_budget_policy_id")

    @_builtins.property
    @pulumi.getter(name="effectiveUserApiScopes")
    def effective_user_api_scopes(self) -> Sequence[_builtins.str]:
        """
        A list of effective api scopes granted to the user access token.
        """
        return pulumi.get(self, "effective_user_api_scopes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oauth2AppClientId")
    def oauth2_app_client_id(self) -> _builtins.str:
        return pulumi.get(self, "oauth2_app_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2AppIntegrationId")
    def oauth2_app_integration_id(self) -> _builtins.str:
        return pulumi.get(self, "oauth2_app_integration_id")

    @_builtins.property
    @pulumi.getter(name="pendingDeployment")
    def pending_deployment(self) -> 'outputs.GetAppAppPendingDeploymentResult':
        return pulumi.get(self, "pending_deployment")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalClientId")
    def service_principal_client_id(self) -> _builtins.str:
        """
        client_id (application_id) of the app service principal
        """
        return pulumi.get(self, "service_principal_client_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.int:
        """
        id of the app service principal
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> _builtins.str:
        """
        name of the app service principal
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter
    def updater(self) -> _builtins.str:
        """
        The email of the user that last updated the app.
        """
        return pulumi.get(self, "updater")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the app once it is deployed.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="budgetPolicyId")
    def budget_policy_id(self) -> Optional[_builtins.str]:
        """
        The Budget Policy ID set for this resource.
        """
        return pulumi.get(self, "budget_policy_id")

    @_builtins.property
    @pulumi.getter(name="computeSize")
    def compute_size(self) -> Optional[_builtins.str]:
        """
        (Optional) A string specifying compute size for the App.
        """
        return pulumi.get(self, "compute_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.GetAppAppResourceResult']]:
        """
        A list of resources that the app have access to.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="userApiScopes")
    def user_api_scopes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "user_api_scopes")


@pulumi.output_type
class GetAppAppActiveDeploymentResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 creator: _builtins.str,
                 deployment_artifacts: 'outputs.GetAppAppActiveDeploymentDeploymentArtifactsResult',
                 status: 'outputs.GetAppAppActiveDeploymentStatusResult',
                 update_time: _builtins.str,
                 deployment_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source_code_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str update_time: The update time of the app.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "deployment_artifacts", deployment_artifacts)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="deploymentArtifacts")
    def deployment_artifacts(self) -> 'outputs.GetAppAppActiveDeploymentDeploymentArtifactsResult':
        return pulumi.get(self, "deployment_artifacts")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.GetAppAppActiveDeploymentStatusResult':
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppAppActiveDeploymentDeploymentArtifactsResult(dict):
    def __init__(__self__, *,
                 source_code_path: Optional[_builtins.str] = None):
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppAppActiveDeploymentStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppAppAppStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppAppComputeStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppAppPendingDeploymentResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 creator: _builtins.str,
                 deployment_artifacts: 'outputs.GetAppAppPendingDeploymentDeploymentArtifactsResult',
                 status: 'outputs.GetAppAppPendingDeploymentStatusResult',
                 update_time: _builtins.str,
                 deployment_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source_code_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str update_time: The update time of the app.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "deployment_artifacts", deployment_artifacts)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="deploymentArtifacts")
    def deployment_artifacts(self) -> 'outputs.GetAppAppPendingDeploymentDeploymentArtifactsResult':
        return pulumi.get(self, "deployment_artifacts")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.GetAppAppPendingDeploymentStatusResult':
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppAppPendingDeploymentDeploymentArtifactsResult(dict):
    def __init__(__self__, *,
                 source_code_path: Optional[_builtins.str] = None):
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppAppPendingDeploymentStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppAppResourceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 database: Optional['outputs.GetAppAppResourceDatabaseResult'] = None,
                 description: Optional[_builtins.str] = None,
                 genie_space: Optional['outputs.GetAppAppResourceGenieSpaceResult'] = None,
                 job: Optional['outputs.GetAppAppResourceJobResult'] = None,
                 secret: Optional['outputs.GetAppAppResourceSecretResult'] = None,
                 serving_endpoint: Optional['outputs.GetAppAppResourceServingEndpointResult'] = None,
                 sql_warehouse: Optional['outputs.GetAppAppResourceSqlWarehouseResult'] = None,
                 uc_securable: Optional['outputs.GetAppAppResourceUcSecurableResult'] = None):
        """
        :param _builtins.str name: The name of the app.
        :param 'GetAppAppResourceDatabaseArgs' database: attribute
        :param _builtins.str description: The description of the resource.
        :param 'GetAppAppResourceGenieSpaceArgs' genie_space: attribute
        :param 'GetAppAppResourceJobArgs' job: attribute
        :param 'GetAppAppResourceSecretArgs' secret: attribute
        :param 'GetAppAppResourceServingEndpointArgs' serving_endpoint: attribute
        :param 'GetAppAppResourceSqlWarehouseArgs' sql_warehouse: attribute
        :param 'GetAppAppResourceUcSecurableArgs' uc_securable: attribute
        """
        pulumi.set(__self__, "name", name)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if genie_space is not None:
            pulumi.set(__self__, "genie_space", genie_space)
        if job is not None:
            pulumi.set(__self__, "job", job)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if serving_endpoint is not None:
            pulumi.set(__self__, "serving_endpoint", serving_endpoint)
        if sql_warehouse is not None:
            pulumi.set(__self__, "sql_warehouse", sql_warehouse)
        if uc_securable is not None:
            pulumi.set(__self__, "uc_securable", uc_securable)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional['outputs.GetAppAppResourceDatabaseResult']:
        """
        attribute
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="genieSpace")
    def genie_space(self) -> Optional['outputs.GetAppAppResourceGenieSpaceResult']:
        """
        attribute
        """
        return pulumi.get(self, "genie_space")

    @_builtins.property
    @pulumi.getter
    def job(self) -> Optional['outputs.GetAppAppResourceJobResult']:
        """
        attribute
        """
        return pulumi.get(self, "job")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.GetAppAppResourceSecretResult']:
        """
        attribute
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="servingEndpoint")
    def serving_endpoint(self) -> Optional['outputs.GetAppAppResourceServingEndpointResult']:
        """
        attribute
        """
        return pulumi.get(self, "serving_endpoint")

    @_builtins.property
    @pulumi.getter(name="sqlWarehouse")
    def sql_warehouse(self) -> Optional['outputs.GetAppAppResourceSqlWarehouseResult']:
        """
        attribute
        """
        return pulumi.get(self, "sql_warehouse")

    @_builtins.property
    @pulumi.getter(name="ucSecurable")
    def uc_securable(self) -> Optional['outputs.GetAppAppResourceUcSecurableResult']:
        """
        attribute
        """
        return pulumi.get(self, "uc_securable")


@pulumi.output_type
class GetAppAppResourceDatabaseResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 instance_name: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str database_name: The name of database.
        :param _builtins.str instance_name: The name of database instance.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of database.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The name of database instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppAppResourceGenieSpaceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permission: _builtins.str,
                 space_id: _builtins.str):
        """
        :param _builtins.str name: The name of the app.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        :param _builtins.str space_id: The unique ID of Genie Space.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "space_id", space_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        The unique ID of Genie Space.
        """
        return pulumi.get(self, "space_id")


@pulumi.output_type
class GetAppAppResourceJobResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppAppResourceSecretResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 permission: _builtins.str,
                 scope: _builtins.str):
        """
        :param _builtins.str key: Key of the secret to grant permission on.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        :param _builtins.str scope: Scope of the secret to grant permission on.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the secret to grant permission on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Scope of the secret to grant permission on.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetAppAppResourceServingEndpointResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str name: The name of the app.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the app.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppAppResourceSqlWarehouseResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppAppResourceUcSecurableResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str,
                 securable_full_name: _builtins.str,
                 securable_type: _builtins.str):
        """
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        :param _builtins.str securable_full_name: the full name of UC securable, i.e. `my-catalog.my-schema.my-volume`.
        :param _builtins.str securable_type: the type of UC securable, i.e. `VOLUME`.
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "securable_full_name", securable_full_name)
        pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="securableFullName")
    def securable_full_name(self) -> _builtins.str:
        """
        the full name of UC securable, i.e. `my-catalog.my-schema.my-volume`.
        """
        return pulumi.get(self, "securable_full_name")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> _builtins.str:
        """
        the type of UC securable, i.e. `VOLUME`.
        """
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class GetAppProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetAppsAppResult(dict):
    def __init__(__self__, *,
                 active_deployment: 'outputs.GetAppsAppActiveDeploymentResult',
                 app_status: 'outputs.GetAppsAppAppStatusResult',
                 compute_status: 'outputs.GetAppsAppComputeStatusResult',
                 create_time: _builtins.str,
                 creator: _builtins.str,
                 default_source_code_path: _builtins.str,
                 effective_budget_policy_id: _builtins.str,
                 effective_user_api_scopes: Sequence[_builtins.str],
                 id: _builtins.str,
                 name: _builtins.str,
                 oauth2_app_client_id: _builtins.str,
                 oauth2_app_integration_id: _builtins.str,
                 pending_deployment: 'outputs.GetAppsAppPendingDeploymentResult',
                 service_principal_client_id: _builtins.str,
                 service_principal_id: _builtins.int,
                 service_principal_name: _builtins.str,
                 update_time: _builtins.str,
                 updater: _builtins.str,
                 url: _builtins.str,
                 budget_policy_id: Optional[_builtins.str] = None,
                 compute_size: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 resources: Optional[Sequence['outputs.GetAppsAppResourceResult']] = None,
                 user_api_scopes: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'GetAppsAppAppStatusArgs' app_status: attribute
        :param 'GetAppsAppComputeStatusArgs' compute_status: attribute
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str default_source_code_path: The default workspace file system path of the source code from which app deployment are created. This field tracks the workspace source code path of the last active deployment.
        :param _builtins.str effective_budget_policy_id: The effective budget policy ID.
        :param Sequence[_builtins.str] effective_user_api_scopes: A list of effective api scopes granted to the user access token.
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str name: The name of Genie Space.
        :param _builtins.str service_principal_client_id: client_id (application_id) of the app service principal
        :param _builtins.int service_principal_id: id of the app service principal
        :param _builtins.str service_principal_name: name of the app service principal
        :param _builtins.str update_time: The update time of the app.
        :param _builtins.str updater: The email of the user that last updated the app.
        :param _builtins.str url: The URL of the app once it is deployed.
        :param _builtins.str budget_policy_id: The Budget Policy ID set for this resource.
        :param _builtins.str compute_size: (Optional) A string specifying compute size for the App.
        :param _builtins.str description: The description of the resource.
        :param Sequence['GetAppsAppResourceArgs'] resources: A list of resources that the app have access to.
        """
        pulumi.set(__self__, "active_deployment", active_deployment)
        pulumi.set(__self__, "app_status", app_status)
        pulumi.set(__self__, "compute_status", compute_status)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "default_source_code_path", default_source_code_path)
        pulumi.set(__self__, "effective_budget_policy_id", effective_budget_policy_id)
        pulumi.set(__self__, "effective_user_api_scopes", effective_user_api_scopes)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oauth2_app_client_id", oauth2_app_client_id)
        pulumi.set(__self__, "oauth2_app_integration_id", oauth2_app_integration_id)
        pulumi.set(__self__, "pending_deployment", pending_deployment)
        pulumi.set(__self__, "service_principal_client_id", service_principal_client_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "service_principal_name", service_principal_name)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "updater", updater)
        pulumi.set(__self__, "url", url)
        if budget_policy_id is not None:
            pulumi.set(__self__, "budget_policy_id", budget_policy_id)
        if compute_size is not None:
            pulumi.set(__self__, "compute_size", compute_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if user_api_scopes is not None:
            pulumi.set(__self__, "user_api_scopes", user_api_scopes)

    @_builtins.property
    @pulumi.getter(name="activeDeployment")
    def active_deployment(self) -> 'outputs.GetAppsAppActiveDeploymentResult':
        return pulumi.get(self, "active_deployment")

    @_builtins.property
    @pulumi.getter(name="appStatus")
    def app_status(self) -> 'outputs.GetAppsAppAppStatusResult':
        """
        attribute
        """
        return pulumi.get(self, "app_status")

    @_builtins.property
    @pulumi.getter(name="computeStatus")
    def compute_status(self) -> 'outputs.GetAppsAppComputeStatusResult':
        """
        attribute
        """
        return pulumi.get(self, "compute_status")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="defaultSourceCodePath")
    def default_source_code_path(self) -> _builtins.str:
        """
        The default workspace file system path of the source code from which app deployment are created. This field tracks the workspace source code path of the last active deployment.
        """
        return pulumi.get(self, "default_source_code_path")

    @_builtins.property
    @pulumi.getter(name="effectiveBudgetPolicyId")
    def effective_budget_policy_id(self) -> _builtins.str:
        """
        The effective budget policy ID.
        """
        return pulumi.get(self, "effective_budget_policy_id")

    @_builtins.property
    @pulumi.getter(name="effectiveUserApiScopes")
    def effective_user_api_scopes(self) -> Sequence[_builtins.str]:
        """
        A list of effective api scopes granted to the user access token.
        """
        return pulumi.get(self, "effective_user_api_scopes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Genie Space.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oauth2AppClientId")
    def oauth2_app_client_id(self) -> _builtins.str:
        return pulumi.get(self, "oauth2_app_client_id")

    @_builtins.property
    @pulumi.getter(name="oauth2AppIntegrationId")
    def oauth2_app_integration_id(self) -> _builtins.str:
        return pulumi.get(self, "oauth2_app_integration_id")

    @_builtins.property
    @pulumi.getter(name="pendingDeployment")
    def pending_deployment(self) -> 'outputs.GetAppsAppPendingDeploymentResult':
        return pulumi.get(self, "pending_deployment")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalClientId")
    def service_principal_client_id(self) -> _builtins.str:
        """
        client_id (application_id) of the app service principal
        """
        return pulumi.get(self, "service_principal_client_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.int:
        """
        id of the app service principal
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> _builtins.str:
        """
        name of the app service principal
        """
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter
    def updater(self) -> _builtins.str:
        """
        The email of the user that last updated the app.
        """
        return pulumi.get(self, "updater")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the app once it is deployed.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="budgetPolicyId")
    def budget_policy_id(self) -> Optional[_builtins.str]:
        """
        The Budget Policy ID set for this resource.
        """
        return pulumi.get(self, "budget_policy_id")

    @_builtins.property
    @pulumi.getter(name="computeSize")
    def compute_size(self) -> Optional[_builtins.str]:
        """
        (Optional) A string specifying compute size for the App.
        """
        return pulumi.get(self, "compute_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.GetAppsAppResourceResult']]:
        """
        A list of resources that the app have access to.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="userApiScopes")
    def user_api_scopes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "user_api_scopes")


@pulumi.output_type
class GetAppsAppActiveDeploymentResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 creator: _builtins.str,
                 deployment_artifacts: 'outputs.GetAppsAppActiveDeploymentDeploymentArtifactsResult',
                 status: 'outputs.GetAppsAppActiveDeploymentStatusResult',
                 update_time: _builtins.str,
                 deployment_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source_code_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str update_time: The update time of the app.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "deployment_artifacts", deployment_artifacts)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="deploymentArtifacts")
    def deployment_artifacts(self) -> 'outputs.GetAppsAppActiveDeploymentDeploymentArtifactsResult':
        return pulumi.get(self, "deployment_artifacts")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.GetAppsAppActiveDeploymentStatusResult':
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppsAppActiveDeploymentDeploymentArtifactsResult(dict):
    def __init__(__self__, *,
                 source_code_path: Optional[_builtins.str] = None):
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppsAppActiveDeploymentStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppsAppAppStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppsAppComputeStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppsAppPendingDeploymentResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 creator: _builtins.str,
                 deployment_artifacts: 'outputs.GetAppsAppPendingDeploymentDeploymentArtifactsResult',
                 status: 'outputs.GetAppsAppPendingDeploymentStatusResult',
                 update_time: _builtins.str,
                 deployment_id: Optional[_builtins.str] = None,
                 mode: Optional[_builtins.str] = None,
                 source_code_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The creation time of the app.
        :param _builtins.str creator: The email of the user that created the app.
        :param _builtins.str update_time: The update time of the app.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "deployment_artifacts", deployment_artifacts)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "update_time", update_time)
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The creation time of the app.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        The email of the user that created the app.
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="deploymentArtifacts")
    def deployment_artifacts(self) -> 'outputs.GetAppsAppPendingDeploymentDeploymentArtifactsResult':
        return pulumi.get(self, "deployment_artifacts")

    @_builtins.property
    @pulumi.getter
    def status(self) -> 'outputs.GetAppsAppPendingDeploymentStatusResult':
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        The update time of the app.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppsAppPendingDeploymentDeploymentArtifactsResult(dict):
    def __init__(__self__, *,
                 source_code_path: Optional[_builtins.str] = None):
        if source_code_path is not None:
            pulumi.set(__self__, "source_code_path", source_code_path)

    @_builtins.property
    @pulumi.getter(name="sourceCodePath")
    def source_code_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source_code_path")


@pulumi.output_type
class GetAppsAppPendingDeploymentStatusResult(dict):
    def __init__(__self__, *,
                 message: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str message: Application status message
        :param _builtins.str state: State of the application.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Application status message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the application.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetAppsAppResourceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 database: Optional['outputs.GetAppsAppResourceDatabaseResult'] = None,
                 description: Optional[_builtins.str] = None,
                 genie_space: Optional['outputs.GetAppsAppResourceGenieSpaceResult'] = None,
                 job: Optional['outputs.GetAppsAppResourceJobResult'] = None,
                 secret: Optional['outputs.GetAppsAppResourceSecretResult'] = None,
                 serving_endpoint: Optional['outputs.GetAppsAppResourceServingEndpointResult'] = None,
                 sql_warehouse: Optional['outputs.GetAppsAppResourceSqlWarehouseResult'] = None,
                 uc_securable: Optional['outputs.GetAppsAppResourceUcSecurableResult'] = None):
        """
        :param _builtins.str name: The name of Genie Space.
        :param 'GetAppsAppResourceDatabaseArgs' database: attribute
        :param _builtins.str description: The description of the resource.
        :param 'GetAppsAppResourceGenieSpaceArgs' genie_space: attribute
        :param 'GetAppsAppResourceJobArgs' job: attribute
        :param 'GetAppsAppResourceSecretArgs' secret: attribute
        :param 'GetAppsAppResourceServingEndpointArgs' serving_endpoint: attribute
        :param 'GetAppsAppResourceSqlWarehouseArgs' sql_warehouse: attribute
        :param 'GetAppsAppResourceUcSecurableArgs' uc_securable: attribute
        """
        pulumi.set(__self__, "name", name)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if genie_space is not None:
            pulumi.set(__self__, "genie_space", genie_space)
        if job is not None:
            pulumi.set(__self__, "job", job)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if serving_endpoint is not None:
            pulumi.set(__self__, "serving_endpoint", serving_endpoint)
        if sql_warehouse is not None:
            pulumi.set(__self__, "sql_warehouse", sql_warehouse)
        if uc_securable is not None:
            pulumi.set(__self__, "uc_securable", uc_securable)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Genie Space.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional['outputs.GetAppsAppResourceDatabaseResult']:
        """
        attribute
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="genieSpace")
    def genie_space(self) -> Optional['outputs.GetAppsAppResourceGenieSpaceResult']:
        """
        attribute
        """
        return pulumi.get(self, "genie_space")

    @_builtins.property
    @pulumi.getter
    def job(self) -> Optional['outputs.GetAppsAppResourceJobResult']:
        """
        attribute
        """
        return pulumi.get(self, "job")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.GetAppsAppResourceSecretResult']:
        """
        attribute
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="servingEndpoint")
    def serving_endpoint(self) -> Optional['outputs.GetAppsAppResourceServingEndpointResult']:
        """
        attribute
        """
        return pulumi.get(self, "serving_endpoint")

    @_builtins.property
    @pulumi.getter(name="sqlWarehouse")
    def sql_warehouse(self) -> Optional['outputs.GetAppsAppResourceSqlWarehouseResult']:
        """
        attribute
        """
        return pulumi.get(self, "sql_warehouse")

    @_builtins.property
    @pulumi.getter(name="ucSecurable")
    def uc_securable(self) -> Optional['outputs.GetAppsAppResourceUcSecurableResult']:
        """
        attribute
        """
        return pulumi.get(self, "uc_securable")


@pulumi.output_type
class GetAppsAppResourceDatabaseResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 instance_name: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str database_name: The name of database.
        :param _builtins.str instance_name: The name of database instance.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of database.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        The name of database instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsAppResourceGenieSpaceResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permission: _builtins.str,
                 space_id: _builtins.str):
        """
        :param _builtins.str name: The name of Genie Space.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        :param _builtins.str space_id: The unique ID of Genie Space.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "space_id", space_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Genie Space.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> _builtins.str:
        """
        The unique ID of Genie Space.
        """
        return pulumi.get(self, "space_id")


@pulumi.output_type
class GetAppsAppResourceJobResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsAppResourceSecretResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 permission: _builtins.str,
                 scope: _builtins.str):
        """
        :param _builtins.str key: Key of the secret to grant permission on.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        :param _builtins.str scope: Scope of the secret to grant permission on.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key of the secret to grant permission on.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Scope of the secret to grant permission on.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetAppsAppResourceServingEndpointResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str name: The name of Genie Space.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Genie Space.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsAppResourceSqlWarehouseResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str id: Id of the job to grant permission on.
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the job to grant permission on.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsAppResourceUcSecurableResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str,
                 securable_full_name: _builtins.str,
                 securable_type: _builtins.str):
        """
        :param _builtins.str permission: Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        :param _builtins.str securable_full_name: the full name of UC securable, i.e. `my-catalog.my-schema.my-volume`.
        :param _builtins.str securable_type: the type of UC securable, i.e. `VOLUME`.
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "securable_full_name", securable_full_name)
        pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission to grant on database. Supported permissions are: `CAN_CONNECT_AND_CREATE`.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="securableFullName")
    def securable_full_name(self) -> _builtins.str:
        """
        the full name of UC securable, i.e. `my-catalog.my-schema.my-volume`.
        """
        return pulumi.get(self, "securable_full_name")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> _builtins.str:
        """
        the type of UC securable, i.e. `VOLUME`.
        """
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class GetAppsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 resource_specs: Optional[Sequence['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecResult']] = None):
        """
        :param _builtins.str name: The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
               It must be unique within the workspace
        :param _builtins.int version: (integer) - The manifest schema version, for now only 1 is allowed
        :param _builtins.str description: (string) - Description of the App Resource
        :param Sequence['GetAppsSettingsCustomTemplateManifestResourceSpecArgs'] resource_specs: (list of AppManifestAppResourceSpec)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_specs is not None:
            pulumi.set(__self__, "resource_specs", resource_specs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
        It must be unique within the workspace
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        (integer) - The manifest schema version, for now only 1 is allowed
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (string) - Description of the App Resource
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="resourceSpecs")
    def resource_specs(self) -> Optional[Sequence['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecResult']]:
        """
        (list of AppManifestAppResourceSpec)
        """
        return pulumi.get(self, "resource_specs")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResourceSpecResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 job_spec: Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecJobSpecResult'] = None,
                 secret_spec: Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecSecretSpecResult'] = None,
                 serving_endpoint_spec: Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpecResult'] = None,
                 sql_warehouse_spec: Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpecResult'] = None,
                 uc_securable_spec: Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpecResult'] = None):
        """
        :param _builtins.str name: The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
               It must be unique within the workspace
        :param _builtins.str description: (string) - Description of the App Resource
        :param 'GetAppsSettingsCustomTemplateManifestResourceSpecJobSpecArgs' job_spec: (AppManifestAppResourceJobSpec)
        :param 'GetAppsSettingsCustomTemplateManifestResourceSpecSecretSpecArgs' secret_spec: (AppManifestAppResourceSecretSpec)
        :param 'GetAppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpecArgs' serving_endpoint_spec: (AppManifestAppResourceServingEndpointSpec)
        :param 'GetAppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpecArgs' sql_warehouse_spec: (AppManifestAppResourceSqlWarehouseSpec)
        :param 'GetAppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpecArgs' uc_securable_spec: (AppManifestAppResourceUcSecurableSpec)
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if job_spec is not None:
            pulumi.set(__self__, "job_spec", job_spec)
        if secret_spec is not None:
            pulumi.set(__self__, "secret_spec", secret_spec)
        if serving_endpoint_spec is not None:
            pulumi.set(__self__, "serving_endpoint_spec", serving_endpoint_spec)
        if sql_warehouse_spec is not None:
            pulumi.set(__self__, "sql_warehouse_spec", sql_warehouse_spec)
        if uc_securable_spec is not None:
            pulumi.set(__self__, "uc_securable_spec", uc_securable_spec)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the template. It must contain only alphanumeric characters, hyphens, underscores, and whitespaces.
        It must be unique within the workspace
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (string) - Description of the App Resource
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="jobSpec")
    def job_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecJobSpecResult']:
        """
        (AppManifestAppResourceJobSpec)
        """
        return pulumi.get(self, "job_spec")

    @_builtins.property
    @pulumi.getter(name="secretSpec")
    def secret_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecSecretSpecResult']:
        """
        (AppManifestAppResourceSecretSpec)
        """
        return pulumi.get(self, "secret_spec")

    @_builtins.property
    @pulumi.getter(name="servingEndpointSpec")
    def serving_endpoint_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpecResult']:
        """
        (AppManifestAppResourceServingEndpointSpec)
        """
        return pulumi.get(self, "serving_endpoint_spec")

    @_builtins.property
    @pulumi.getter(name="sqlWarehouseSpec")
    def sql_warehouse_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpecResult']:
        """
        (AppManifestAppResourceSqlWarehouseSpec)
        """
        return pulumi.get(self, "sql_warehouse_spec")

    @_builtins.property
    @pulumi.getter(name="ucSecurableSpec")
    def uc_securable_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpecResult']:
        """
        (AppManifestAppResourceUcSecurableSpec)
        """
        return pulumi.get(self, "uc_securable_spec")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResourceSpecJobSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResourceSpecSecretSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResourceSpecServingEndpointSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResourceSpecSqlWarehouseSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplateManifestResourceSpecUcSecurableSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str,
                 securable_type: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        :param _builtins.str securable_type: (string) - Possible values are: `TABLE`, `VOLUME`
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> _builtins.str:
        """
        (string) - Possible values are: `TABLE`, `VOLUME`
        """
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateResult(dict):
    def __init__(__self__, *,
                 creator: _builtins.str,
                 description: _builtins.str,
                 git_provider: _builtins.str,
                 git_repo: _builtins.str,
                 manifest: 'outputs.GetAppsSettingsCustomTemplatesTemplateManifestResult',
                 name: _builtins.str,
                 path: _builtins.str):
        """
        :param _builtins.str creator: (string)
        :param _builtins.str description: (string) - Description of the App Resource
        :param _builtins.str git_provider: (string) - The Git provider of the template
        :param _builtins.str git_repo: (string) - The Git repository URL that the template resides in
        :param 'GetAppsSettingsCustomTemplatesTemplateManifestArgs' manifest: (AppManifest) - The manifest of the template. It defines fields and default values when installing the template
        :param _builtins.str name: (string) - Name of the App Resource
        :param _builtins.str path: (string) - The path to the template within the Git repository
        """
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "git_provider", git_provider)
        pulumi.set(__self__, "git_repo", git_repo)
        pulumi.set(__self__, "manifest", manifest)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (string) - Description of the App Resource
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="gitProvider")
    def git_provider(self) -> _builtins.str:
        """
        (string) - The Git provider of the template
        """
        return pulumi.get(self, "git_provider")

    @_builtins.property
    @pulumi.getter(name="gitRepo")
    def git_repo(self) -> _builtins.str:
        """
        (string) - The Git repository URL that the template resides in
        """
        return pulumi.get(self, "git_repo")

    @_builtins.property
    @pulumi.getter
    def manifest(self) -> 'outputs.GetAppsSettingsCustomTemplatesTemplateManifestResult':
        """
        (AppManifest) - The manifest of the template. It defines fields and default values when installing the template
        """
        return pulumi.get(self, "manifest")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the App Resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        (string) - The path to the template within the Git repository
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.int,
                 description: Optional[_builtins.str] = None,
                 resource_specs: Optional[Sequence['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecResult']] = None):
        """
        :param _builtins.str name: (string) - Name of the App Resource
        :param _builtins.int version: (integer) - The manifest schema version, for now only 1 is allowed
        :param _builtins.str description: (string) - Description of the App Resource
        :param Sequence['GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecArgs'] resource_specs: (list of AppManifestAppResourceSpec)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if resource_specs is not None:
            pulumi.set(__self__, "resource_specs", resource_specs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the App Resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        (integer) - The manifest schema version, for now only 1 is allowed
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (string) - Description of the App Resource
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="resourceSpecs")
    def resource_specs(self) -> Optional[Sequence['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecResult']]:
        """
        (list of AppManifestAppResourceSpec)
        """
        return pulumi.get(self, "resource_specs")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 job_spec: Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecJobSpecResult'] = None,
                 secret_spec: Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSecretSpecResult'] = None,
                 serving_endpoint_spec: Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecServingEndpointSpecResult'] = None,
                 sql_warehouse_spec: Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSqlWarehouseSpecResult'] = None,
                 uc_securable_spec: Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecUcSecurableSpecResult'] = None):
        """
        :param _builtins.str name: (string) - Name of the App Resource
        :param _builtins.str description: (string) - Description of the App Resource
        :param 'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecJobSpecArgs' job_spec: (AppManifestAppResourceJobSpec)
        :param 'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSecretSpecArgs' secret_spec: (AppManifestAppResourceSecretSpec)
        :param 'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecServingEndpointSpecArgs' serving_endpoint_spec: (AppManifestAppResourceServingEndpointSpec)
        :param 'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSqlWarehouseSpecArgs' sql_warehouse_spec: (AppManifestAppResourceSqlWarehouseSpec)
        :param 'GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecUcSecurableSpecArgs' uc_securable_spec: (AppManifestAppResourceUcSecurableSpec)
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if job_spec is not None:
            pulumi.set(__self__, "job_spec", job_spec)
        if secret_spec is not None:
            pulumi.set(__self__, "secret_spec", secret_spec)
        if serving_endpoint_spec is not None:
            pulumi.set(__self__, "serving_endpoint_spec", serving_endpoint_spec)
        if sql_warehouse_spec is not None:
            pulumi.set(__self__, "sql_warehouse_spec", sql_warehouse_spec)
        if uc_securable_spec is not None:
            pulumi.set(__self__, "uc_securable_spec", uc_securable_spec)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the App Resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (string) - Description of the App Resource
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="jobSpec")
    def job_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecJobSpecResult']:
        """
        (AppManifestAppResourceJobSpec)
        """
        return pulumi.get(self, "job_spec")

    @_builtins.property
    @pulumi.getter(name="secretSpec")
    def secret_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSecretSpecResult']:
        """
        (AppManifestAppResourceSecretSpec)
        """
        return pulumi.get(self, "secret_spec")

    @_builtins.property
    @pulumi.getter(name="servingEndpointSpec")
    def serving_endpoint_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecServingEndpointSpecResult']:
        """
        (AppManifestAppResourceServingEndpointSpec)
        """
        return pulumi.get(self, "serving_endpoint_spec")

    @_builtins.property
    @pulumi.getter(name="sqlWarehouseSpec")
    def sql_warehouse_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSqlWarehouseSpecResult']:
        """
        (AppManifestAppResourceSqlWarehouseSpec)
        """
        return pulumi.get(self, "sql_warehouse_spec")

    @_builtins.property
    @pulumi.getter(name="ucSecurableSpec")
    def uc_securable_spec(self) -> Optional['outputs.GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecUcSecurableSpecResult']:
        """
        (AppManifestAppResourceUcSecurableSpec)
        """
        return pulumi.get(self, "uc_securable_spec")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecJobSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSecretSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecServingEndpointSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecSqlWarehouseSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetAppsSettingsCustomTemplatesTemplateManifestResourceSpecUcSecurableSpecResult(dict):
    def __init__(__self__, *,
                 permission: _builtins.str,
                 securable_type: _builtins.str):
        """
        :param _builtins.str permission: (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        :param _builtins.str securable_type: (string) - Possible values are: `TABLE`, `VOLUME`
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        (string) - Possible values are: `MANAGE`, `READ_VOLUME`, `SELECT`, `WRITE_VOLUME`
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> _builtins.str:
        """
        (string) - Possible values are: `TABLE`, `VOLUME`
        """
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class GetBudgetPoliciesFilterByResult(dict):
    def __init__(__self__, *,
                 creator_user_id: Optional[_builtins.int] = None,
                 creator_user_name: Optional[_builtins.str] = None,
                 policy_name: Optional[_builtins.str] = None):
        """
        :param _builtins.int creator_user_id: The policy creator user id to be filtered on.
               If unspecified, all policies will be returned
        :param _builtins.str creator_user_name: The policy creator user name to be filtered on.
               If unspecified, all policies will be returned
        :param _builtins.str policy_name: (string) - The name of the policy.
               - Must be unique among active policies.
               - Can contain only characters from the ISO 8859-1 (latin1) set.
               - Can't start with reserved keywords such as `databricks:default-policy`
        """
        if creator_user_id is not None:
            pulumi.set(__self__, "creator_user_id", creator_user_id)
        if creator_user_name is not None:
            pulumi.set(__self__, "creator_user_name", creator_user_name)
        if policy_name is not None:
            pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="creatorUserId")
    def creator_user_id(self) -> Optional[_builtins.int]:
        """
        The policy creator user id to be filtered on.
        If unspecified, all policies will be returned
        """
        return pulumi.get(self, "creator_user_id")

    @_builtins.property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[_builtins.str]:
        """
        The policy creator user name to be filtered on.
        If unspecified, all policies will be returned
        """
        return pulumi.get(self, "creator_user_name")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> Optional[_builtins.str]:
        """
        (string) - The name of the policy.
        - Must be unique among active policies.
        - Can contain only characters from the ISO 8859-1 (latin1) set.
        - Can't start with reserved keywords such as `databricks:default-policy`
        """
        return pulumi.get(self, "policy_name")


@pulumi.output_type
class GetBudgetPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 binding_workspace_ids: Sequence[_builtins.int],
                 custom_tags: Sequence['outputs.GetBudgetPoliciesPolicyCustomTagResult'],
                 policy_id: _builtins.str,
                 policy_name: _builtins.str):
        """
        :param Sequence[_builtins.int] binding_workspace_ids: (list of integer) - List of workspaces that this budget policy will be exclusively bound to.
               An empty binding implies that this budget policy is open to any workspace in the account
        :param Sequence['GetBudgetPoliciesPolicyCustomTagArgs'] custom_tags: (list of CustomPolicyTag) - A list of tags defined by the customer. At most 20 entries are allowed per policy
        :param _builtins.str policy_id: (string) - The Id of the policy. This field is generated by Databricks and globally unique
        :param _builtins.str policy_name: (string) - The name of the policy.
               - Must be unique among active policies.
               - Can contain only characters from the ISO 8859-1 (latin1) set.
               - Can't start with reserved keywords such as `databricks:default-policy`
        """
        pulumi.set(__self__, "binding_workspace_ids", binding_workspace_ids)
        pulumi.set(__self__, "custom_tags", custom_tags)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_name", policy_name)

    @_builtins.property
    @pulumi.getter(name="bindingWorkspaceIds")
    def binding_workspace_ids(self) -> Sequence[_builtins.int]:
        """
        (list of integer) - List of workspaces that this budget policy will be exclusively bound to.
        An empty binding implies that this budget policy is open to any workspace in the account
        """
        return pulumi.get(self, "binding_workspace_ids")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence['outputs.GetBudgetPoliciesPolicyCustomTagResult']:
        """
        (list of CustomPolicyTag) - A list of tags defined by the customer. At most 20 entries are allowed per policy
        """
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        (string) - The Id of the policy. This field is generated by Databricks and globally unique
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyName")
    def policy_name(self) -> _builtins.str:
        """
        (string) - The name of the policy.
        - Must be unique among active policies.
        - Can contain only characters from the ISO 8859-1 (latin1) set.
        - Can't start with reserved keywords such as `databricks:default-policy`
        """
        return pulumi.get(self, "policy_name")


@pulumi.output_type
class GetBudgetPoliciesPolicyCustomTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (string) - The key of the tag.
               - Must be unique among all custom tags of the same policy
               - Cannot be budget-policy-name, budget-policy-id or "budget-policy-resolution-result" -
               these tags are preserved
        :param _builtins.str value: (string) - The value of the tag
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (string) - The key of the tag.
        - Must be unique among all custom tags of the same policy
        - Cannot be budget-policy-name, budget-policy-id or "budget-policy-resolution-result" -
        these tags are preserved
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - The value of the tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetBudgetPoliciesSortSpecResult(dict):
    def __init__(__self__, *,
                 descending: Optional[_builtins.bool] = None,
                 field: Optional[_builtins.str] = None):
        """
        :param _builtins.bool descending: Whether to sort in descending order
        :param _builtins.str field: The filed to sort by. Possible values are: `POLICY_NAME`
        """
        if descending is not None:
            pulumi.set(__self__, "descending", descending)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def descending(self) -> Optional[_builtins.bool]:
        """
        Whether to sort in descending order
        """
        return pulumi.get(self, "descending")

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        The filed to sort by. Possible values are: `POLICY_NAME`
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class GetBudgetPolicyCustomTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (string) - The key of the tag.
               - Must be unique among all custom tags of the same policy
               - Cannot be budget-policy-name, budget-policy-id or "budget-policy-resolution-result" -
               these tags are preserved
        :param _builtins.str value: (string) - The value of the tag
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (string) - The key of the tag.
        - Must be unique among all custom tags of the same policy
        - Cannot be budget-policy-name, budget-policy-id or "budget-policy-resolution-result" -
        these tags are preserved
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - The value of the tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCatalogCatalogInfoResult(dict):
    def __init__(__self__, *,
                 browse_only: Optional[_builtins.bool] = None,
                 catalog_type: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 connection_name: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 effective_predictive_optimization_flag: Optional['outputs.GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagResult'] = None,
                 enable_predictive_optimization: Optional[_builtins.str] = None,
                 full_name: Optional[_builtins.str] = None,
                 isolation_mode: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 owner: Optional[_builtins.str] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 provider_name: Optional[_builtins.str] = None,
                 provisioning_info: Optional['outputs.GetCatalogCatalogInfoProvisioningInfoResult'] = None,
                 securable_type: Optional[_builtins.str] = None,
                 share_name: Optional[_builtins.str] = None,
                 storage_location: Optional[_builtins.str] = None,
                 storage_root: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str catalog_type: Type of the catalog, e.g. `MANAGED_CATALOG`, `DELTASHARING_CATALOG`, `SYSTEM_CATALOG`,
        :param _builtins.str comment: Free-form text description
        :param _builtins.str connection_name: The name of the connection to an external data source.
        :param _builtins.int created_at: Time at which this catalog was created, in epoch milliseconds.
        :param _builtins.str created_by: Username of catalog creator.
        :param 'GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagArgs' effective_predictive_optimization_flag: object describing applied predictive optimization flag.
        :param _builtins.str enable_predictive_optimization: Whether predictive optimization should be enabled for this object and objects under it.
        :param _builtins.str full_name: The full name of the catalog. Corresponds with the name field.
        :param _builtins.str isolation_mode: Whether the current securable is accessible from all workspaces or a  specific set of workspaces.
        :param _builtins.str metastore_id: Unique identifier of parent metastore.
        :param _builtins.str name: name of the catalog
        :param Mapping[str, _builtins.str] options: A map of key-value properties attached to the securable.
        :param _builtins.str owner: Current owner of the catalog
        :param Mapping[str, _builtins.str] properties: A map of key-value properties attached to the securable.
        :param _builtins.str provider_name: The name of delta sharing provider.
        :param _builtins.str securable_type: Securable type.
        :param _builtins.str share_name: The name of the share under the share provider.
        :param _builtins.str storage_location: Storage Location URL (full path) for managed tables within catalog.
        :param _builtins.str storage_root: Storage root URL for managed tables within catalog.
        :param _builtins.int updated_at: Time at which this catalog was last modified, in epoch milliseconds.
        :param _builtins.str updated_by: Username of user who last modified catalog.
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_type is not None:
            pulumi.set(__self__, "catalog_type", catalog_type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if effective_predictive_optimization_flag is not None:
            pulumi.set(__self__, "effective_predictive_optimization_flag", effective_predictive_optimization_flag)
        if enable_predictive_optimization is not None:
            pulumi.set(__self__, "enable_predictive_optimization", enable_predictive_optimization)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if provisioning_info is not None:
            pulumi.set(__self__, "provisioning_info", provisioning_info)
        if securable_type is not None:
            pulumi.set(__self__, "securable_type", securable_type)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter(name="catalogType")
    def catalog_type(self) -> Optional[_builtins.str]:
        """
        Type of the catalog, e.g. `MANAGED_CATALOG`, `DELTASHARING_CATALOG`, `SYSTEM_CATALOG`,
        """
        return pulumi.get(self, "catalog_type")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Free-form text description
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        """
        The name of the connection to an external data source.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Username of catalog creator.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="effectivePredictiveOptimizationFlag")
    def effective_predictive_optimization_flag(self) -> Optional['outputs.GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagResult']:
        """
        object describing applied predictive optimization flag.
        """
        return pulumi.get(self, "effective_predictive_optimization_flag")

    @_builtins.property
    @pulumi.getter(name="enablePredictiveOptimization")
    def enable_predictive_optimization(self) -> Optional[_builtins.str]:
        """
        Whether predictive optimization should be enabled for this object and objects under it.
        """
        return pulumi.get(self, "enable_predictive_optimization")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        The full name of the catalog. Corresponds with the name field.
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[_builtins.str]:
        """
        Whether the current securable is accessible from all workspaces or a  specific set of workspaces.
        """
        return pulumi.get(self, "isolation_mode")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of parent metastore.
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        name of the catalog
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of key-value properties attached to the securable.
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Current owner of the catalog
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of key-value properties attached to the securable.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[_builtins.str]:
        """
        The name of delta sharing provider.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="provisioningInfo")
    def provisioning_info(self) -> Optional['outputs.GetCatalogCatalogInfoProvisioningInfoResult']:
        return pulumi.get(self, "provisioning_info")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> Optional[_builtins.str]:
        """
        Securable type.
        """
        return pulumi.get(self, "securable_type")

    @_builtins.property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[_builtins.str]:
        """
        The name of the share under the share provider.
        """
        return pulumi.get(self, "share_name")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[_builtins.str]:
        """
        Storage Location URL (full path) for managed tables within catalog.
        """
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[_builtins.str]:
        """
        Storage root URL for managed tables within catalog.
        """
        return pulumi.get(self, "storage_root")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        Username of user who last modified catalog.
        """
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class GetCatalogCatalogInfoEffectivePredictiveOptimizationFlagResult(dict):
    def __init__(__self__, *,
                 value: _builtins.str,
                 inherited_from_name: Optional[_builtins.str] = None,
                 inherited_from_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_name")

    @_builtins.property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_type")


@pulumi.output_type
class GetCatalogCatalogInfoProvisioningInfoResult(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCatalogProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetCatalogsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetClusterClusterInfoResult(dict):
    def __init__(__self__, *,
                 autoscale: Optional['outputs.GetClusterClusterInfoAutoscaleResult'] = None,
                 autotermination_minutes: Optional[_builtins.int] = None,
                 aws_attributes: Optional['outputs.GetClusterClusterInfoAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetClusterClusterInfoAzureAttributesResult'] = None,
                 cluster_cores: Optional[_builtins.float] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.GetClusterClusterInfoClusterLogConfResult'] = None,
                 cluster_log_status: Optional['outputs.GetClusterClusterInfoClusterLogStatusResult'] = None,
                 cluster_memory_mb: Optional[_builtins.int] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 cluster_source: Optional[_builtins.str] = None,
                 creator_user_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 default_tags: Optional[Mapping[str, _builtins.str]] = None,
                 docker_image: Optional['outputs.GetClusterClusterInfoDockerImageResult'] = None,
                 driver: Optional['outputs.GetClusterClusterInfoDriverResult'] = None,
                 driver_instance_pool_id: Optional[_builtins.str] = None,
                 driver_node_type_id: Optional[_builtins.str] = None,
                 enable_elastic_disk: Optional[_builtins.bool] = None,
                 enable_local_disk_encryption: Optional[_builtins.bool] = None,
                 executors: Optional[Sequence['outputs.GetClusterClusterInfoExecutorResult']] = None,
                 gcp_attributes: Optional['outputs.GetClusterClusterInfoGcpAttributesResult'] = None,
                 init_scripts: Optional[Sequence['outputs.GetClusterClusterInfoInitScriptResult']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 is_single_node: Optional[_builtins.bool] = None,
                 jdbc_port: Optional[_builtins.int] = None,
                 kind: Optional[_builtins.str] = None,
                 last_restarted_time: Optional[_builtins.int] = None,
                 last_state_loss_time: Optional[_builtins.int] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 remote_disk_throughput: Optional[_builtins.int] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_context_id: Optional[_builtins.int] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 spec: Optional['outputs.GetClusterClusterInfoSpecResult'] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 start_time: Optional[_builtins.int] = None,
                 state: Optional[_builtins.str] = None,
                 state_message: Optional[_builtins.str] = None,
                 terminated_time: Optional[_builtins.int] = None,
                 termination_reason: Optional['outputs.GetClusterClusterInfoTerminationReasonResult'] = None,
                 total_initial_remote_disk_size: Optional[_builtins.int] = None,
                 use_ml_runtime: Optional[_builtins.bool] = None,
                 workload_type: Optional['outputs.GetClusterClusterInfoWorkloadTypeResult'] = None):
        """
        :param _builtins.int autotermination_minutes: Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        :param _builtins.str cluster_id: The id of the cluster.
        :param _builtins.str cluster_name: The exact name of the cluster to search. Can only be specified if there is exactly one cluster with the provided name.
        :param Mapping[str, _builtins.str] custom_tags: Additional tags for cluster resources.
        :param _builtins.str data_security_mode: Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        :param _builtins.str driver_instance_pool_id: similar to `instance_pool_id`, but for driver node.
        :param _builtins.str driver_node_type_id: The node type of the Spark driver.
        :param _builtins.bool enable_elastic_disk: Use autoscaling local storage.
        :param _builtins.bool enable_local_disk_encryption: Enable local disk encryption.
        :param _builtins.str instance_pool_id: The pool of idle instances the cluster is attached to.
        :param _builtins.str node_type_id: Any supported get_node_type id.
        :param _builtins.str policy_id: Identifier of Cluster Policy to validate cluster and preset certain defaults.
        :param _builtins.str runtime_engine: The type of runtime of the cluster
        :param _builtins.str single_user_name: The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        :param Mapping[str, _builtins.str] spark_conf: Map with key-value pairs to fine-tune Spark clusters.
        :param Mapping[str, _builtins.str] spark_env_vars: Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        :param _builtins.str spark_version: [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        :param Sequence[_builtins.str] ssh_public_keys: SSH public key contents that will be added to each Spark node in this cluster.
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_cores is not None:
            pulumi.set(__self__, "cluster_cores", cluster_cores)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_log_status is not None:
            pulumi.set(__self__, "cluster_log_status", cluster_log_status)
        if cluster_memory_mb is not None:
            pulumi.set(__self__, "cluster_memory_mb", cluster_memory_mb)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_source is not None:
            pulumi.set(__self__, "cluster_source", cluster_source)
        if creator_user_name is not None:
            pulumi.set(__self__, "creator_user_name", creator_user_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if default_tags is not None:
            pulumi.set(__self__, "default_tags", default_tags)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if driver is not None:
            pulumi.set(__self__, "driver", driver)
        if driver_instance_pool_id is not None:
            pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        if driver_node_type_id is not None:
            pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if enable_local_disk_encryption is not None:
            pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        if executors is not None:
            pulumi.set(__self__, "executors", executors)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if is_single_node is not None:
            pulumi.set(__self__, "is_single_node", is_single_node)
        if jdbc_port is not None:
            pulumi.set(__self__, "jdbc_port", jdbc_port)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if last_restarted_time is not None:
            pulumi.set(__self__, "last_restarted_time", last_restarted_time)
        if last_state_loss_time is not None:
            pulumi.set(__self__, "last_state_loss_time", last_state_loss_time)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if remote_disk_throughput is not None:
            pulumi.set(__self__, "remote_disk_throughput", remote_disk_throughput)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_context_id is not None:
            pulumi.set(__self__, "spark_context_id", spark_context_id)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_message is not None:
            pulumi.set(__self__, "state_message", state_message)
        if terminated_time is not None:
            pulumi.set(__self__, "terminated_time", terminated_time)
        if termination_reason is not None:
            pulumi.set(__self__, "termination_reason", termination_reason)
        if total_initial_remote_disk_size is not None:
            pulumi.set(__self__, "total_initial_remote_disk_size", total_initial_remote_disk_size)
        if use_ml_runtime is not None:
            pulumi.set(__self__, "use_ml_runtime", use_ml_runtime)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetClusterClusterInfoAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[_builtins.int]:
        """
        Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination.
        """
        return pulumi.get(self, "autotermination_minutes")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetClusterClusterInfoAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterCores")
    def cluster_cores(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cluster_cores")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        The id of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterLogStatus")
    def cluster_log_status(self) -> Optional['outputs.GetClusterClusterInfoClusterLogStatusResult']:
        return pulumi.get(self, "cluster_log_status")

    @_builtins.property
    @pulumi.getter(name="clusterMemoryMb")
    def cluster_memory_mb(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cluster_memory_mb")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The exact name of the cluster to search. Can only be specified if there is exactly one cluster with the provided name.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterSource")
    def cluster_source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_source")

    @_builtins.property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "creator_user_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional tags for cluster resources.
        """
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "default_tags")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetClusterClusterInfoDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter
    def driver(self) -> Optional['outputs.GetClusterClusterInfoDriverResult']:
        return pulumi.get(self, "driver")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> Optional[_builtins.str]:
        """
        similar to `instance_pool_id`, but for driver node.
        """
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> Optional[_builtins.str]:
        """
        The node type of the Spark driver.
        """
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[_builtins.bool]:
        """
        Use autoscaling local storage.
        """
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> Optional[_builtins.bool]:
        """
        Enable local disk encryption.
        """
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter
    def executors(self) -> Optional[Sequence['outputs.GetClusterClusterInfoExecutorResult']]:
        return pulumi.get(self, "executors")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetClusterClusterInfoGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetClusterClusterInfoInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        """
        The pool of idle instances the cluster is attached to.
        """
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="isSingleNode")
    def is_single_node(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_single_node")

    @_builtins.property
    @pulumi.getter(name="jdbcPort")
    def jdbc_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "jdbc_port")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="lastRestartedTime")
    def last_restarted_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_restarted_time")

    @_builtins.property
    @pulumi.getter(name="lastStateLossTime")
    def last_state_loss_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_state_loss_time")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        """
        Any supported get_node_type id.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="remoteDiskThroughput")
    def remote_disk_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "remote_disk_throughput")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        """
        The type of runtime of the cluster
        """
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkContextId")
    def spark_context_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spark_context_id")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GetClusterClusterInfoSpecResult']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="stateMessage")
    def state_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state_message")

    @_builtins.property
    @pulumi.getter(name="terminatedTime")
    def terminated_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "terminated_time")

    @_builtins.property
    @pulumi.getter(name="terminationReason")
    def termination_reason(self) -> Optional['outputs.GetClusterClusterInfoTerminationReasonResult']:
        return pulumi.get(self, "termination_reason")

    @_builtins.property
    @pulumi.getter(name="totalInitialRemoteDiskSize")
    def total_initial_remote_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_initial_remote_disk_size")

    @_builtins.property
    @pulumi.getter(name="useMlRuntime")
    def use_ml_runtime(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_ml_runtime")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.GetClusterClusterInfoWorkloadTypeResult']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class GetClusterClusterInfoAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetClusterClusterInfoAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetClusterClusterInfoAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.GetClusterClusterInfoAzureAttributesLogAnalyticsInfoResult'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.GetClusterClusterInfoAzureAttributesLogAnalyticsInfoResult']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetClusterClusterInfoAzureAttributesLogAnalyticsInfoResult(dict):
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetClusterClusterInfoClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetClusterClusterInfoClusterLogConfS3Result'] = None,
                 volumes: Optional['outputs.GetClusterClusterInfoClusterLogConfVolumesResult'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetClusterClusterInfoClusterLogConfVolumesResult']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterClusterInfoClusterLogConfVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoClusterLogStatusResult(dict):
    def __init__(__self__, *,
                 last_attempted: Optional[_builtins.int] = None,
                 last_exception: Optional[_builtins.str] = None):
        if last_attempted is not None:
            pulumi.set(__self__, "last_attempted", last_attempted)
        if last_exception is not None:
            pulumi.set(__self__, "last_exception", last_exception)

    @_builtins.property
    @pulumi.getter(name="lastAttempted")
    def last_attempted(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_attempted")

    @_builtins.property
    @pulumi.getter(name="lastException")
    def last_exception(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last_exception")


@pulumi.output_type
class GetClusterClusterInfoDockerImageResult(dict):
    def __init__(__self__, *,
                 basic_auth: Optional['outputs.GetClusterClusterInfoDockerImageBasicAuthResult'] = None,
                 url: Optional[_builtins.str] = None):
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetClusterClusterInfoDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClusterClusterInfoDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterClusterInfoDriverResult(dict):
    def __init__(__self__, *,
                 host_private_ip: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 node_aws_attributes: Optional['outputs.GetClusterClusterInfoDriverNodeAwsAttributesResult'] = None,
                 node_id: Optional[_builtins.str] = None,
                 private_ip: Optional[_builtins.str] = None,
                 public_dns: Optional[_builtins.str] = None,
                 start_timestamp: Optional[_builtins.int] = None):
        if host_private_ip is not None:
            pulumi.set(__self__, "host_private_ip", host_private_ip)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if node_aws_attributes is not None:
            pulumi.set(__self__, "node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_dns is not None:
            pulumi.set(__self__, "public_dns", public_dns)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @_builtins.property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_private_ip")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoDriverNodeAwsAttributesResult']:
        return pulumi.get(self, "node_aws_attributes")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_dns")

    @_builtins.property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "start_timestamp")


@pulumi.output_type
class GetClusterClusterInfoDriverNodeAwsAttributesResult(dict):
    def __init__(__self__, *,
                 is_spot: Optional[_builtins.bool] = None):
        if is_spot is not None:
            pulumi.set(__self__, "is_spot", is_spot)

    @_builtins.property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_spot")


@pulumi.output_type
class GetClusterClusterInfoExecutorResult(dict):
    def __init__(__self__, *,
                 host_private_ip: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 node_aws_attributes: Optional['outputs.GetClusterClusterInfoExecutorNodeAwsAttributesResult'] = None,
                 node_id: Optional[_builtins.str] = None,
                 private_ip: Optional[_builtins.str] = None,
                 public_dns: Optional[_builtins.str] = None,
                 start_timestamp: Optional[_builtins.int] = None):
        if host_private_ip is not None:
            pulumi.set(__self__, "host_private_ip", host_private_ip)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if node_aws_attributes is not None:
            pulumi.set(__self__, "node_aws_attributes", node_aws_attributes)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_dns is not None:
            pulumi.set(__self__, "public_dns", public_dns)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @_builtins.property
    @pulumi.getter(name="hostPrivateIp")
    def host_private_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_private_ip")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="nodeAwsAttributes")
    def node_aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoExecutorNodeAwsAttributesResult']:
        return pulumi.get(self, "node_aws_attributes")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_ip")

    @_builtins.property
    @pulumi.getter(name="publicDns")
    def public_dns(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_dns")

    @_builtins.property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "start_timestamp")


@pulumi.output_type
class GetClusterClusterInfoExecutorNodeAwsAttributesResult(dict):
    def __init__(__self__, *,
                 is_spot: Optional[_builtins.bool] = None):
        if is_spot is not None:
            pulumi.set(__self__, "is_spot", is_spot)

    @_builtins.property
    @pulumi.getter(name="isSpot")
    def is_spot(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_spot")


@pulumi.output_type
class GetClusterClusterInfoGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetClusterClusterInfoInitScriptResult(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.GetClusterClusterInfoInitScriptAbfssResult'] = None,
                 dbfs: Optional['outputs.GetClusterClusterInfoInitScriptDbfsResult'] = None,
                 file: Optional['outputs.GetClusterClusterInfoInitScriptFileResult'] = None,
                 gcs: Optional['outputs.GetClusterClusterInfoInitScriptGcsResult'] = None,
                 s3: Optional['outputs.GetClusterClusterInfoInitScriptS3Result'] = None,
                 volumes: Optional['outputs.GetClusterClusterInfoInitScriptVolumesResult'] = None,
                 workspace: Optional['outputs.GetClusterClusterInfoInitScriptWorkspaceResult'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.GetClusterClusterInfoInitScriptAbfssResult']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetClusterClusterInfoInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetClusterClusterInfoInitScriptFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.GetClusterClusterInfoInitScriptGcsResult']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetClusterClusterInfoInitScriptS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetClusterClusterInfoInitScriptVolumesResult']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.GetClusterClusterInfoInitScriptWorkspaceResult']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetClusterClusterInfoInitScriptAbfssResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoInitScriptFileResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoInitScriptGcsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterClusterInfoInitScriptVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoInitScriptWorkspaceResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 driver_instance_pool_id: _builtins.str,
                 driver_node_type_id: _builtins.str,
                 enable_elastic_disk: _builtins.bool,
                 enable_local_disk_encryption: _builtins.bool,
                 node_type_id: _builtins.str,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.GetClusterClusterInfoSpecAutoscaleResult'] = None,
                 aws_attributes: Optional['outputs.GetClusterClusterInfoSpecAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetClusterClusterInfoSpecAzureAttributesResult'] = None,
                 cluster_log_conf: Optional['outputs.GetClusterClusterInfoSpecClusterLogConfResult'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.GetClusterClusterInfoSpecClusterMountInfoResult']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.GetClusterClusterInfoSpecDockerImageResult'] = None,
                 gcp_attributes: Optional['outputs.GetClusterClusterInfoSpecGcpAttributesResult'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.GetClusterClusterInfoSpecInitScriptResult']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 is_single_node: Optional[_builtins.bool] = None,
                 kind: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.GetClusterClusterInfoSpecLibraryResult']] = None,
                 num_workers: Optional[_builtins.int] = None,
                 policy_id: Optional[_builtins.str] = None,
                 provider_config: Optional['outputs.GetClusterClusterInfoSpecProviderConfigResult'] = None,
                 remote_disk_throughput: Optional[_builtins.int] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 total_initial_remote_disk_size: Optional[_builtins.int] = None,
                 use_ml_runtime: Optional[_builtins.bool] = None,
                 workload_type: Optional['outputs.GetClusterClusterInfoSpecWorkloadTypeResult'] = None):
        """
        :param _builtins.str cluster_id: The id of the cluster.
        :param _builtins.str driver_instance_pool_id: similar to `instance_pool_id`, but for driver node.
        :param _builtins.str driver_node_type_id: The node type of the Spark driver.
        :param _builtins.bool enable_elastic_disk: Use autoscaling local storage.
        :param _builtins.bool enable_local_disk_encryption: Enable local disk encryption.
        :param _builtins.str node_type_id: Any supported get_node_type id.
        :param _builtins.str cluster_name: The exact name of the cluster to search. Can only be specified if there is exactly one cluster with the provided name.
        :param Mapping[str, _builtins.str] custom_tags: Additional tags for cluster resources.
        :param _builtins.str data_security_mode: Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        :param _builtins.str idempotency_token: An optional token to guarantee the idempotency of cluster creation requests.
        :param _builtins.str instance_pool_id: The pool of idle instances the cluster is attached to.
        :param _builtins.str policy_id: Identifier of Cluster Policy to validate cluster and preset certain defaults.
        :param 'GetClusterClusterInfoSpecProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        :param _builtins.str runtime_engine: The type of runtime of the cluster
        :param _builtins.str single_user_name: The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        :param Mapping[str, _builtins.str] spark_conf: Map with key-value pairs to fine-tune Spark clusters.
        :param Mapping[str, _builtins.str] spark_env_vars: Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        :param _builtins.str spark_version: [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        :param Sequence[_builtins.str] ssh_public_keys: SSH public key contents that will be added to each Spark node in this cluster.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if is_single_node is not None:
            pulumi.set(__self__, "is_single_node", is_single_node)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if remote_disk_throughput is not None:
            pulumi.set(__self__, "remote_disk_throughput", remote_disk_throughput)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if total_initial_remote_disk_size is not None:
            pulumi.set(__self__, "total_initial_remote_disk_size", total_initial_remote_disk_size)
        if use_ml_runtime is not None:
            pulumi.set(__self__, "use_ml_runtime", use_ml_runtime)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The id of the cluster.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> _builtins.str:
        """
        similar to `instance_pool_id`, but for driver node.
        """
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> _builtins.str:
        """
        The node type of the Spark driver.
        """
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> _builtins.bool:
        """
        Use autoscaling local storage.
        """
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> _builtins.bool:
        """
        Enable local disk encryption.
        """
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        Any supported get_node_type id.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetClusterClusterInfoSpecAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetClusterClusterInfoSpecAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetClusterClusterInfoSpecAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetClusterClusterInfoSpecClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.GetClusterClusterInfoSpecClusterMountInfoResult']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The exact name of the cluster to search. Can only be specified if there is exactly one cluster with the provided name.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Additional tags for cluster resources.
        """
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        """
        Security features of the cluster. Unity Catalog requires `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. Default to `NONE`, i.e. no security feature enabled.
        """
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetClusterClusterInfoSpecDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetClusterClusterInfoSpecGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        """
        An optional token to guarantee the idempotency of cluster creation requests.
        """
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetClusterClusterInfoSpecInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        """
        The pool of idle instances the cluster is attached to.
        """
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="isSingleNode")
    def is_single_node(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_single_node")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.GetClusterClusterInfoSpecLibraryResult']]:
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        """
        Identifier of Cluster Policy to validate cluster and preset certain defaults.
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.GetClusterClusterInfoSpecProviderConfigResult']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter(name="remoteDiskThroughput")
    def remote_disk_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "remote_disk_throughput")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        """
        The type of runtime of the cluster
        """
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        """
        The optional user name of the user to assign to an interactive cluster. This field is required when using standard AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
        """
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map with key-value pairs to fine-tune Spark clusters.
        """
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X='Y') while launching the driver and workers.
        """
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        """
        [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster.
        """
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        SSH public key contents that will be added to each Spark node in this cluster.
        """
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="totalInitialRemoteDiskSize")
    def total_initial_remote_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "total_initial_remote_disk_size")

    @_builtins.property
    @pulumi.getter(name="useMlRuntime")
    def use_ml_runtime(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_ml_runtime")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.GetClusterClusterInfoSpecWorkloadTypeResult']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class GetClusterClusterInfoSpecAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetClusterClusterInfoSpecAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_iops: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_throughput: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_iops is not None:
            pulumi.set(__self__, "ebs_volume_iops", ebs_volume_iops)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_throughput is not None:
            pulumi.set(__self__, "ebs_volume_throughput", ebs_volume_throughput)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeIops")
    def ebs_volume_iops(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_iops")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeThroughput")
    def ebs_volume_throughput(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_throughput")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetClusterClusterInfoSpecAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 log_analytics_info: Optional['outputs.GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoResult'] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if log_analytics_info is not None:
            pulumi.set(__self__, "log_analytics_info", log_analytics_info)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsInfo")
    def log_analytics_info(self) -> Optional['outputs.GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoResult']:
        return pulumi.get(self, "log_analytics_info")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetClusterClusterInfoSpecAzureAttributesLogAnalyticsInfoResult(dict):
    def __init__(__self__, *,
                 log_analytics_primary_key: Optional[_builtins.str] = None,
                 log_analytics_workspace_id: Optional[_builtins.str] = None):
        if log_analytics_primary_key is not None:
            pulumi.set(__self__, "log_analytics_primary_key", log_analytics_primary_key)
        if log_analytics_workspace_id is not None:
            pulumi.set(__self__, "log_analytics_workspace_id", log_analytics_workspace_id)

    @_builtins.property
    @pulumi.getter(name="logAnalyticsPrimaryKey")
    def log_analytics_primary_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_primary_key")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceId")
    def log_analytics_workspace_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_analytics_workspace_id")


@pulumi.output_type
class GetClusterClusterInfoSpecClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetClusterClusterInfoSpecClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetClusterClusterInfoSpecClusterLogConfS3Result'] = None,
                 volumes: Optional['outputs.GetClusterClusterInfoSpecClusterLogConfVolumesResult'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetClusterClusterInfoSpecClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetClusterClusterInfoSpecClusterLogConfS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetClusterClusterInfoSpecClusterLogConfVolumesResult']:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class GetClusterClusterInfoSpecClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterClusterInfoSpecClusterLogConfVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecClusterMountInfoResult(dict):
    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoResult',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoResult':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class GetClusterClusterInfoSpecClusterMountInfoNetworkFilesystemInfoResult(dict):
    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class GetClusterClusterInfoSpecDockerImageResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.GetClusterClusterInfoSpecDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetClusterClusterInfoSpecDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetClusterClusterInfoSpecDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterClusterInfoSpecGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptResult(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.GetClusterClusterInfoSpecInitScriptAbfssResult'] = None,
                 dbfs: Optional['outputs.GetClusterClusterInfoSpecInitScriptDbfsResult'] = None,
                 file: Optional['outputs.GetClusterClusterInfoSpecInitScriptFileResult'] = None,
                 gcs: Optional['outputs.GetClusterClusterInfoSpecInitScriptGcsResult'] = None,
                 s3: Optional['outputs.GetClusterClusterInfoSpecInitScriptS3Result'] = None,
                 volumes: Optional['outputs.GetClusterClusterInfoSpecInitScriptVolumesResult'] = None,
                 workspace: Optional['outputs.GetClusterClusterInfoSpecInitScriptWorkspaceResult'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptAbfssResult']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""For init scripts use 'volumes', 'workspace' or cloud storage location instead of 'dbfs'.""")
    def dbfs(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptGcsResult']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptVolumesResult']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.GetClusterClusterInfoSpecInitScriptWorkspaceResult']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptAbfssResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptFileResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptGcsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecInitScriptWorkspaceResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetClusterClusterInfoSpecLibraryResult(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.GetClusterClusterInfoSpecLibraryCranResult'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.GetClusterClusterInfoSpecLibraryMavenResult'] = None,
                 provider_config: Optional['outputs.GetClusterClusterInfoSpecLibraryProviderConfigResult'] = None,
                 pypi: Optional['outputs.GetClusterClusterInfoSpecLibraryPypiResult'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        """
        :param 'GetClusterClusterInfoSpecLibraryProviderConfigArgs' provider_config: Configure the provider for management through account provider. This block consists of the following fields:
        """
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.GetClusterClusterInfoSpecLibraryCranResult']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.GetClusterClusterInfoSpecLibraryMavenResult']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.GetClusterClusterInfoSpecLibraryProviderConfigResult']:
        """
        Configure the provider for management through account provider. This block consists of the following fields:
        """
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.GetClusterClusterInfoSpecLibraryPypiResult']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class GetClusterClusterInfoSpecLibraryCranResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetClusterClusterInfoSpecLibraryMavenResult(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetClusterClusterInfoSpecLibraryProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetClusterClusterInfoSpecLibraryPypiResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetClusterClusterInfoSpecProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetClusterClusterInfoSpecWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 clients: 'outputs.GetClusterClusterInfoSpecWorkloadTypeClientsResult'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.GetClusterClusterInfoSpecWorkloadTypeClientsResult':
        return pulumi.get(self, "clients")


@pulumi.output_type
class GetClusterClusterInfoSpecWorkloadTypeClientsResult(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GetClusterClusterInfoTerminationReasonResult(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterClusterInfoWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 clients: 'outputs.GetClusterClusterInfoWorkloadTypeClientsResult'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.GetClusterClusterInfoWorkloadTypeClientsResult':
        return pulumi.get(self, "clients")


@pulumi.output_type
class GetClusterClusterInfoWorkloadTypeClientsResult(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GetClusterPolicyProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetClusterProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetClustersFilterByResult(dict):
    def __init__(__self__, *,
                 cluster_sources: Optional[Sequence[_builtins.str]] = None,
                 cluster_states: Optional[Sequence[_builtins.str]] = None,
                 is_pinned: Optional[_builtins.bool] = None,
                 policy_id: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] cluster_sources: List of cluster sources to filter by. Possible values are `API`, `JOB`, `MODELS`, `PIPELINE`, `PIPELINE_MAINTENANCE`, `SQL`, and `UI`.
        :param Sequence[_builtins.str] cluster_states: List of cluster states to filter by. Possible values are `RUNNING`, `PENDING`, `RESIZING`, `RESTARTING`, `TERMINATING`, `TERMINATED`, `ERROR`, and `UNKNOWN`.
        :param _builtins.bool is_pinned: Whether to filter by pinned clusters.
        :param _builtins.str policy_id: Filter by ClusterPolicy id.
        """
        if cluster_sources is not None:
            pulumi.set(__self__, "cluster_sources", cluster_sources)
        if cluster_states is not None:
            pulumi.set(__self__, "cluster_states", cluster_states)
        if is_pinned is not None:
            pulumi.set(__self__, "is_pinned", is_pinned)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)

    @_builtins.property
    @pulumi.getter(name="clusterSources")
    def cluster_sources(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of cluster sources to filter by. Possible values are `API`, `JOB`, `MODELS`, `PIPELINE`, `PIPELINE_MAINTENANCE`, `SQL`, and `UI`.
        """
        return pulumi.get(self, "cluster_sources")

    @_builtins.property
    @pulumi.getter(name="clusterStates")
    def cluster_states(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of cluster states to filter by. Possible values are `RUNNING`, `PENDING`, `RESIZING`, `RESTARTING`, `TERMINATING`, `TERMINATED`, `ERROR`, and `UNKNOWN`.
        """
        return pulumi.get(self, "cluster_states")

    @_builtins.property
    @pulumi.getter(name="isPinned")
    def is_pinned(self) -> Optional[_builtins.bool]:
        """
        Whether to filter by pinned clusters.
        """
        return pulumi.get(self, "is_pinned")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        """
        Filter by ClusterPolicy id.
        """
        return pulumi.get(self, "policy_id")


@pulumi.output_type
class GetClustersProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetCurrentMetastoreMetastoreInfoResult(dict):
    def __init__(__self__, *,
                 cloud: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 default_data_access_config_id: Optional[_builtins.str] = None,
                 delta_sharing_organization_name: Optional[_builtins.str] = None,
                 delta_sharing_recipient_token_lifetime_in_seconds: Optional[_builtins.int] = None,
                 delta_sharing_scope: Optional[_builtins.str] = None,
                 external_access_enabled: Optional[_builtins.bool] = None,
                 global_metastore_id: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 privilege_model_version: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 storage_root: Optional[_builtins.str] = None,
                 storage_root_credential_id: Optional[_builtins.str] = None,
                 storage_root_credential_name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param _builtins.int created_at: Timestamp (in milliseconds) when the current metastore was created.
        :param _builtins.str created_by: the ID of the identity that created the current metastore.
        :param _builtins.str default_data_access_config_id: the ID of the default data access configuration.
        :param _builtins.str delta_sharing_organization_name: The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        :param _builtins.int delta_sharing_recipient_token_lifetime_in_seconds: the expiration duration in seconds on recipient data access tokens.
        :param _builtins.str delta_sharing_scope: Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        :param _builtins.str global_metastore_id: Identifier in form of `<cloud>:<region>:<metastore_id>` for use in Databricks to Databricks Delta Sharing.
        :param _builtins.str metastore_id: Metastore ID.
        :param _builtins.str name: Name of metastore.
        :param _builtins.str owner: Username/group name/sp application_id of the metastore owner.
        :param _builtins.str privilege_model_version: the version of the privilege model used by the metastore.
        :param _builtins.str region: (Mandatory for account-level) The region of the metastore.
        :param _builtins.str storage_root: Path on cloud storage account, where managed `Table` are stored.
        :param _builtins.str storage_root_credential_id: ID of a storage credential used for the `storage_root`.
        :param _builtins.str storage_root_credential_name: Name of a storage credential used for the `storage_root`.
        :param _builtins.int updated_at: Timestamp (in milliseconds) when the current metastore was updated.
        :param _builtins.str updated_by: the ID of the identity that updated the current metastore.
        """
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if default_data_access_config_id is not None:
            pulumi.set(__self__, "default_data_access_config_id", default_data_access_config_id)
        if delta_sharing_organization_name is not None:
            pulumi.set(__self__, "delta_sharing_organization_name", delta_sharing_organization_name)
        if delta_sharing_recipient_token_lifetime_in_seconds is not None:
            pulumi.set(__self__, "delta_sharing_recipient_token_lifetime_in_seconds", delta_sharing_recipient_token_lifetime_in_seconds)
        if delta_sharing_scope is not None:
            pulumi.set(__self__, "delta_sharing_scope", delta_sharing_scope)
        if external_access_enabled is not None:
            pulumi.set(__self__, "external_access_enabled", external_access_enabled)
        if global_metastore_id is not None:
            pulumi.set(__self__, "global_metastore_id", global_metastore_id)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if privilege_model_version is not None:
            pulumi.set(__self__, "privilege_model_version", privilege_model_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if storage_root_credential_id is not None:
            pulumi.set(__self__, "storage_root_credential_id", storage_root_credential_id)
        if storage_root_credential_name is not None:
            pulumi.set(__self__, "storage_root_credential_name", storage_root_credential_name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        Timestamp (in milliseconds) when the current metastore was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        the ID of the identity that created the current metastore.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="defaultDataAccessConfigId")
    def default_data_access_config_id(self) -> Optional[_builtins.str]:
        """
        the ID of the default data access configuration.
        """
        return pulumi.get(self, "default_data_access_config_id")

    @_builtins.property
    @pulumi.getter(name="deltaSharingOrganizationName")
    def delta_sharing_organization_name(self) -> Optional[_builtins.str]:
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        return pulumi.get(self, "delta_sharing_organization_name")

    @_builtins.property
    @pulumi.getter(name="deltaSharingRecipientTokenLifetimeInSeconds")
    def delta_sharing_recipient_token_lifetime_in_seconds(self) -> Optional[_builtins.int]:
        """
        the expiration duration in seconds on recipient data access tokens.
        """
        return pulumi.get(self, "delta_sharing_recipient_token_lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter(name="deltaSharingScope")
    def delta_sharing_scope(self) -> Optional[_builtins.str]:
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        """
        return pulumi.get(self, "delta_sharing_scope")

    @_builtins.property
    @pulumi.getter(name="externalAccessEnabled")
    def external_access_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "external_access_enabled")

    @_builtins.property
    @pulumi.getter(name="globalMetastoreId")
    def global_metastore_id(self) -> Optional[_builtins.str]:
        """
        Identifier in form of `<cloud>:<region>:<metastore_id>` for use in Databricks to Databricks Delta Sharing.
        """
        return pulumi.get(self, "global_metastore_id")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        Metastore ID.
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of metastore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Username/group name/sp application_id of the metastore owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="privilegeModelVersion")
    def privilege_model_version(self) -> Optional[_builtins.str]:
        """
        the version of the privilege model used by the metastore.
        """
        return pulumi.get(self, "privilege_model_version")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        (Mandatory for account-level) The region of the metastore.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[_builtins.str]:
        """
        Path on cloud storage account, where managed `Table` are stored.
        """
        return pulumi.get(self, "storage_root")

    @_builtins.property
    @pulumi.getter(name="storageRootCredentialId")
    def storage_root_credential_id(self) -> Optional[_builtins.str]:
        """
        ID of a storage credential used for the `storage_root`.
        """
        return pulumi.get(self, "storage_root_credential_id")

    @_builtins.property
    @pulumi.getter(name="storageRootCredentialName")
    def storage_root_credential_name(self) -> Optional[_builtins.str]:
        """
        Name of a storage credential used for the `storage_root`.
        """
        return pulumi.get(self, "storage_root_credential_name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        Timestamp (in milliseconds) when the current metastore was updated.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        the ID of the identity that updated the current metastore.
        """
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class GetCurrentMetastoreProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetDashboardsDashboardResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 dashboard_id: _builtins.str,
                 etag: _builtins.str,
                 lifecycle_state: _builtins.str,
                 parent_path: _builtins.str,
                 path: _builtins.str,
                 update_time: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 serialized_dashboard: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: The timestamp of when the dashboard was created.
        :param _builtins.str dashboard_id: The unique ID of the dashboard.
        :param _builtins.str display_name: The display name of the dashboard.
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "lifecycle_state", lifecycle_state)
        pulumi.set(__self__, "parent_path", parent_path)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "update_time", update_time)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if serialized_dashboard is not None:
            pulumi.set(__self__, "serialized_dashboard", serialized_dashboard)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The timestamp of when the dashboard was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        """
        The unique ID of the dashboard.
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> _builtins.str:
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="lifecycleState")
    def lifecycle_state(self) -> _builtins.str:
        return pulumi.get(self, "lifecycle_state")

    @_builtins.property
    @pulumi.getter(name="parentPath")
    def parent_path(self) -> _builtins.str:
        return pulumi.get(self, "parent_path")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the dashboard.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="serializedDashboard")
    def serialized_dashboard(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serialized_dashboard")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetDashboardsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetDataQualityMonitorAnomalyDetectionConfigResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigResult(dict):
    def __init__(__self__, *,
                 dashboard_id: _builtins.str,
                 drift_metrics_table_name: _builtins.str,
                 effective_warehouse_id: _builtins.str,
                 latest_monitor_failure_message: _builtins.str,
                 monitor_version: _builtins.int,
                 monitored_table_name: _builtins.str,
                 output_schema_id: _builtins.str,
                 profile_metrics_table_name: _builtins.str,
                 status: _builtins.str,
                 assets_dir: Optional[_builtins.str] = None,
                 baseline_table_name: Optional[_builtins.str] = None,
                 custom_metrics: Optional[Sequence['outputs.GetDataQualityMonitorDataProfilingConfigCustomMetricResult']] = None,
                 inference_log: Optional['outputs.GetDataQualityMonitorDataProfilingConfigInferenceLogResult'] = None,
                 notification_settings: Optional['outputs.GetDataQualityMonitorDataProfilingConfigNotificationSettingsResult'] = None,
                 schedule: Optional['outputs.GetDataQualityMonitorDataProfilingConfigScheduleResult'] = None,
                 skip_builtin_dashboard: Optional[_builtins.bool] = None,
                 slicing_exprs: Optional[Sequence[_builtins.str]] = None,
                 snapshot: Optional['outputs.GetDataQualityMonitorDataProfilingConfigSnapshotResult'] = None,
                 time_series: Optional['outputs.GetDataQualityMonitorDataProfilingConfigTimeSeriesResult'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str dashboard_id: (string) - Id of dashboard that visualizes the computed metrics.
               This can be empty if the monitor is in PENDING state
        :param _builtins.str drift_metrics_table_name: (string) - Table that stores drift metrics data. Format: `catalog.schema.table_name`
        :param _builtins.str effective_warehouse_id: (string) - The warehouse for dashboard creation
        :param _builtins.str latest_monitor_failure_message: (string) - The latest error message for a monitor failure
        :param _builtins.int monitor_version: (integer) - Represents the current monitor configuration version in use. The version will be represented in a
               numeric fashion (1,2,3...). The field has flexibility to take on negative values, which can indicate corrupted
               monitor_version numbers
        :param _builtins.str monitored_table_name: (string) - Unity Catalog table to monitor. Format: `catalog.schema.table_name`
        :param _builtins.str output_schema_id: (string) - ID of the schema where output tables are created
        :param _builtins.str profile_metrics_table_name: (string) - Table that stores profile metrics data. Format: `catalog.schema.table_name`
        :param _builtins.str status: (string) - The data profiling monitor status. Possible values are: `DATA_PROFILING_STATUS_ACTIVE`, `DATA_PROFILING_STATUS_DELETE_PENDING`, `DATA_PROFILING_STATUS_ERROR`, `DATA_PROFILING_STATUS_FAILED`, `DATA_PROFILING_STATUS_PENDING`
        :param _builtins.str assets_dir: (string) - Field for specifying the absolute path to a custom directory to store data-monitoring
               assets. Normally prepopulated to a default user location via UI and Python APIs
        :param _builtins.str baseline_table_name: (string) - Baseline table name.
               Baseline data is used to compute drift from the data in the monitored `table_name`.
               The baseline table and the monitored table shall have the same schema
        :param Sequence['GetDataQualityMonitorDataProfilingConfigCustomMetricArgs'] custom_metrics: (list of DataProfilingCustomMetric) - Custom metrics
        :param 'GetDataQualityMonitorDataProfilingConfigInferenceLogArgs' inference_log: (InferenceLogConfig) - `Analysis Configuration` for monitoring inference log tables
        :param 'GetDataQualityMonitorDataProfilingConfigNotificationSettingsArgs' notification_settings: (NotificationSettings) - Field for specifying notification settings
        :param 'GetDataQualityMonitorDataProfilingConfigScheduleArgs' schedule: (CronSchedule) - The cron schedule
        :param _builtins.bool skip_builtin_dashboard: (boolean) - Whether to skip creating a default dashboard summarizing data quality metrics
        :param Sequence[_builtins.str] slicing_exprs: (list of string) - List of column expressions to slice data with for targeted analysis. The data is grouped by
               each expression independently, resulting in a separate slice for each predicate and its
               complements. For example `slicing_exprs=[col_1, col_2 > 10]` will generate the following
               slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in
               `col1`. For high-cardinality columns, only the top 100 unique values by frequency will
               generate slices
        :param 'GetDataQualityMonitorDataProfilingConfigSnapshotArgs' snapshot: (SnapshotConfig) - `Analysis Configuration` for monitoring snapshot tables
        :param 'GetDataQualityMonitorDataProfilingConfigTimeSeriesArgs' time_series: (TimeSeriesConfig) - `Analysis Configuration` for monitoring time series tables
        :param _builtins.str warehouse_id: (string) - Optional argument to specify the warehouse for dashboard creation. If not specified, the first running
               warehouse will be used
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "drift_metrics_table_name", drift_metrics_table_name)
        pulumi.set(__self__, "effective_warehouse_id", effective_warehouse_id)
        pulumi.set(__self__, "latest_monitor_failure_message", latest_monitor_failure_message)
        pulumi.set(__self__, "monitor_version", monitor_version)
        pulumi.set(__self__, "monitored_table_name", monitored_table_name)
        pulumi.set(__self__, "output_schema_id", output_schema_id)
        pulumi.set(__self__, "profile_metrics_table_name", profile_metrics_table_name)
        pulumi.set(__self__, "status", status)
        if assets_dir is not None:
            pulumi.set(__self__, "assets_dir", assets_dir)
        if baseline_table_name is not None:
            pulumi.set(__self__, "baseline_table_name", baseline_table_name)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if inference_log is not None:
            pulumi.set(__self__, "inference_log", inference_log)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if skip_builtin_dashboard is not None:
            pulumi.set(__self__, "skip_builtin_dashboard", skip_builtin_dashboard)
        if slicing_exprs is not None:
            pulumi.set(__self__, "slicing_exprs", slicing_exprs)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if time_series is not None:
            pulumi.set(__self__, "time_series", time_series)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        """
        (string) - Id of dashboard that visualizes the computed metrics.
        This can be empty if the monitor is in PENDING state
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="driftMetricsTableName")
    def drift_metrics_table_name(self) -> _builtins.str:
        """
        (string) - Table that stores drift metrics data. Format: `catalog.schema.table_name`
        """
        return pulumi.get(self, "drift_metrics_table_name")

    @_builtins.property
    @pulumi.getter(name="effectiveWarehouseId")
    def effective_warehouse_id(self) -> _builtins.str:
        """
        (string) - The warehouse for dashboard creation
        """
        return pulumi.get(self, "effective_warehouse_id")

    @_builtins.property
    @pulumi.getter(name="latestMonitorFailureMessage")
    def latest_monitor_failure_message(self) -> _builtins.str:
        """
        (string) - The latest error message for a monitor failure
        """
        return pulumi.get(self, "latest_monitor_failure_message")

    @_builtins.property
    @pulumi.getter(name="monitorVersion")
    def monitor_version(self) -> _builtins.int:
        """
        (integer) - Represents the current monitor configuration version in use. The version will be represented in a
        numeric fashion (1,2,3...). The field has flexibility to take on negative values, which can indicate corrupted
        monitor_version numbers
        """
        return pulumi.get(self, "monitor_version")

    @_builtins.property
    @pulumi.getter(name="monitoredTableName")
    def monitored_table_name(self) -> _builtins.str:
        """
        (string) - Unity Catalog table to monitor. Format: `catalog.schema.table_name`
        """
        return pulumi.get(self, "monitored_table_name")

    @_builtins.property
    @pulumi.getter(name="outputSchemaId")
    def output_schema_id(self) -> _builtins.str:
        """
        (string) - ID of the schema where output tables are created
        """
        return pulumi.get(self, "output_schema_id")

    @_builtins.property
    @pulumi.getter(name="profileMetricsTableName")
    def profile_metrics_table_name(self) -> _builtins.str:
        """
        (string) - Table that stores profile metrics data. Format: `catalog.schema.table_name`
        """
        return pulumi.get(self, "profile_metrics_table_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        (string) - The data profiling monitor status. Possible values are: `DATA_PROFILING_STATUS_ACTIVE`, `DATA_PROFILING_STATUS_DELETE_PENDING`, `DATA_PROFILING_STATUS_ERROR`, `DATA_PROFILING_STATUS_FAILED`, `DATA_PROFILING_STATUS_PENDING`
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="assetsDir")
    def assets_dir(self) -> Optional[_builtins.str]:
        """
        (string) - Field for specifying the absolute path to a custom directory to store data-monitoring
        assets. Normally prepopulated to a default user location via UI and Python APIs
        """
        return pulumi.get(self, "assets_dir")

    @_builtins.property
    @pulumi.getter(name="baselineTableName")
    def baseline_table_name(self) -> Optional[_builtins.str]:
        """
        (string) - Baseline table name.
        Baseline data is used to compute drift from the data in the monitored `table_name`.
        The baseline table and the monitored table shall have the same schema
        """
        return pulumi.get(self, "baseline_table_name")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[Sequence['outputs.GetDataQualityMonitorDataProfilingConfigCustomMetricResult']]:
        """
        (list of DataProfilingCustomMetric) - Custom metrics
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter(name="inferenceLog")
    def inference_log(self) -> Optional['outputs.GetDataQualityMonitorDataProfilingConfigInferenceLogResult']:
        """
        (InferenceLogConfig) - `Analysis Configuration` for monitoring inference log tables
        """
        return pulumi.get(self, "inference_log")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.GetDataQualityMonitorDataProfilingConfigNotificationSettingsResult']:
        """
        (NotificationSettings) - Field for specifying notification settings
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.GetDataQualityMonitorDataProfilingConfigScheduleResult']:
        """
        (CronSchedule) - The cron schedule
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="skipBuiltinDashboard")
    def skip_builtin_dashboard(self) -> Optional[_builtins.bool]:
        """
        (boolean) - Whether to skip creating a default dashboard summarizing data quality metrics
        """
        return pulumi.get(self, "skip_builtin_dashboard")

    @_builtins.property
    @pulumi.getter(name="slicingExprs")
    def slicing_exprs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - List of column expressions to slice data with for targeted analysis. The data is grouped by
        each expression independently, resulting in a separate slice for each predicate and its
        complements. For example `slicing_exprs=[col_1, col_2 > 10]` will generate the following
        slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in
        `col1`. For high-cardinality columns, only the top 100 unique values by frequency will
        generate slices
        """
        return pulumi.get(self, "slicing_exprs")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.GetDataQualityMonitorDataProfilingConfigSnapshotResult']:
        """
        (SnapshotConfig) - `Analysis Configuration` for monitoring snapshot tables
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> Optional['outputs.GetDataQualityMonitorDataProfilingConfigTimeSeriesResult']:
        """
        (TimeSeriesConfig) - `Analysis Configuration` for monitoring time series tables
        """
        return pulumi.get(self, "time_series")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        (string) - Optional argument to specify the warehouse for dashboard creation. If not specified, the first running
        warehouse will be used
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigCustomMetricResult(dict):
    def __init__(__self__, *,
                 definition: _builtins.str,
                 input_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 output_data_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str definition: (string) - Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param Sequence[_builtins.str] input_columns: (list of string) - A list of column names in the input table the metric should be computed for.
               Can use ``":table"`` to indicate that the metric needs information from multiple columns
        :param _builtins.str name: (string) - Name of the metric in the output tables
        :param _builtins.str output_data_type: (string) - The output type of the custom metric
        :param _builtins.str type: (string) - The type of the custom metric. Possible values are: `DATA_PROFILING_CUSTOM_METRIC_TYPE_AGGREGATE`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DERIVED`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DRIFT`
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        (string) - Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence[_builtins.str]:
        """
        (list of string) - A list of column names in the input table the metric should be computed for.
        Can use ``":table"`` to indicate that the metric needs information from multiple columns
        """
        return pulumi.get(self, "input_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the metric in the output tables
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> _builtins.str:
        """
        (string) - The output type of the custom metric
        """
        return pulumi.get(self, "output_data_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (string) - The type of the custom metric. Possible values are: `DATA_PROFILING_CUSTOM_METRIC_TYPE_AGGREGATE`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DERIVED`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DRIFT`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigInferenceLogResult(dict):
    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 model_id_column: _builtins.str,
                 prediction_column: _builtins.str,
                 problem_type: _builtins.str,
                 timestamp_column: _builtins.str,
                 label_column: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] granularities: (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        :param _builtins.str model_id_column: (string) - Column for the model identifier
        :param _builtins.str prediction_column: (string) - Column for the prediction
        :param _builtins.str problem_type: (string) - Problem type the model aims to solve. Possible values are: `INFERENCE_PROBLEM_TYPE_CLASSIFICATION`, `INFERENCE_PROBLEM_TYPE_REGRESSION`
        :param _builtins.str timestamp_column: (string) - Column for the timestamp
        :param _builtins.str label_column: (string) - Column for the label
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_column", model_id_column)
        pulumi.set(__self__, "prediction_column", prediction_column)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_column", timestamp_column)
        if label_column is not None:
            pulumi.set(__self__, "label_column", label_column)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="modelIdColumn")
    def model_id_column(self) -> _builtins.str:
        """
        (string) - Column for the model identifier
        """
        return pulumi.get(self, "model_id_column")

    @_builtins.property
    @pulumi.getter(name="predictionColumn")
    def prediction_column(self) -> _builtins.str:
        """
        (string) - Column for the prediction
        """
        return pulumi.get(self, "prediction_column")

    @_builtins.property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> _builtins.str:
        """
        (string) - Problem type the model aims to solve. Possible values are: `INFERENCE_PROBLEM_TYPE_CLASSIFICATION`, `INFERENCE_PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @_builtins.property
    @pulumi.getter(name="timestampColumn")
    def timestamp_column(self) -> _builtins.str:
        """
        (string) - Column for the timestamp
        """
        return pulumi.get(self, "timestamp_column")

    @_builtins.property
    @pulumi.getter(name="labelColumn")
    def label_column(self) -> Optional[_builtins.str]:
        """
        (string) - Column for the label
        """
        return pulumi.get(self, "label_column")


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 on_failure: Optional['outputs.GetDataQualityMonitorDataProfilingConfigNotificationSettingsOnFailureResult'] = None):
        """
        :param 'GetDataQualityMonitorDataProfilingConfigNotificationSettingsOnFailureArgs' on_failure: (NotificationDestination) - Destinations to send notifications on failure/timeout
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.GetDataQualityMonitorDataProfilingConfigNotificationSettingsOnFailureResult']:
        """
        (NotificationDestination) - Destinations to send notifications on failure/timeout
        """
        return pulumi.get(self, "on_failure")


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigNotificationSettingsOnFailureResult(dict):
    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] email_addresses: (list of string) - The list of email addresses to send the notification to. A maximum of 5 email addresses is supported
        """
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - The list of email addresses to send the notification to. A maximum of 5 email addresses is supported
        """
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigScheduleResult(dict):
    def __init__(__self__, *,
                 pause_status: _builtins.str,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str):
        """
        :param _builtins.str pause_status: (string) - Read only field that indicates whether the schedule is paused or not. Possible values are: `CRON_SCHEDULE_PAUSE_STATUS_PAUSED`, `CRON_SCHEDULE_PAUSE_STATUS_UNPAUSED`
        :param _builtins.str quartz_cron_expression: (string) - The expression that determines when to run the monitor. See [examples](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html)
        :param _builtins.str timezone_id: (string) - A Java timezone id. The schedule for a job will be resolved with respect to this timezone.
               See `Java TimeZone <http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html>`_ for details.
               The timezone id (e.g., ``America/Los_Angeles``) in which to evaluate the quartz expression
        """
        pulumi.set(__self__, "pause_status", pause_status)
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> _builtins.str:
        """
        (string) - Read only field that indicates whether the schedule is paused or not. Possible values are: `CRON_SCHEDULE_PAUSE_STATUS_PAUSED`, `CRON_SCHEDULE_PAUSE_STATUS_UNPAUSED`
        """
        return pulumi.get(self, "pause_status")

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        """
        (string) - The expression that determines when to run the monitor. See [examples](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html)
        """
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        (string) - A Java timezone id. The schedule for a job will be resolved with respect to this timezone.
        See `Java TimeZone <http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html>`_ for details.
        The timezone id (e.g., ``America/Los_Angeles``) in which to evaluate the quartz expression
        """
        return pulumi.get(self, "timezone_id")


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigSnapshotResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetDataQualityMonitorDataProfilingConfigTimeSeriesResult(dict):
    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 timestamp_column: _builtins.str):
        """
        :param Sequence[_builtins.str] granularities: (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        :param _builtins.str timestamp_column: (string) - Column for the timestamp
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_column", timestamp_column)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="timestampColumn")
    def timestamp_column(self) -> _builtins.str:
        """
        (string) - Column for the timestamp
        """
        return pulumi.get(self, "timestamp_column")


@pulumi.output_type
class GetDataQualityMonitorsMonitorResult(dict):
    def __init__(__self__, *,
                 anomaly_detection_config: 'outputs.GetDataQualityMonitorsMonitorAnomalyDetectionConfigResult',
                 data_profiling_config: 'outputs.GetDataQualityMonitorsMonitorDataProfilingConfigResult',
                 object_id: _builtins.str,
                 object_type: _builtins.str):
        """
        :param 'GetDataQualityMonitorsMonitorAnomalyDetectionConfigArgs' anomaly_detection_config: (AnomalyDetectionConfig) - Anomaly Detection Configuration, applicable to `schema` object types
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigArgs' data_profiling_config: (DataProfilingConfig) - Data Profiling Configuration, applicable to `table` object types. Exactly one `Analysis Configuration`
               must be present
        :param _builtins.str object_id: (string) - The UUID of the request object. It is `schema_id` for `schema`, and `table_id` for `table`.
        :param _builtins.str object_type: (string) - The type of the monitored object. Can be one of the following: `schema` or `table`
        """
        pulumi.set(__self__, "anomaly_detection_config", anomaly_detection_config)
        pulumi.set(__self__, "data_profiling_config", data_profiling_config)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "object_type", object_type)

    @_builtins.property
    @pulumi.getter(name="anomalyDetectionConfig")
    def anomaly_detection_config(self) -> 'outputs.GetDataQualityMonitorsMonitorAnomalyDetectionConfigResult':
        """
        (AnomalyDetectionConfig) - Anomaly Detection Configuration, applicable to `schema` object types
        """
        return pulumi.get(self, "anomaly_detection_config")

    @_builtins.property
    @pulumi.getter(name="dataProfilingConfig")
    def data_profiling_config(self) -> 'outputs.GetDataQualityMonitorsMonitorDataProfilingConfigResult':
        """
        (DataProfilingConfig) - Data Profiling Configuration, applicable to `table` object types. Exactly one `Analysis Configuration`
        must be present
        """
        return pulumi.get(self, "data_profiling_config")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        (string) - The UUID of the request object. It is `schema_id` for `schema`, and `table_id` for `table`.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        (string) - The type of the monitored object. Can be one of the following: `schema` or `table`
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class GetDataQualityMonitorsMonitorAnomalyDetectionConfigResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigResult(dict):
    def __init__(__self__, *,
                 dashboard_id: _builtins.str,
                 drift_metrics_table_name: _builtins.str,
                 effective_warehouse_id: _builtins.str,
                 latest_monitor_failure_message: _builtins.str,
                 monitor_version: _builtins.int,
                 monitored_table_name: _builtins.str,
                 output_schema_id: _builtins.str,
                 profile_metrics_table_name: _builtins.str,
                 status: _builtins.str,
                 assets_dir: Optional[_builtins.str] = None,
                 baseline_table_name: Optional[_builtins.str] = None,
                 custom_metrics: Optional[Sequence['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigCustomMetricResult']] = None,
                 inference_log: Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigInferenceLogResult'] = None,
                 notification_settings: Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsResult'] = None,
                 schedule: Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigScheduleResult'] = None,
                 skip_builtin_dashboard: Optional[_builtins.bool] = None,
                 slicing_exprs: Optional[Sequence[_builtins.str]] = None,
                 snapshot: Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigSnapshotResult'] = None,
                 time_series: Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigTimeSeriesResult'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str dashboard_id: (string) - Id of dashboard that visualizes the computed metrics.
               This can be empty if the monitor is in PENDING state
        :param _builtins.str drift_metrics_table_name: (string) - Table that stores drift metrics data. Format: `catalog.schema.table_name`
        :param _builtins.str effective_warehouse_id: (string) - The warehouse for dashboard creation
        :param _builtins.str latest_monitor_failure_message: (string) - The latest error message for a monitor failure
        :param _builtins.int monitor_version: (integer) - Represents the current monitor configuration version in use. The version will be represented in a
               numeric fashion (1,2,3...). The field has flexibility to take on negative values, which can indicate corrupted
               monitor_version numbers
        :param _builtins.str monitored_table_name: (string) - Unity Catalog table to monitor. Format: `catalog.schema.table_name`
        :param _builtins.str output_schema_id: (string) - ID of the schema where output tables are created
        :param _builtins.str profile_metrics_table_name: (string) - Table that stores profile metrics data. Format: `catalog.schema.table_name`
        :param _builtins.str status: (string) - The data profiling monitor status. Possible values are: `DATA_PROFILING_STATUS_ACTIVE`, `DATA_PROFILING_STATUS_DELETE_PENDING`, `DATA_PROFILING_STATUS_ERROR`, `DATA_PROFILING_STATUS_FAILED`, `DATA_PROFILING_STATUS_PENDING`
        :param _builtins.str assets_dir: (string) - Field for specifying the absolute path to a custom directory to store data-monitoring
               assets. Normally prepopulated to a default user location via UI and Python APIs
        :param _builtins.str baseline_table_name: (string) - Baseline table name.
               Baseline data is used to compute drift from the data in the monitored `table_name`.
               The baseline table and the monitored table shall have the same schema
        :param Sequence['GetDataQualityMonitorsMonitorDataProfilingConfigCustomMetricArgs'] custom_metrics: (list of DataProfilingCustomMetric) - Custom metrics
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigInferenceLogArgs' inference_log: (InferenceLogConfig) - `Analysis Configuration` for monitoring inference log tables
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsArgs' notification_settings: (NotificationSettings) - Field for specifying notification settings
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigScheduleArgs' schedule: (CronSchedule) - The cron schedule
        :param _builtins.bool skip_builtin_dashboard: (boolean) - Whether to skip creating a default dashboard summarizing data quality metrics
        :param Sequence[_builtins.str] slicing_exprs: (list of string) - List of column expressions to slice data with for targeted analysis. The data is grouped by
               each expression independently, resulting in a separate slice for each predicate and its
               complements. For example `slicing_exprs=[col_1, col_2 > 10]` will generate the following
               slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in
               `col1`. For high-cardinality columns, only the top 100 unique values by frequency will
               generate slices
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigSnapshotArgs' snapshot: (SnapshotConfig) - `Analysis Configuration` for monitoring snapshot tables
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigTimeSeriesArgs' time_series: (TimeSeriesConfig) - `Analysis Configuration` for monitoring time series tables
        :param _builtins.str warehouse_id: (string) - Optional argument to specify the warehouse for dashboard creation. If not specified, the first running
               warehouse will be used
        """
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        pulumi.set(__self__, "drift_metrics_table_name", drift_metrics_table_name)
        pulumi.set(__self__, "effective_warehouse_id", effective_warehouse_id)
        pulumi.set(__self__, "latest_monitor_failure_message", latest_monitor_failure_message)
        pulumi.set(__self__, "monitor_version", monitor_version)
        pulumi.set(__self__, "monitored_table_name", monitored_table_name)
        pulumi.set(__self__, "output_schema_id", output_schema_id)
        pulumi.set(__self__, "profile_metrics_table_name", profile_metrics_table_name)
        pulumi.set(__self__, "status", status)
        if assets_dir is not None:
            pulumi.set(__self__, "assets_dir", assets_dir)
        if baseline_table_name is not None:
            pulumi.set(__self__, "baseline_table_name", baseline_table_name)
        if custom_metrics is not None:
            pulumi.set(__self__, "custom_metrics", custom_metrics)
        if inference_log is not None:
            pulumi.set(__self__, "inference_log", inference_log)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if skip_builtin_dashboard is not None:
            pulumi.set(__self__, "skip_builtin_dashboard", skip_builtin_dashboard)
        if slicing_exprs is not None:
            pulumi.set(__self__, "slicing_exprs", slicing_exprs)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if time_series is not None:
            pulumi.set(__self__, "time_series", time_series)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        """
        (string) - Id of dashboard that visualizes the computed metrics.
        This can be empty if the monitor is in PENDING state
        """
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="driftMetricsTableName")
    def drift_metrics_table_name(self) -> _builtins.str:
        """
        (string) - Table that stores drift metrics data. Format: `catalog.schema.table_name`
        """
        return pulumi.get(self, "drift_metrics_table_name")

    @_builtins.property
    @pulumi.getter(name="effectiveWarehouseId")
    def effective_warehouse_id(self) -> _builtins.str:
        """
        (string) - The warehouse for dashboard creation
        """
        return pulumi.get(self, "effective_warehouse_id")

    @_builtins.property
    @pulumi.getter(name="latestMonitorFailureMessage")
    def latest_monitor_failure_message(self) -> _builtins.str:
        """
        (string) - The latest error message for a monitor failure
        """
        return pulumi.get(self, "latest_monitor_failure_message")

    @_builtins.property
    @pulumi.getter(name="monitorVersion")
    def monitor_version(self) -> _builtins.int:
        """
        (integer) - Represents the current monitor configuration version in use. The version will be represented in a
        numeric fashion (1,2,3...). The field has flexibility to take on negative values, which can indicate corrupted
        monitor_version numbers
        """
        return pulumi.get(self, "monitor_version")

    @_builtins.property
    @pulumi.getter(name="monitoredTableName")
    def monitored_table_name(self) -> _builtins.str:
        """
        (string) - Unity Catalog table to monitor. Format: `catalog.schema.table_name`
        """
        return pulumi.get(self, "monitored_table_name")

    @_builtins.property
    @pulumi.getter(name="outputSchemaId")
    def output_schema_id(self) -> _builtins.str:
        """
        (string) - ID of the schema where output tables are created
        """
        return pulumi.get(self, "output_schema_id")

    @_builtins.property
    @pulumi.getter(name="profileMetricsTableName")
    def profile_metrics_table_name(self) -> _builtins.str:
        """
        (string) - Table that stores profile metrics data. Format: `catalog.schema.table_name`
        """
        return pulumi.get(self, "profile_metrics_table_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        (string) - The data profiling monitor status. Possible values are: `DATA_PROFILING_STATUS_ACTIVE`, `DATA_PROFILING_STATUS_DELETE_PENDING`, `DATA_PROFILING_STATUS_ERROR`, `DATA_PROFILING_STATUS_FAILED`, `DATA_PROFILING_STATUS_PENDING`
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="assetsDir")
    def assets_dir(self) -> Optional[_builtins.str]:
        """
        (string) - Field for specifying the absolute path to a custom directory to store data-monitoring
        assets. Normally prepopulated to a default user location via UI and Python APIs
        """
        return pulumi.get(self, "assets_dir")

    @_builtins.property
    @pulumi.getter(name="baselineTableName")
    def baseline_table_name(self) -> Optional[_builtins.str]:
        """
        (string) - Baseline table name.
        Baseline data is used to compute drift from the data in the monitored `table_name`.
        The baseline table and the monitored table shall have the same schema
        """
        return pulumi.get(self, "baseline_table_name")

    @_builtins.property
    @pulumi.getter(name="customMetrics")
    def custom_metrics(self) -> Optional[Sequence['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigCustomMetricResult']]:
        """
        (list of DataProfilingCustomMetric) - Custom metrics
        """
        return pulumi.get(self, "custom_metrics")

    @_builtins.property
    @pulumi.getter(name="inferenceLog")
    def inference_log(self) -> Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigInferenceLogResult']:
        """
        (InferenceLogConfig) - `Analysis Configuration` for monitoring inference log tables
        """
        return pulumi.get(self, "inference_log")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsResult']:
        """
        (NotificationSettings) - Field for specifying notification settings
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigScheduleResult']:
        """
        (CronSchedule) - The cron schedule
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="skipBuiltinDashboard")
    def skip_builtin_dashboard(self) -> Optional[_builtins.bool]:
        """
        (boolean) - Whether to skip creating a default dashboard summarizing data quality metrics
        """
        return pulumi.get(self, "skip_builtin_dashboard")

    @_builtins.property
    @pulumi.getter(name="slicingExprs")
    def slicing_exprs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - List of column expressions to slice data with for targeted analysis. The data is grouped by
        each expression independently, resulting in a separate slice for each predicate and its
        complements. For example `slicing_exprs=[col_1, col_2 > 10]` will generate the following
        slices: two slices for `col_2 > 10` (True and False), and one slice per unique value in
        `col1`. For high-cardinality columns, only the top 100 unique values by frequency will
        generate slices
        """
        return pulumi.get(self, "slicing_exprs")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigSnapshotResult']:
        """
        (SnapshotConfig) - `Analysis Configuration` for monitoring snapshot tables
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="timeSeries")
    def time_series(self) -> Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigTimeSeriesResult']:
        """
        (TimeSeriesConfig) - `Analysis Configuration` for monitoring time series tables
        """
        return pulumi.get(self, "time_series")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        """
        (string) - Optional argument to specify the warehouse for dashboard creation. If not specified, the first running
        warehouse will be used
        """
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigCustomMetricResult(dict):
    def __init__(__self__, *,
                 definition: _builtins.str,
                 input_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 output_data_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str definition: (string) - Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        :param Sequence[_builtins.str] input_columns: (list of string) - A list of column names in the input table the metric should be computed for.
               Can use ``":table"`` to indicate that the metric needs information from multiple columns
        :param _builtins.str name: (string) - Name of the metric in the output tables
        :param _builtins.str output_data_type: (string) - The output type of the custom metric
        :param _builtins.str type: (string) - The type of the custom metric. Possible values are: `DATA_PROFILING_CUSTOM_METRIC_TYPE_AGGREGATE`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DERIVED`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DRIFT`
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "input_columns", input_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_data_type", output_data_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        (string) - Jinja template for a SQL expression that specifies how to compute the metric. See [create metric definition](https://docs.databricks.com/en/lakehouse-monitoring/custom-metrics.html#create-definition)
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter(name="inputColumns")
    def input_columns(self) -> Sequence[_builtins.str]:
        """
        (list of string) - A list of column names in the input table the metric should be computed for.
        Can use ``":table"`` to indicate that the metric needs information from multiple columns
        """
        return pulumi.get(self, "input_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the metric in the output tables
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputDataType")
    def output_data_type(self) -> _builtins.str:
        """
        (string) - The output type of the custom metric
        """
        return pulumi.get(self, "output_data_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        (string) - The type of the custom metric. Possible values are: `DATA_PROFILING_CUSTOM_METRIC_TYPE_AGGREGATE`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DERIVED`, `DATA_PROFILING_CUSTOM_METRIC_TYPE_DRIFT`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigInferenceLogResult(dict):
    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 model_id_column: _builtins.str,
                 prediction_column: _builtins.str,
                 problem_type: _builtins.str,
                 timestamp_column: _builtins.str,
                 label_column: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] granularities: (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        :param _builtins.str model_id_column: (string) - Column for the model identifier
        :param _builtins.str prediction_column: (string) - Column for the prediction
        :param _builtins.str problem_type: (string) - Problem type the model aims to solve. Possible values are: `INFERENCE_PROBLEM_TYPE_CLASSIFICATION`, `INFERENCE_PROBLEM_TYPE_REGRESSION`
        :param _builtins.str timestamp_column: (string) - Column for the timestamp
        :param _builtins.str label_column: (string) - Column for the label
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "model_id_column", model_id_column)
        pulumi.set(__self__, "prediction_column", prediction_column)
        pulumi.set(__self__, "problem_type", problem_type)
        pulumi.set(__self__, "timestamp_column", timestamp_column)
        if label_column is not None:
            pulumi.set(__self__, "label_column", label_column)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="modelIdColumn")
    def model_id_column(self) -> _builtins.str:
        """
        (string) - Column for the model identifier
        """
        return pulumi.get(self, "model_id_column")

    @_builtins.property
    @pulumi.getter(name="predictionColumn")
    def prediction_column(self) -> _builtins.str:
        """
        (string) - Column for the prediction
        """
        return pulumi.get(self, "prediction_column")

    @_builtins.property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> _builtins.str:
        """
        (string) - Problem type the model aims to solve. Possible values are: `INFERENCE_PROBLEM_TYPE_CLASSIFICATION`, `INFERENCE_PROBLEM_TYPE_REGRESSION`
        """
        return pulumi.get(self, "problem_type")

    @_builtins.property
    @pulumi.getter(name="timestampColumn")
    def timestamp_column(self) -> _builtins.str:
        """
        (string) - Column for the timestamp
        """
        return pulumi.get(self, "timestamp_column")

    @_builtins.property
    @pulumi.getter(name="labelColumn")
    def label_column(self) -> Optional[_builtins.str]:
        """
        (string) - Column for the label
        """
        return pulumi.get(self, "label_column")


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 on_failure: Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsOnFailureResult'] = None):
        """
        :param 'GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsOnFailureArgs' on_failure: (NotificationDestination) - Destinations to send notifications on failure/timeout
        """
        if on_failure is not None:
            pulumi.set(__self__, "on_failure", on_failure)

    @_builtins.property
    @pulumi.getter(name="onFailure")
    def on_failure(self) -> Optional['outputs.GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsOnFailureResult']:
        """
        (NotificationDestination) - Destinations to send notifications on failure/timeout
        """
        return pulumi.get(self, "on_failure")


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigNotificationSettingsOnFailureResult(dict):
    def __init__(__self__, *,
                 email_addresses: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] email_addresses: (list of string) - The list of email addresses to send the notification to. A maximum of 5 email addresses is supported
        """
        if email_addresses is not None:
            pulumi.set(__self__, "email_addresses", email_addresses)

    @_builtins.property
    @pulumi.getter(name="emailAddresses")
    def email_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - The list of email addresses to send the notification to. A maximum of 5 email addresses is supported
        """
        return pulumi.get(self, "email_addresses")


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigScheduleResult(dict):
    def __init__(__self__, *,
                 pause_status: _builtins.str,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str):
        """
        :param _builtins.str pause_status: (string) - Read only field that indicates whether the schedule is paused or not. Possible values are: `CRON_SCHEDULE_PAUSE_STATUS_PAUSED`, `CRON_SCHEDULE_PAUSE_STATUS_UNPAUSED`
        :param _builtins.str quartz_cron_expression: (string) - The expression that determines when to run the monitor. See [examples](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html)
        :param _builtins.str timezone_id: (string) - A Java timezone id. The schedule for a job will be resolved with respect to this timezone.
               See `Java TimeZone <http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html>`_ for details.
               The timezone id (e.g., ``America/Los_Angeles``) in which to evaluate the quartz expression
        """
        pulumi.set(__self__, "pause_status", pause_status)
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> _builtins.str:
        """
        (string) - Read only field that indicates whether the schedule is paused or not. Possible values are: `CRON_SCHEDULE_PAUSE_STATUS_PAUSED`, `CRON_SCHEDULE_PAUSE_STATUS_UNPAUSED`
        """
        return pulumi.get(self, "pause_status")

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        """
        (string) - The expression that determines when to run the monitor. See [examples](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html)
        """
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        """
        (string) - A Java timezone id. The schedule for a job will be resolved with respect to this timezone.
        See `Java TimeZone <http://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html>`_ for details.
        The timezone id (e.g., ``America/Los_Angeles``) in which to evaluate the quartz expression
        """
        return pulumi.get(self, "timezone_id")


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigSnapshotResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetDataQualityMonitorsMonitorDataProfilingConfigTimeSeriesResult(dict):
    def __init__(__self__, *,
                 granularities: Sequence[_builtins.str],
                 timestamp_column: _builtins.str):
        """
        :param Sequence[_builtins.str] granularities: (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        :param _builtins.str timestamp_column: (string) - Column for the timestamp
        """
        pulumi.set(__self__, "granularities", granularities)
        pulumi.set(__self__, "timestamp_column", timestamp_column)

    @_builtins.property
    @pulumi.getter
    def granularities(self) -> Sequence[_builtins.str]:
        """
        (list of string) - List of granularities to use when aggregating data into time windows based on their timestamp
        """
        return pulumi.get(self, "granularities")

    @_builtins.property
    @pulumi.getter(name="timestampColumn")
    def timestamp_column(self) -> _builtins.str:
        """
        (string) - Column for the timestamp
        """
        return pulumi.get(self, "timestamp_column")


@pulumi.output_type
class GetDataQualityRefreshesRefreshResult(dict):
    def __init__(__self__, *,
                 end_time_ms: _builtins.int,
                 message: _builtins.str,
                 object_id: _builtins.str,
                 object_type: _builtins.str,
                 refresh_id: _builtins.int,
                 start_time_ms: _builtins.int,
                 state: _builtins.str,
                 trigger: _builtins.str):
        """
        :param _builtins.int end_time_ms: (integer) - Time when the refresh ended (milliseconds since 1/1/1970 UTC)
        :param _builtins.str message: (string) - An optional message to give insight into the current state of the refresh (e.g. FAILURE messages)
        :param _builtins.str object_id: The UUID of the request object. It is `schema_id` for `schema`, and `table_id` for `table`.
               
               Find the `schema_id` from either:
               1. The [schema_id](https://docs.databricks.com/api/workspace/schemas/get#schema_id) of the `Schemas` resource.
               2. In [Catalog Explorer](https://docs.databricks.com/aws/en/catalog-explorer/) > select the `schema` > go to the `Details` tab > the `Schema ID` field.
               
               Find the `table_id` from either:
               1. The [table_id](https://docs.databricks.com/api/workspace/tables/get#table_id) of the `Tables` resource.
               2. In [Catalog Explorer](https://docs.databricks.com/aws/en/catalog-explorer/) > select the `table` > go to the `Details` tab > the `Table ID` field
        :param _builtins.str object_type: The type of the monitored object. Can be one of the following: `schema` or `table`
        :param _builtins.int refresh_id: (integer) - Unique id of the refresh operation
        :param _builtins.int start_time_ms: (integer) - Time when the refresh started (milliseconds since 1/1/1970 UTC)
        :param _builtins.str state: (string) - The current state of the refresh. Possible values are: `MONITOR_REFRESH_STATE_CANCELED`, `MONITOR_REFRESH_STATE_FAILED`, `MONITOR_REFRESH_STATE_PENDING`, `MONITOR_REFRESH_STATE_RUNNING`, `MONITOR_REFRESH_STATE_SUCCESS`, `MONITOR_REFRESH_STATE_UNKNOWN`
        :param _builtins.str trigger: (string) - What triggered the refresh. Possible values are: `MONITOR_REFRESH_TRIGGER_DATA_CHANGE`, `MONITOR_REFRESH_TRIGGER_MANUAL`, `MONITOR_REFRESH_TRIGGER_SCHEDULE`, `MONITOR_REFRESH_TRIGGER_UNKNOWN`
        """
        pulumi.set(__self__, "end_time_ms", end_time_ms)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "object_type", object_type)
        pulumi.set(__self__, "refresh_id", refresh_id)
        pulumi.set(__self__, "start_time_ms", start_time_ms)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "trigger", trigger)

    @_builtins.property
    @pulumi.getter(name="endTimeMs")
    def end_time_ms(self) -> _builtins.int:
        """
        (integer) - Time when the refresh ended (milliseconds since 1/1/1970 UTC)
        """
        return pulumi.get(self, "end_time_ms")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        (string) - An optional message to give insight into the current state of the refresh (e.g. FAILURE messages)
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        The UUID of the request object. It is `schema_id` for `schema`, and `table_id` for `table`.

        Find the `schema_id` from either:
        1. The [schema_id](https://docs.databricks.com/api/workspace/schemas/get#schema_id) of the `Schemas` resource.
        2. In [Catalog Explorer](https://docs.databricks.com/aws/en/catalog-explorer/) > select the `schema` > go to the `Details` tab > the `Schema ID` field.

        Find the `table_id` from either:
        1. The [table_id](https://docs.databricks.com/api/workspace/tables/get#table_id) of the `Tables` resource.
        2. In [Catalog Explorer](https://docs.databricks.com/aws/en/catalog-explorer/) > select the `table` > go to the `Details` tab > the `Table ID` field
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        The type of the monitored object. Can be one of the following: `schema` or `table`
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="refreshId")
    def refresh_id(self) -> _builtins.int:
        """
        (integer) - Unique id of the refresh operation
        """
        return pulumi.get(self, "refresh_id")

    @_builtins.property
    @pulumi.getter(name="startTimeMs")
    def start_time_ms(self) -> _builtins.int:
        """
        (integer) - Time when the refresh started (milliseconds since 1/1/1970 UTC)
        """
        return pulumi.get(self, "start_time_ms")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - The current state of the refresh. Possible values are: `MONITOR_REFRESH_STATE_CANCELED`, `MONITOR_REFRESH_STATE_FAILED`, `MONITOR_REFRESH_STATE_PENDING`, `MONITOR_REFRESH_STATE_RUNNING`, `MONITOR_REFRESH_STATE_SUCCESS`, `MONITOR_REFRESH_STATE_UNKNOWN`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> _builtins.str:
        """
        (string) - What triggered the refresh. Possible values are: `MONITOR_REFRESH_TRIGGER_DATA_CHANGE`, `MONITOR_REFRESH_TRIGGER_MANUAL`, `MONITOR_REFRESH_TRIGGER_SCHEDULE`, `MONITOR_REFRESH_TRIGGER_UNKNOWN`
        """
        return pulumi.get(self, "trigger")


@pulumi.output_type
class GetDatabaseDatabaseCatalogsDatabaseCatalogResult(dict):
    def __init__(__self__, *,
                 create_database_if_not_exists: _builtins.bool,
                 database_instance_name: _builtins.str,
                 database_name: _builtins.str,
                 name: _builtins.str,
                 uid: _builtins.str):
        """
        :param _builtins.bool create_database_if_not_exists: (boolean)
        :param _builtins.str database_instance_name: (string) - The name of the DatabaseInstance housing the database
        :param _builtins.str database_name: (string) - The name of the database (in a instance) associated with the catalog
        :param _builtins.str name: (string) - The name of the catalog in UC
        :param _builtins.str uid: (string)
        """
        pulumi.set(__self__, "create_database_if_not_exists", create_database_if_not_exists)
        pulumi.set(__self__, "database_instance_name", database_instance_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="createDatabaseIfNotExists")
    def create_database_if_not_exists(self) -> _builtins.bool:
        """
        (boolean)
        """
        return pulumi.get(self, "create_database_if_not_exists")

    @_builtins.property
    @pulumi.getter(name="databaseInstanceName")
    def database_instance_name(self) -> _builtins.str:
        """
        (string) - The name of the DatabaseInstance housing the database
        """
        return pulumi.get(self, "database_instance_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        (string) - The name of the database (in a instance) associated with the catalog
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - The name of the catalog in UC
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetDatabaseInstanceChildInstanceRefResult(dict):
    def __init__(__self__, *,
                 effective_lsn: _builtins.str,
                 lsn: _builtins.str,
                 uid: _builtins.str,
                 branch_time: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str effective_lsn: (string) - For a parent ref instance, this is the LSN on the parent instance from which the
               instance was created.
               For a child ref instance, this is the LSN on the instance from which the child instance
               was created
        :param _builtins.str lsn: (string) - User-specified WAL LSN of the ref database instance.
        :param _builtins.str uid: (string) - Id of the ref database instance
        :param _builtins.str branch_time: (string) - Branch time of the ref database instance.
               For a parent ref instance, this is the point in time on the parent instance from which the
               instance was created.
               For a child ref instance, this is the point in time on the instance from which the child
               instance was created.
               Input: For specifying the point in time to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str name: The name of the instance. This is the unique identifier for the instance
        """
        pulumi.set(__self__, "effective_lsn", effective_lsn)
        pulumi.set(__self__, "lsn", lsn)
        pulumi.set(__self__, "uid", uid)
        if branch_time is not None:
            pulumi.set(__self__, "branch_time", branch_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="effectiveLsn")
    def effective_lsn(self) -> _builtins.str:
        """
        (string) - For a parent ref instance, this is the LSN on the parent instance from which the
        instance was created.
        For a child ref instance, this is the LSN on the instance from which the child instance
        was created
        """
        return pulumi.get(self, "effective_lsn")

    @_builtins.property
    @pulumi.getter
    def lsn(self) -> _builtins.str:
        """
        (string) - User-specified WAL LSN of the ref database instance.
        """
        return pulumi.get(self, "lsn")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="branchTime")
    def branch_time(self) -> Optional[_builtins.str]:
        """
        (string) - Branch time of the ref database instance.
        For a parent ref instance, this is the point in time on the parent instance from which the
        instance was created.
        For a child ref instance, this is the point in time on the instance from which the child
        instance was created.
        Input: For specifying the point in time to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "branch_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance. This is the unique identifier for the instance
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseInstanceCustomTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (string) - The key of the custom tag
        :param _builtins.str value: (string) - The value of the custom tag
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (string) - The key of the custom tag
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - The value of the custom tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseInstanceEffectiveCustomTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (string) - The key of the custom tag
        :param _builtins.str value: (string) - The value of the custom tag
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (string) - The key of the custom tag
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - The value of the custom tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseInstanceParentInstanceRefResult(dict):
    def __init__(__self__, *,
                 effective_lsn: _builtins.str,
                 lsn: _builtins.str,
                 uid: _builtins.str,
                 branch_time: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str effective_lsn: (string) - For a parent ref instance, this is the LSN on the parent instance from which the
               instance was created.
               For a child ref instance, this is the LSN on the instance from which the child instance
               was created
        :param _builtins.str lsn: (string) - User-specified WAL LSN of the ref database instance.
        :param _builtins.str uid: (string) - Id of the ref database instance
        :param _builtins.str branch_time: (string) - Branch time of the ref database instance.
               For a parent ref instance, this is the point in time on the parent instance from which the
               instance was created.
               For a child ref instance, this is the point in time on the instance from which the child
               instance was created.
               Input: For specifying the point in time to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str name: The name of the instance. This is the unique identifier for the instance
        """
        pulumi.set(__self__, "effective_lsn", effective_lsn)
        pulumi.set(__self__, "lsn", lsn)
        pulumi.set(__self__, "uid", uid)
        if branch_time is not None:
            pulumi.set(__self__, "branch_time", branch_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="effectiveLsn")
    def effective_lsn(self) -> _builtins.str:
        """
        (string) - For a parent ref instance, this is the LSN on the parent instance from which the
        instance was created.
        For a child ref instance, this is the LSN on the instance from which the child instance
        was created
        """
        return pulumi.get(self, "effective_lsn")

    @_builtins.property
    @pulumi.getter
    def lsn(self) -> _builtins.str:
        """
        (string) - User-specified WAL LSN of the ref database instance.
        """
        return pulumi.get(self, "lsn")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="branchTime")
    def branch_time(self) -> Optional[_builtins.str]:
        """
        (string) - Branch time of the ref database instance.
        For a parent ref instance, this is the point in time on the parent instance from which the
        instance was created.
        For a child ref instance, this is the point in time on the instance from which the child
        instance was created.
        Input: For specifying the point in time to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "branch_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance. This is the unique identifier for the instance
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseInstancesDatabaseInstanceResult(dict):
    def __init__(__self__, *,
                 capacity: _builtins.str,
                 child_instance_refs: Sequence['outputs.GetDatabaseInstancesDatabaseInstanceChildInstanceRefResult'],
                 creation_time: _builtins.str,
                 creator: _builtins.str,
                 custom_tags: Sequence['outputs.GetDatabaseInstancesDatabaseInstanceCustomTagResult'],
                 effective_capacity: _builtins.str,
                 effective_custom_tags: Sequence['outputs.GetDatabaseInstancesDatabaseInstanceEffectiveCustomTagResult'],
                 effective_enable_pg_native_login: _builtins.bool,
                 effective_enable_readable_secondaries: _builtins.bool,
                 effective_node_count: _builtins.int,
                 effective_retention_window_in_days: _builtins.int,
                 effective_stopped: _builtins.bool,
                 effective_usage_policy_id: _builtins.str,
                 enable_pg_native_login: _builtins.bool,
                 enable_readable_secondaries: _builtins.bool,
                 name: _builtins.str,
                 node_count: _builtins.int,
                 parent_instance_ref: 'outputs.GetDatabaseInstancesDatabaseInstanceParentInstanceRefResult',
                 pg_version: _builtins.str,
                 read_only_dns: _builtins.str,
                 read_write_dns: _builtins.str,
                 retention_window_in_days: _builtins.int,
                 state: _builtins.str,
                 stopped: _builtins.bool,
                 uid: _builtins.str,
                 usage_policy_id: _builtins.str):
        """
        :param _builtins.str capacity: (string) - The sku of the instance. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        :param Sequence['GetDatabaseInstancesDatabaseInstanceChildInstanceRefArgs'] child_instance_refs: (list of DatabaseInstanceRef) - The refs of the child instances. This is only available if the instance is
               parent instance
        :param _builtins.str creation_time: (string) - The timestamp when the instance was created
        :param _builtins.str creator: (string) - The email of the creator of the instance
        :param Sequence['GetDatabaseInstancesDatabaseInstanceCustomTagArgs'] custom_tags: (list of CustomTag) - Custom tags associated with the instance. This field is only included on create and update responses
        :param _builtins.str effective_capacity: (string, deprecated) - Deprecated. The sku of the instance; this field will always match the value of capacity
        :param Sequence['GetDatabaseInstancesDatabaseInstanceEffectiveCustomTagArgs'] effective_custom_tags: (list of CustomTag) - The recorded custom tags associated with the instance
        :param _builtins.bool effective_enable_pg_native_login: (boolean) - Whether the instance has PG native password login enabled
        :param _builtins.bool effective_enable_readable_secondaries: (boolean) - Whether secondaries serving read-only traffic are enabled. Defaults to false
        :param _builtins.int effective_node_count: (integer) - The number of nodes in the instance, composed of 1 primary and 0 or more secondaries. Defaults to
               1 primary and 0 secondaries
        :param _builtins.int effective_retention_window_in_days: (integer) - The retention window for the instance. This is the time window in days
               for which the historical data is retained
        :param _builtins.bool effective_stopped: (boolean) - Whether the instance is stopped
        :param _builtins.str effective_usage_policy_id: (string) - The policy that is applied to the instance
        :param _builtins.bool enable_pg_native_login: (boolean) - Whether to enable PG native password login on the instance. Defaults to false
        :param _builtins.bool enable_readable_secondaries: (boolean) - Whether to enable secondaries to serve read-only traffic. Defaults to false
        :param _builtins.str name: (string) - Name of the ref database instance
        :param _builtins.int node_count: (integer) - The number of nodes in the instance, composed of 1 primary and 0 or more secondaries. Defaults to
               1 primary and 0 secondaries. This field is input only, see effective_node_count for the output
        :param 'GetDatabaseInstancesDatabaseInstanceParentInstanceRefArgs' parent_instance_ref: (DatabaseInstanceRef) - The ref of the parent instance. This is only available if the instance is
               child instance.
               Input: For specifying the parent instance to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str pg_version: (string) - The version of Postgres running on the instance
        :param _builtins.str read_only_dns: (string) - The DNS endpoint to connect to the instance for read only access. This is only available if
               enable_readable_secondaries is true
        :param _builtins.str read_write_dns: (string) - The DNS endpoint to connect to the instance for read+write access
        :param _builtins.int retention_window_in_days: (integer) - The retention window for the instance. This is the time window in days
               for which the historical data is retained. The default value is 7 days.
               Valid values are 2 to 35 days
        :param _builtins.str state: (string) - The current state of the instance. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        :param _builtins.bool stopped: (boolean) - Whether to stop the instance. An input only param, see effective_stopped for the output
        :param _builtins.str uid: (string) - Id of the ref database instance
        :param _builtins.str usage_policy_id: (string) - The desired usage policy to associate with the instance
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "child_instance_refs", child_instance_refs)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "custom_tags", custom_tags)
        pulumi.set(__self__, "effective_capacity", effective_capacity)
        pulumi.set(__self__, "effective_custom_tags", effective_custom_tags)
        pulumi.set(__self__, "effective_enable_pg_native_login", effective_enable_pg_native_login)
        pulumi.set(__self__, "effective_enable_readable_secondaries", effective_enable_readable_secondaries)
        pulumi.set(__self__, "effective_node_count", effective_node_count)
        pulumi.set(__self__, "effective_retention_window_in_days", effective_retention_window_in_days)
        pulumi.set(__self__, "effective_stopped", effective_stopped)
        pulumi.set(__self__, "effective_usage_policy_id", effective_usage_policy_id)
        pulumi.set(__self__, "enable_pg_native_login", enable_pg_native_login)
        pulumi.set(__self__, "enable_readable_secondaries", enable_readable_secondaries)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "parent_instance_ref", parent_instance_ref)
        pulumi.set(__self__, "pg_version", pg_version)
        pulumi.set(__self__, "read_only_dns", read_only_dns)
        pulumi.set(__self__, "read_write_dns", read_write_dns)
        pulumi.set(__self__, "retention_window_in_days", retention_window_in_days)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stopped", stopped)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "usage_policy_id", usage_policy_id)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.str:
        """
        (string) - The sku of the instance. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="childInstanceRefs")
    def child_instance_refs(self) -> Sequence['outputs.GetDatabaseInstancesDatabaseInstanceChildInstanceRefResult']:
        """
        (list of DatabaseInstanceRef) - The refs of the child instances. This is only available if the instance is
        parent instance
        """
        return pulumi.get(self, "child_instance_refs")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        """
        (string) - The timestamp when the instance was created
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        (string) - The email of the creator of the instance
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Sequence['outputs.GetDatabaseInstancesDatabaseInstanceCustomTagResult']:
        """
        (list of CustomTag) - Custom tags associated with the instance. This field is only included on create and update responses
        """
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="effectiveCapacity")
    def effective_capacity(self) -> _builtins.str:
        """
        (string, deprecated) - Deprecated. The sku of the instance; this field will always match the value of capacity
        """
        return pulumi.get(self, "effective_capacity")

    @_builtins.property
    @pulumi.getter(name="effectiveCustomTags")
    def effective_custom_tags(self) -> Sequence['outputs.GetDatabaseInstancesDatabaseInstanceEffectiveCustomTagResult']:
        """
        (list of CustomTag) - The recorded custom tags associated with the instance
        """
        return pulumi.get(self, "effective_custom_tags")

    @_builtins.property
    @pulumi.getter(name="effectiveEnablePgNativeLogin")
    def effective_enable_pg_native_login(self) -> _builtins.bool:
        """
        (boolean) - Whether the instance has PG native password login enabled
        """
        return pulumi.get(self, "effective_enable_pg_native_login")

    @_builtins.property
    @pulumi.getter(name="effectiveEnableReadableSecondaries")
    def effective_enable_readable_secondaries(self) -> _builtins.bool:
        """
        (boolean) - Whether secondaries serving read-only traffic are enabled. Defaults to false
        """
        return pulumi.get(self, "effective_enable_readable_secondaries")

    @_builtins.property
    @pulumi.getter(name="effectiveNodeCount")
    def effective_node_count(self) -> _builtins.int:
        """
        (integer) - The number of nodes in the instance, composed of 1 primary and 0 or more secondaries. Defaults to
        1 primary and 0 secondaries
        """
        return pulumi.get(self, "effective_node_count")

    @_builtins.property
    @pulumi.getter(name="effectiveRetentionWindowInDays")
    def effective_retention_window_in_days(self) -> _builtins.int:
        """
        (integer) - The retention window for the instance. This is the time window in days
        for which the historical data is retained
        """
        return pulumi.get(self, "effective_retention_window_in_days")

    @_builtins.property
    @pulumi.getter(name="effectiveStopped")
    def effective_stopped(self) -> _builtins.bool:
        """
        (boolean) - Whether the instance is stopped
        """
        return pulumi.get(self, "effective_stopped")

    @_builtins.property
    @pulumi.getter(name="effectiveUsagePolicyId")
    def effective_usage_policy_id(self) -> _builtins.str:
        """
        (string) - The policy that is applied to the instance
        """
        return pulumi.get(self, "effective_usage_policy_id")

    @_builtins.property
    @pulumi.getter(name="enablePgNativeLogin")
    def enable_pg_native_login(self) -> _builtins.bool:
        """
        (boolean) - Whether to enable PG native password login on the instance. Defaults to false
        """
        return pulumi.get(self, "enable_pg_native_login")

    @_builtins.property
    @pulumi.getter(name="enableReadableSecondaries")
    def enable_readable_secondaries(self) -> _builtins.bool:
        """
        (boolean) - Whether to enable secondaries to serve read-only traffic. Defaults to false
        """
        return pulumi.get(self, "enable_readable_secondaries")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the ref database instance
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        (integer) - The number of nodes in the instance, composed of 1 primary and 0 or more secondaries. Defaults to
        1 primary and 0 secondaries. This field is input only, see effective_node_count for the output
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="parentInstanceRef")
    def parent_instance_ref(self) -> 'outputs.GetDatabaseInstancesDatabaseInstanceParentInstanceRefResult':
        """
        (DatabaseInstanceRef) - The ref of the parent instance. This is only available if the instance is
        child instance.
        Input: For specifying the parent instance to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "parent_instance_ref")

    @_builtins.property
    @pulumi.getter(name="pgVersion")
    def pg_version(self) -> _builtins.str:
        """
        (string) - The version of Postgres running on the instance
        """
        return pulumi.get(self, "pg_version")

    @_builtins.property
    @pulumi.getter(name="readOnlyDns")
    def read_only_dns(self) -> _builtins.str:
        """
        (string) - The DNS endpoint to connect to the instance for read only access. This is only available if
        enable_readable_secondaries is true
        """
        return pulumi.get(self, "read_only_dns")

    @_builtins.property
    @pulumi.getter(name="readWriteDns")
    def read_write_dns(self) -> _builtins.str:
        """
        (string) - The DNS endpoint to connect to the instance for read+write access
        """
        return pulumi.get(self, "read_write_dns")

    @_builtins.property
    @pulumi.getter(name="retentionWindowInDays")
    def retention_window_in_days(self) -> _builtins.int:
        """
        (integer) - The retention window for the instance. This is the time window in days
        for which the historical data is retained. The default value is 7 days.
        Valid values are 2 to 35 days
        """
        return pulumi.get(self, "retention_window_in_days")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - The current state of the instance. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def stopped(self) -> _builtins.bool:
        """
        (boolean) - Whether to stop the instance. An input only param, see effective_stopped for the output
        """
        return pulumi.get(self, "stopped")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="usagePolicyId")
    def usage_policy_id(self) -> _builtins.str:
        """
        (string) - The desired usage policy to associate with the instance
        """
        return pulumi.get(self, "usage_policy_id")


@pulumi.output_type
class GetDatabaseInstancesDatabaseInstanceChildInstanceRefResult(dict):
    def __init__(__self__, *,
                 effective_lsn: _builtins.str,
                 lsn: _builtins.str,
                 uid: _builtins.str,
                 branch_time: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str effective_lsn: (string) - For a parent ref instance, this is the LSN on the parent instance from which the
               instance was created.
               For a child ref instance, this is the LSN on the instance from which the child instance
               was created
        :param _builtins.str lsn: (string) - User-specified WAL LSN of the ref database instance.
        :param _builtins.str uid: (string) - Id of the ref database instance
        :param _builtins.str branch_time: (string) - Branch time of the ref database instance.
               For a parent ref instance, this is the point in time on the parent instance from which the
               instance was created.
               For a child ref instance, this is the point in time on the instance from which the child
               instance was created.
               Input: For specifying the point in time to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str name: (string) - Name of the ref database instance
        """
        pulumi.set(__self__, "effective_lsn", effective_lsn)
        pulumi.set(__self__, "lsn", lsn)
        pulumi.set(__self__, "uid", uid)
        if branch_time is not None:
            pulumi.set(__self__, "branch_time", branch_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="effectiveLsn")
    def effective_lsn(self) -> _builtins.str:
        """
        (string) - For a parent ref instance, this is the LSN on the parent instance from which the
        instance was created.
        For a child ref instance, this is the LSN on the instance from which the child instance
        was created
        """
        return pulumi.get(self, "effective_lsn")

    @_builtins.property
    @pulumi.getter
    def lsn(self) -> _builtins.str:
        """
        (string) - User-specified WAL LSN of the ref database instance.
        """
        return pulumi.get(self, "lsn")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="branchTime")
    def branch_time(self) -> Optional[_builtins.str]:
        """
        (string) - Branch time of the ref database instance.
        For a parent ref instance, this is the point in time on the parent instance from which the
        instance was created.
        For a child ref instance, this is the point in time on the instance from which the child
        instance was created.
        Input: For specifying the point in time to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "branch_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (string) - Name of the ref database instance
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseInstancesDatabaseInstanceCustomTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (string) - The key of the custom tag
        :param _builtins.str value: (string) - The value of the custom tag
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (string) - The key of the custom tag
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - The value of the custom tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseInstancesDatabaseInstanceEffectiveCustomTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: (string) - The key of the custom tag
        :param _builtins.str value: (string) - The value of the custom tag
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        (string) - The key of the custom tag
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - The value of the custom tag
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseInstancesDatabaseInstanceParentInstanceRefResult(dict):
    def __init__(__self__, *,
                 effective_lsn: _builtins.str,
                 lsn: _builtins.str,
                 uid: _builtins.str,
                 branch_time: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str effective_lsn: (string) - For a parent ref instance, this is the LSN on the parent instance from which the
               instance was created.
               For a child ref instance, this is the LSN on the instance from which the child instance
               was created
        :param _builtins.str lsn: (string) - User-specified WAL LSN of the ref database instance.
        :param _builtins.str uid: (string) - Id of the ref database instance
        :param _builtins.str branch_time: (string) - Branch time of the ref database instance.
               For a parent ref instance, this is the point in time on the parent instance from which the
               instance was created.
               For a child ref instance, this is the point in time on the instance from which the child
               instance was created.
               Input: For specifying the point in time to create a child instance. Optional.
               Output: Only populated if provided as input to create a child instance
        :param _builtins.str name: (string) - Name of the ref database instance
        """
        pulumi.set(__self__, "effective_lsn", effective_lsn)
        pulumi.set(__self__, "lsn", lsn)
        pulumi.set(__self__, "uid", uid)
        if branch_time is not None:
            pulumi.set(__self__, "branch_time", branch_time)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="effectiveLsn")
    def effective_lsn(self) -> _builtins.str:
        """
        (string) - For a parent ref instance, this is the LSN on the parent instance from which the
        instance was created.
        For a child ref instance, this is the LSN on the instance from which the child instance
        was created
        """
        return pulumi.get(self, "effective_lsn")

    @_builtins.property
    @pulumi.getter
    def lsn(self) -> _builtins.str:
        """
        (string) - User-specified WAL LSN of the ref database instance.
        """
        return pulumi.get(self, "lsn")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Id of the ref database instance
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="branchTime")
    def branch_time(self) -> Optional[_builtins.str]:
        """
        (string) - Branch time of the ref database instance.
        For a parent ref instance, this is the point in time on the parent instance from which the
        instance was created.
        For a child ref instance, this is the point in time on the instance from which the child
        instance was created.
        Input: For specifying the point in time to create a child instance. Optional.
        Output: Only populated if provided as input to create a child instance
        """
        return pulumi.get(self, "branch_time")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (string) - Name of the ref database instance
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusResult(dict):
    def __init__(__self__, *,
                 detailed_state: _builtins.str,
                 last_sync: 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncResult',
                 message: _builtins.str,
                 pipeline_id: _builtins.str,
                 continuous_update_status: Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusResult'] = None,
                 failed_status: Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatusResult'] = None,
                 provisioning_status: Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusResult'] = None,
                 triggered_update_status: Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusResult'] = None):
        """
        :param _builtins.str detailed_state: (string) - The state of the synced table. Possible values are: `SYNCED_TABLED_OFFLINE`, `SYNCED_TABLE_OFFLINE_FAILED`, `SYNCED_TABLE_ONLINE`, `SYNCED_TABLE_ONLINE_CONTINUOUS_UPDATE`, `SYNCED_TABLE_ONLINE_NO_PENDING_UPDATE`, `SYNCED_TABLE_ONLINE_PIPELINE_FAILED`, `SYNCED_TABLE_ONLINE_TRIGGERED_UPDATE`, `SYNCED_TABLE_ONLINE_UPDATING_PIPELINE_RESOURCES`, `SYNCED_TABLE_PROVISIONING`, `SYNCED_TABLE_PROVISIONING_INITIAL_SNAPSHOT`, `SYNCED_TABLE_PROVISIONING_PIPELINE_RESOURCES`
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncArgs' last_sync: (SyncedTablePosition) - Summary of the last successful synchronization from source to destination.
        :param _builtins.str message: (string) - A text description of the current state of the synced table
        :param _builtins.str pipeline_id: (string) - ID of the associated pipeline. The pipeline ID may have been provided by the client
               (in the case of bin packing), or generated by the server (when creating a new pipeline)
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusArgs' continuous_update_status: (SyncedTableContinuousUpdateStatus)
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatusArgs' failed_status: (SyncedTableFailedStatus)
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusArgs' provisioning_status: (SyncedTableProvisioningStatus)
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusArgs' triggered_update_status: (SyncedTableTriggeredUpdateStatus)
        """
        pulumi.set(__self__, "detailed_state", detailed_state)
        pulumi.set(__self__, "last_sync", last_sync)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if continuous_update_status is not None:
            pulumi.set(__self__, "continuous_update_status", continuous_update_status)
        if failed_status is not None:
            pulumi.set(__self__, "failed_status", failed_status)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if triggered_update_status is not None:
            pulumi.set(__self__, "triggered_update_status", triggered_update_status)

    @_builtins.property
    @pulumi.getter(name="detailedState")
    def detailed_state(self) -> _builtins.str:
        """
        (string) - The state of the synced table. Possible values are: `SYNCED_TABLED_OFFLINE`, `SYNCED_TABLE_OFFLINE_FAILED`, `SYNCED_TABLE_ONLINE`, `SYNCED_TABLE_ONLINE_CONTINUOUS_UPDATE`, `SYNCED_TABLE_ONLINE_NO_PENDING_UPDATE`, `SYNCED_TABLE_ONLINE_PIPELINE_FAILED`, `SYNCED_TABLE_ONLINE_TRIGGERED_UPDATE`, `SYNCED_TABLE_ONLINE_UPDATING_PIPELINE_RESOURCES`, `SYNCED_TABLE_PROVISIONING`, `SYNCED_TABLE_PROVISIONING_INITIAL_SNAPSHOT`, `SYNCED_TABLE_PROVISIONING_PIPELINE_RESOURCES`
        """
        return pulumi.get(self, "detailed_state")

    @_builtins.property
    @pulumi.getter(name="lastSync")
    def last_sync(self) -> 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncResult':
        """
        (SyncedTablePosition) - Summary of the last successful synchronization from source to destination.
        """
        return pulumi.get(self, "last_sync")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        (string) - A text description of the current state of the synced table
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        """
        (string) - ID of the associated pipeline. The pipeline ID may have been provided by the client
        (in the case of bin packing), or generated by the server (when creating a new pipeline)
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="continuousUpdateStatus")
    def continuous_update_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusResult']:
        """
        (SyncedTableContinuousUpdateStatus)
        """
        return pulumi.get(self, "continuous_update_status")

    @_builtins.property
    @pulumi.getter(name="failedStatus")
    def failed_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatusResult']:
        """
        (SyncedTableFailedStatus)
        """
        return pulumi.get(self, "failed_status")

    @_builtins.property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusResult']:
        """
        (SyncedTableProvisioningStatus)
        """
        return pulumi.get(self, "provisioning_status")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateStatus")
    def triggered_update_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusResult']:
        """
        (SyncedTableTriggeredUpdateStatus)
        """
        return pulumi.get(self, "triggered_update_status")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusResult(dict):
    def __init__(__self__, *,
                 initial_pipeline_sync_progress: 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult',
                 last_processed_commit_version: _builtins.int,
                 timestamp: _builtins.str):
        """
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs' initial_pipeline_sync_progress: (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
               PROVISIONING_INITIAL_SNAPSHOT state
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        """
        pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)
        pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult':
        """
        (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
        PROVISIONING_INITIAL_SNAPSHOT state
        """
        return pulumi.get(self, "initial_pipeline_sync_progress")

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> _builtins.int:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult(dict):
    def __init__(__self__, *,
                 estimated_completion_time_seconds: _builtins.float,
                 latest_version_currently_processing: _builtins.int,
                 provisioning_phase: _builtins.str,
                 sync_progress_completion: _builtins.float,
                 synced_row_count: _builtins.int,
                 total_row_count: _builtins.int):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        pulumi.set(__self__, "synced_row_count", synced_row_count)
        pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> _builtins.float:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> _builtins.int:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> _builtins.str:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> _builtins.float:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> _builtins.int:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> _builtins.int:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusFailedStatusResult(dict):
    def __init__(__self__, *,
                 last_processed_commit_version: _builtins.int,
                 timestamp: _builtins.str):
        """
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        """
        pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> _builtins.int:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncResult(dict):
    def __init__(__self__, *,
                 delta_table_sync_info: 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult',
                 sync_end_timestamp: _builtins.str,
                 sync_start_timestamp: _builtins.str):
        """
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoArgs' delta_table_sync_info: (DeltaTableSyncInfo)
        :param _builtins.str sync_end_timestamp: (string) - The end timestamp of the most recent successful synchronization.
               This is the time when the data is available in the synced table
        :param _builtins.str sync_start_timestamp: (string) - The starting timestamp of the most recent successful synchronization from the source table
               to the destination (synced) table.
               Note this is the starting timestamp of the sync operation, not the end time.
               E.g., for a batch, this is the time when the sync operation started
        """
        pulumi.set(__self__, "delta_table_sync_info", delta_table_sync_info)
        pulumi.set(__self__, "sync_end_timestamp", sync_end_timestamp)
        pulumi.set(__self__, "sync_start_timestamp", sync_start_timestamp)

    @_builtins.property
    @pulumi.getter(name="deltaTableSyncInfo")
    def delta_table_sync_info(self) -> 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult':
        """
        (DeltaTableSyncInfo)
        """
        return pulumi.get(self, "delta_table_sync_info")

    @_builtins.property
    @pulumi.getter(name="syncEndTimestamp")
    def sync_end_timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the most recent successful synchronization.
        This is the time when the data is available in the synced table
        """
        return pulumi.get(self, "sync_end_timestamp")

    @_builtins.property
    @pulumi.getter(name="syncStartTimestamp")
    def sync_start_timestamp(self) -> _builtins.str:
        """
        (string) - The starting timestamp of the most recent successful synchronization from the source table
        to the destination (synced) table.
        Note this is the starting timestamp of the sync operation, not the end time.
        E.g., for a batch, this is the time when the sync operation started
        """
        return pulumi.get(self, "sync_start_timestamp")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult(dict):
    def __init__(__self__, *,
                 delta_commit_timestamp: _builtins.str,
                 delta_commit_version: _builtins.int):
        """
        :param _builtins.str delta_commit_timestamp: (string) - The timestamp when the above Delta version was committed in the source Delta table.
               Note: This is the Delta commit time, not the time the data was written to the synced table
        :param _builtins.int delta_commit_version: (integer) - The Delta Lake commit version that was last successfully synced
        """
        pulumi.set(__self__, "delta_commit_timestamp", delta_commit_timestamp)
        pulumi.set(__self__, "delta_commit_version", delta_commit_version)

    @_builtins.property
    @pulumi.getter(name="deltaCommitTimestamp")
    def delta_commit_timestamp(self) -> _builtins.str:
        """
        (string) - The timestamp when the above Delta version was committed in the source Delta table.
        Note: This is the Delta commit time, not the time the data was written to the synced table
        """
        return pulumi.get(self, "delta_commit_timestamp")

    @_builtins.property
    @pulumi.getter(name="deltaCommitVersion")
    def delta_commit_version(self) -> _builtins.int:
        """
        (integer) - The Delta Lake commit version that was last successfully synced
        """
        return pulumi.get(self, "delta_commit_version")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusResult(dict):
    def __init__(__self__, *,
                 initial_pipeline_sync_progress: 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult'):
        """
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressArgs' initial_pipeline_sync_progress: (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
               PROVISIONING_INITIAL_SNAPSHOT state
        """
        pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult':
        """
        (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
        PROVISIONING_INITIAL_SNAPSHOT state
        """
        return pulumi.get(self, "initial_pipeline_sync_progress")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult(dict):
    def __init__(__self__, *,
                 estimated_completion_time_seconds: _builtins.float,
                 latest_version_currently_processing: _builtins.int,
                 provisioning_phase: _builtins.str,
                 sync_progress_completion: _builtins.float,
                 synced_row_count: _builtins.int,
                 total_row_count: _builtins.int):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        pulumi.set(__self__, "synced_row_count", synced_row_count)
        pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> _builtins.float:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> _builtins.int:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> _builtins.str:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> _builtins.float:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> _builtins.int:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> _builtins.int:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusResult(dict):
    def __init__(__self__, *,
                 last_processed_commit_version: _builtins.int,
                 timestamp: _builtins.str,
                 triggered_update_progress: 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult'):
        """
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        :param 'GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs' triggered_update_progress: (SyncedTablePipelineProgress) - Progress of the active data synchronization pipeline
        """
        pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "triggered_update_progress", triggered_update_progress)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> _builtins.int:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateProgress")
    def triggered_update_progress(self) -> 'outputs.GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult':
        """
        (SyncedTablePipelineProgress) - Progress of the active data synchronization pipeline
        """
        return pulumi.get(self, "triggered_update_progress")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult(dict):
    def __init__(__self__, *,
                 estimated_completion_time_seconds: _builtins.float,
                 latest_version_currently_processing: _builtins.int,
                 provisioning_phase: _builtins.str,
                 sync_progress_completion: _builtins.float,
                 synced_row_count: _builtins.int,
                 total_row_count: _builtins.int):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        pulumi.set(__self__, "synced_row_count", synced_row_count)
        pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> _builtins.float:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> _builtins.int:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> _builtins.str:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> _builtins.float:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> _builtins.int:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> _builtins.int:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableSpecResult(dict):
    def __init__(__self__, *,
                 create_database_objects_if_missing: _builtins.bool,
                 existing_pipeline_id: _builtins.str,
                 new_pipeline_spec: 'outputs.GetDatabaseSyncedDatabaseTableSpecNewPipelineSpecResult',
                 primary_key_columns: Optional[Sequence[_builtins.str]] = None,
                 scheduling_policy: Optional[_builtins.str] = None,
                 source_table_full_name: Optional[_builtins.str] = None,
                 timeseries_key: Optional[_builtins.str] = None):
        """
        :param _builtins.bool create_database_objects_if_missing: (boolean) - If true, the synced table's logical database and schema resources in PG
               will be created if they do not already exist
        :param _builtins.str existing_pipeline_id: (string) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        :param 'GetDatabaseSyncedDatabaseTableSpecNewPipelineSpecArgs' new_pipeline_spec: (NewPipelineSpec) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        :param Sequence[_builtins.str] primary_key_columns: (list of string) - Primary Key columns to be used for data insert/update in the destination
        :param _builtins.str scheduling_policy: (string) - Scheduling policy of the underlying pipeline. Possible values are: `CONTINUOUS`, `SNAPSHOT`, `TRIGGERED`
        :param _builtins.str source_table_full_name: (string) - Three-part (catalog, schema, table) name of the source Delta table
        :param _builtins.str timeseries_key: (string) - Time series key to deduplicate (tie-break) rows with the same primary key
        """
        pulumi.set(__self__, "create_database_objects_if_missing", create_database_objects_if_missing)
        pulumi.set(__self__, "existing_pipeline_id", existing_pipeline_id)
        pulumi.set(__self__, "new_pipeline_spec", new_pipeline_spec)
        if primary_key_columns is not None:
            pulumi.set(__self__, "primary_key_columns", primary_key_columns)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        if source_table_full_name is not None:
            pulumi.set(__self__, "source_table_full_name", source_table_full_name)
        if timeseries_key is not None:
            pulumi.set(__self__, "timeseries_key", timeseries_key)

    @_builtins.property
    @pulumi.getter(name="createDatabaseObjectsIfMissing")
    def create_database_objects_if_missing(self) -> _builtins.bool:
        """
        (boolean) - If true, the synced table's logical database and schema resources in PG
        will be created if they do not already exist
        """
        return pulumi.get(self, "create_database_objects_if_missing")

    @_builtins.property
    @pulumi.getter(name="existingPipelineId")
    def existing_pipeline_id(self) -> _builtins.str:
        """
        (string) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        """
        return pulumi.get(self, "existing_pipeline_id")

    @_builtins.property
    @pulumi.getter(name="newPipelineSpec")
    def new_pipeline_spec(self) -> 'outputs.GetDatabaseSyncedDatabaseTableSpecNewPipelineSpecResult':
        """
        (NewPipelineSpec) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        """
        return pulumi.get(self, "new_pipeline_spec")

    @_builtins.property
    @pulumi.getter(name="primaryKeyColumns")
    def primary_key_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - Primary Key columns to be used for data insert/update in the destination
        """
        return pulumi.get(self, "primary_key_columns")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional[_builtins.str]:
        """
        (string) - Scheduling policy of the underlying pipeline. Possible values are: `CONTINUOUS`, `SNAPSHOT`, `TRIGGERED`
        """
        return pulumi.get(self, "scheduling_policy")

    @_builtins.property
    @pulumi.getter(name="sourceTableFullName")
    def source_table_full_name(self) -> Optional[_builtins.str]:
        """
        (string) - Three-part (catalog, schema, table) name of the source Delta table
        """
        return pulumi.get(self, "source_table_full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesKey")
    def timeseries_key(self) -> Optional[_builtins.str]:
        """
        (string) - Time series key to deduplicate (tie-break) rows with the same primary key
        """
        return pulumi.get(self, "timeseries_key")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTableSpecNewPipelineSpecResult(dict):
    def __init__(__self__, *,
                 storage_catalog: Optional[_builtins.str] = None,
                 storage_schema: Optional[_builtins.str] = None):
        """
        :param _builtins.str storage_catalog: (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        :param _builtins.str storage_schema: (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        """
        if storage_catalog is not None:
            pulumi.set(__self__, "storage_catalog", storage_catalog)
        if storage_schema is not None:
            pulumi.set(__self__, "storage_schema", storage_schema)

    @_builtins.property
    @pulumi.getter(name="storageCatalog")
    def storage_catalog(self) -> Optional[_builtins.str]:
        """
        (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        """
        return pulumi.get(self, "storage_catalog")

    @_builtins.property
    @pulumi.getter(name="storageSchema")
    def storage_schema(self) -> Optional[_builtins.str]:
        """
        (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        """
        return pulumi.get(self, "storage_schema")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableResult(dict):
    def __init__(__self__, *,
                 data_synchronization_status: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusResult',
                 database_instance_name: _builtins.str,
                 effective_database_instance_name: _builtins.str,
                 effective_logical_database_name: _builtins.str,
                 logical_database_name: _builtins.str,
                 name: _builtins.str,
                 spec: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableSpecResult',
                 unity_catalog_provisioning_state: _builtins.str):
        """
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusArgs' data_synchronization_status: (SyncedTableStatus) - Synced Table data synchronization status
        :param _builtins.str database_instance_name: (string) - Name of the target database instance. This is required when creating synced database tables in standard catalogs.
               This is optional when creating synced database tables in registered catalogs. If this field is specified
               when creating synced database tables in registered catalogs, the database instance name MUST
               match that of the registered catalog (or the request will be rejected)
        :param _builtins.str effective_database_instance_name: (string) - The name of the database instance that this table is registered to. This field is always returned, and for
               tables inside database catalogs is inferred database instance associated with the catalog
        :param _builtins.str effective_logical_database_name: (string) - The name of the logical database that this table is registered to
        :param _builtins.str logical_database_name: (string) - Target Postgres database object (logical database) name for this table.
        :param _builtins.str name: (string) - Full three-part (catalog, schema, table) name of the table
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableSpecArgs' spec: (SyncedTableSpec)
        :param _builtins.str unity_catalog_provisioning_state: (string) - The provisioning state of the synced table entity in Unity Catalog. This is distinct from the
               state of the data synchronization pipeline (i.e. the table may be in "ACTIVE" but the pipeline
               may be in "PROVISIONING" as it runs asynchronously). Possible values are: `ACTIVE`, `DEGRADED`, `DELETING`, `FAILED`, `PROVISIONING`, `UPDATING`
        """
        pulumi.set(__self__, "data_synchronization_status", data_synchronization_status)
        pulumi.set(__self__, "database_instance_name", database_instance_name)
        pulumi.set(__self__, "effective_database_instance_name", effective_database_instance_name)
        pulumi.set(__self__, "effective_logical_database_name", effective_logical_database_name)
        pulumi.set(__self__, "logical_database_name", logical_database_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "unity_catalog_provisioning_state", unity_catalog_provisioning_state)

    @_builtins.property
    @pulumi.getter(name="dataSynchronizationStatus")
    def data_synchronization_status(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusResult':
        """
        (SyncedTableStatus) - Synced Table data synchronization status
        """
        return pulumi.get(self, "data_synchronization_status")

    @_builtins.property
    @pulumi.getter(name="databaseInstanceName")
    def database_instance_name(self) -> _builtins.str:
        """
        (string) - Name of the target database instance. This is required when creating synced database tables in standard catalogs.
        This is optional when creating synced database tables in registered catalogs. If this field is specified
        when creating synced database tables in registered catalogs, the database instance name MUST
        match that of the registered catalog (or the request will be rejected)
        """
        return pulumi.get(self, "database_instance_name")

    @_builtins.property
    @pulumi.getter(name="effectiveDatabaseInstanceName")
    def effective_database_instance_name(self) -> _builtins.str:
        """
        (string) - The name of the database instance that this table is registered to. This field is always returned, and for
        tables inside database catalogs is inferred database instance associated with the catalog
        """
        return pulumi.get(self, "effective_database_instance_name")

    @_builtins.property
    @pulumi.getter(name="effectiveLogicalDatabaseName")
    def effective_logical_database_name(self) -> _builtins.str:
        """
        (string) - The name of the logical database that this table is registered to
        """
        return pulumi.get(self, "effective_logical_database_name")

    @_builtins.property
    @pulumi.getter(name="logicalDatabaseName")
    def logical_database_name(self) -> _builtins.str:
        """
        (string) - Target Postgres database object (logical database) name for this table.
        """
        return pulumi.get(self, "logical_database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Full three-part (catalog, schema, table) name of the table
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableSpecResult':
        """
        (SyncedTableSpec)
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="unityCatalogProvisioningState")
    def unity_catalog_provisioning_state(self) -> _builtins.str:
        """
        (string) - The provisioning state of the synced table entity in Unity Catalog. This is distinct from the
        state of the data synchronization pipeline (i.e. the table may be in "ACTIVE" but the pipeline
        may be in "PROVISIONING" as it runs asynchronously). Possible values are: `ACTIVE`, `DEGRADED`, `DELETING`, `FAILED`, `PROVISIONING`, `UPDATING`
        """
        return pulumi.get(self, "unity_catalog_provisioning_state")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusResult(dict):
    def __init__(__self__, *,
                 detailed_state: _builtins.str,
                 last_sync: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncResult',
                 message: _builtins.str,
                 pipeline_id: _builtins.str,
                 continuous_update_status: Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusResult'] = None,
                 failed_status: Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusFailedStatusResult'] = None,
                 provisioning_status: Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusResult'] = None,
                 triggered_update_status: Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusResult'] = None):
        """
        :param _builtins.str detailed_state: (string) - The state of the synced table. Possible values are: `SYNCED_TABLED_OFFLINE`, `SYNCED_TABLE_OFFLINE_FAILED`, `SYNCED_TABLE_ONLINE`, `SYNCED_TABLE_ONLINE_CONTINUOUS_UPDATE`, `SYNCED_TABLE_ONLINE_NO_PENDING_UPDATE`, `SYNCED_TABLE_ONLINE_PIPELINE_FAILED`, `SYNCED_TABLE_ONLINE_TRIGGERED_UPDATE`, `SYNCED_TABLE_ONLINE_UPDATING_PIPELINE_RESOURCES`, `SYNCED_TABLE_PROVISIONING`, `SYNCED_TABLE_PROVISIONING_INITIAL_SNAPSHOT`, `SYNCED_TABLE_PROVISIONING_PIPELINE_RESOURCES`
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncArgs' last_sync: (SyncedTablePosition) - Summary of the last successful synchronization from source to destination.
        :param _builtins.str message: (string) - A text description of the current state of the synced table
        :param _builtins.str pipeline_id: (string) - ID of the associated pipeline. The pipeline ID may have been provided by the client
               (in the case of bin packing), or generated by the server (when creating a new pipeline)
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusArgs' continuous_update_status: (SyncedTableContinuousUpdateStatus)
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusFailedStatusArgs' failed_status: (SyncedTableFailedStatus)
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusArgs' provisioning_status: (SyncedTableProvisioningStatus)
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusArgs' triggered_update_status: (SyncedTableTriggeredUpdateStatus)
        """
        pulumi.set(__self__, "detailed_state", detailed_state)
        pulumi.set(__self__, "last_sync", last_sync)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if continuous_update_status is not None:
            pulumi.set(__self__, "continuous_update_status", continuous_update_status)
        if failed_status is not None:
            pulumi.set(__self__, "failed_status", failed_status)
        if provisioning_status is not None:
            pulumi.set(__self__, "provisioning_status", provisioning_status)
        if triggered_update_status is not None:
            pulumi.set(__self__, "triggered_update_status", triggered_update_status)

    @_builtins.property
    @pulumi.getter(name="detailedState")
    def detailed_state(self) -> _builtins.str:
        """
        (string) - The state of the synced table. Possible values are: `SYNCED_TABLED_OFFLINE`, `SYNCED_TABLE_OFFLINE_FAILED`, `SYNCED_TABLE_ONLINE`, `SYNCED_TABLE_ONLINE_CONTINUOUS_UPDATE`, `SYNCED_TABLE_ONLINE_NO_PENDING_UPDATE`, `SYNCED_TABLE_ONLINE_PIPELINE_FAILED`, `SYNCED_TABLE_ONLINE_TRIGGERED_UPDATE`, `SYNCED_TABLE_ONLINE_UPDATING_PIPELINE_RESOURCES`, `SYNCED_TABLE_PROVISIONING`, `SYNCED_TABLE_PROVISIONING_INITIAL_SNAPSHOT`, `SYNCED_TABLE_PROVISIONING_PIPELINE_RESOURCES`
        """
        return pulumi.get(self, "detailed_state")

    @_builtins.property
    @pulumi.getter(name="lastSync")
    def last_sync(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncResult':
        """
        (SyncedTablePosition) - Summary of the last successful synchronization from source to destination.
        """
        return pulumi.get(self, "last_sync")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        (string) - A text description of the current state of the synced table
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        """
        (string) - ID of the associated pipeline. The pipeline ID may have been provided by the client
        (in the case of bin packing), or generated by the server (when creating a new pipeline)
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="continuousUpdateStatus")
    def continuous_update_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusResult']:
        """
        (SyncedTableContinuousUpdateStatus)
        """
        return pulumi.get(self, "continuous_update_status")

    @_builtins.property
    @pulumi.getter(name="failedStatus")
    def failed_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusFailedStatusResult']:
        """
        (SyncedTableFailedStatus)
        """
        return pulumi.get(self, "failed_status")

    @_builtins.property
    @pulumi.getter(name="provisioningStatus")
    def provisioning_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusResult']:
        """
        (SyncedTableProvisioningStatus)
        """
        return pulumi.get(self, "provisioning_status")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateStatus")
    def triggered_update_status(self) -> Optional['outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusResult']:
        """
        (SyncedTableTriggeredUpdateStatus)
        """
        return pulumi.get(self, "triggered_update_status")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusResult(dict):
    def __init__(__self__, *,
                 initial_pipeline_sync_progress: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult',
                 last_processed_commit_version: _builtins.int,
                 timestamp: _builtins.str):
        """
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressArgs' initial_pipeline_sync_progress: (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
               PROVISIONING_INITIAL_SNAPSHOT state
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        """
        pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)
        pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult':
        """
        (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
        PROVISIONING_INITIAL_SNAPSHOT state
        """
        return pulumi.get(self, "initial_pipeline_sync_progress")

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> _builtins.int:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusContinuousUpdateStatusInitialPipelineSyncProgressResult(dict):
    def __init__(__self__, *,
                 estimated_completion_time_seconds: _builtins.float,
                 latest_version_currently_processing: _builtins.int,
                 provisioning_phase: _builtins.str,
                 sync_progress_completion: _builtins.float,
                 synced_row_count: _builtins.int,
                 total_row_count: _builtins.int):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        pulumi.set(__self__, "synced_row_count", synced_row_count)
        pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> _builtins.float:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> _builtins.int:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> _builtins.str:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> _builtins.float:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> _builtins.int:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> _builtins.int:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusFailedStatusResult(dict):
    def __init__(__self__, *,
                 last_processed_commit_version: _builtins.int,
                 timestamp: _builtins.str):
        """
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        """
        pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> _builtins.int:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncResult(dict):
    def __init__(__self__, *,
                 delta_table_sync_info: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult',
                 sync_end_timestamp: _builtins.str,
                 sync_start_timestamp: _builtins.str):
        """
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoArgs' delta_table_sync_info: (DeltaTableSyncInfo)
        :param _builtins.str sync_end_timestamp: (string) - The end timestamp of the most recent successful synchronization.
               This is the time when the data is available in the synced table
        :param _builtins.str sync_start_timestamp: (string) - The starting timestamp of the most recent successful synchronization from the source table
               to the destination (synced) table.
               Note this is the starting timestamp of the sync operation, not the end time.
               E.g., for a batch, this is the time when the sync operation started
        """
        pulumi.set(__self__, "delta_table_sync_info", delta_table_sync_info)
        pulumi.set(__self__, "sync_end_timestamp", sync_end_timestamp)
        pulumi.set(__self__, "sync_start_timestamp", sync_start_timestamp)

    @_builtins.property
    @pulumi.getter(name="deltaTableSyncInfo")
    def delta_table_sync_info(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult':
        """
        (DeltaTableSyncInfo)
        """
        return pulumi.get(self, "delta_table_sync_info")

    @_builtins.property
    @pulumi.getter(name="syncEndTimestamp")
    def sync_end_timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the most recent successful synchronization.
        This is the time when the data is available in the synced table
        """
        return pulumi.get(self, "sync_end_timestamp")

    @_builtins.property
    @pulumi.getter(name="syncStartTimestamp")
    def sync_start_timestamp(self) -> _builtins.str:
        """
        (string) - The starting timestamp of the most recent successful synchronization from the source table
        to the destination (synced) table.
        Note this is the starting timestamp of the sync operation, not the end time.
        E.g., for a batch, this is the time when the sync operation started
        """
        return pulumi.get(self, "sync_start_timestamp")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusLastSyncDeltaTableSyncInfoResult(dict):
    def __init__(__self__, *,
                 delta_commit_timestamp: _builtins.str,
                 delta_commit_version: _builtins.int):
        """
        :param _builtins.str delta_commit_timestamp: (string) - The timestamp when the above Delta version was committed in the source Delta table.
               Note: This is the Delta commit time, not the time the data was written to the synced table
        :param _builtins.int delta_commit_version: (integer) - The Delta Lake commit version that was last successfully synced
        """
        pulumi.set(__self__, "delta_commit_timestamp", delta_commit_timestamp)
        pulumi.set(__self__, "delta_commit_version", delta_commit_version)

    @_builtins.property
    @pulumi.getter(name="deltaCommitTimestamp")
    def delta_commit_timestamp(self) -> _builtins.str:
        """
        (string) - The timestamp when the above Delta version was committed in the source Delta table.
        Note: This is the Delta commit time, not the time the data was written to the synced table
        """
        return pulumi.get(self, "delta_commit_timestamp")

    @_builtins.property
    @pulumi.getter(name="deltaCommitVersion")
    def delta_commit_version(self) -> _builtins.int:
        """
        (integer) - The Delta Lake commit version that was last successfully synced
        """
        return pulumi.get(self, "delta_commit_version")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusResult(dict):
    def __init__(__self__, *,
                 initial_pipeline_sync_progress: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult'):
        """
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressArgs' initial_pipeline_sync_progress: (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
               PROVISIONING_INITIAL_SNAPSHOT state
        """
        pulumi.set(__self__, "initial_pipeline_sync_progress", initial_pipeline_sync_progress)

    @_builtins.property
    @pulumi.getter(name="initialPipelineSyncProgress")
    def initial_pipeline_sync_progress(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult':
        """
        (SyncedTablePipelineProgress) - Details about initial data synchronization. Only populated when in the
        PROVISIONING_INITIAL_SNAPSHOT state
        """
        return pulumi.get(self, "initial_pipeline_sync_progress")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusProvisioningStatusInitialPipelineSyncProgressResult(dict):
    def __init__(__self__, *,
                 estimated_completion_time_seconds: _builtins.float,
                 latest_version_currently_processing: _builtins.int,
                 provisioning_phase: _builtins.str,
                 sync_progress_completion: _builtins.float,
                 synced_row_count: _builtins.int,
                 total_row_count: _builtins.int):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        pulumi.set(__self__, "synced_row_count", synced_row_count)
        pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> _builtins.float:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> _builtins.int:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> _builtins.str:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> _builtins.float:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> _builtins.int:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> _builtins.int:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusResult(dict):
    def __init__(__self__, *,
                 last_processed_commit_version: _builtins.int,
                 timestamp: _builtins.str,
                 triggered_update_progress: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult'):
        """
        :param _builtins.int last_processed_commit_version: (integer) - The last source table Delta version that was successfully synced to the synced table
        :param _builtins.str timestamp: (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
               table. This is when the data is available in the synced table
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressArgs' triggered_update_progress: (SyncedTablePipelineProgress) - Progress of the active data synchronization pipeline
        """
        pulumi.set(__self__, "last_processed_commit_version", last_processed_commit_version)
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "triggered_update_progress", triggered_update_progress)

    @_builtins.property
    @pulumi.getter(name="lastProcessedCommitVersion")
    def last_processed_commit_version(self) -> _builtins.int:
        """
        (integer) - The last source table Delta version that was successfully synced to the synced table
        """
        return pulumi.get(self, "last_processed_commit_version")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        (string) - The end timestamp of the last time any data was synchronized from the source table to the synced
        table. This is when the data is available in the synced table
        """
        return pulumi.get(self, "timestamp")

    @_builtins.property
    @pulumi.getter(name="triggeredUpdateProgress")
    def triggered_update_progress(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult':
        """
        (SyncedTablePipelineProgress) - Progress of the active data synchronization pipeline
        """
        return pulumi.get(self, "triggered_update_progress")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableDataSynchronizationStatusTriggeredUpdateStatusTriggeredUpdateProgressResult(dict):
    def __init__(__self__, *,
                 estimated_completion_time_seconds: _builtins.float,
                 latest_version_currently_processing: _builtins.int,
                 provisioning_phase: _builtins.str,
                 sync_progress_completion: _builtins.float,
                 synced_row_count: _builtins.int,
                 total_row_count: _builtins.int):
        """
        :param _builtins.float estimated_completion_time_seconds: (number) - The estimated time remaining to complete this update in seconds
        :param _builtins.int latest_version_currently_processing: (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
               have completely processed this version yet
        :param _builtins.str provisioning_phase: (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        :param _builtins.float sync_progress_completion: (number) - The completion ratio of this update. This is a number between 0 and 1
        :param _builtins.int synced_row_count: (integer) - The number of rows that have been synced in this update
        :param _builtins.int total_row_count: (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        pulumi.set(__self__, "estimated_completion_time_seconds", estimated_completion_time_seconds)
        pulumi.set(__self__, "latest_version_currently_processing", latest_version_currently_processing)
        pulumi.set(__self__, "provisioning_phase", provisioning_phase)
        pulumi.set(__self__, "sync_progress_completion", sync_progress_completion)
        pulumi.set(__self__, "synced_row_count", synced_row_count)
        pulumi.set(__self__, "total_row_count", total_row_count)

    @_builtins.property
    @pulumi.getter(name="estimatedCompletionTimeSeconds")
    def estimated_completion_time_seconds(self) -> _builtins.float:
        """
        (number) - The estimated time remaining to complete this update in seconds
        """
        return pulumi.get(self, "estimated_completion_time_seconds")

    @_builtins.property
    @pulumi.getter(name="latestVersionCurrentlyProcessing")
    def latest_version_currently_processing(self) -> _builtins.int:
        """
        (integer) - The source table Delta version that was last processed by the pipeline. The pipeline may not
        have completely processed this version yet
        """
        return pulumi.get(self, "latest_version_currently_processing")

    @_builtins.property
    @pulumi.getter(name="provisioningPhase")
    def provisioning_phase(self) -> _builtins.str:
        """
        (string) - The current phase of the data synchronization pipeline. Possible values are: `PROVISIONING_PHASE_INDEX_SCAN`, `PROVISIONING_PHASE_INDEX_SORT`, `PROVISIONING_PHASE_MAIN`
        """
        return pulumi.get(self, "provisioning_phase")

    @_builtins.property
    @pulumi.getter(name="syncProgressCompletion")
    def sync_progress_completion(self) -> _builtins.float:
        """
        (number) - The completion ratio of this update. This is a number between 0 and 1
        """
        return pulumi.get(self, "sync_progress_completion")

    @_builtins.property
    @pulumi.getter(name="syncedRowCount")
    def synced_row_count(self) -> _builtins.int:
        """
        (integer) - The number of rows that have been synced in this update
        """
        return pulumi.get(self, "synced_row_count")

    @_builtins.property
    @pulumi.getter(name="totalRowCount")
    def total_row_count(self) -> _builtins.int:
        """
        (integer) - The total number of rows that need to be synced in this update. This number may be an estimate
        """
        return pulumi.get(self, "total_row_count")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableSpecResult(dict):
    def __init__(__self__, *,
                 create_database_objects_if_missing: _builtins.bool,
                 existing_pipeline_id: _builtins.str,
                 new_pipeline_spec: 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableSpecNewPipelineSpecResult',
                 primary_key_columns: Optional[Sequence[_builtins.str]] = None,
                 scheduling_policy: Optional[_builtins.str] = None,
                 source_table_full_name: Optional[_builtins.str] = None,
                 timeseries_key: Optional[_builtins.str] = None):
        """
        :param _builtins.bool create_database_objects_if_missing: (boolean) - If true, the synced table's logical database and schema resources in PG
               will be created if they do not already exist
        :param _builtins.str existing_pipeline_id: (string) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        :param 'GetDatabaseSyncedDatabaseTablesSyncedTableSpecNewPipelineSpecArgs' new_pipeline_spec: (NewPipelineSpec) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        :param Sequence[_builtins.str] primary_key_columns: (list of string) - Primary Key columns to be used for data insert/update in the destination
        :param _builtins.str scheduling_policy: (string) - Scheduling policy of the underlying pipeline. Possible values are: `CONTINUOUS`, `SNAPSHOT`, `TRIGGERED`
        :param _builtins.str source_table_full_name: (string) - Three-part (catalog, schema, table) name of the source Delta table
        :param _builtins.str timeseries_key: (string) - Time series key to deduplicate (tie-break) rows with the same primary key
        """
        pulumi.set(__self__, "create_database_objects_if_missing", create_database_objects_if_missing)
        pulumi.set(__self__, "existing_pipeline_id", existing_pipeline_id)
        pulumi.set(__self__, "new_pipeline_spec", new_pipeline_spec)
        if primary_key_columns is not None:
            pulumi.set(__self__, "primary_key_columns", primary_key_columns)
        if scheduling_policy is not None:
            pulumi.set(__self__, "scheduling_policy", scheduling_policy)
        if source_table_full_name is not None:
            pulumi.set(__self__, "source_table_full_name", source_table_full_name)
        if timeseries_key is not None:
            pulumi.set(__self__, "timeseries_key", timeseries_key)

    @_builtins.property
    @pulumi.getter(name="createDatabaseObjectsIfMissing")
    def create_database_objects_if_missing(self) -> _builtins.bool:
        """
        (boolean) - If true, the synced table's logical database and schema resources in PG
        will be created if they do not already exist
        """
        return pulumi.get(self, "create_database_objects_if_missing")

    @_builtins.property
    @pulumi.getter(name="existingPipelineId")
    def existing_pipeline_id(self) -> _builtins.str:
        """
        (string) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        """
        return pulumi.get(self, "existing_pipeline_id")

    @_builtins.property
    @pulumi.getter(name="newPipelineSpec")
    def new_pipeline_spec(self) -> 'outputs.GetDatabaseSyncedDatabaseTablesSyncedTableSpecNewPipelineSpecResult':
        """
        (NewPipelineSpec) - At most one of existing_pipeline_id and new_pipeline_spec should be defined.
        """
        return pulumi.get(self, "new_pipeline_spec")

    @_builtins.property
    @pulumi.getter(name="primaryKeyColumns")
    def primary_key_columns(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - Primary Key columns to be used for data insert/update in the destination
        """
        return pulumi.get(self, "primary_key_columns")

    @_builtins.property
    @pulumi.getter(name="schedulingPolicy")
    def scheduling_policy(self) -> Optional[_builtins.str]:
        """
        (string) - Scheduling policy of the underlying pipeline. Possible values are: `CONTINUOUS`, `SNAPSHOT`, `TRIGGERED`
        """
        return pulumi.get(self, "scheduling_policy")

    @_builtins.property
    @pulumi.getter(name="sourceTableFullName")
    def source_table_full_name(self) -> Optional[_builtins.str]:
        """
        (string) - Three-part (catalog, schema, table) name of the source Delta table
        """
        return pulumi.get(self, "source_table_full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesKey")
    def timeseries_key(self) -> Optional[_builtins.str]:
        """
        (string) - Time series key to deduplicate (tie-break) rows with the same primary key
        """
        return pulumi.get(self, "timeseries_key")


@pulumi.output_type
class GetDatabaseSyncedDatabaseTablesSyncedTableSpecNewPipelineSpecResult(dict):
    def __init__(__self__, *,
                 storage_catalog: Optional[_builtins.str] = None,
                 storage_schema: Optional[_builtins.str] = None):
        """
        :param _builtins.str storage_catalog: (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        :param _builtins.str storage_schema: (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        """
        if storage_catalog is not None:
            pulumi.set(__self__, "storage_catalog", storage_catalog)
        if storage_schema is not None:
            pulumi.set(__self__, "storage_schema", storage_schema)

    @_builtins.property
    @pulumi.getter(name="storageCatalog")
    def storage_catalog(self) -> Optional[_builtins.str]:
        """
        (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        """
        return pulumi.get(self, "storage_catalog")

    @_builtins.property
    @pulumi.getter(name="storageSchema")
    def storage_schema(self) -> Optional[_builtins.str]:
        """
        (string) - This field needs to be specified if the destination catalog is a managed postgres catalog.
        """
        return pulumi.get(self, "storage_schema")


@pulumi.output_type
class GetDbfsFilePathsPathListResult(dict):
    def __init__(__self__, *,
                 file_size: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Path on DBFS for the file to perform listing
        """
        if file_size is not None:
            pulumi.set(__self__, "file_size", file_size)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="fileSize")
    def file_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "file_size")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path on DBFS for the file to perform listing
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetDirectoryProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetEntityTagAssignmentsTagAssignmentResult(dict):
    def __init__(__self__, *,
                 entity_name: _builtins.str,
                 entity_type: _builtins.str,
                 tag_key: _builtins.str,
                 tag_value: _builtins.str):
        """
        :param _builtins.str entity_name: The fully qualified name of the entity to which the tag is assigned
        :param _builtins.str entity_type: The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes
        :param _builtins.str tag_key: (string) - The key of the tag
        :param _builtins.str tag_value: (string) - The value of the tag
        """
        pulumi.set(__self__, "entity_name", entity_name)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_value", tag_value)

    @_builtins.property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> _builtins.str:
        """
        The fully qualified name of the entity to which the tag is assigned
        """
        return pulumi.get(self, "entity_name")

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> _builtins.str:
        """
        The type of the entity to which the tag is assigned. Allowed values are: catalogs, schemas, tables, columns, volumes
        """
        return pulumi.get(self, "entity_type")

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> _builtins.str:
        """
        (string) - The key of the tag
        """
        return pulumi.get(self, "tag_key")

    @_builtins.property
    @pulumi.getter(name="tagValue")
    def tag_value(self) -> _builtins.str:
        """
        (string) - The value of the tag
        """
        return pulumi.get(self, "tag_value")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoResult(dict):
    def __init__(__self__, *,
                 browse_only: Optional[_builtins.bool] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 credential_id: Optional[_builtins.str] = None,
                 credential_name: Optional[_builtins.str] = None,
                 enable_file_events: Optional[_builtins.bool] = None,
                 encryption_details: Optional['outputs.GetExternalLocationExternalLocationInfoEncryptionDetailsResult'] = None,
                 fallback: Optional[_builtins.bool] = None,
                 file_event_queue: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueResult'] = None,
                 isolation_mode: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: User-supplied comment.
        :param _builtins.int created_at: Time at which this catalog was created, in epoch milliseconds.
        :param _builtins.str created_by: Username of catalog creator.
        :param _builtins.str credential_id: Unique ID of storage credential.
        :param _builtins.str credential_name: Name of the StorageCredential to use with this external location.
        :param 'GetExternalLocationExternalLocationInfoEncryptionDetailsArgs' encryption_details: A block describing encryption options that apply to clients connecting to cloud storage. Consisting of the following attributes:
        :param _builtins.str metastore_id: Unique identifier of the parent Metastore.
        :param _builtins.str name: The name of the external location
        :param _builtins.str owner: Username/groupname/sp application_id of the external location owner.
        :param _builtins.bool read_only: Indicates whether the external location is read-only.
        :param _builtins.int updated_at: Time at which this catalog was last modified, in epoch milliseconds.
        :param _builtins.str updated_by: Username of user who last modified catalog.
        :param _builtins.str url: Path URL in cloud storage, of the form: `s3://[bucket-host]/[bucket-dir]` (AWS), `abfss://[user]@[host]/[path]` (Azure), `gs://[bucket-host]/[bucket-dir]` (GCP).
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if enable_file_events is not None:
            pulumi.set(__self__, "enable_file_events", enable_file_events)
        if encryption_details is not None:
            pulumi.set(__self__, "encryption_details", encryption_details)
        if fallback is not None:
            pulumi.set(__self__, "fallback", fallback)
        if file_event_queue is not None:
            pulumi.set(__self__, "file_event_queue", file_event_queue)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        User-supplied comment.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Username of catalog creator.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        """
        Unique ID of storage credential.
        """
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[_builtins.str]:
        """
        Name of the StorageCredential to use with this external location.
        """
        return pulumi.get(self, "credential_name")

    @_builtins.property
    @pulumi.getter(name="enableFileEvents")
    def enable_file_events(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_file_events")

    @_builtins.property
    @pulumi.getter(name="encryptionDetails")
    def encryption_details(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoEncryptionDetailsResult']:
        """
        A block describing encryption options that apply to clients connecting to cloud storage. Consisting of the following attributes:
        """
        return pulumi.get(self, "encryption_details")

    @_builtins.property
    @pulumi.getter
    def fallback(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fallback")

    @_builtins.property
    @pulumi.getter(name="fileEventQueue")
    def file_event_queue(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueResult']:
        return pulumi.get(self, "file_event_queue")

    @_builtins.property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "isolation_mode")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the parent Metastore.
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the external location
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Username/groupname/sp application_id of the external location owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the external location is read-only.
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        Username of user who last modified catalog.
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Path URL in cloud storage, of the form: `s3://[bucket-host]/[bucket-dir]` (AWS), `abfss://[user]@[host]/[path]` (Azure), `gs://[bucket-host]/[bucket-dir]` (GCP).
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoEncryptionDetailsResult(dict):
    def __init__(__self__, *,
                 sse_encryption_details: Optional['outputs.GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsResult'] = None):
        """
        :param 'GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsArgs' sse_encryption_details: a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
        """
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @_builtins.property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsResult']:
        """
        a block describing server-Side Encryption properties for clients communicating with AWS S3. Consists of the following attributes:
        """
        return pulumi.get(self, "sse_encryption_details")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoEncryptionDetailsSseEncryptionDetailsResult(dict):
    def __init__(__self__, *,
                 algorithm: Optional[_builtins.str] = None,
                 aws_kms_key_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str algorithm: Encryption algorithm value. Sets the value of the `x-amz-server-side-encryption` header in S3 request.
        :param _builtins.str aws_kms_key_arn: ARN of the SSE-KMS key used with the S3 location, when `algorithm = "SSE-KMS"`.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        """
        Encryption algorithm value. Sets the value of the `x-amz-server-side-encryption` header in S3 request.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the SSE-KMS key used with the S3 location, when `algorithm = "SSE-KMS"`.
        """
        return pulumi.get(self, "aws_kms_key_arn")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueResult(dict):
    def __init__(__self__, *,
                 managed_aqs: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueManagedAqsResult'] = None,
                 managed_pubsub: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueManagedPubsubResult'] = None,
                 managed_sqs: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueManagedSqsResult'] = None,
                 provided_aqs: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueProvidedAqsResult'] = None,
                 provided_pubsub: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueProvidedPubsubResult'] = None,
                 provided_sqs: Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueProvidedSqsResult'] = None):
        if managed_aqs is not None:
            pulumi.set(__self__, "managed_aqs", managed_aqs)
        if managed_pubsub is not None:
            pulumi.set(__self__, "managed_pubsub", managed_pubsub)
        if managed_sqs is not None:
            pulumi.set(__self__, "managed_sqs", managed_sqs)
        if provided_aqs is not None:
            pulumi.set(__self__, "provided_aqs", provided_aqs)
        if provided_pubsub is not None:
            pulumi.set(__self__, "provided_pubsub", provided_pubsub)
        if provided_sqs is not None:
            pulumi.set(__self__, "provided_sqs", provided_sqs)

    @_builtins.property
    @pulumi.getter(name="managedAqs")
    def managed_aqs(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueManagedAqsResult']:
        return pulumi.get(self, "managed_aqs")

    @_builtins.property
    @pulumi.getter(name="managedPubsub")
    def managed_pubsub(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueManagedPubsubResult']:
        return pulumi.get(self, "managed_pubsub")

    @_builtins.property
    @pulumi.getter(name="managedSqs")
    def managed_sqs(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueManagedSqsResult']:
        return pulumi.get(self, "managed_sqs")

    @_builtins.property
    @pulumi.getter(name="providedAqs")
    def provided_aqs(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueProvidedAqsResult']:
        return pulumi.get(self, "provided_aqs")

    @_builtins.property
    @pulumi.getter(name="providedPubsub")
    def provided_pubsub(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueProvidedPubsubResult']:
        return pulumi.get(self, "provided_pubsub")

    @_builtins.property
    @pulumi.getter(name="providedSqs")
    def provided_sqs(self) -> Optional['outputs.GetExternalLocationExternalLocationInfoFileEventQueueProvidedSqsResult']:
        return pulumi.get(self, "provided_sqs")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueManagedAqsResult(dict):
    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 queue_url: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None):
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "queue_url")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueManagedPubsubResult(dict):
    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 subscription_name: Optional[_builtins.str] = None):
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueManagedSqsResult(dict):
    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 queue_url: Optional[_builtins.str] = None):
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "queue_url")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueProvidedAqsResult(dict):
    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 queue_url: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None):
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "queue_url")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueProvidedPubsubResult(dict):
    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 subscription_name: Optional[_builtins.str] = None):
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class GetExternalLocationExternalLocationInfoFileEventQueueProvidedSqsResult(dict):
    def __init__(__self__, *,
                 managed_resource_id: Optional[_builtins.str] = None,
                 queue_url: Optional[_builtins.str] = None):
        if managed_resource_id is not None:
            pulumi.set(__self__, "managed_resource_id", managed_resource_id)
        if queue_url is not None:
            pulumi.set(__self__, "queue_url", queue_url)

    @_builtins.property
    @pulumi.getter(name="managedResourceId")
    def managed_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "managed_resource_id")

    @_builtins.property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "queue_url")


@pulumi.output_type
class GetExternalLocationProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetExternalLocationsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetExternalMetadatasExternalMetadataResult(dict):
    def __init__(__self__, *,
                 columns: Sequence[_builtins.str],
                 create_time: _builtins.str,
                 created_by: _builtins.str,
                 description: _builtins.str,
                 entity_type: _builtins.str,
                 id: _builtins.str,
                 metastore_id: _builtins.str,
                 name: _builtins.str,
                 owner: _builtins.str,
                 properties: Mapping[str, _builtins.str],
                 system_type: _builtins.str,
                 update_time: _builtins.str,
                 updated_by: _builtins.str,
                 url: _builtins.str):
        """
        :param Sequence[_builtins.str] columns: (list of string) - List of columns associated with the external metadata object
        :param _builtins.str create_time: (string) - Time at which this external metadata object was created
        :param _builtins.str created_by: (string) - Username of external metadata object creator
        :param _builtins.str description: (string) - User-provided free-form text description
        :param _builtins.str entity_type: (string) - Type of entity within the external system
        :param _builtins.str id: (string) - Unique identifier of the external metadata object
        :param _builtins.str metastore_id: (string) - Unique identifier of parent metastore
        :param _builtins.str name: (string) - Name of the external metadata object
        :param _builtins.str owner: (string) - Owner of the external metadata object
        :param Mapping[str, _builtins.str] properties: (object) - A map of key-value properties attached to the external metadata object
        :param _builtins.str system_type: (string) - Type of external system. Possible values are: `AMAZON_REDSHIFT`, `AZURE_SYNAPSE`, `CONFLUENT`, `DATABRICKS`, `GOOGLE_BIGQUERY`, `KAFKA`, `LOOKER`, `MICROSOFT_FABRIC`, `MICROSOFT_SQL_SERVER`, `MONGODB`, `MYSQL`, `ORACLE`, `OTHER`, `POSTGRESQL`, `POWER_BI`, `SALESFORCE`, `SAP`, `SERVICENOW`, `SNOWFLAKE`, `STREAM_NATIVE`, `TABLEAU`, `TERADATA`, `WORKDAY`
        :param _builtins.str update_time: (string) - Time at which this external metadata object was last modified
        :param _builtins.str updated_by: (string) - Username of user who last modified external metadata object
        :param _builtins.str url: (string) - URL associated with the external metadata object
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "metastore_id", metastore_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "properties", properties)
        pulumi.set(__self__, "system_type", system_type)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "updated_by", updated_by)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Sequence[_builtins.str]:
        """
        (list of string) - List of columns associated with the external metadata object
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        (string) - Time at which this external metadata object was created
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        (string) - Username of external metadata object creator
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (string) - User-provided free-form text description
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> _builtins.str:
        """
        (string) - Type of entity within the external system
        """
        return pulumi.get(self, "entity_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (string) - Unique identifier of the external metadata object
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> _builtins.str:
        """
        (string) - Unique identifier of parent metastore
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the external metadata object
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> _builtins.str:
        """
        (string) - Owner of the external metadata object
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Mapping[str, _builtins.str]:
        """
        (object) - A map of key-value properties attached to the external metadata object
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="systemType")
    def system_type(self) -> _builtins.str:
        """
        (string) - Type of external system. Possible values are: `AMAZON_REDSHIFT`, `AZURE_SYNAPSE`, `CONFLUENT`, `DATABRICKS`, `GOOGLE_BIGQUERY`, `KAFKA`, `LOOKER`, `MICROSOFT_FABRIC`, `MICROSOFT_SQL_SERVER`, `MONGODB`, `MYSQL`, `ORACLE`, `OTHER`, `POSTGRESQL`, `POWER_BI`, `SALESFORCE`, `SAP`, `SERVICENOW`, `SNOWFLAKE`, `STREAM_NATIVE`, `TABLEAU`, `TERADATA`, `WORKDAY`
        """
        return pulumi.get(self, "system_type")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        (string) - Time at which this external metadata object was last modified
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> _builtins.str:
        """
        (string) - Username of user who last modified external metadata object
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        (string) - URL associated with the external metadata object
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFeatureEngineeringFeatureFunctionResult(dict):
    def __init__(__self__, *,
                 function_type: _builtins.str,
                 extra_parameters: Optional[Sequence['outputs.GetFeatureEngineeringFeatureFunctionExtraParameterResult']] = None):
        """
        :param _builtins.str function_type: (string) - The type of the function. Possible values are: `APPROX_COUNT_DISTINCT`, `APPROX_PERCENTILE`, `AVG`, `COUNT`, `FIRST`, `LAST`, `MAX`, `MIN`, `STDDEV_POP`, `STDDEV_SAMP`, `SUM`, `VAR_POP`, `VAR_SAMP`
        :param Sequence['GetFeatureEngineeringFeatureFunctionExtraParameterArgs'] extra_parameters: (list of FunctionExtraParameter) - Extra parameters for parameterized functions
        """
        pulumi.set(__self__, "function_type", function_type)
        if extra_parameters is not None:
            pulumi.set(__self__, "extra_parameters", extra_parameters)

    @_builtins.property
    @pulumi.getter(name="functionType")
    def function_type(self) -> _builtins.str:
        """
        (string) - The type of the function. Possible values are: `APPROX_COUNT_DISTINCT`, `APPROX_PERCENTILE`, `AVG`, `COUNT`, `FIRST`, `LAST`, `MAX`, `MIN`, `STDDEV_POP`, `STDDEV_SAMP`, `SUM`, `VAR_POP`, `VAR_SAMP`
        """
        return pulumi.get(self, "function_type")

    @_builtins.property
    @pulumi.getter(name="extraParameters")
    def extra_parameters(self) -> Optional[Sequence['outputs.GetFeatureEngineeringFeatureFunctionExtraParameterResult']]:
        """
        (list of FunctionExtraParameter) - Extra parameters for parameterized functions
        """
        return pulumi.get(self, "extra_parameters")


@pulumi.output_type
class GetFeatureEngineeringFeatureFunctionExtraParameterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: (string) - The name of the parameter
        :param _builtins.str value: (string) - The value of the parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (string) - The name of the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        (string) - The value of the parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFeatureEngineeringFeatureSourceResult(dict):
    def __init__(__self__, *,
                 delta_table_source: Optional['outputs.GetFeatureEngineeringFeatureSourceDeltaTableSourceResult'] = None):
        """
        :param 'GetFeatureEngineeringFeatureSourceDeltaTableSourceArgs' delta_table_source: (DeltaTableSource)
        """
        if delta_table_source is not None:
            pulumi.set(__self__, "delta_table_source", delta_table_source)

    @_builtins.property
    @pulumi.getter(name="deltaTableSource")
    def delta_table_source(self) -> Optional['outputs.GetFeatureEngineeringFeatureSourceDeltaTableSourceResult']:
        """
        (DeltaTableSource)
        """
        return pulumi.get(self, "delta_table_source")


@pulumi.output_type
class GetFeatureEngineeringFeatureSourceDeltaTableSourceResult(dict):
    def __init__(__self__, *,
                 entity_columns: Sequence[_builtins.str],
                 full_name: _builtins.str,
                 timeseries_column: _builtins.str):
        """
        :param Sequence[_builtins.str] entity_columns: (list of string) - The entity columns of the Delta table
        :param _builtins.str full_name: The full three-part name (catalog, schema, name) of the feature
        :param _builtins.str timeseries_column: (string) - The timeseries column of the Delta table
        """
        pulumi.set(__self__, "entity_columns", entity_columns)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "timeseries_column", timeseries_column)

    @_builtins.property
    @pulumi.getter(name="entityColumns")
    def entity_columns(self) -> Sequence[_builtins.str]:
        """
        (list of string) - The entity columns of the Delta table
        """
        return pulumi.get(self, "entity_columns")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        The full three-part name (catalog, schema, name) of the feature
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesColumn")
    def timeseries_column(self) -> _builtins.str:
        """
        (string) - The timeseries column of the Delta table
        """
        return pulumi.get(self, "timeseries_column")


@pulumi.output_type
class GetFeatureEngineeringFeatureTimeWindowResult(dict):
    def __init__(__self__, *,
                 continuous: Optional['outputs.GetFeatureEngineeringFeatureTimeWindowContinuousResult'] = None,
                 sliding: Optional['outputs.GetFeatureEngineeringFeatureTimeWindowSlidingResult'] = None,
                 tumbling: Optional['outputs.GetFeatureEngineeringFeatureTimeWindowTumblingResult'] = None):
        """
        :param 'GetFeatureEngineeringFeatureTimeWindowContinuousArgs' continuous: (ContinuousWindow)
        :param 'GetFeatureEngineeringFeatureTimeWindowSlidingArgs' sliding: (SlidingWindow)
        :param 'GetFeatureEngineeringFeatureTimeWindowTumblingArgs' tumbling: (TumblingWindow)
        """
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if sliding is not None:
            pulumi.set(__self__, "sliding", sliding)
        if tumbling is not None:
            pulumi.set(__self__, "tumbling", tumbling)

    @_builtins.property
    @pulumi.getter
    def continuous(self) -> Optional['outputs.GetFeatureEngineeringFeatureTimeWindowContinuousResult']:
        """
        (ContinuousWindow)
        """
        return pulumi.get(self, "continuous")

    @_builtins.property
    @pulumi.getter
    def sliding(self) -> Optional['outputs.GetFeatureEngineeringFeatureTimeWindowSlidingResult']:
        """
        (SlidingWindow)
        """
        return pulumi.get(self, "sliding")

    @_builtins.property
    @pulumi.getter
    def tumbling(self) -> Optional['outputs.GetFeatureEngineeringFeatureTimeWindowTumblingResult']:
        """
        (TumblingWindow)
        """
        return pulumi.get(self, "tumbling")


@pulumi.output_type
class GetFeatureEngineeringFeatureTimeWindowContinuousResult(dict):
    def __init__(__self__, *,
                 window_duration: _builtins.str,
                 offset: Optional[_builtins.str] = None):
        """
        :param _builtins.str window_duration: (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        :param _builtins.str offset: (string) - The offset of the continuous window (must be non-positive)
        """
        pulumi.set(__self__, "window_duration", window_duration)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        """
        (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        return pulumi.get(self, "window_duration")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        (string) - The offset of the continuous window (must be non-positive)
        """
        return pulumi.get(self, "offset")


@pulumi.output_type
class GetFeatureEngineeringFeatureTimeWindowSlidingResult(dict):
    def __init__(__self__, *,
                 slide_duration: _builtins.str,
                 window_duration: _builtins.str):
        """
        :param _builtins.str slide_duration: (string) - The slide duration (interval by which windows advance, must be positive and less than duration)
        :param _builtins.str window_duration: (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        pulumi.set(__self__, "slide_duration", slide_duration)
        pulumi.set(__self__, "window_duration", window_duration)

    @_builtins.property
    @pulumi.getter(name="slideDuration")
    def slide_duration(self) -> _builtins.str:
        """
        (string) - The slide duration (interval by which windows advance, must be positive and less than duration)
        """
        return pulumi.get(self, "slide_duration")

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        """
        (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        return pulumi.get(self, "window_duration")


@pulumi.output_type
class GetFeatureEngineeringFeatureTimeWindowTumblingResult(dict):
    def __init__(__self__, *,
                 window_duration: _builtins.str):
        """
        :param _builtins.str window_duration: (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        pulumi.set(__self__, "window_duration", window_duration)

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        """
        (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        return pulumi.get(self, "window_duration")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 filter_condition: _builtins.str,
                 full_name: _builtins.str,
                 function: 'outputs.GetFeatureEngineeringFeaturesFeatureFunctionResult',
                 inputs: Sequence[_builtins.str],
                 source: 'outputs.GetFeatureEngineeringFeaturesFeatureSourceResult',
                 time_window: 'outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowResult'):
        """
        :param _builtins.str description: (string) - The description of the feature
        :param _builtins.str filter_condition: (string) - The filter condition applied to the source data before aggregation
        :param _builtins.str full_name: (string) - The full three-part (catalog, schema, table) name of the Delta table
        :param 'GetFeatureEngineeringFeaturesFeatureFunctionArgs' function: (Function) - The function by which the feature is computed
        :param Sequence[_builtins.str] inputs: (list of string) - The input columns from which the feature is computed
        :param 'GetFeatureEngineeringFeaturesFeatureSourceArgs' source: (DataSource) - The data source of the feature
        :param 'GetFeatureEngineeringFeaturesFeatureTimeWindowArgs' time_window: (TimeWindow) - The time window in which the feature is computed
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "filter_condition", filter_condition)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "time_window", time_window)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (string) - The description of the feature
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="filterCondition")
    def filter_condition(self) -> _builtins.str:
        """
        (string) - The filter condition applied to the source data before aggregation
        """
        return pulumi.get(self, "filter_condition")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        (string) - The full three-part (catalog, schema, table) name of the Delta table
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter
    def function(self) -> 'outputs.GetFeatureEngineeringFeaturesFeatureFunctionResult':
        """
        (Function) - The function by which the feature is computed
        """
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Sequence[_builtins.str]:
        """
        (list of string) - The input columns from which the feature is computed
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.GetFeatureEngineeringFeaturesFeatureSourceResult':
        """
        (DataSource) - The data source of the feature
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> 'outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowResult':
        """
        (TimeWindow) - The time window in which the feature is computed
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureFunctionResult(dict):
    def __init__(__self__, *,
                 function_type: _builtins.str,
                 extra_parameters: Optional[Sequence['outputs.GetFeatureEngineeringFeaturesFeatureFunctionExtraParameterResult']] = None):
        """
        :param _builtins.str function_type: (string) - The type of the function. Possible values are: `APPROX_COUNT_DISTINCT`, `APPROX_PERCENTILE`, `AVG`, `COUNT`, `FIRST`, `LAST`, `MAX`, `MIN`, `STDDEV_POP`, `STDDEV_SAMP`, `SUM`, `VAR_POP`, `VAR_SAMP`
        :param Sequence['GetFeatureEngineeringFeaturesFeatureFunctionExtraParameterArgs'] extra_parameters: (list of FunctionExtraParameter) - Extra parameters for parameterized functions
        """
        pulumi.set(__self__, "function_type", function_type)
        if extra_parameters is not None:
            pulumi.set(__self__, "extra_parameters", extra_parameters)

    @_builtins.property
    @pulumi.getter(name="functionType")
    def function_type(self) -> _builtins.str:
        """
        (string) - The type of the function. Possible values are: `APPROX_COUNT_DISTINCT`, `APPROX_PERCENTILE`, `AVG`, `COUNT`, `FIRST`, `LAST`, `MAX`, `MIN`, `STDDEV_POP`, `STDDEV_SAMP`, `SUM`, `VAR_POP`, `VAR_SAMP`
        """
        return pulumi.get(self, "function_type")

    @_builtins.property
    @pulumi.getter(name="extraParameters")
    def extra_parameters(self) -> Optional[Sequence['outputs.GetFeatureEngineeringFeaturesFeatureFunctionExtraParameterResult']]:
        """
        (list of FunctionExtraParameter) - Extra parameters for parameterized functions
        """
        return pulumi.get(self, "extra_parameters")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureFunctionExtraParameterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: (string) - The name of the parameter
        :param _builtins.str value: (string) - The value of the parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (string) - The name of the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        (string) - The value of the parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureSourceResult(dict):
    def __init__(__self__, *,
                 delta_table_source: Optional['outputs.GetFeatureEngineeringFeaturesFeatureSourceDeltaTableSourceResult'] = None):
        """
        :param 'GetFeatureEngineeringFeaturesFeatureSourceDeltaTableSourceArgs' delta_table_source: (DeltaTableSource)
        """
        if delta_table_source is not None:
            pulumi.set(__self__, "delta_table_source", delta_table_source)

    @_builtins.property
    @pulumi.getter(name="deltaTableSource")
    def delta_table_source(self) -> Optional['outputs.GetFeatureEngineeringFeaturesFeatureSourceDeltaTableSourceResult']:
        """
        (DeltaTableSource)
        """
        return pulumi.get(self, "delta_table_source")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureSourceDeltaTableSourceResult(dict):
    def __init__(__self__, *,
                 entity_columns: Sequence[_builtins.str],
                 full_name: _builtins.str,
                 timeseries_column: _builtins.str):
        """
        :param Sequence[_builtins.str] entity_columns: (list of string) - The entity columns of the Delta table
        :param _builtins.str full_name: (string) - The full three-part (catalog, schema, table) name of the Delta table
        :param _builtins.str timeseries_column: (string) - The timeseries column of the Delta table
        """
        pulumi.set(__self__, "entity_columns", entity_columns)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "timeseries_column", timeseries_column)

    @_builtins.property
    @pulumi.getter(name="entityColumns")
    def entity_columns(self) -> Sequence[_builtins.str]:
        """
        (list of string) - The entity columns of the Delta table
        """
        return pulumi.get(self, "entity_columns")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> _builtins.str:
        """
        (string) - The full three-part (catalog, schema, table) name of the Delta table
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="timeseriesColumn")
    def timeseries_column(self) -> _builtins.str:
        """
        (string) - The timeseries column of the Delta table
        """
        return pulumi.get(self, "timeseries_column")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureTimeWindowResult(dict):
    def __init__(__self__, *,
                 continuous: Optional['outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowContinuousResult'] = None,
                 sliding: Optional['outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowSlidingResult'] = None,
                 tumbling: Optional['outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowTumblingResult'] = None):
        """
        :param 'GetFeatureEngineeringFeaturesFeatureTimeWindowContinuousArgs' continuous: (ContinuousWindow)
        :param 'GetFeatureEngineeringFeaturesFeatureTimeWindowSlidingArgs' sliding: (SlidingWindow)
        :param 'GetFeatureEngineeringFeaturesFeatureTimeWindowTumblingArgs' tumbling: (TumblingWindow)
        """
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if sliding is not None:
            pulumi.set(__self__, "sliding", sliding)
        if tumbling is not None:
            pulumi.set(__self__, "tumbling", tumbling)

    @_builtins.property
    @pulumi.getter
    def continuous(self) -> Optional['outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowContinuousResult']:
        """
        (ContinuousWindow)
        """
        return pulumi.get(self, "continuous")

    @_builtins.property
    @pulumi.getter
    def sliding(self) -> Optional['outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowSlidingResult']:
        """
        (SlidingWindow)
        """
        return pulumi.get(self, "sliding")

    @_builtins.property
    @pulumi.getter
    def tumbling(self) -> Optional['outputs.GetFeatureEngineeringFeaturesFeatureTimeWindowTumblingResult']:
        """
        (TumblingWindow)
        """
        return pulumi.get(self, "tumbling")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureTimeWindowContinuousResult(dict):
    def __init__(__self__, *,
                 window_duration: _builtins.str,
                 offset: Optional[_builtins.str] = None):
        """
        :param _builtins.str window_duration: (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        :param _builtins.str offset: (string) - The offset of the continuous window (must be non-positive)
        """
        pulumi.set(__self__, "window_duration", window_duration)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        """
        (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        return pulumi.get(self, "window_duration")

    @_builtins.property
    @pulumi.getter
    def offset(self) -> Optional[_builtins.str]:
        """
        (string) - The offset of the continuous window (must be non-positive)
        """
        return pulumi.get(self, "offset")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureTimeWindowSlidingResult(dict):
    def __init__(__self__, *,
                 slide_duration: _builtins.str,
                 window_duration: _builtins.str):
        """
        :param _builtins.str slide_duration: (string) - The slide duration (interval by which windows advance, must be positive and less than duration)
        :param _builtins.str window_duration: (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        pulumi.set(__self__, "slide_duration", slide_duration)
        pulumi.set(__self__, "window_duration", window_duration)

    @_builtins.property
    @pulumi.getter(name="slideDuration")
    def slide_duration(self) -> _builtins.str:
        """
        (string) - The slide duration (interval by which windows advance, must be positive and less than duration)
        """
        return pulumi.get(self, "slide_duration")

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        """
        (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        return pulumi.get(self, "window_duration")


@pulumi.output_type
class GetFeatureEngineeringFeaturesFeatureTimeWindowTumblingResult(dict):
    def __init__(__self__, *,
                 window_duration: _builtins.str):
        """
        :param _builtins.str window_duration: (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        pulumi.set(__self__, "window_duration", window_duration)

    @_builtins.property
    @pulumi.getter(name="windowDuration")
    def window_duration(self) -> _builtins.str:
        """
        (string) - The duration of each tumbling window (non-overlapping, fixed-duration windows)
        """
        return pulumi.get(self, "window_duration")


@pulumi.output_type
class GetFeatureEngineeringMaterializedFeatureOfflineStoreConfigResult(dict):
    def __init__(__self__, *,
                 catalog_name: _builtins.str,
                 schema_name: _builtins.str,
                 table_name_prefix: _builtins.str):
        """
        :param _builtins.str catalog_name: (string) - The Unity Catalog catalog name
        :param _builtins.str schema_name: (string) - The Unity Catalog schema name
        :param _builtins.str table_name_prefix: (string) - Prefix for Unity Catalog table name.
               The materialized feature will be stored in a table with this prefix and a generated postfix
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> _builtins.str:
        """
        (string) - The Unity Catalog catalog name
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        """
        (string) - The Unity Catalog schema name
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> _builtins.str:
        """
        (string) - Prefix for Unity Catalog table name.
        The materialized feature will be stored in a table with this prefix and a generated postfix
        """
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class GetFeatureEngineeringMaterializedFeatureOnlineStoreConfigResult(dict):
    def __init__(__self__, *,
                 capacity: _builtins.str,
                 creation_time: _builtins.str,
                 creator: _builtins.str,
                 name: _builtins.str,
                 state: _builtins.str,
                 read_replica_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str capacity: (string) - The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        :param _builtins.str creation_time: (string) - The timestamp when the online store was created
        :param _builtins.str creator: (string) - The email of the creator of the online store
        :param _builtins.str name: (string) - The name of the online store. This is the unique identifier for the online store
        :param _builtins.str state: (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        :param _builtins.int read_replica_count: (integer) - The number of read replicas for the online store. Defaults to 0
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        if read_replica_count is not None:
            pulumi.set(__self__, "read_replica_count", read_replica_count)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.str:
        """
        (string) - The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        """
        (string) - The timestamp when the online store was created
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        (string) - The email of the creator of the online store
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - The name of the online store. This is the unique identifier for the online store
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="readReplicaCount")
    def read_replica_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The number of read replicas for the online store. Defaults to 0
        """
        return pulumi.get(self, "read_replica_count")


@pulumi.output_type
class GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureResult(dict):
    def __init__(__self__, *,
                 feature_name: _builtins.str,
                 last_materialization_time: _builtins.str,
                 materialized_feature_id: _builtins.str,
                 offline_store_config: 'outputs.GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOfflineStoreConfigResult',
                 online_store_config: 'outputs.GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOnlineStoreConfigResult',
                 pipeline_schedule_state: _builtins.str,
                 table_name: _builtins.str):
        """
        :param _builtins.str feature_name: Filter by feature name. If specified, only materialized features materialized from this feature will be returned
        :param _builtins.str last_materialization_time: (string) - The timestamp when the pipeline last ran and updated the materialized feature values.
               If the pipeline has not run yet, this field will be null
        :param _builtins.str materialized_feature_id: (string) - Unique identifier for the materialized feature
        :param 'GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOfflineStoreConfigArgs' offline_store_config: (OfflineStoreConfig)
        :param 'GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOnlineStoreConfigArgs' online_store_config: (OnlineStore)
        :param _builtins.str pipeline_schedule_state: (string) - The schedule state of the materialization pipeline. Possible values are: `ACTIVE`, `PAUSED`, `SNAPSHOT`
        :param _builtins.str table_name: (string) - The fully qualified Unity Catalog path to the table containing the materialized feature (Delta table or Lakebase table). Output only
        """
        pulumi.set(__self__, "feature_name", feature_name)
        pulumi.set(__self__, "last_materialization_time", last_materialization_time)
        pulumi.set(__self__, "materialized_feature_id", materialized_feature_id)
        pulumi.set(__self__, "offline_store_config", offline_store_config)
        pulumi.set(__self__, "online_store_config", online_store_config)
        pulumi.set(__self__, "pipeline_schedule_state", pipeline_schedule_state)
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="featureName")
    def feature_name(self) -> _builtins.str:
        """
        Filter by feature name. If specified, only materialized features materialized from this feature will be returned
        """
        return pulumi.get(self, "feature_name")

    @_builtins.property
    @pulumi.getter(name="lastMaterializationTime")
    def last_materialization_time(self) -> _builtins.str:
        """
        (string) - The timestamp when the pipeline last ran and updated the materialized feature values.
        If the pipeline has not run yet, this field will be null
        """
        return pulumi.get(self, "last_materialization_time")

    @_builtins.property
    @pulumi.getter(name="materializedFeatureId")
    def materialized_feature_id(self) -> _builtins.str:
        """
        (string) - Unique identifier for the materialized feature
        """
        return pulumi.get(self, "materialized_feature_id")

    @_builtins.property
    @pulumi.getter(name="offlineStoreConfig")
    def offline_store_config(self) -> 'outputs.GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOfflineStoreConfigResult':
        """
        (OfflineStoreConfig)
        """
        return pulumi.get(self, "offline_store_config")

    @_builtins.property
    @pulumi.getter(name="onlineStoreConfig")
    def online_store_config(self) -> 'outputs.GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOnlineStoreConfigResult':
        """
        (OnlineStore)
        """
        return pulumi.get(self, "online_store_config")

    @_builtins.property
    @pulumi.getter(name="pipelineScheduleState")
    def pipeline_schedule_state(self) -> _builtins.str:
        """
        (string) - The schedule state of the materialization pipeline. Possible values are: `ACTIVE`, `PAUSED`, `SNAPSHOT`
        """
        return pulumi.get(self, "pipeline_schedule_state")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        """
        (string) - The fully qualified Unity Catalog path to the table containing the materialized feature (Delta table or Lakebase table). Output only
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOfflineStoreConfigResult(dict):
    def __init__(__self__, *,
                 catalog_name: _builtins.str,
                 schema_name: _builtins.str,
                 table_name_prefix: _builtins.str):
        """
        :param _builtins.str catalog_name: (string) - The Unity Catalog catalog name
        :param _builtins.str schema_name: (string) - The Unity Catalog schema name
        :param _builtins.str table_name_prefix: (string) - Prefix for Unity Catalog table name.
               The materialized feature will be stored in a table with this prefix and a generated postfix
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> _builtins.str:
        """
        (string) - The Unity Catalog catalog name
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        """
        (string) - The Unity Catalog schema name
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> _builtins.str:
        """
        (string) - Prefix for Unity Catalog table name.
        The materialized feature will be stored in a table with this prefix and a generated postfix
        """
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class GetFeatureEngineeringMaterializedFeaturesMaterializedFeatureOnlineStoreConfigResult(dict):
    def __init__(__self__, *,
                 capacity: _builtins.str,
                 creation_time: _builtins.str,
                 creator: _builtins.str,
                 name: _builtins.str,
                 state: _builtins.str,
                 read_replica_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str capacity: (string) - The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        :param _builtins.str creation_time: (string) - The timestamp when the online store was created
        :param _builtins.str creator: (string) - The email of the creator of the online store
        :param _builtins.str name: (string) - The name of the online store. This is the unique identifier for the online store
        :param _builtins.str state: (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        :param _builtins.int read_replica_count: (integer) - The number of read replicas for the online store. Defaults to 0
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "state", state)
        if read_replica_count is not None:
            pulumi.set(__self__, "read_replica_count", read_replica_count)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.str:
        """
        (string) - The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        """
        (string) - The timestamp when the online store was created
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        (string) - The email of the creator of the online store
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - The name of the online store. This is the unique identifier for the online store
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="readReplicaCount")
    def read_replica_count(self) -> Optional[_builtins.int]:
        """
        (integer) - The number of read replicas for the online store. Defaults to 0
        """
        return pulumi.get(self, "read_replica_count")


@pulumi.output_type
class GetFunctionsFunctionResult(dict):
    def __init__(__self__, *,
                 browse_only: Optional[_builtins.bool] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 external_language: Optional[_builtins.str] = None,
                 external_name: Optional[_builtins.str] = None,
                 full_data_type: Optional[_builtins.str] = None,
                 full_name: Optional[_builtins.str] = None,
                 function_id: Optional[_builtins.str] = None,
                 input_params: Optional['outputs.GetFunctionsFunctionInputParamsResult'] = None,
                 is_deterministic: Optional[_builtins.bool] = None,
                 is_null_call: Optional[_builtins.bool] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 parameter_style: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 return_params: Optional['outputs.GetFunctionsFunctionReturnParamsResult'] = None,
                 routine_body: Optional[_builtins.str] = None,
                 routine_definition: Optional[_builtins.str] = None,
                 routine_dependencies: Optional['outputs.GetFunctionsFunctionRoutineDependenciesResult'] = None,
                 schema_name: Optional[_builtins.str] = None,
                 security_type: Optional[_builtins.str] = None,
                 specific_name: Optional[_builtins.str] = None,
                 sql_data_access: Optional[_builtins.str] = None,
                 sql_path: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param _builtins.bool browse_only: Indicates whether the principal is limited to retrieving metadata for the associated object through the `BROWSE` privilege when `include_browse` is enabled in the request.
        :param _builtins.str catalog_name: Name of databricks_catalog.
        :param _builtins.str comment: User-provided free-form text description.
        :param _builtins.int created_at: Time at which this function was created, in epoch milliseconds.
        :param _builtins.str created_by: Username of function creator.
        :param _builtins.str data_type: Scalar function return data type.
        :param _builtins.str external_language: External function language.
        :param _builtins.str external_name: External function name.
        :param _builtins.str full_data_type: Pretty printed function data type.
        :param _builtins.str full_name: Full name of function, in form of catalog_name.schema_name.function__name
        :param _builtins.str function_id: Id of Function, relative to parent schema.
        :param 'GetFunctionsFunctionInputParamsArgs' input_params: object describing input parameters. Consists of the single attribute:
        :param _builtins.bool is_deterministic: Boolean flag specifying whether the function is deterministic.
        :param _builtins.bool is_null_call: Boolean flag whether function null call.
        :param _builtins.str metastore_id: Unique identifier of parent metastore.
        :param _builtins.str name: Name of parameter.
        :param _builtins.str owner: Username of current owner of function.
        :param _builtins.str parameter_style: Function parameter style. `S` is the value for SQL.
        :param _builtins.str properties: JSON-serialized key-value pair map, encoded (escaped) as a string.
        :param 'GetFunctionsFunctionReturnParamsArgs' return_params: Table function return parameters.  See `input_params` for description.
        :param _builtins.str routine_body: Function language (`SQL` or `EXTERNAL`). When `EXTERNAL` is used, the language of the routine function should be specified in the `external_language` field, and the `return_params` of the function cannot be used (as `TABLE` return type is not supported), and the `sql_data_access` field must be `NO_SQL`.
        :param _builtins.str routine_definition: Function body.
        :param 'GetFunctionsFunctionRoutineDependenciesArgs' routine_dependencies: Function dependencies.
        :param _builtins.str schema_name: Name of databricks_schema.
        :param _builtins.str security_type: Function security type. (Enum: `DEFINER`).
        :param _builtins.str specific_name: Specific name of the function; Reserved for future use.
        :param _builtins.str sql_data_access: Function SQL data access (`CONTAINS_SQL`, `READS_SQL_DATA`, `NO_SQL`).
        :param _builtins.str sql_path: List of schemes whose objects can be referenced without qualification.
        :param _builtins.int updated_at: Time at which this function was created, in epoch milliseconds.
        :param _builtins.str updated_by: Username of user who last modified function.
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if external_language is not None:
            pulumi.set(__self__, "external_language", external_language)
        if external_name is not None:
            pulumi.set(__self__, "external_name", external_name)
        if full_data_type is not None:
            pulumi.set(__self__, "full_data_type", full_data_type)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if input_params is not None:
            pulumi.set(__self__, "input_params", input_params)
        if is_deterministic is not None:
            pulumi.set(__self__, "is_deterministic", is_deterministic)
        if is_null_call is not None:
            pulumi.set(__self__, "is_null_call", is_null_call)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if parameter_style is not None:
            pulumi.set(__self__, "parameter_style", parameter_style)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if return_params is not None:
            pulumi.set(__self__, "return_params", return_params)
        if routine_body is not None:
            pulumi.set(__self__, "routine_body", routine_body)
        if routine_definition is not None:
            pulumi.set(__self__, "routine_definition", routine_definition)
        if routine_dependencies is not None:
            pulumi.set(__self__, "routine_dependencies", routine_dependencies)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if security_type is not None:
            pulumi.set(__self__, "security_type", security_type)
        if specific_name is not None:
            pulumi.set(__self__, "specific_name", specific_name)
        if sql_data_access is not None:
            pulumi.set(__self__, "sql_data_access", sql_data_access)
        if sql_path is not None:
            pulumi.set(__self__, "sql_path", sql_path)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the principal is limited to retrieving metadata for the associated object through the `BROWSE` privilege when `include_browse` is enabled in the request.
        """
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        Name of databricks_catalog.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        User-provided free-form text description.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        Time at which this function was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Username of function creator.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        Scalar function return data type.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter(name="externalLanguage")
    def external_language(self) -> Optional[_builtins.str]:
        """
        External function language.
        """
        return pulumi.get(self, "external_language")

    @_builtins.property
    @pulumi.getter(name="externalName")
    def external_name(self) -> Optional[_builtins.str]:
        """
        External function name.
        """
        return pulumi.get(self, "external_name")

    @_builtins.property
    @pulumi.getter(name="fullDataType")
    def full_data_type(self) -> Optional[_builtins.str]:
        """
        Pretty printed function data type.
        """
        return pulumi.get(self, "full_data_type")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        Full name of function, in form of catalog_name.schema_name.function__name
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[_builtins.str]:
        """
        Id of Function, relative to parent schema.
        """
        return pulumi.get(self, "function_id")

    @_builtins.property
    @pulumi.getter(name="inputParams")
    def input_params(self) -> Optional['outputs.GetFunctionsFunctionInputParamsResult']:
        """
        object describing input parameters. Consists of the single attribute:
        """
        return pulumi.get(self, "input_params")

    @_builtins.property
    @pulumi.getter(name="isDeterministic")
    def is_deterministic(self) -> Optional[_builtins.bool]:
        """
        Boolean flag specifying whether the function is deterministic.
        """
        return pulumi.get(self, "is_deterministic")

    @_builtins.property
    @pulumi.getter(name="isNullCall")
    def is_null_call(self) -> Optional[_builtins.bool]:
        """
        Boolean flag whether function null call.
        """
        return pulumi.get(self, "is_null_call")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of parent metastore.
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Username of current owner of function.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="parameterStyle")
    def parameter_style(self) -> Optional[_builtins.str]:
        """
        Function parameter style. `S` is the value for SQL.
        """
        return pulumi.get(self, "parameter_style")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        JSON-serialized key-value pair map, encoded (escaped) as a string.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="returnParams")
    def return_params(self) -> Optional['outputs.GetFunctionsFunctionReturnParamsResult']:
        """
        Table function return parameters.  See `input_params` for description.
        """
        return pulumi.get(self, "return_params")

    @_builtins.property
    @pulumi.getter(name="routineBody")
    def routine_body(self) -> Optional[_builtins.str]:
        """
        Function language (`SQL` or `EXTERNAL`). When `EXTERNAL` is used, the language of the routine function should be specified in the `external_language` field, and the `return_params` of the function cannot be used (as `TABLE` return type is not supported), and the `sql_data_access` field must be `NO_SQL`.
        """
        return pulumi.get(self, "routine_body")

    @_builtins.property
    @pulumi.getter(name="routineDefinition")
    def routine_definition(self) -> Optional[_builtins.str]:
        """
        Function body.
        """
        return pulumi.get(self, "routine_definition")

    @_builtins.property
    @pulumi.getter(name="routineDependencies")
    def routine_dependencies(self) -> Optional['outputs.GetFunctionsFunctionRoutineDependenciesResult']:
        """
        Function dependencies.
        """
        return pulumi.get(self, "routine_dependencies")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        Name of databricks_schema.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="securityType")
    def security_type(self) -> Optional[_builtins.str]:
        """
        Function security type. (Enum: `DEFINER`).
        """
        return pulumi.get(self, "security_type")

    @_builtins.property
    @pulumi.getter(name="specificName")
    def specific_name(self) -> Optional[_builtins.str]:
        """
        Specific name of the function; Reserved for future use.
        """
        return pulumi.get(self, "specific_name")

    @_builtins.property
    @pulumi.getter(name="sqlDataAccess")
    def sql_data_access(self) -> Optional[_builtins.str]:
        """
        Function SQL data access (`CONTAINS_SQL`, `READS_SQL_DATA`, `NO_SQL`).
        """
        return pulumi.get(self, "sql_data_access")

    @_builtins.property
    @pulumi.getter(name="sqlPath")
    def sql_path(self) -> Optional[_builtins.str]:
        """
        List of schemes whose objects can be referenced without qualification.
        """
        return pulumi.get(self, "sql_path")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        Time at which this function was created, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        Username of user who last modified function.
        """
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class GetFunctionsFunctionInputParamsResult(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence['outputs.GetFunctionsFunctionInputParamsParameterResult']] = None):
        """
        :param Sequence['GetFunctionsFunctionInputParamsParameterArgs'] parameters: The array of definitions of the function's parameters:
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GetFunctionsFunctionInputParamsParameterResult']]:
        """
        The array of definitions of the function's parameters:
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetFunctionsFunctionInputParamsParameterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 position: _builtins.int,
                 type_name: _builtins.str,
                 type_text: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 parameter_default: Optional[_builtins.str] = None,
                 parameter_mode: Optional[_builtins.str] = None,
                 parameter_type: Optional[_builtins.str] = None,
                 type_interval_type: Optional[_builtins.str] = None,
                 type_json: Optional[_builtins.str] = None,
                 type_precision: Optional[_builtins.int] = None,
                 type_scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of parameter.
        :param _builtins.int position: Ordinal position of column (starting at position 0).
        :param _builtins.str type_name: Name of type (INT, STRUCT, MAP, etc.).
        :param _builtins.str type_text: Full data type spec, SQL/catalogString text.
        :param _builtins.str comment: User-provided free-form text description.
        :param _builtins.str parameter_default: Default value of the parameter.
        :param _builtins.str parameter_mode: The mode of the function parameter.
        :param _builtins.str parameter_type: The type of function parameter (`PARAM` or `COLUMN`).
        :param _builtins.str type_interval_type: Format of IntervalType.
        :param _builtins.str type_json: Full data type spec, JSON-serialized.
        :param _builtins.int type_precision: Digits of precision; required on Create for DecimalTypes.
        :param _builtins.int type_scale: Digits to right of decimal; Required on Create for DecimalTypes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameter_default is not None:
            pulumi.set(__self__, "parameter_default", parameter_default)
        if parameter_mode is not None:
            pulumi.set(__self__, "parameter_mode", parameter_mode)
        if parameter_type is not None:
            pulumi.set(__self__, "parameter_type", parameter_type)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.int:
        """
        Ordinal position of column (starting at position 0).
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        """
        Name of type (INT, STRUCT, MAP, etc.).
        """
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter(name="typeText")
    def type_text(self) -> _builtins.str:
        """
        Full data type spec, SQL/catalogString text.
        """
        return pulumi.get(self, "type_text")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        User-provided free-form text description.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="parameterDefault")
    def parameter_default(self) -> Optional[_builtins.str]:
        """
        Default value of the parameter.
        """
        return pulumi.get(self, "parameter_default")

    @_builtins.property
    @pulumi.getter(name="parameterMode")
    def parameter_mode(self) -> Optional[_builtins.str]:
        """
        The mode of the function parameter.
        """
        return pulumi.get(self, "parameter_mode")

    @_builtins.property
    @pulumi.getter(name="parameterType")
    def parameter_type(self) -> Optional[_builtins.str]:
        """
        The type of function parameter (`PARAM` or `COLUMN`).
        """
        return pulumi.get(self, "parameter_type")

    @_builtins.property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[_builtins.str]:
        """
        Format of IntervalType.
        """
        return pulumi.get(self, "type_interval_type")

    @_builtins.property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[_builtins.str]:
        """
        Full data type spec, JSON-serialized.
        """
        return pulumi.get(self, "type_json")

    @_builtins.property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[_builtins.int]:
        """
        Digits of precision; required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_precision")

    @_builtins.property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[_builtins.int]:
        """
        Digits to right of decimal; Required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_scale")


@pulumi.output_type
class GetFunctionsFunctionReturnParamsResult(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence['outputs.GetFunctionsFunctionReturnParamsParameterResult']] = None):
        """
        :param Sequence['GetFunctionsFunctionReturnParamsParameterArgs'] parameters: The array of definitions of the function's parameters:
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GetFunctionsFunctionReturnParamsParameterResult']]:
        """
        The array of definitions of the function's parameters:
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetFunctionsFunctionReturnParamsParameterResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 position: _builtins.int,
                 type_name: _builtins.str,
                 type_text: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 parameter_default: Optional[_builtins.str] = None,
                 parameter_mode: Optional[_builtins.str] = None,
                 parameter_type: Optional[_builtins.str] = None,
                 type_interval_type: Optional[_builtins.str] = None,
                 type_json: Optional[_builtins.str] = None,
                 type_precision: Optional[_builtins.int] = None,
                 type_scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Name of parameter.
        :param _builtins.int position: Ordinal position of column (starting at position 0).
        :param _builtins.str type_name: Name of type (INT, STRUCT, MAP, etc.).
        :param _builtins.str type_text: Full data type spec, SQL/catalogString text.
        :param _builtins.str comment: User-provided free-form text description.
        :param _builtins.str parameter_default: Default value of the parameter.
        :param _builtins.str parameter_mode: The mode of the function parameter.
        :param _builtins.str parameter_type: The type of function parameter (`PARAM` or `COLUMN`).
        :param _builtins.str type_interval_type: Format of IntervalType.
        :param _builtins.str type_json: Full data type spec, JSON-serialized.
        :param _builtins.int type_precision: Digits of precision; required on Create for DecimalTypes.
        :param _builtins.int type_scale: Digits to right of decimal; Required on Create for DecimalTypes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "position", position)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "type_text", type_text)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if parameter_default is not None:
            pulumi.set(__self__, "parameter_default", parameter_default)
        if parameter_mode is not None:
            pulumi.set(__self__, "parameter_mode", parameter_mode)
        if parameter_type is not None:
            pulumi.set(__self__, "parameter_type", parameter_type)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def position(self) -> _builtins.int:
        """
        Ordinal position of column (starting at position 0).
        """
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        """
        Name of type (INT, STRUCT, MAP, etc.).
        """
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter(name="typeText")
    def type_text(self) -> _builtins.str:
        """
        Full data type spec, SQL/catalogString text.
        """
        return pulumi.get(self, "type_text")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        User-provided free-form text description.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="parameterDefault")
    def parameter_default(self) -> Optional[_builtins.str]:
        """
        Default value of the parameter.
        """
        return pulumi.get(self, "parameter_default")

    @_builtins.property
    @pulumi.getter(name="parameterMode")
    def parameter_mode(self) -> Optional[_builtins.str]:
        """
        The mode of the function parameter.
        """
        return pulumi.get(self, "parameter_mode")

    @_builtins.property
    @pulumi.getter(name="parameterType")
    def parameter_type(self) -> Optional[_builtins.str]:
        """
        The type of function parameter (`PARAM` or `COLUMN`).
        """
        return pulumi.get(self, "parameter_type")

    @_builtins.property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[_builtins.str]:
        """
        Format of IntervalType.
        """
        return pulumi.get(self, "type_interval_type")

    @_builtins.property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[_builtins.str]:
        """
        Full data type spec, JSON-serialized.
        """
        return pulumi.get(self, "type_json")

    @_builtins.property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[_builtins.int]:
        """
        Digits of precision; required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_precision")

    @_builtins.property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[_builtins.int]:
        """
        Digits to right of decimal; Required on Create for DecimalTypes.
        """
        return pulumi.get(self, "type_scale")


@pulumi.output_type
class GetFunctionsFunctionRoutineDependenciesResult(dict):
    def __init__(__self__, *,
                 dependencies: Optional[Sequence['outputs.GetFunctionsFunctionRoutineDependenciesDependencyResult']] = None):
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['outputs.GetFunctionsFunctionRoutineDependenciesDependencyResult']]:
        return pulumi.get(self, "dependencies")


@pulumi.output_type
class GetFunctionsFunctionRoutineDependenciesDependencyResult(dict):
    def __init__(__self__, *,
                 connection: Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyConnectionResult'] = None,
                 credential: Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyCredentialResult'] = None,
                 function: Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyFunctionResult'] = None,
                 table: Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyTableResult'] = None):
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyConnectionResult']:
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def credential(self) -> Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyCredentialResult']:
        return pulumi.get(self, "credential")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyFunctionResult']:
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def table(self) -> Optional['outputs.GetFunctionsFunctionRoutineDependenciesDependencyTableResult']:
        return pulumi.get(self, "table")


@pulumi.output_type
class GetFunctionsFunctionRoutineDependenciesDependencyConnectionResult(dict):
    def __init__(__self__, *,
                 connection_name: Optional[_builtins.str] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")


@pulumi.output_type
class GetFunctionsFunctionRoutineDependenciesDependencyCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: Optional[_builtins.str] = None):
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_name")


@pulumi.output_type
class GetFunctionsFunctionRoutineDependenciesDependencyFunctionResult(dict):
    def __init__(__self__, *,
                 function_full_name: _builtins.str):
        pulumi.set(__self__, "function_full_name", function_full_name)

    @_builtins.property
    @pulumi.getter(name="functionFullName")
    def function_full_name(self) -> _builtins.str:
        return pulumi.get(self, "function_full_name")


@pulumi.output_type
class GetFunctionsFunctionRoutineDependenciesDependencyTableResult(dict):
    def __init__(__self__, *,
                 table_full_name: _builtins.str):
        pulumi.set(__self__, "table_full_name", table_full_name)

    @_builtins.property
    @pulumi.getter(name="tableFullName")
    def table_full_name(self) -> _builtins.str:
        return pulumi.get(self, "table_full_name")


@pulumi.output_type
class GetFunctionsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetInstancePoolPoolInfoResult(dict):
    def __init__(__self__, *,
                 default_tags: Mapping[str, _builtins.str],
                 idle_instance_autotermination_minutes: _builtins.int,
                 instance_pool_id: _builtins.str,
                 instance_pool_name: _builtins.str,
                 aws_attributes: Optional['outputs.GetInstancePoolPoolInfoAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetInstancePoolPoolInfoAzureAttributesResult'] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 disk_spec: Optional['outputs.GetInstancePoolPoolInfoDiskSpecResult'] = None,
                 enable_elastic_disk: Optional[_builtins.bool] = None,
                 gcp_attributes: Optional['outputs.GetInstancePoolPoolInfoGcpAttributesResult'] = None,
                 instance_pool_fleet_attributes: Optional[Sequence['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeResult']] = None,
                 max_capacity: Optional[_builtins.int] = None,
                 min_idle_instances: Optional[_builtins.int] = None,
                 node_type_id: Optional[_builtins.str] = None,
                 preloaded_docker_images: Optional[Sequence['outputs.GetInstancePoolPoolInfoPreloadedDockerImageResult']] = None,
                 preloaded_spark_versions: Optional[Sequence[_builtins.str]] = None,
                 state: Optional[_builtins.str] = None,
                 stats: Optional['outputs.GetInstancePoolPoolInfoStatsResult'] = None):
        pulumi.set(__self__, "default_tags", default_tags)
        pulumi.set(__self__, "idle_instance_autotermination_minutes", idle_instance_autotermination_minutes)
        pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        pulumi.set(__self__, "instance_pool_name", instance_pool_name)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if disk_spec is not None:
            pulumi.set(__self__, "disk_spec", disk_spec)
        if enable_elastic_disk is not None:
            pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if instance_pool_fleet_attributes is not None:
            pulumi.set(__self__, "instance_pool_fleet_attributes", instance_pool_fleet_attributes)
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_idle_instances is not None:
            pulumi.set(__self__, "min_idle_instances", min_idle_instances)
        if node_type_id is not None:
            pulumi.set(__self__, "node_type_id", node_type_id)
        if preloaded_docker_images is not None:
            pulumi.set(__self__, "preloaded_docker_images", preloaded_docker_images)
        if preloaded_spark_versions is not None:
            pulumi.set(__self__, "preloaded_spark_versions", preloaded_spark_versions)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stats is not None:
            pulumi.set(__self__, "stats", stats)

    @_builtins.property
    @pulumi.getter(name="defaultTags")
    def default_tags(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "default_tags")

    @_builtins.property
    @pulumi.getter(name="idleInstanceAutoterminationMinutes")
    def idle_instance_autotermination_minutes(self) -> _builtins.int:
        return pulumi.get(self, "idle_instance_autotermination_minutes")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="instancePoolName")
    def instance_pool_name(self) -> _builtins.str:
        return pulumi.get(self, "instance_pool_name")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetInstancePoolPoolInfoAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetInstancePoolPoolInfoAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="diskSpec")
    def disk_spec(self) -> Optional['outputs.GetInstancePoolPoolInfoDiskSpecResult']:
        return pulumi.get(self, "disk_spec")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetInstancePoolPoolInfoGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="instancePoolFleetAttributes")
    def instance_pool_fleet_attributes(self) -> Optional[Sequence['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeResult']]:
        return pulumi.get(self, "instance_pool_fleet_attributes")

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_capacity")

    @_builtins.property
    @pulumi.getter(name="minIdleInstances")
    def min_idle_instances(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_idle_instances")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="preloadedDockerImages")
    def preloaded_docker_images(self) -> Optional[Sequence['outputs.GetInstancePoolPoolInfoPreloadedDockerImageResult']]:
        return pulumi.get(self, "preloaded_docker_images")

    @_builtins.property
    @pulumi.getter(name="preloadedSparkVersions")
    def preloaded_spark_versions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "preloaded_spark_versions")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def stats(self) -> Optional['outputs.GetInstancePoolPoolInfoStatsResult']:
        return pulumi.get(self, "stats")


@pulumi.output_type
class GetInstancePoolPoolInfoAwsAttributesResult(dict):
    def __init__(__self__, *,
                 zone_id: _builtins.str,
                 availability: Optional[_builtins.str] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None):
        pulumi.set(__self__, "zone_id", zone_id)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")


@pulumi.output_type
class GetInstancePoolPoolInfoAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetInstancePoolPoolInfoDiskSpecResult(dict):
    def __init__(__self__, *,
                 disk_count: Optional[_builtins.int] = None,
                 disk_size: Optional[_builtins.int] = None,
                 disk_type: Optional['outputs.GetInstancePoolPoolInfoDiskSpecDiskTypeResult'] = None):
        if disk_count is not None:
            pulumi.set(__self__, "disk_count", disk_count)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter(name="diskCount")
    def disk_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "disk_count")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional['outputs.GetInstancePoolPoolInfoDiskSpecDiskTypeResult']:
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class GetInstancePoolPoolInfoDiskSpecDiskTypeResult(dict):
    def __init__(__self__, *,
                 azure_disk_volume_type: Optional[_builtins.str] = None,
                 ebs_volume_type: Optional[_builtins.str] = None):
        if azure_disk_volume_type is not None:
            pulumi.set(__self__, "azure_disk_volume_type", azure_disk_volume_type)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)

    @_builtins.property
    @pulumi.getter(name="azureDiskVolumeType")
    def azure_disk_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "azure_disk_volume_type")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")


@pulumi.output_type
class GetInstancePoolPoolInfoGcpAttributesResult(dict):
    def __init__(__self__, *,
                 local_ssd_count: _builtins.int,
                 zone_id: _builtins.str,
                 gcp_availability: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        pulumi.set(__self__, "zone_id", zone_id)
        if gcp_availability is not None:
            pulumi.set(__self__, "gcp_availability", gcp_availability)

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> _builtins.int:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter(name="gcpAvailability")
    def gcp_availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gcp_availability")


@pulumi.output_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeResult(dict):
    def __init__(__self__, *,
                 launch_template_overrides: Sequence['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideResult'],
                 fleet_on_demand_option: Optional['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionResult'] = None,
                 fleet_spot_option: Optional['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionResult'] = None):
        pulumi.set(__self__, "launch_template_overrides", launch_template_overrides)
        if fleet_on_demand_option is not None:
            pulumi.set(__self__, "fleet_on_demand_option", fleet_on_demand_option)
        if fleet_spot_option is not None:
            pulumi.set(__self__, "fleet_spot_option", fleet_spot_option)

    @_builtins.property
    @pulumi.getter(name="launchTemplateOverrides")
    def launch_template_overrides(self) -> Sequence['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideResult']:
        return pulumi.get(self, "launch_template_overrides")

    @_builtins.property
    @pulumi.getter(name="fleetOnDemandOption")
    def fleet_on_demand_option(self) -> Optional['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionResult']:
        return pulumi.get(self, "fleet_on_demand_option")

    @_builtins.property
    @pulumi.getter(name="fleetSpotOption")
    def fleet_spot_option(self) -> Optional['outputs.GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionResult']:
        return pulumi.get(self, "fleet_spot_option")


@pulumi.output_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetOnDemandOptionResult(dict):
    def __init__(__self__, *,
                 allocation_strategy: _builtins.str,
                 instance_pools_to_use_count: Optional[_builtins.int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> _builtins.str:
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_pools_to_use_count")


@pulumi.output_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeFleetSpotOptionResult(dict):
    def __init__(__self__, *,
                 allocation_strategy: _builtins.str,
                 instance_pools_to_use_count: Optional[_builtins.int] = None):
        pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> _builtins.str:
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "instance_pools_to_use_count")


@pulumi.output_type
class GetInstancePoolPoolInfoInstancePoolFleetAttributeLaunchTemplateOverrideResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 instance_type: _builtins.str):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "instance_type", instance_type)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> _builtins.str:
        return pulumi.get(self, "instance_type")


@pulumi.output_type
class GetInstancePoolPoolInfoPreloadedDockerImageResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetInstancePoolPoolInfoPreloadedDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetInstancePoolPoolInfoStatsResult(dict):
    def __init__(__self__, *,
                 idle_count: Optional[_builtins.int] = None,
                 pending_idle_count: Optional[_builtins.int] = None,
                 pending_used_count: Optional[_builtins.int] = None,
                 used_count: Optional[_builtins.int] = None):
        if idle_count is not None:
            pulumi.set(__self__, "idle_count", idle_count)
        if pending_idle_count is not None:
            pulumi.set(__self__, "pending_idle_count", pending_idle_count)
        if pending_used_count is not None:
            pulumi.set(__self__, "pending_used_count", pending_used_count)
        if used_count is not None:
            pulumi.set(__self__, "used_count", used_count)

    @_builtins.property
    @pulumi.getter(name="idleCount")
    def idle_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "idle_count")

    @_builtins.property
    @pulumi.getter(name="pendingIdleCount")
    def pending_idle_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "pending_idle_count")

    @_builtins.property
    @pulumi.getter(name="pendingUsedCount")
    def pending_used_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "pending_used_count")

    @_builtins.property
    @pulumi.getter(name="usedCount")
    def used_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "used_count")


@pulumi.output_type
class GetInstanceProfilesInstanceProfileResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 is_meta: _builtins.bool,
                 name: _builtins.str,
                 role_arn: _builtins.str):
        """
        :param _builtins.str arn: ARN of the instance profile.
        :param _builtins.bool is_meta: Whether the instance profile is a meta instance profile or not.
        :param _builtins.str name: Name of the instance profile.
        :param _builtins.str role_arn: ARN of the role attached to the instance profile.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "is_meta", is_meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        ARN of the instance profile.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="isMeta")
    def is_meta(self) -> _builtins.bool:
        """
        Whether the instance profile is a meta instance profile or not.
        """
        return pulumi.get(self, "is_meta")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the instance profile.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        ARN of the role attached to the instance profile.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetInstanceProfilesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetJobJobSettingsResult(dict):
    def __init__(__self__, *,
                 run_as_user_name: _builtins.str,
                 created_time: Optional[_builtins.int] = None,
                 creator_user_name: Optional[_builtins.str] = None,
                 job_id: Optional[_builtins.int] = None,
                 settings: Optional['outputs.GetJobJobSettingsSettingsResult'] = None):
        pulumi.set(__self__, "run_as_user_name", run_as_user_name)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if creator_user_name is not None:
            pulumi.set(__self__, "creator_user_name", creator_user_name)
        if job_id is not None:
            pulumi.set(__self__, "job_id", job_id)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> _builtins.str:
        return pulumi.get(self, "run_as_user_name")

    @_builtins.property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "created_time")

    @_builtins.property
    @pulumi.getter(name="creatorUserName")
    def creator_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "creator_user_name")

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional['outputs.GetJobJobSettingsSettingsResult']:
        return pulumi.get(self, "settings")


@pulumi.output_type
class GetJobJobSettingsSettingsResult(dict):
    def __init__(__self__, *,
                 format: _builtins.str,
                 run_as: 'outputs.GetJobJobSettingsSettingsRunAsResult',
                 continuous: Optional['outputs.GetJobJobSettingsSettingsContinuousResult'] = None,
                 dbt_task: Optional['outputs.GetJobJobSettingsSettingsDbtTaskResult'] = None,
                 deployment: Optional['outputs.GetJobJobSettingsSettingsDeploymentResult'] = None,
                 description: Optional[_builtins.str] = None,
                 edit_mode: Optional[_builtins.str] = None,
                 email_notifications: Optional['outputs.GetJobJobSettingsSettingsEmailNotificationsResult'] = None,
                 environments: Optional[Sequence['outputs.GetJobJobSettingsSettingsEnvironmentResult']] = None,
                 existing_cluster_id: Optional[_builtins.str] = None,
                 git_source: Optional['outputs.GetJobJobSettingsSettingsGitSourceResult'] = None,
                 health: Optional['outputs.GetJobJobSettingsSettingsHealthResult'] = None,
                 job_clusters: Optional[Sequence['outputs.GetJobJobSettingsSettingsJobClusterResult']] = None,
                 libraries: Optional[Sequence['outputs.GetJobJobSettingsSettingsLibraryResult']] = None,
                 max_concurrent_runs: Optional[_builtins.int] = None,
                 max_retries: Optional[_builtins.int] = None,
                 min_retry_interval_millis: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 new_cluster: Optional['outputs.GetJobJobSettingsSettingsNewClusterResult'] = None,
                 notebook_task: Optional['outputs.GetJobJobSettingsSettingsNotebookTaskResult'] = None,
                 notification_settings: Optional['outputs.GetJobJobSettingsSettingsNotificationSettingsResult'] = None,
                 parameters: Optional[Sequence['outputs.GetJobJobSettingsSettingsParameterResult']] = None,
                 pipeline_task: Optional['outputs.GetJobJobSettingsSettingsPipelineTaskResult'] = None,
                 python_wheel_task: Optional['outputs.GetJobJobSettingsSettingsPythonWheelTaskResult'] = None,
                 queue: Optional['outputs.GetJobJobSettingsSettingsQueueResult'] = None,
                 retry_on_timeout: Optional[_builtins.bool] = None,
                 run_job_task: Optional['outputs.GetJobJobSettingsSettingsRunJobTaskResult'] = None,
                 schedule: Optional['outputs.GetJobJobSettingsSettingsScheduleResult'] = None,
                 spark_jar_task: Optional['outputs.GetJobJobSettingsSettingsSparkJarTaskResult'] = None,
                 spark_python_task: Optional['outputs.GetJobJobSettingsSettingsSparkPythonTaskResult'] = None,
                 spark_submit_task: Optional['outputs.GetJobJobSettingsSettingsSparkSubmitTaskResult'] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 tasks: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskResult']] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 trigger: Optional['outputs.GetJobJobSettingsSettingsTriggerResult'] = None,
                 webhook_notifications: Optional['outputs.GetJobJobSettingsSettingsWebhookNotificationsResult'] = None):
        """
        :param _builtins.str name: the job name of Job if the resource was matched by id.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "run_as", run_as)
        if continuous is not None:
            pulumi.set(__self__, "continuous", continuous)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if edit_mode is not None:
            pulumi.set(__self__, "edit_mode", edit_mode)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if git_source is not None:
            pulumi.set(__self__, "git_source", git_source)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_clusters is not None:
            pulumi.set(__self__, "job_clusters", job_clusters)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if queue is not None:
            pulumi.set(__self__, "queue", queue)
        if retry_on_timeout is not None:
            pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if trigger is not None:
            pulumi.set(__self__, "trigger", trigger)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @_builtins.property
    @pulumi.getter
    def format(self) -> _builtins.str:
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="runAs")
    def run_as(self) -> 'outputs.GetJobJobSettingsSettingsRunAsResult':
        return pulumi.get(self, "run_as")

    @_builtins.property
    @pulumi.getter
    def continuous(self) -> Optional['outputs.GetJobJobSettingsSettingsContinuousResult']:
        return pulumi.get(self, "continuous")

    @_builtins.property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['outputs.GetJobJobSettingsSettingsDbtTaskResult']:
        return pulumi.get(self, "dbt_task")

    @_builtins.property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.GetJobJobSettingsSettingsDeploymentResult']:
        return pulumi.get(self, "deployment")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="editMode")
    def edit_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "edit_mode")

    @_builtins.property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['outputs.GetJobJobSettingsSettingsEmailNotificationsResult']:
        return pulumi.get(self, "email_notifications")

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsEnvironmentResult']]:
        return pulumi.get(self, "environments")

    @_builtins.property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "existing_cluster_id")

    @_builtins.property
    @pulumi.getter(name="gitSource")
    def git_source(self) -> Optional['outputs.GetJobJobSettingsSettingsGitSourceResult']:
        return pulumi.get(self, "git_source")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional['outputs.GetJobJobSettingsSettingsHealthResult']:
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="jobClusters")
    def job_clusters(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsJobClusterResult']]:
        return pulumi.get(self, "job_clusters")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsLibraryResult']]:
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_concurrent_runs")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterResult']:
        return pulumi.get(self, "new_cluster")

    @_builtins.property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['outputs.GetJobJobSettingsSettingsNotebookTaskResult']:
        return pulumi.get(self, "notebook_task")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.GetJobJobSettingsSettingsNotificationSettingsResult']:
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsParameterResult']]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['outputs.GetJobJobSettingsSettingsPipelineTaskResult']:
        return pulumi.get(self, "pipeline_task")

    @_builtins.property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['outputs.GetJobJobSettingsSettingsPythonWheelTaskResult']:
        return pulumi.get(self, "python_wheel_task")

    @_builtins.property
    @pulumi.getter
    def queue(self) -> Optional['outputs.GetJobJobSettingsSettingsQueueResult']:
        return pulumi.get(self, "queue")

    @_builtins.property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "retry_on_timeout")

    @_builtins.property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['outputs.GetJobJobSettingsSettingsRunJobTaskResult']:
        return pulumi.get(self, "run_job_task")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.GetJobJobSettingsSettingsScheduleResult']:
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['outputs.GetJobJobSettingsSettingsSparkJarTaskResult']:
        return pulumi.get(self, "spark_jar_task")

    @_builtins.property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['outputs.GetJobJobSettingsSettingsSparkPythonTaskResult']:
        return pulumi.get(self, "spark_python_task")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['outputs.GetJobJobSettingsSettingsSparkSubmitTaskResult']:
        return pulumi.get(self, "spark_submit_task")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def tasks(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskResult']]:
        return pulumi.get(self, "tasks")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Optional['outputs.GetJobJobSettingsSettingsTriggerResult']:
        return pulumi.get(self, "trigger")

    @_builtins.property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['outputs.GetJobJobSettingsSettingsWebhookNotificationsResult']:
        return pulumi.get(self, "webhook_notifications")


@pulumi.output_type
class GetJobJobSettingsSettingsContinuousResult(dict):
    def __init__(__self__, *,
                 pause_status: Optional[_builtins.str] = None):
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class GetJobJobSettingsSettingsDbtTaskResult(dict):
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str],
                 catalog: Optional[_builtins.str] = None,
                 profiles_directory: Optional[_builtins.str] = None,
                 project_directory: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profiles_directory")

    @_builtins.property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "project_directory")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsDeploymentResult(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 metadata_file_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "kind", kind)
        if metadata_file_path is not None:
            pulumi.set(__self__, "metadata_file_path", metadata_file_path)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="metadataFilePath")
    def metadata_file_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metadata_file_path")


@pulumi.output_type
class GetJobJobSettingsSettingsEmailNotificationsResult(dict):
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_failures: Optional[Sequence[_builtins.str]] = None,
                 on_starts: Optional[Sequence[_builtins.str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_successes: Optional[Sequence[_builtins.str]] = None):
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class GetJobJobSettingsSettingsEnvironmentResult(dict):
    def __init__(__self__, *,
                 environment_key: _builtins.str,
                 spec: Optional['outputs.GetJobJobSettingsSettingsEnvironmentSpecResult'] = None):
        pulumi.set(__self__, "environment_key", environment_key)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> _builtins.str:
        return pulumi.get(self, "environment_key")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GetJobJobSettingsSettingsEnvironmentSpecResult']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetJobJobSettingsSettingsEnvironmentSpecResult(dict):
    def __init__(__self__, *,
                 client: Optional[_builtins.str] = None,
                 dependencies: Optional[Sequence[_builtins.str]] = None,
                 environment_version: Optional[_builtins.str] = None,
                 java_dependencies: Optional[Sequence[_builtins.str]] = None):
        if client is not None:
            pulumi.set(__self__, "client", client)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if environment_version is not None:
            pulumi.set(__self__, "environment_version", environment_version)
        if java_dependencies is not None:
            pulumi.set(__self__, "java_dependencies", java_dependencies)

    @_builtins.property
    @pulumi.getter
    def client(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "client")

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="environmentVersion")
    def environment_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "environment_version")

    @_builtins.property
    @pulumi.getter(name="javaDependencies")
    def java_dependencies(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "java_dependencies")


@pulumi.output_type
class GetJobJobSettingsSettingsGitSourceResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 branch: Optional[_builtins.str] = None,
                 commit: Optional[_builtins.str] = None,
                 job_source: Optional['outputs.GetJobJobSettingsSettingsGitSourceJobSourceResult'] = None,
                 provider: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        pulumi.set(__self__, "url", url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit is not None:
            pulumi.set(__self__, "commit", commit)
        if job_source is not None:
            pulumi.set(__self__, "job_source", job_source)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter
    def commit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "commit")

    @_builtins.property
    @pulumi.getter(name="jobSource")
    def job_source(self) -> Optional['outputs.GetJobJobSettingsSettingsGitSourceJobSourceResult']:
        return pulumi.get(self, "job_source")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetJobJobSettingsSettingsGitSourceJobSourceResult(dict):
    def __init__(__self__, *,
                 import_from_git_branch: _builtins.str,
                 job_config_path: _builtins.str,
                 dirty_state: Optional[_builtins.str] = None):
        pulumi.set(__self__, "import_from_git_branch", import_from_git_branch)
        pulumi.set(__self__, "job_config_path", job_config_path)
        if dirty_state is not None:
            pulumi.set(__self__, "dirty_state", dirty_state)

    @_builtins.property
    @pulumi.getter(name="importFromGitBranch")
    def import_from_git_branch(self) -> _builtins.str:
        return pulumi.get(self, "import_from_git_branch")

    @_builtins.property
    @pulumi.getter(name="jobConfigPath")
    def job_config_path(self) -> _builtins.str:
        return pulumi.get(self, "job_config_path")

    @_builtins.property
    @pulumi.getter(name="dirtyState")
    def dirty_state(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dirty_state")


@pulumi.output_type
class GetJobJobSettingsSettingsHealthResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetJobJobSettingsSettingsHealthRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetJobJobSettingsSettingsHealthRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetJobJobSettingsSettingsHealthRuleResult(dict):
    def __init__(__self__, *,
                 metric: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterResult(dict):
    def __init__(__self__, *,
                 job_cluster_key: _builtins.str,
                 new_cluster: 'outputs.GetJobJobSettingsSettingsJobClusterNewClusterResult'):
        pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        pulumi.set(__self__, "new_cluster", new_cluster)

    @_builtins.property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> _builtins.str:
        return pulumi.get(self, "job_cluster_key")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> 'outputs.GetJobJobSettingsSettingsJobClusterNewClusterResult':
        return pulumi.get(self, "new_cluster")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterResult(dict):
    def __init__(__self__, *,
                 driver_instance_pool_id: _builtins.str,
                 driver_node_type_id: _builtins.str,
                 enable_elastic_disk: _builtins.bool,
                 enable_local_disk_encryption: _builtins.bool,
                 node_type_id: _builtins.str,
                 num_workers: _builtins.int,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleResult'] = None,
                 autotermination_minutes: Optional[_builtins.int] = None,
                 aws_attributes: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesResult'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfResult'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoResult']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterDockerImageResult'] = None,
                 gcp_attributes: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesResult'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptResult']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 policy_id: Optional[_builtins.str] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 workload_type: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeResult'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> _builtins.bool:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> _builtins.bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> _builtins.int:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autotermination_minutes")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoResult']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeResult']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Result'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoResult(dict):
    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoResult',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoResult':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterClusterMountInfoNetworkFilesystemInfoResult(dict):
    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptResult(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssResult'] = None,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsResult'] = None,
                 file: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileResult'] = None,
                 gcs: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Result'] = None,
                 volumes: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesResult'] = None,
                 workspace: Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceResult'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssResult']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsResult']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesResult']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceResult']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptAbfssResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptFileResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptGcsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterInitScriptWorkspaceResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 clients: 'outputs.GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsResult'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsResult':
        return pulumi.get(self, "clients")


@pulumi.output_type
class GetJobJobSettingsSettingsJobClusterNewClusterWorkloadTypeClientsResult(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GetJobJobSettingsSettingsLibraryResult(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.GetJobJobSettingsSettingsLibraryCranResult'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.GetJobJobSettingsSettingsLibraryMavenResult'] = None,
                 provider_config: Optional['outputs.GetJobJobSettingsSettingsLibraryProviderConfigResult'] = None,
                 pypi: Optional['outputs.GetJobJobSettingsSettingsLibraryPypiResult'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.GetJobJobSettingsSettingsLibraryCranResult']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.GetJobJobSettingsSettingsLibraryMavenResult']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.GetJobJobSettingsSettingsLibraryProviderConfigResult']:
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.GetJobJobSettingsSettingsLibraryPypiResult']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class GetJobJobSettingsSettingsLibraryCranResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsLibraryMavenResult(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsLibraryProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetJobJobSettingsSettingsLibraryPypiResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterResult(dict):
    def __init__(__self__, *,
                 driver_instance_pool_id: _builtins.str,
                 driver_node_type_id: _builtins.str,
                 enable_elastic_disk: _builtins.bool,
                 enable_local_disk_encryption: _builtins.bool,
                 node_type_id: _builtins.str,
                 num_workers: _builtins.int,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.GetJobJobSettingsSettingsNewClusterAutoscaleResult'] = None,
                 autotermination_minutes: Optional[_builtins.int] = None,
                 aws_attributes: Optional['outputs.GetJobJobSettingsSettingsNewClusterAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetJobJobSettingsSettingsNewClusterAzureAttributesResult'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.GetJobJobSettingsSettingsNewClusterClusterLogConfResult'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.GetJobJobSettingsSettingsNewClusterClusterMountInfoResult']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.GetJobJobSettingsSettingsNewClusterDockerImageResult'] = None,
                 gcp_attributes: Optional['outputs.GetJobJobSettingsSettingsNewClusterGcpAttributesResult'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.GetJobJobSettingsSettingsNewClusterInitScriptResult']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 policy_id: Optional[_builtins.str] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 workload_type: Optional['outputs.GetJobJobSettingsSettingsNewClusterWorkloadTypeResult'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> _builtins.bool:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> _builtins.bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> _builtins.int:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autotermination_minutes")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsNewClusterClusterMountInfoResult']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsNewClusterInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterWorkloadTypeResult']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsNewClusterClusterLogConfS3Result'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterClusterLogConfS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterClusterMountInfoResult(dict):
    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoResult',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoResult':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterClusterMountInfoNetworkFilesystemInfoResult(dict):
    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterDockerImageResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptResult(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptAbfssResult'] = None,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptDbfsResult'] = None,
                 file: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptFileResult'] = None,
                 gcs: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptGcsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptS3Result'] = None,
                 volumes: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptVolumesResult'] = None,
                 workspace: Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceResult'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptAbfssResult']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptGcsResult']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptVolumesResult']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceResult']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptAbfssResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptFileResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptGcsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterInitScriptWorkspaceResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 clients: 'outputs.GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsResult'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsResult':
        return pulumi.get(self, "clients")


@pulumi.output_type
class GetJobJobSettingsSettingsNewClusterWorkloadTypeClientsResult(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GetJobJobSettingsSettingsNotebookTaskResult(dict):
    def __init__(__self__, *,
                 notebook_path: _builtins.str,
                 base_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> _builtins.str:
        return pulumi.get(self, "notebook_path")

    @_builtins.property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "base_parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 no_alert_for_canceled_runs: Optional[_builtins.bool] = None,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None):
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @_builtins.property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")


@pulumi.output_type
class GetJobJobSettingsSettingsParameterResult(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str name: the job name of Job if the resource was matched by id.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetJobJobSettingsSettingsPipelineTaskResult(dict):
    def __init__(__self__, *,
                 pipeline_id: _builtins.str,
                 full_refresh: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class GetJobJobSettingsSettingsPythonWheelTaskResult(dict):
    def __init__(__self__, *,
                 entry_point: Optional[_builtins.str] = None,
                 named_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 package_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "named_parameters")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsQueueResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetJobJobSettingsSettingsRunAsResult(dict):
    def __init__(__self__, *,
                 service_principal_name: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if service_principal_name is not None:
            pulumi.set(__self__, "service_principal_name", service_principal_name)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="servicePrincipalName")
    def service_principal_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_principal_name")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsRunJobTaskResult(dict):
    def __init__(__self__, *,
                 job_id: _builtins.int,
                 job_parameters: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.int:
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "job_parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsScheduleResult(dict):
    def __init__(__self__, *,
                 quartz_cron_expression: _builtins.str,
                 timezone_id: _builtins.str,
                 pause_status: Optional[_builtins.str] = None):
        pulumi.set(__self__, "quartz_cron_expression", quartz_cron_expression)
        pulumi.set(__self__, "timezone_id", timezone_id)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)

    @_builtins.property
    @pulumi.getter(name="quartzCronExpression")
    def quartz_cron_expression(self) -> _builtins.str:
        return pulumi.get(self, "quartz_cron_expression")

    @_builtins.property
    @pulumi.getter(name="timezoneId")
    def timezone_id(self) -> _builtins.str:
        return pulumi.get(self, "timezone_id")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pause_status")


@pulumi.output_type
class GetJobJobSettingsSettingsSparkJarTaskResult(dict):
    def __init__(__self__, *,
                 jar_uri: Optional[_builtins.str] = None,
                 main_class_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar_uri")

    @_builtins.property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "main_class_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsSparkPythonTaskResult(dict):
    def __init__(__self__, *,
                 python_file: _builtins.str,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> _builtins.str:
        return pulumi.get(self, "python_file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetJobJobSettingsSettingsSparkSubmitTaskResult(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskResult(dict):
    def __init__(__self__, *,
                 retry_on_timeout: _builtins.bool,
                 task_key: _builtins.str,
                 condition_task: Optional['outputs.GetJobJobSettingsSettingsTaskConditionTaskResult'] = None,
                 dashboard_task: Optional['outputs.GetJobJobSettingsSettingsTaskDashboardTaskResult'] = None,
                 dbt_task: Optional['outputs.GetJobJobSettingsSettingsTaskDbtTaskResult'] = None,
                 depends_ons: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskDependsOnResult']] = None,
                 description: Optional[_builtins.str] = None,
                 email_notifications: Optional['outputs.GetJobJobSettingsSettingsTaskEmailNotificationsResult'] = None,
                 environment_key: Optional[_builtins.str] = None,
                 existing_cluster_id: Optional[_builtins.str] = None,
                 for_each_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskResult'] = None,
                 health: Optional['outputs.GetJobJobSettingsSettingsTaskHealthResult'] = None,
                 job_cluster_key: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskLibraryResult']] = None,
                 max_retries: Optional[_builtins.int] = None,
                 min_retry_interval_millis: Optional[_builtins.int] = None,
                 new_cluster: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterResult'] = None,
                 notebook_task: Optional['outputs.GetJobJobSettingsSettingsTaskNotebookTaskResult'] = None,
                 notification_settings: Optional['outputs.GetJobJobSettingsSettingsTaskNotificationSettingsResult'] = None,
                 pipeline_task: Optional['outputs.GetJobJobSettingsSettingsTaskPipelineTaskResult'] = None,
                 power_bi_task: Optional['outputs.GetJobJobSettingsSettingsTaskPowerBiTaskResult'] = None,
                 python_wheel_task: Optional['outputs.GetJobJobSettingsSettingsTaskPythonWheelTaskResult'] = None,
                 run_if: Optional[_builtins.str] = None,
                 run_job_task: Optional['outputs.GetJobJobSettingsSettingsTaskRunJobTaskResult'] = None,
                 spark_jar_task: Optional['outputs.GetJobJobSettingsSettingsTaskSparkJarTaskResult'] = None,
                 spark_python_task: Optional['outputs.GetJobJobSettingsSettingsTaskSparkPythonTaskResult'] = None,
                 spark_submit_task: Optional['outputs.GetJobJobSettingsSettingsTaskSparkSubmitTaskResult'] = None,
                 sql_task: Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskResult'] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 webhook_notifications: Optional['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsResult'] = None):
        pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        pulumi.set(__self__, "task_key", task_key)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dashboard_task is not None:
            pulumi.set(__self__, "dashboard_task", dashboard_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if for_each_task is not None:
            pulumi.set(__self__, "for_each_task", for_each_task)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if power_bi_task is not None:
            pulumi.set(__self__, "power_bi_task", power_bi_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @_builtins.property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> _builtins.bool:
        return pulumi.get(self, "retry_on_timeout")

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskConditionTaskResult']:
        return pulumi.get(self, "condition_task")

    @_builtins.property
    @pulumi.getter(name="dashboardTask")
    def dashboard_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskDashboardTaskResult']:
        return pulumi.get(self, "dashboard_task")

    @_builtins.property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskDbtTaskResult']:
        return pulumi.get(self, "dbt_task")

    @_builtins.property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskDependsOnResult']]:
        return pulumi.get(self, "depends_ons")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskEmailNotificationsResult']:
        return pulumi.get(self, "email_notifications")

    @_builtins.property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "environment_key")

    @_builtins.property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "existing_cluster_id")

    @_builtins.property
    @pulumi.getter(name="forEachTask")
    def for_each_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskResult']:
        return pulumi.get(self, "for_each_task")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskHealthResult']:
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "job_cluster_key")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskLibraryResult']]:
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterResult']:
        return pulumi.get(self, "new_cluster")

    @_builtins.property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNotebookTaskResult']:
        return pulumi.get(self, "notebook_task")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNotificationSettingsResult']:
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskPipelineTaskResult']:
        return pulumi.get(self, "pipeline_task")

    @_builtins.property
    @pulumi.getter(name="powerBiTask")
    def power_bi_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskPowerBiTaskResult']:
        return pulumi.get(self, "power_bi_task")

    @_builtins.property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskPythonWheelTaskResult']:
        return pulumi.get(self, "python_wheel_task")

    @_builtins.property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_if")

    @_builtins.property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskRunJobTaskResult']:
        return pulumi.get(self, "run_job_task")

    @_builtins.property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSparkJarTaskResult']:
        return pulumi.get(self, "spark_jar_task")

    @_builtins.property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSparkPythonTaskResult']:
        return pulumi.get(self, "spark_python_task")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSparkSubmitTaskResult']:
        return pulumi.get(self, "spark_submit_task")

    @_builtins.property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskResult']:
        return pulumi.get(self, "sql_task")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsResult']:
        return pulumi.get(self, "webhook_notifications")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskConditionTaskResult(dict):
    def __init__(__self__, *,
                 left: _builtins.str,
                 op: _builtins.str,
                 right: _builtins.str):
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @_builtins.property
    @pulumi.getter
    def left(self) -> _builtins.str:
        return pulumi.get(self, "left")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def right(self) -> _builtins.str:
        return pulumi.get(self, "right")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskDashboardTaskResult(dict):
    def __init__(__self__, *,
                 dashboard_id: Optional[_builtins.str] = None,
                 subscription: Optional['outputs.GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionResult'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        if dashboard_id is not None:
            pulumi.set(__self__, "dashboard_id", dashboard_id)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionResult']:
        return pulumi.get(self, "subscription")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionResult(dict):
    def __init__(__self__, *,
                 custom_subject: Optional[_builtins.str] = None,
                 paused: Optional[_builtins.bool] = None,
                 subscribers: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionSubscriberResult']] = None):
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionSubscriberResult']]:
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskDashboardTaskSubscriptionSubscriberResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskDbtTaskResult(dict):
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str],
                 catalog: Optional[_builtins.str] = None,
                 profiles_directory: Optional[_builtins.str] = None,
                 project_directory: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profiles_directory")

    @_builtins.property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "project_directory")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskDependsOnResult(dict):
    def __init__(__self__, *,
                 task_key: _builtins.str,
                 outcome: Optional[_builtins.str] = None):
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter
    def outcome(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outcome")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskEmailNotificationsResult(dict):
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_failures: Optional[Sequence[_builtins.str]] = None,
                 on_starts: Optional[Sequence[_builtins.str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_successes: Optional[Sequence[_builtins.str]] = None):
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskResult(dict):
    def __init__(__self__, *,
                 inputs: _builtins.str,
                 task: 'outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskResult',
                 concurrency: Optional[_builtins.int] = None):
        pulumi.set(__self__, "inputs", inputs)
        pulumi.set(__self__, "task", task)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> _builtins.str:
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def task(self) -> 'outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskResult':
        return pulumi.get(self, "task")

    @_builtins.property
    @pulumi.getter
    def concurrency(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "concurrency")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskResult(dict):
    def __init__(__self__, *,
                 retry_on_timeout: _builtins.bool,
                 task_key: _builtins.str,
                 condition_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskResult'] = None,
                 dashboard_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskResult'] = None,
                 dbt_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskResult'] = None,
                 depends_ons: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnResult']] = None,
                 description: Optional[_builtins.str] = None,
                 email_notifications: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsResult'] = None,
                 environment_key: Optional[_builtins.str] = None,
                 existing_cluster_id: Optional[_builtins.str] = None,
                 health: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskHealthResult'] = None,
                 job_cluster_key: Optional[_builtins.str] = None,
                 libraries: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryResult']] = None,
                 max_retries: Optional[_builtins.int] = None,
                 min_retry_interval_millis: Optional[_builtins.int] = None,
                 new_cluster: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterResult'] = None,
                 notebook_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskResult'] = None,
                 notification_settings: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsResult'] = None,
                 pipeline_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskResult'] = None,
                 power_bi_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskResult'] = None,
                 python_wheel_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskResult'] = None,
                 run_if: Optional[_builtins.str] = None,
                 run_job_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskResult'] = None,
                 spark_jar_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskResult'] = None,
                 spark_python_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskResult'] = None,
                 spark_submit_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskResult'] = None,
                 sql_task: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskResult'] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 webhook_notifications: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsResult'] = None):
        pulumi.set(__self__, "retry_on_timeout", retry_on_timeout)
        pulumi.set(__self__, "task_key", task_key)
        if condition_task is not None:
            pulumi.set(__self__, "condition_task", condition_task)
        if dashboard_task is not None:
            pulumi.set(__self__, "dashboard_task", dashboard_task)
        if dbt_task is not None:
            pulumi.set(__self__, "dbt_task", dbt_task)
        if depends_ons is not None:
            pulumi.set(__self__, "depends_ons", depends_ons)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if email_notifications is not None:
            pulumi.set(__self__, "email_notifications", email_notifications)
        if environment_key is not None:
            pulumi.set(__self__, "environment_key", environment_key)
        if existing_cluster_id is not None:
            pulumi.set(__self__, "existing_cluster_id", existing_cluster_id)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if job_cluster_key is not None:
            pulumi.set(__self__, "job_cluster_key", job_cluster_key)
        if libraries is not None:
            pulumi.set(__self__, "libraries", libraries)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if min_retry_interval_millis is not None:
            pulumi.set(__self__, "min_retry_interval_millis", min_retry_interval_millis)
        if new_cluster is not None:
            pulumi.set(__self__, "new_cluster", new_cluster)
        if notebook_task is not None:
            pulumi.set(__self__, "notebook_task", notebook_task)
        if notification_settings is not None:
            pulumi.set(__self__, "notification_settings", notification_settings)
        if pipeline_task is not None:
            pulumi.set(__self__, "pipeline_task", pipeline_task)
        if power_bi_task is not None:
            pulumi.set(__self__, "power_bi_task", power_bi_task)
        if python_wheel_task is not None:
            pulumi.set(__self__, "python_wheel_task", python_wheel_task)
        if run_if is not None:
            pulumi.set(__self__, "run_if", run_if)
        if run_job_task is not None:
            pulumi.set(__self__, "run_job_task", run_job_task)
        if spark_jar_task is not None:
            pulumi.set(__self__, "spark_jar_task", spark_jar_task)
        if spark_python_task is not None:
            pulumi.set(__self__, "spark_python_task", spark_python_task)
        if spark_submit_task is not None:
            pulumi.set(__self__, "spark_submit_task", spark_submit_task)
        if sql_task is not None:
            pulumi.set(__self__, "sql_task", sql_task)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if webhook_notifications is not None:
            pulumi.set(__self__, "webhook_notifications", webhook_notifications)

    @_builtins.property
    @pulumi.getter(name="retryOnTimeout")
    def retry_on_timeout(self) -> _builtins.bool:
        return pulumi.get(self, "retry_on_timeout")

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter(name="conditionTask")
    def condition_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskResult']:
        return pulumi.get(self, "condition_task")

    @_builtins.property
    @pulumi.getter(name="dashboardTask")
    def dashboard_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskResult']:
        return pulumi.get(self, "dashboard_task")

    @_builtins.property
    @pulumi.getter(name="dbtTask")
    def dbt_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskResult']:
        return pulumi.get(self, "dbt_task")

    @_builtins.property
    @pulumi.getter(name="dependsOns")
    def depends_ons(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnResult']]:
        return pulumi.get(self, "depends_ons")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="emailNotifications")
    def email_notifications(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsResult']:
        return pulumi.get(self, "email_notifications")

    @_builtins.property
    @pulumi.getter(name="environmentKey")
    def environment_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "environment_key")

    @_builtins.property
    @pulumi.getter(name="existingClusterId")
    def existing_cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "existing_cluster_id")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskHealthResult']:
        return pulumi.get(self, "health")

    @_builtins.property
    @pulumi.getter(name="jobClusterKey")
    def job_cluster_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "job_cluster_key")

    @_builtins.property
    @pulumi.getter
    def libraries(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryResult']]:
        return pulumi.get(self, "libraries")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="minRetryIntervalMillis")
    def min_retry_interval_millis(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_retry_interval_millis")

    @_builtins.property
    @pulumi.getter(name="newCluster")
    def new_cluster(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterResult']:
        return pulumi.get(self, "new_cluster")

    @_builtins.property
    @pulumi.getter(name="notebookTask")
    def notebook_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskResult']:
        return pulumi.get(self, "notebook_task")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsResult']:
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="pipelineTask")
    def pipeline_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskResult']:
        return pulumi.get(self, "pipeline_task")

    @_builtins.property
    @pulumi.getter(name="powerBiTask")
    def power_bi_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskResult']:
        return pulumi.get(self, "power_bi_task")

    @_builtins.property
    @pulumi.getter(name="pythonWheelTask")
    def python_wheel_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskResult']:
        return pulumi.get(self, "python_wheel_task")

    @_builtins.property
    @pulumi.getter(name="runIf")
    def run_if(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_if")

    @_builtins.property
    @pulumi.getter(name="runJobTask")
    def run_job_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskResult']:
        return pulumi.get(self, "run_job_task")

    @_builtins.property
    @pulumi.getter(name="sparkJarTask")
    def spark_jar_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskResult']:
        return pulumi.get(self, "spark_jar_task")

    @_builtins.property
    @pulumi.getter(name="sparkPythonTask")
    def spark_python_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskResult']:
        return pulumi.get(self, "spark_python_task")

    @_builtins.property
    @pulumi.getter(name="sparkSubmitTask")
    def spark_submit_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskResult']:
        return pulumi.get(self, "spark_submit_task")

    @_builtins.property
    @pulumi.getter(name="sqlTask")
    def sql_task(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskResult']:
        return pulumi.get(self, "sql_task")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="webhookNotifications")
    def webhook_notifications(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsResult']:
        return pulumi.get(self, "webhook_notifications")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskConditionTaskResult(dict):
    def __init__(__self__, *,
                 left: _builtins.str,
                 op: _builtins.str,
                 right: _builtins.str):
        pulumi.set(__self__, "left", left)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "right", right)

    @_builtins.property
    @pulumi.getter
    def left(self) -> _builtins.str:
        return pulumi.get(self, "left")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def right(self) -> _builtins.str:
        return pulumi.get(self, "right")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskResult(dict):
    def __init__(__self__, *,
                 dashboard_id: Optional[_builtins.str] = None,
                 subscription: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionResult'] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        if dashboard_id is not None:
            pulumi.set(__self__, "dashboard_id", dashboard_id)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionResult']:
        return pulumi.get(self, "subscription")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionResult(dict):
    def __init__(__self__, *,
                 custom_subject: Optional[_builtins.str] = None,
                 paused: Optional[_builtins.bool] = None,
                 subscribers: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionSubscriberResult']] = None):
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if subscribers is not None:
            pulumi.set(__self__, "subscribers", subscribers)

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def subscribers(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionSubscriberResult']]:
        return pulumi.get(self, "subscribers")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDashboardTaskSubscriptionSubscriberResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDbtTaskResult(dict):
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str],
                 catalog: Optional[_builtins.str] = None,
                 profiles_directory: Optional[_builtins.str] = None,
                 project_directory: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "commands", commands)
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if profiles_directory is not None:
            pulumi.set(__self__, "profiles_directory", profiles_directory)
        if project_directory is not None:
            pulumi.set(__self__, "project_directory", project_directory)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "commands")

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter(name="profilesDirectory")
    def profiles_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "profiles_directory")

    @_builtins.property
    @pulumi.getter(name="projectDirectory")
    def project_directory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "project_directory")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskDependsOnResult(dict):
    def __init__(__self__, *,
                 task_key: _builtins.str,
                 outcome: Optional[_builtins.str] = None):
        pulumi.set(__self__, "task_key", task_key)
        if outcome is not None:
            pulumi.set(__self__, "outcome", outcome)

    @_builtins.property
    @pulumi.getter(name="taskKey")
    def task_key(self) -> _builtins.str:
        return pulumi.get(self, "task_key")

    @_builtins.property
    @pulumi.getter
    def outcome(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "outcome")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskEmailNotificationsResult(dict):
    def __init__(__self__, *,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None,
                 on_duration_warning_threshold_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_failures: Optional[Sequence[_builtins.str]] = None,
                 on_starts: Optional[Sequence[_builtins.str]] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence[_builtins.str]] = None,
                 on_successes: Optional[Sequence[_builtins.str]] = None):
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskHealthResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskHealthRuleResult(dict):
    def __init__(__self__, *,
                 metric: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryResult(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranResult'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenResult'] = None,
                 provider_config: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryProviderConfigResult'] = None,
                 pypi: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiResult'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranResult']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenResult']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryProviderConfigResult']:
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiResult']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryCranResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryMavenResult(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskLibraryPypiResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterResult(dict):
    def __init__(__self__, *,
                 driver_instance_pool_id: _builtins.str,
                 driver_node_type_id: _builtins.str,
                 enable_elastic_disk: _builtins.bool,
                 enable_local_disk_encryption: _builtins.bool,
                 node_type_id: _builtins.str,
                 num_workers: _builtins.int,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleResult'] = None,
                 autotermination_minutes: Optional[_builtins.int] = None,
                 aws_attributes: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesResult'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfResult'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoResult']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageResult'] = None,
                 gcp_attributes: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesResult'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptResult']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 policy_id: Optional[_builtins.str] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 workload_type: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeResult'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> _builtins.bool:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> _builtins.bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> _builtins.int:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autotermination_minutes")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoResult']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeResult']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Result'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoResult(dict):
    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult(dict):
    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptResult(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssResult'] = None,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsResult'] = None,
                 file: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileResult'] = None,
                 gcs: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Result'] = None,
                 volumes: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesResult'] = None,
                 workspace: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceResult'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssResult']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsResult']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesResult']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceResult']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptAbfssResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptFileResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptGcsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterInitScriptWorkspaceResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 clients: 'outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsResult'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsResult':
        return pulumi.get(self, "clients")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNewClusterWorkloadTypeClientsResult(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNotebookTaskResult(dict):
    def __init__(__self__, *,
                 notebook_path: _builtins.str,
                 base_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> _builtins.str:
        return pulumi.get(self, "notebook_path")

    @_builtins.property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "base_parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[_builtins.bool] = None,
                 no_alert_for_canceled_runs: Optional[_builtins.bool] = None,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None):
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @_builtins.property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @_builtins.property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPipelineTaskResult(dict):
    def __init__(__self__, *,
                 pipeline_id: _builtins.str,
                 full_refresh: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskResult(dict):
    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 power_bi_model: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskPowerBiModelResult'] = None,
                 refresh_after_update: Optional[_builtins.bool] = None,
                 tables: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskTableResult']] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if power_bi_model is not None:
            pulumi.set(__self__, "power_bi_model", power_bi_model)
        if refresh_after_update is not None:
            pulumi.set(__self__, "refresh_after_update", refresh_after_update)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="powerBiModel")
    def power_bi_model(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskPowerBiModelResult']:
        return pulumi.get(self, "power_bi_model")

    @_builtins.property
    @pulumi.getter(name="refreshAfterUpdate")
    def refresh_after_update(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "refresh_after_update")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskTableResult']]:
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskPowerBiModelResult(dict):
    def __init__(__self__, *,
                 authentication_method: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 overwrite_existing: Optional[_builtins.bool] = None,
                 storage_mode: Optional[_builtins.str] = None,
                 workspace_name: Optional[_builtins.str] = None):
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if overwrite_existing is not None:
            pulumi.set(__self__, "overwrite_existing", overwrite_existing)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)
        if workspace_name is not None:
            pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "authentication_method")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="overwriteExisting")
    def overwrite_existing(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_existing")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_mode")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPowerBiTaskTableResult(dict):
    def __init__(__self__, *,
                 catalog: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 storage_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: the job name of Job if the resource was matched by id.
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_mode")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskPythonWheelTaskResult(dict):
    def __init__(__self__, *,
                 entry_point: Optional[_builtins.str] = None,
                 named_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 package_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "named_parameters")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskRunJobTaskResult(dict):
    def __init__(__self__, *,
                 job_id: _builtins.int,
                 job_parameters: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.int:
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "job_parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkJarTaskResult(dict):
    def __init__(__self__, *,
                 jar_uri: Optional[_builtins.str] = None,
                 main_class_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar_uri")

    @_builtins.property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "main_class_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkPythonTaskResult(dict):
    def __init__(__self__, *,
                 python_file: _builtins.str,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> _builtins.str:
        return pulumi.get(self, "python_file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSparkSubmitTaskResult(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskResult(dict):
    def __init__(__self__, *,
                 warehouse_id: _builtins.str,
                 alert: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertResult'] = None,
                 dashboard: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardResult'] = None,
                 file: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileResult'] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 query: Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryResult'] = None):
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> _builtins.str:
        return pulumi.get(self, "warehouse_id")

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertResult']:
        return pulumi.get(self, "alert")

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardResult']:
        return pulumi.get(self, "dashboard")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryResult']:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertResult(dict):
    def __init__(__self__, *,
                 alert_id: _builtins.str,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionResult']] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> _builtins.str:
        return pulumi.get(self, "alert_id")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionResult']]:
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskAlertSubscriptionResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardResult(dict):
    def __init__(__self__, *,
                 dashboard_id: _builtins.str,
                 custom_subject: Optional[_builtins.str] = None,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionResult']] = None):
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionResult']]:
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskDashboardSubscriptionResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskFileResult(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskSqlTaskQueryResult(dict):
    def __init__(__self__, *,
                 query_id: _builtins.str):
        pulumi.set(__self__, "query_id", query_id)

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        return pulumi.get(self, "query_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsResult(dict):
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededResult']] = None,
                 on_failures: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureResult']] = None,
                 on_starts: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartResult']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededResult']] = None,
                 on_successes: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessResult']] = None):
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededResult']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureResult']]:
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartResult']]:
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededResult']]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessResult']]:
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnDurationWarningThresholdExceededResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnFailureResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStartResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnStreamingBacklogExceededResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskForEachTaskTaskWebhookNotificationsOnSuccessResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskHealthResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetJobJobSettingsSettingsTaskHealthRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetJobJobSettingsSettingsTaskHealthRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskHealthRuleResult(dict):
    def __init__(__self__, *,
                 metric: _builtins.str,
                 op: _builtins.str,
                 value: _builtins.int):
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        return pulumi.get(self, "metric")

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskLibraryResult(dict):
    def __init__(__self__, *,
                 cran: Optional['outputs.GetJobJobSettingsSettingsTaskLibraryCranResult'] = None,
                 egg: Optional[_builtins.str] = None,
                 jar: Optional[_builtins.str] = None,
                 maven: Optional['outputs.GetJobJobSettingsSettingsTaskLibraryMavenResult'] = None,
                 provider_config: Optional['outputs.GetJobJobSettingsSettingsTaskLibraryProviderConfigResult'] = None,
                 pypi: Optional['outputs.GetJobJobSettingsSettingsTaskLibraryPypiResult'] = None,
                 requirements: Optional[_builtins.str] = None,
                 whl: Optional[_builtins.str] = None):
        if cran is not None:
            pulumi.set(__self__, "cran", cran)
        if egg is not None:
            pulumi.set(__self__, "egg", egg)
        if jar is not None:
            pulumi.set(__self__, "jar", jar)
        if maven is not None:
            pulumi.set(__self__, "maven", maven)
        if provider_config is not None:
            pulumi.set(__self__, "provider_config", provider_config)
        if pypi is not None:
            pulumi.set(__self__, "pypi", pypi)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)
        if whl is not None:
            pulumi.set(__self__, "whl", whl)

    @_builtins.property
    @pulumi.getter
    def cran(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskLibraryCranResult']:
        return pulumi.get(self, "cran")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The `egg` library type is deprecated. Please use `whl` or `pypi` instead.""")
    def egg(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "egg")

    @_builtins.property
    @pulumi.getter
    def jar(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar")

    @_builtins.property
    @pulumi.getter
    def maven(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskLibraryMavenResult']:
        return pulumi.get(self, "maven")

    @_builtins.property
    @pulumi.getter(name="providerConfig")
    def provider_config(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskLibraryProviderConfigResult']:
        return pulumi.get(self, "provider_config")

    @_builtins.property
    @pulumi.getter
    def pypi(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskLibraryPypiResult']:
        return pulumi.get(self, "pypi")

    @_builtins.property
    @pulumi.getter
    def requirements(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requirements")

    @_builtins.property
    @pulumi.getter
    def whl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "whl")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskLibraryCranResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskLibraryMavenResult(dict):
    def __init__(__self__, *,
                 coordinates: _builtins.str,
                 exclusions: Optional[Sequence[_builtins.str]] = None,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "coordinates", coordinates)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def coordinates(self) -> _builtins.str:
        return pulumi.get(self, "coordinates")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskLibraryProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskLibraryPypiResult(dict):
    def __init__(__self__, *,
                 package: _builtins.str,
                 repo: Optional[_builtins.str] = None):
        pulumi.set(__self__, "package", package)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def package(self) -> _builtins.str:
        return pulumi.get(self, "package")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterResult(dict):
    def __init__(__self__, *,
                 driver_instance_pool_id: _builtins.str,
                 driver_node_type_id: _builtins.str,
                 enable_elastic_disk: _builtins.bool,
                 enable_local_disk_encryption: _builtins.bool,
                 node_type_id: _builtins.str,
                 num_workers: _builtins.int,
                 apply_policy_default_values: Optional[_builtins.bool] = None,
                 autoscale: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterAutoscaleResult'] = None,
                 autotermination_minutes: Optional[_builtins.int] = None,
                 aws_attributes: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterAwsAttributesResult'] = None,
                 azure_attributes: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterAzureAttributesResult'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_log_conf: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterLogConfResult'] = None,
                 cluster_mount_infos: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoResult']] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None,
                 data_security_mode: Optional[_builtins.str] = None,
                 docker_image: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterDockerImageResult'] = None,
                 gcp_attributes: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterGcpAttributesResult'] = None,
                 idempotency_token: Optional[_builtins.str] = None,
                 init_scripts: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptResult']] = None,
                 instance_pool_id: Optional[_builtins.str] = None,
                 policy_id: Optional[_builtins.str] = None,
                 runtime_engine: Optional[_builtins.str] = None,
                 single_user_name: Optional[_builtins.str] = None,
                 spark_conf: Optional[Mapping[str, _builtins.str]] = None,
                 spark_env_vars: Optional[Mapping[str, _builtins.str]] = None,
                 spark_version: Optional[_builtins.str] = None,
                 ssh_public_keys: Optional[Sequence[_builtins.str]] = None,
                 workload_type: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeResult'] = None):
        pulumi.set(__self__, "driver_instance_pool_id", driver_instance_pool_id)
        pulumi.set(__self__, "driver_node_type_id", driver_node_type_id)
        pulumi.set(__self__, "enable_elastic_disk", enable_elastic_disk)
        pulumi.set(__self__, "enable_local_disk_encryption", enable_local_disk_encryption)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "num_workers", num_workers)
        if apply_policy_default_values is not None:
            pulumi.set(__self__, "apply_policy_default_values", apply_policy_default_values)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if autotermination_minutes is not None:
            pulumi.set(__self__, "autotermination_minutes", autotermination_minutes)
        if aws_attributes is not None:
            pulumi.set(__self__, "aws_attributes", aws_attributes)
        if azure_attributes is not None:
            pulumi.set(__self__, "azure_attributes", azure_attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_log_conf is not None:
            pulumi.set(__self__, "cluster_log_conf", cluster_log_conf)
        if cluster_mount_infos is not None:
            pulumi.set(__self__, "cluster_mount_infos", cluster_mount_infos)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if data_security_mode is not None:
            pulumi.set(__self__, "data_security_mode", data_security_mode)
        if docker_image is not None:
            pulumi.set(__self__, "docker_image", docker_image)
        if gcp_attributes is not None:
            pulumi.set(__self__, "gcp_attributes", gcp_attributes)
        if idempotency_token is not None:
            pulumi.set(__self__, "idempotency_token", idempotency_token)
        if init_scripts is not None:
            pulumi.set(__self__, "init_scripts", init_scripts)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if runtime_engine is not None:
            pulumi.set(__self__, "runtime_engine", runtime_engine)
        if single_user_name is not None:
            pulumi.set(__self__, "single_user_name", single_user_name)
        if spark_conf is not None:
            pulumi.set(__self__, "spark_conf", spark_conf)
        if spark_env_vars is not None:
            pulumi.set(__self__, "spark_env_vars", spark_env_vars)
        if spark_version is not None:
            pulumi.set(__self__, "spark_version", spark_version)
        if ssh_public_keys is not None:
            pulumi.set(__self__, "ssh_public_keys", ssh_public_keys)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @_builtins.property
    @pulumi.getter(name="driverInstancePoolId")
    def driver_instance_pool_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="driverNodeTypeId")
    def driver_node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "driver_node_type_id")

    @_builtins.property
    @pulumi.getter(name="enableElasticDisk")
    def enable_elastic_disk(self) -> _builtins.bool:
        return pulumi.get(self, "enable_elastic_disk")

    @_builtins.property
    @pulumi.getter(name="enableLocalDiskEncryption")
    def enable_local_disk_encryption(self) -> _builtins.bool:
        return pulumi.get(self, "enable_local_disk_encryption")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> _builtins.int:
        return pulumi.get(self, "num_workers")

    @_builtins.property
    @pulumi.getter(name="applyPolicyDefaultValues")
    def apply_policy_default_values(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "apply_policy_default_values")

    @_builtins.property
    @pulumi.getter
    def autoscale(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterAutoscaleResult']:
        return pulumi.get(self, "autoscale")

    @_builtins.property
    @pulumi.getter(name="autoterminationMinutes")
    def autotermination_minutes(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autotermination_minutes")

    @_builtins.property
    @pulumi.getter(name="awsAttributes")
    def aws_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterAwsAttributesResult']:
        return pulumi.get(self, "aws_attributes")

    @_builtins.property
    @pulumi.getter(name="azureAttributes")
    def azure_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterAzureAttributesResult']:
        return pulumi.get(self, "azure_attributes")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterLogConf")
    def cluster_log_conf(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterLogConfResult']:
        return pulumi.get(self, "cluster_log_conf")

    @_builtins.property
    @pulumi.getter(name="clusterMountInfos")
    def cluster_mount_infos(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoResult']]:
        return pulumi.get(self, "cluster_mount_infos")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_tags")

    @_builtins.property
    @pulumi.getter(name="dataSecurityMode")
    def data_security_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_security_mode")

    @_builtins.property
    @pulumi.getter(name="dockerImage")
    def docker_image(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterDockerImageResult']:
        return pulumi.get(self, "docker_image")

    @_builtins.property
    @pulumi.getter(name="gcpAttributes")
    def gcp_attributes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterGcpAttributesResult']:
        return pulumi.get(self, "gcp_attributes")

    @_builtins.property
    @pulumi.getter(name="idempotencyToken")
    def idempotency_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "idempotency_token")

    @_builtins.property
    @pulumi.getter(name="initScripts")
    def init_scripts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptResult']]:
        return pulumi.get(self, "init_scripts")

    @_builtins.property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_pool_id")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="runtimeEngine")
    def runtime_engine(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "runtime_engine")

    @_builtins.property
    @pulumi.getter(name="singleUserName")
    def single_user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "single_user_name")

    @_builtins.property
    @pulumi.getter(name="sparkConf")
    def spark_conf(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_conf")

    @_builtins.property
    @pulumi.getter(name="sparkEnvVars")
    def spark_env_vars(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "spark_env_vars")

    @_builtins.property
    @pulumi.getter(name="sparkVersion")
    def spark_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "spark_version")

    @_builtins.property
    @pulumi.getter(name="sshPublicKeys")
    def ssh_public_keys(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ssh_public_keys")

    @_builtins.property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeResult']:
        return pulumi.get(self, "workload_type")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterAutoscaleResult(dict):
    def __init__(__self__, *,
                 max_workers: Optional[_builtins.int] = None,
                 min_workers: Optional[_builtins.int] = None):
        if max_workers is not None:
            pulumi.set(__self__, "max_workers", max_workers)
        if min_workers is not None:
            pulumi.set(__self__, "min_workers", min_workers)

    @_builtins.property
    @pulumi.getter(name="maxWorkers")
    def max_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_workers")

    @_builtins.property
    @pulumi.getter(name="minWorkers")
    def min_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_workers")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterAwsAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 ebs_volume_count: Optional[_builtins.int] = None,
                 ebs_volume_size: Optional[_builtins.int] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 instance_profile_arn: Optional[_builtins.str] = None,
                 spot_bid_price_percent: Optional[_builtins.int] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if ebs_volume_count is not None:
            pulumi.set(__self__, "ebs_volume_count", ebs_volume_count)
        if ebs_volume_size is not None:
            pulumi.set(__self__, "ebs_volume_size", ebs_volume_size)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)
        if spot_bid_price_percent is not None:
            pulumi.set(__self__, "spot_bid_price_percent", spot_bid_price_percent)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeCount")
    def ebs_volume_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_count")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeSize")
    def ebs_volume_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "ebs_volume_size")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")

    @_builtins.property
    @pulumi.getter(name="spotBidPricePercent")
    def spot_bid_price_percent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "spot_bid_price_percent")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterAzureAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 first_on_demand: Optional[_builtins.int] = None,
                 spot_bid_max_price: Optional[_builtins.float] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if first_on_demand is not None:
            pulumi.set(__self__, "first_on_demand", first_on_demand)
        if spot_bid_max_price is not None:
            pulumi.set(__self__, "spot_bid_max_price", spot_bid_max_price)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="firstOnDemand")
    def first_on_demand(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "first_on_demand")

    @_builtins.property
    @pulumi.getter(name="spotBidMaxPrice")
    def spot_bid_max_price(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "spot_bid_max_price")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfResult(dict):
    def __init__(__self__, *,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Result'] = None):
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Result']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterClusterLogConfS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoResult(dict):
    def __init__(__self__, *,
                 local_mount_dir_path: _builtins.str,
                 network_filesystem_info: 'outputs.GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult',
                 remote_mount_dir_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "local_mount_dir_path", local_mount_dir_path)
        pulumi.set(__self__, "network_filesystem_info", network_filesystem_info)
        if remote_mount_dir_path is not None:
            pulumi.set(__self__, "remote_mount_dir_path", remote_mount_dir_path)

    @_builtins.property
    @pulumi.getter(name="localMountDirPath")
    def local_mount_dir_path(self) -> _builtins.str:
        return pulumi.get(self, "local_mount_dir_path")

    @_builtins.property
    @pulumi.getter(name="networkFilesystemInfo")
    def network_filesystem_info(self) -> 'outputs.GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult':
        return pulumi.get(self, "network_filesystem_info")

    @_builtins.property
    @pulumi.getter(name="remoteMountDirPath")
    def remote_mount_dir_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "remote_mount_dir_path")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterClusterMountInfoNetworkFilesystemInfoResult(dict):
    def __init__(__self__, *,
                 server_address: _builtins.str,
                 mount_options: Optional[_builtins.str] = None):
        pulumi.set(__self__, "server_address", server_address)
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)

    @_builtins.property
    @pulumi.getter(name="serverAddress")
    def server_address(self) -> _builtins.str:
        return pulumi.get(self, "server_address")

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mount_options")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterDockerImageResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 basic_auth: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthResult'] = None):
        pulumi.set(__self__, "url", url)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthResult']:
        return pulumi.get(self, "basic_auth")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterDockerImageBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterGcpAttributesResult(dict):
    def __init__(__self__, *,
                 availability: Optional[_builtins.str] = None,
                 boot_disk_size: Optional[_builtins.int] = None,
                 google_service_account: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 use_preemptible_executors: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if google_service_account is not None:
            pulumi.set(__self__, "google_service_account", google_service_account)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if use_preemptible_executors is not None:
            pulumi.set(__self__, "use_preemptible_executors", use_preemptible_executors)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @_builtins.property
    @pulumi.getter(name="googleServiceAccount")
    def google_service_account(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "google_service_account")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="usePreemptibleExecutors")
    def use_preemptible_executors(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_preemptible_executors")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptResult(dict):
    def __init__(__self__, *,
                 abfss: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssResult'] = None,
                 dbfs: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsResult'] = None,
                 file: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptFileResult'] = None,
                 gcs: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsResult'] = None,
                 s3: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Result'] = None,
                 volumes: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesResult'] = None,
                 workspace: Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceResult'] = None):
        if abfss is not None:
            pulumi.set(__self__, "abfss", abfss)
        if dbfs is not None:
            pulumi.set(__self__, "dbfs", dbfs)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if gcs is not None:
            pulumi.set(__self__, "gcs", gcs)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if workspace is not None:
            pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def abfss(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssResult']:
        return pulumi.get(self, "abfss")

    @_builtins.property
    @pulumi.getter
    def dbfs(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsResult']:
        return pulumi.get(self, "dbfs")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def gcs(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsResult']:
        return pulumi.get(self, "gcs")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Result']:
        return pulumi.get(self, "s3")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesResult']:
        return pulumi.get(self, "volumes")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceResult']:
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptAbfssResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptDbfsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptFileResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptGcsResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptS3Result(dict):
    def __init__(__self__, *,
                 destination: _builtins.str,
                 canned_acl: Optional[_builtins.str] = None,
                 enable_encryption: Optional[_builtins.bool] = None,
                 encryption_type: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        pulumi.set(__self__, "destination", destination)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if enable_encryption is not None:
            pulumi.set(__self__, "enable_encryption", enable_encryption)
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "canned_acl")

    @_builtins.property
    @pulumi.getter(name="enableEncryption")
    def enable_encryption(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enable_encryption")

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "encryption_type")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptVolumesResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterInitScriptWorkspaceResult(dict):
    def __init__(__self__, *,
                 destination: _builtins.str):
        pulumi.set(__self__, "destination", destination)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        return pulumi.get(self, "destination")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeResult(dict):
    def __init__(__self__, *,
                 clients: 'outputs.GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsResult'):
        pulumi.set(__self__, "clients", clients)

    @_builtins.property
    @pulumi.getter
    def clients(self) -> 'outputs.GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsResult':
        return pulumi.get(self, "clients")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNewClusterWorkloadTypeClientsResult(dict):
    def __init__(__self__, *,
                 jobs: Optional[_builtins.bool] = None,
                 notebooks: Optional[_builtins.bool] = None):
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if notebooks is not None:
            pulumi.set(__self__, "notebooks", notebooks)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def notebooks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "notebooks")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNotebookTaskResult(dict):
    def __init__(__self__, *,
                 notebook_path: _builtins.str,
                 base_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 source: Optional[_builtins.str] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "notebook_path", notebook_path)
        if base_parameters is not None:
            pulumi.set(__self__, "base_parameters", base_parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="notebookPath")
    def notebook_path(self) -> _builtins.str:
        return pulumi.get(self, "notebook_path")

    @_builtins.property
    @pulumi.getter(name="baseParameters")
    def base_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "base_parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskNotificationSettingsResult(dict):
    def __init__(__self__, *,
                 alert_on_last_attempt: Optional[_builtins.bool] = None,
                 no_alert_for_canceled_runs: Optional[_builtins.bool] = None,
                 no_alert_for_skipped_runs: Optional[_builtins.bool] = None):
        if alert_on_last_attempt is not None:
            pulumi.set(__self__, "alert_on_last_attempt", alert_on_last_attempt)
        if no_alert_for_canceled_runs is not None:
            pulumi.set(__self__, "no_alert_for_canceled_runs", no_alert_for_canceled_runs)
        if no_alert_for_skipped_runs is not None:
            pulumi.set(__self__, "no_alert_for_skipped_runs", no_alert_for_skipped_runs)

    @_builtins.property
    @pulumi.getter(name="alertOnLastAttempt")
    def alert_on_last_attempt(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "alert_on_last_attempt")

    @_builtins.property
    @pulumi.getter(name="noAlertForCanceledRuns")
    def no_alert_for_canceled_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_canceled_runs")

    @_builtins.property
    @pulumi.getter(name="noAlertForSkippedRuns")
    def no_alert_for_skipped_runs(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "no_alert_for_skipped_runs")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskPipelineTaskResult(dict):
    def __init__(__self__, *,
                 pipeline_id: _builtins.str,
                 full_refresh: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        if full_refresh is not None:
            pulumi.set(__self__, "full_refresh", full_refresh)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> _builtins.str:
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="fullRefresh")
    def full_refresh(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "full_refresh")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskPowerBiTaskResult(dict):
    def __init__(__self__, *,
                 connection_resource_name: Optional[_builtins.str] = None,
                 power_bi_model: Optional['outputs.GetJobJobSettingsSettingsTaskPowerBiTaskPowerBiModelResult'] = None,
                 refresh_after_update: Optional[_builtins.bool] = None,
                 tables: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskPowerBiTaskTableResult']] = None,
                 warehouse_id: Optional[_builtins.str] = None):
        if connection_resource_name is not None:
            pulumi.set(__self__, "connection_resource_name", connection_resource_name)
        if power_bi_model is not None:
            pulumi.set(__self__, "power_bi_model", power_bi_model)
        if refresh_after_update is not None:
            pulumi.set(__self__, "refresh_after_update", refresh_after_update)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if warehouse_id is not None:
            pulumi.set(__self__, "warehouse_id", warehouse_id)

    @_builtins.property
    @pulumi.getter(name="connectionResourceName")
    def connection_resource_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_resource_name")

    @_builtins.property
    @pulumi.getter(name="powerBiModel")
    def power_bi_model(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskPowerBiTaskPowerBiModelResult']:
        return pulumi.get(self, "power_bi_model")

    @_builtins.property
    @pulumi.getter(name="refreshAfterUpdate")
    def refresh_after_update(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "refresh_after_update")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskPowerBiTaskTableResult']]:
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "warehouse_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskPowerBiTaskPowerBiModelResult(dict):
    def __init__(__self__, *,
                 authentication_method: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 overwrite_existing: Optional[_builtins.bool] = None,
                 storage_mode: Optional[_builtins.str] = None,
                 workspace_name: Optional[_builtins.str] = None):
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if overwrite_existing is not None:
            pulumi.set(__self__, "overwrite_existing", overwrite_existing)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)
        if workspace_name is not None:
            pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "authentication_method")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="overwriteExisting")
    def overwrite_existing(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "overwrite_existing")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_mode")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskPowerBiTaskTableResult(dict):
    def __init__(__self__, *,
                 catalog: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 storage_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: the job name of Job if the resource was matched by id.
        """
        if catalog is not None:
            pulumi.set(__self__, "catalog", catalog)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if storage_mode is not None:
            pulumi.set(__self__, "storage_mode", storage_mode)

    @_builtins.property
    @pulumi.getter
    def catalog(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        the job name of Job if the resource was matched by id.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="storageMode")
    def storage_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_mode")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskPythonWheelTaskResult(dict):
    def __init__(__self__, *,
                 entry_point: Optional[_builtins.str] = None,
                 named_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 package_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if entry_point is not None:
            pulumi.set(__self__, "entry_point", entry_point)
        if named_parameters is not None:
            pulumi.set(__self__, "named_parameters", named_parameters)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="entryPoint")
    def entry_point(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "entry_point")

    @_builtins.property
    @pulumi.getter(name="namedParameters")
    def named_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "named_parameters")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskRunJobTaskResult(dict):
    def __init__(__self__, *,
                 job_id: _builtins.int,
                 job_parameters: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "job_id", job_id)
        if job_parameters is not None:
            pulumi.set(__self__, "job_parameters", job_parameters)

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.int:
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="jobParameters")
    def job_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "job_parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSparkJarTaskResult(dict):
    def __init__(__self__, *,
                 jar_uri: Optional[_builtins.str] = None,
                 main_class_name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if jar_uri is not None:
            pulumi.set(__self__, "jar_uri", jar_uri)
        if main_class_name is not None:
            pulumi.set(__self__, "main_class_name", main_class_name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="jarUri")
    def jar_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "jar_uri")

    @_builtins.property
    @pulumi.getter(name="mainClassName")
    def main_class_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "main_class_name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSparkPythonTaskResult(dict):
    def __init__(__self__, *,
                 python_file: _builtins.str,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "python_file", python_file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="pythonFile")
    def python_file(self) -> _builtins.str:
        return pulumi.get(self, "python_file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSparkSubmitTaskResult(dict):
    def __init__(__self__, *,
                 parameters: Optional[Sequence[_builtins.str]] = None):
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskResult(dict):
    def __init__(__self__, *,
                 warehouse_id: _builtins.str,
                 alert: Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskAlertResult'] = None,
                 dashboard: Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskDashboardResult'] = None,
                 file: Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskFileResult'] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 query: Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskQueryResult'] = None):
        pulumi.set(__self__, "warehouse_id", warehouse_id)
        if alert is not None:
            pulumi.set(__self__, "alert", alert)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter(name="warehouseId")
    def warehouse_id(self) -> _builtins.str:
        return pulumi.get(self, "warehouse_id")

    @_builtins.property
    @pulumi.getter
    def alert(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskAlertResult']:
        return pulumi.get(self, "alert")

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskDashboardResult']:
        return pulumi.get(self, "dashboard")

    @_builtins.property
    @pulumi.getter
    def file(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskFileResult']:
        return pulumi.get(self, "file")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional['outputs.GetJobJobSettingsSettingsTaskSqlTaskQueryResult']:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskAlertResult(dict):
    def __init__(__self__, *,
                 alert_id: _builtins.str,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionResult']] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> _builtins.str:
        return pulumi.get(self, "alert_id")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionResult']]:
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskAlertSubscriptionResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskDashboardResult(dict):
    def __init__(__self__, *,
                 dashboard_id: _builtins.str,
                 custom_subject: Optional[_builtins.str] = None,
                 pause_subscriptions: Optional[_builtins.bool] = None,
                 subscriptions: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionResult']] = None):
        pulumi.set(__self__, "dashboard_id", dashboard_id)
        if custom_subject is not None:
            pulumi.set(__self__, "custom_subject", custom_subject)
        if pause_subscriptions is not None:
            pulumi.set(__self__, "pause_subscriptions", pause_subscriptions)
        if subscriptions is not None:
            pulumi.set(__self__, "subscriptions", subscriptions)

    @_builtins.property
    @pulumi.getter(name="dashboardId")
    def dashboard_id(self) -> _builtins.str:
        return pulumi.get(self, "dashboard_id")

    @_builtins.property
    @pulumi.getter(name="customSubject")
    def custom_subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_subject")

    @_builtins.property
    @pulumi.getter(name="pauseSubscriptions")
    def pause_subscriptions(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "pause_subscriptions")

    @_builtins.property
    @pulumi.getter
    def subscriptions(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionResult']]:
        return pulumi.get(self, "subscriptions")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskDashboardSubscriptionResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 user_name: Optional[_builtins.str] = None):
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskFileResult(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 source: Optional[_builtins.str] = None):
        pulumi.set(__self__, "path", path)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskSqlTaskQueryResult(dict):
    def __init__(__self__, *,
                 query_id: _builtins.str):
        pulumi.set(__self__, "query_id", query_id)

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        return pulumi.get(self, "query_id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsResult(dict):
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededResult']] = None,
                 on_failures: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureResult']] = None,
                 on_starts: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartResult']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededResult']] = None,
                 on_successes: Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessResult']] = None):
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededResult']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureResult']]:
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartResult']]:
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededResult']]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessResult']]:
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnDurationWarningThresholdExceededResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnFailureResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnStartResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnStreamingBacklogExceededResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTaskWebhookNotificationsOnSuccessResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsTriggerResult(dict):
    def __init__(__self__, *,
                 file_arrival: Optional['outputs.GetJobJobSettingsSettingsTriggerFileArrivalResult'] = None,
                 pause_status: Optional[_builtins.str] = None,
                 periodic: Optional['outputs.GetJobJobSettingsSettingsTriggerPeriodicResult'] = None,
                 table_update: Optional['outputs.GetJobJobSettingsSettingsTriggerTableUpdateResult'] = None):
        if file_arrival is not None:
            pulumi.set(__self__, "file_arrival", file_arrival)
        if pause_status is not None:
            pulumi.set(__self__, "pause_status", pause_status)
        if periodic is not None:
            pulumi.set(__self__, "periodic", periodic)
        if table_update is not None:
            pulumi.set(__self__, "table_update", table_update)

    @_builtins.property
    @pulumi.getter(name="fileArrival")
    def file_arrival(self) -> Optional['outputs.GetJobJobSettingsSettingsTriggerFileArrivalResult']:
        return pulumi.get(self, "file_arrival")

    @_builtins.property
    @pulumi.getter(name="pauseStatus")
    def pause_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pause_status")

    @_builtins.property
    @pulumi.getter
    def periodic(self) -> Optional['outputs.GetJobJobSettingsSettingsTriggerPeriodicResult']:
        return pulumi.get(self, "periodic")

    @_builtins.property
    @pulumi.getter(name="tableUpdate")
    def table_update(self) -> Optional['outputs.GetJobJobSettingsSettingsTriggerTableUpdateResult']:
        return pulumi.get(self, "table_update")


@pulumi.output_type
class GetJobJobSettingsSettingsTriggerFileArrivalResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 min_time_between_triggers_seconds: Optional[_builtins.int] = None,
                 wait_after_last_change_seconds: Optional[_builtins.int] = None):
        pulumi.set(__self__, "url", url)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @_builtins.property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "wait_after_last_change_seconds")


@pulumi.output_type
class GetJobJobSettingsSettingsTriggerPeriodicResult(dict):
    def __init__(__self__, *,
                 interval: _builtins.int,
                 unit: _builtins.str):
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.int:
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def unit(self) -> _builtins.str:
        return pulumi.get(self, "unit")


@pulumi.output_type
class GetJobJobSettingsSettingsTriggerTableUpdateResult(dict):
    def __init__(__self__, *,
                 table_names: Sequence[_builtins.str],
                 condition: Optional[_builtins.str] = None,
                 min_time_between_triggers_seconds: Optional[_builtins.int] = None,
                 wait_after_last_change_seconds: Optional[_builtins.int] = None):
        pulumi.set(__self__, "table_names", table_names)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if min_time_between_triggers_seconds is not None:
            pulumi.set(__self__, "min_time_between_triggers_seconds", min_time_between_triggers_seconds)
        if wait_after_last_change_seconds is not None:
            pulumi.set(__self__, "wait_after_last_change_seconds", wait_after_last_change_seconds)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "table_names")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter(name="minTimeBetweenTriggersSeconds")
    def min_time_between_triggers_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_time_between_triggers_seconds")

    @_builtins.property
    @pulumi.getter(name="waitAfterLastChangeSeconds")
    def wait_after_last_change_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "wait_after_last_change_seconds")


@pulumi.output_type
class GetJobJobSettingsSettingsWebhookNotificationsResult(dict):
    def __init__(__self__, *,
                 on_duration_warning_threshold_exceededs: Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededResult']] = None,
                 on_failures: Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnFailureResult']] = None,
                 on_starts: Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnStartResult']] = None,
                 on_streaming_backlog_exceededs: Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededResult']] = None,
                 on_successes: Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnSuccessResult']] = None):
        if on_duration_warning_threshold_exceededs is not None:
            pulumi.set(__self__, "on_duration_warning_threshold_exceededs", on_duration_warning_threshold_exceededs)
        if on_failures is not None:
            pulumi.set(__self__, "on_failures", on_failures)
        if on_starts is not None:
            pulumi.set(__self__, "on_starts", on_starts)
        if on_streaming_backlog_exceededs is not None:
            pulumi.set(__self__, "on_streaming_backlog_exceededs", on_streaming_backlog_exceededs)
        if on_successes is not None:
            pulumi.set(__self__, "on_successes", on_successes)

    @_builtins.property
    @pulumi.getter(name="onDurationWarningThresholdExceededs")
    def on_duration_warning_threshold_exceededs(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededResult']]:
        return pulumi.get(self, "on_duration_warning_threshold_exceededs")

    @_builtins.property
    @pulumi.getter(name="onFailures")
    def on_failures(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnFailureResult']]:
        return pulumi.get(self, "on_failures")

    @_builtins.property
    @pulumi.getter(name="onStarts")
    def on_starts(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnStartResult']]:
        return pulumi.get(self, "on_starts")

    @_builtins.property
    @pulumi.getter(name="onStreamingBacklogExceededs")
    def on_streaming_backlog_exceededs(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededResult']]:
        return pulumi.get(self, "on_streaming_backlog_exceededs")

    @_builtins.property
    @pulumi.getter(name="onSuccesses")
    def on_successes(self) -> Optional[Sequence['outputs.GetJobJobSettingsSettingsWebhookNotificationsOnSuccessResult']]:
        return pulumi.get(self, "on_successes")


@pulumi.output_type
class GetJobJobSettingsSettingsWebhookNotificationsOnDurationWarningThresholdExceededResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsWebhookNotificationsOnFailureResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsWebhookNotificationsOnStartResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsWebhookNotificationsOnStreamingBacklogExceededResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobJobSettingsSettingsWebhookNotificationsOnSuccessResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: the id of Job if the resource was matched by name.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        the id of Job if the resource was matched by name.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetJobsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetMaterializedFeaturesFeatureTagsFeatureTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: (string)
        :param _builtins.str value: (string)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMetastoreMetastoreInfoResult(dict):
    def __init__(__self__, *,
                 cloud: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 default_data_access_config_id: Optional[_builtins.str] = None,
                 delta_sharing_organization_name: Optional[_builtins.str] = None,
                 delta_sharing_recipient_token_lifetime_in_seconds: Optional[_builtins.int] = None,
                 delta_sharing_scope: Optional[_builtins.str] = None,
                 external_access_enabled: Optional[_builtins.bool] = None,
                 global_metastore_id: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 privilege_model_version: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 storage_root: Optional[_builtins.str] = None,
                 storage_root_credential_id: Optional[_builtins.str] = None,
                 storage_root_credential_name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str delta_sharing_organization_name: The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        :param _builtins.int delta_sharing_recipient_token_lifetime_in_seconds: Used to set expiration duration in seconds on recipient data access tokens.
        :param _builtins.str delta_sharing_scope: Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        :param _builtins.str metastore_id: ID of the metastore
        :param _builtins.str name: Name of the metastore
        :param _builtins.str owner: Username/groupname/sp application_id of the metastore owner.
        :param _builtins.str region: Region of the metastore
        :param _builtins.str storage_root: Path on cloud storage account, where managed `Table` are stored.
        """
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if default_data_access_config_id is not None:
            pulumi.set(__self__, "default_data_access_config_id", default_data_access_config_id)
        if delta_sharing_organization_name is not None:
            pulumi.set(__self__, "delta_sharing_organization_name", delta_sharing_organization_name)
        if delta_sharing_recipient_token_lifetime_in_seconds is not None:
            pulumi.set(__self__, "delta_sharing_recipient_token_lifetime_in_seconds", delta_sharing_recipient_token_lifetime_in_seconds)
        if delta_sharing_scope is not None:
            pulumi.set(__self__, "delta_sharing_scope", delta_sharing_scope)
        if external_access_enabled is not None:
            pulumi.set(__self__, "external_access_enabled", external_access_enabled)
        if global_metastore_id is not None:
            pulumi.set(__self__, "global_metastore_id", global_metastore_id)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if privilege_model_version is not None:
            pulumi.set(__self__, "privilege_model_version", privilege_model_version)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if storage_root_credential_id is not None:
            pulumi.set(__self__, "storage_root_credential_id", storage_root_credential_id)
        if storage_root_credential_name is not None:
            pulumi.set(__self__, "storage_root_credential_name", storage_root_credential_name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="defaultDataAccessConfigId")
    def default_data_access_config_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_data_access_config_id")

    @_builtins.property
    @pulumi.getter(name="deltaSharingOrganizationName")
    def delta_sharing_organization_name(self) -> Optional[_builtins.str]:
        """
        The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing.
        """
        return pulumi.get(self, "delta_sharing_organization_name")

    @_builtins.property
    @pulumi.getter(name="deltaSharingRecipientTokenLifetimeInSeconds")
    def delta_sharing_recipient_token_lifetime_in_seconds(self) -> Optional[_builtins.int]:
        """
        Used to set expiration duration in seconds on recipient data access tokens.
        """
        return pulumi.get(self, "delta_sharing_recipient_token_lifetime_in_seconds")

    @_builtins.property
    @pulumi.getter(name="deltaSharingScope")
    def delta_sharing_scope(self) -> Optional[_builtins.str]:
        """
        Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL. INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
        """
        return pulumi.get(self, "delta_sharing_scope")

    @_builtins.property
    @pulumi.getter(name="externalAccessEnabled")
    def external_access_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "external_access_enabled")

    @_builtins.property
    @pulumi.getter(name="globalMetastoreId")
    def global_metastore_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "global_metastore_id")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        ID of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the metastore
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Username/groupname/sp application_id of the metastore owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="privilegeModelVersion")
    def privilege_model_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "privilege_model_version")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the metastore
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[_builtins.str]:
        """
        Path on cloud storage account, where managed `Table` are stored.
        """
        return pulumi.get(self, "storage_root")

    @_builtins.property
    @pulumi.getter(name="storageRootCredentialId")
    def storage_root_credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_root_credential_id")

    @_builtins.property
    @pulumi.getter(name="storageRootCredentialName")
    def storage_root_credential_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_root_credential_name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class GetMlflowExperimentProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetMlflowExperimentTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMlflowModelLatestVersionResult(dict):
    def __init__(__self__, *,
                 creation_timestamp: Optional[_builtins.int] = None,
                 current_stage: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 last_updated_timestamp: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 run_id: Optional[_builtins.str] = None,
                 run_link: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 status_message: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.GetMlflowModelLatestVersionTagResult']] = None,
                 user_id: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: User-specified description for the object.
        :param _builtins.str name: Name of the registered model.
        :param Sequence['GetMlflowModelLatestVersionTagArgs'] tags: Array of tags associated with the model.
        :param _builtins.str user_id: The username of the user that created the object.
        """
        if creation_timestamp is not None:
            pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        if current_stage is not None:
            pulumi.set(__self__, "current_stage", current_stage)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if last_updated_timestamp is not None:
            pulumi.set(__self__, "last_updated_timestamp", last_updated_timestamp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if run_id is not None:
            pulumi.set(__self__, "run_id", run_id)
        if run_link is not None:
            pulumi.set(__self__, "run_link", run_link)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_message is not None:
            pulumi.set(__self__, "status_message", status_message)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter(name="currentStage")
    def current_stage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "current_stage")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        User-specified description for the object.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedTimestamp")
    def last_updated_timestamp(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_updated_timestamp")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the registered model.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="runId")
    def run_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_id")

    @_builtins.property
    @pulumi.getter(name="runLink")
    def run_link(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_link")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status_message")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetMlflowModelLatestVersionTagResult']]:
        """
        Array of tags associated with the model.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        The username of the user that created the object.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMlflowModelLatestVersionTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMlflowModelProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetMlflowModelTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMlflowModelsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigResult(dict):
    def __init__(__self__, *,
                 default_rules: Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesResult'] = None,
                 target_rules: Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigTargetRulesResult'] = None):
        """
        :param 'GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesArgs' default_rules: Array of default rules.
        :param 'GetMwsNetworkConnectivityConfigEgressConfigTargetRulesArgs' target_rules: Array of target rules.
        """
        if default_rules is not None:
            pulumi.set(__self__, "default_rules", default_rules)
        if target_rules is not None:
            pulumi.set(__self__, "target_rules", target_rules)

    @_builtins.property
    @pulumi.getter(name="defaultRules")
    def default_rules(self) -> Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesResult']:
        """
        Array of default rules.
        """
        return pulumi.get(self, "default_rules")

    @_builtins.property
    @pulumi.getter(name="targetRules")
    def target_rules(self) -> Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigTargetRulesResult']:
        """
        Array of target rules.
        """
        return pulumi.get(self, "target_rules")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesResult(dict):
    def __init__(__self__, *,
                 aws_stable_ip_rule: Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleResult'] = None,
                 azure_service_endpoint_rule: Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleResult'] = None):
        """
        :param 'GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleArgs' aws_stable_ip_rule: The stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.
        :param 'GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleArgs' azure_service_endpoint_rule: Array of Azure service endpoint rules.
        """
        if aws_stable_ip_rule is not None:
            pulumi.set(__self__, "aws_stable_ip_rule", aws_stable_ip_rule)
        if azure_service_endpoint_rule is not None:
            pulumi.set(__self__, "azure_service_endpoint_rule", azure_service_endpoint_rule)

    @_builtins.property
    @pulumi.getter(name="awsStableIpRule")
    def aws_stable_ip_rule(self) -> Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleResult']:
        """
        The stable AWS IP CIDR blocks. You can use these to configure the firewall of your resources to allow traffic from your Databricks workspace.
        """
        return pulumi.get(self, "aws_stable_ip_rule")

    @_builtins.property
    @pulumi.getter(name="azureServiceEndpointRule")
    def azure_service_endpoint_rule(self) -> Optional['outputs.GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleResult']:
        """
        Array of Azure service endpoint rules.
        """
        return pulumi.get(self, "azure_service_endpoint_rule")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAwsStableIpRuleResult(dict):
    def __init__(__self__, *,
                 cidr_blocks: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] cidr_blocks: The list of stable IP CIDR blocks from which Databricks network traffic originates when accessing your resources.
        """
        if cidr_blocks is not None:
            pulumi.set(__self__, "cidr_blocks", cidr_blocks)

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of stable IP CIDR blocks from which Databricks network traffic originates when accessing your resources.
        """
        return pulumi.get(self, "cidr_blocks")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigDefaultRulesAzureServiceEndpointRuleResult(dict):
    def __init__(__self__, *,
                 subnets: Optional[Sequence[_builtins.str]] = None,
                 target_region: Optional[_builtins.str] = None,
                 target_services: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] subnets: Array of strings representing the subnet IDs.
        :param _builtins.str target_region: The target region for the service endpoint.
        :param Sequence[_builtins.str] target_services: Array of target services.
        """
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if target_region is not None:
            pulumi.set(__self__, "target_region", target_region)
        if target_services is not None:
            pulumi.set(__self__, "target_services", target_services)

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of strings representing the subnet IDs.
        """
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="targetRegion")
    def target_region(self) -> Optional[_builtins.str]:
        """
        The target region for the service endpoint.
        """
        return pulumi.get(self, "target_region")

    @_builtins.property
    @pulumi.getter(name="targetServices")
    def target_services(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of target services.
        """
        return pulumi.get(self, "target_services")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigTargetRulesResult(dict):
    def __init__(__self__, *,
                 aws_private_endpoint_rules: Optional[Sequence['outputs.GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRuleResult']] = None,
                 azure_private_endpoint_rules: Optional[Sequence['outputs.GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleResult']] = None):
        """
        :param Sequence['GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleArgs'] azure_private_endpoint_rules: Array of private endpoint rule objects.
        """
        if aws_private_endpoint_rules is not None:
            pulumi.set(__self__, "aws_private_endpoint_rules", aws_private_endpoint_rules)
        if azure_private_endpoint_rules is not None:
            pulumi.set(__self__, "azure_private_endpoint_rules", azure_private_endpoint_rules)

    @_builtins.property
    @pulumi.getter(name="awsPrivateEndpointRules")
    def aws_private_endpoint_rules(self) -> Optional[Sequence['outputs.GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRuleResult']]:
        return pulumi.get(self, "aws_private_endpoint_rules")

    @_builtins.property
    @pulumi.getter(name="azurePrivateEndpointRules")
    def azure_private_endpoint_rules(self) -> Optional[Sequence['outputs.GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleResult']]:
        """
        Array of private endpoint rule objects.
        """
        return pulumi.get(self, "azure_private_endpoint_rules")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAwsPrivateEndpointRuleResult(dict):
    def __init__(__self__, *,
                 account_id: Optional[_builtins.str] = None,
                 connection_state: Optional[_builtins.str] = None,
                 creation_time: Optional[_builtins.int] = None,
                 deactivated: Optional[_builtins.bool] = None,
                 deactivated_at: Optional[_builtins.int] = None,
                 domain_names: Optional[Sequence[_builtins.str]] = None,
                 enabled: Optional[_builtins.bool] = None,
                 endpoint_service: Optional[_builtins.str] = None,
                 network_connectivity_config_id: Optional[_builtins.str] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 rule_id: Optional[_builtins.str] = None,
                 updated_time: Optional[_builtins.int] = None,
                 vpc_endpoint_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str account_id: The Databricks account ID associated with this network configuration.
        :param _builtins.str connection_state: The current status of this private endpoint.
        :param _builtins.int creation_time: Time in epoch milliseconds when this object was created.
        :param _builtins.bool deactivated: Whether this private endpoint is deactivated.
        :param _builtins.int deactivated_at: Time in epoch milliseconds when this object was deactivated.
        :param _builtins.str network_connectivity_config_id: The Databricks network connectivity configuration ID.
        :param _builtins.str rule_id: The ID of a private endpoint rule.
        :param _builtins.int updated_time: Time in epoch milliseconds when the network was updated.
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if deactivated is not None:
            pulumi.set(__self__, "deactivated", deactivated)
        if deactivated_at is not None:
            pulumi.set(__self__, "deactivated_at", deactivated_at)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if endpoint_service is not None:
            pulumi.set(__self__, "endpoint_service", endpoint_service)
        if network_connectivity_config_id is not None:
            pulumi.set(__self__, "network_connectivity_config_id", network_connectivity_config_id)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if updated_time is not None:
            pulumi.set(__self__, "updated_time", updated_time)
        if vpc_endpoint_id is not None:
            pulumi.set(__self__, "vpc_endpoint_id", vpc_endpoint_id)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[_builtins.str]:
        """
        The Databricks account ID associated with this network configuration.
        """
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[_builtins.str]:
        """
        The current status of this private endpoint.
        """
        return pulumi.get(self, "connection_state")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.int]:
        """
        Time in epoch milliseconds when this object was created.
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def deactivated(self) -> Optional[_builtins.bool]:
        """
        Whether this private endpoint is deactivated.
        """
        return pulumi.get(self, "deactivated")

    @_builtins.property
    @pulumi.getter(name="deactivatedAt")
    def deactivated_at(self) -> Optional[_builtins.int]:
        """
        Time in epoch milliseconds when this object was deactivated.
        """
        return pulumi.get(self, "deactivated_at")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="endpointService")
    def endpoint_service(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_service")

    @_builtins.property
    @pulumi.getter(name="networkConnectivityConfigId")
    def network_connectivity_config_id(self) -> Optional[_builtins.str]:
        """
        The Databricks network connectivity configuration ID.
        """
        return pulumi.get(self, "network_connectivity_config_id")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[_builtins.str]:
        """
        The ID of a private endpoint rule.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="updatedTime")
    def updated_time(self) -> Optional[_builtins.int]:
        """
        Time in epoch milliseconds when the network was updated.
        """
        return pulumi.get(self, "updated_time")

    @_builtins.property
    @pulumi.getter(name="vpcEndpointId")
    def vpc_endpoint_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc_endpoint_id")


@pulumi.output_type
class GetMwsNetworkConnectivityConfigEgressConfigTargetRulesAzurePrivateEndpointRuleResult(dict):
    def __init__(__self__, *,
                 connection_state: Optional[_builtins.str] = None,
                 creation_time: Optional[_builtins.int] = None,
                 deactivated: Optional[_builtins.bool] = None,
                 deactivated_at: Optional[_builtins.int] = None,
                 domain_names: Optional[Sequence[_builtins.str]] = None,
                 endpoint_name: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.str] = None,
                 network_connectivity_config_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 rule_id: Optional[_builtins.str] = None,
                 updated_time: Optional[_builtins.int] = None):
        """
        :param _builtins.str connection_state: The current status of this private endpoint.
        :param _builtins.int creation_time: Time in epoch milliseconds when this object was created.
        :param _builtins.bool deactivated: Whether this private endpoint is deactivated.
        :param _builtins.int deactivated_at: Time in epoch milliseconds when this object was deactivated.
        :param _builtins.str endpoint_name: The name of the Azure private endpoint resource.
        :param _builtins.str group_id: The sub-resource type (group ID) of the target resource.
        :param _builtins.str network_connectivity_config_id: The Databricks network connectivity configuration ID.
        :param _builtins.str resource_id: The Azure resource ID of the target resource.
        :param _builtins.str rule_id: The ID of a private endpoint rule.
        :param _builtins.int updated_time: Time in epoch milliseconds when the network was updated.
        """
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if deactivated is not None:
            pulumi.set(__self__, "deactivated", deactivated)
        if deactivated_at is not None:
            pulumi.set(__self__, "deactivated_at", deactivated_at)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if network_connectivity_config_id is not None:
            pulumi.set(__self__, "network_connectivity_config_id", network_connectivity_config_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if updated_time is not None:
            pulumi.set(__self__, "updated_time", updated_time)

    @_builtins.property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[_builtins.str]:
        """
        The current status of this private endpoint.
        """
        return pulumi.get(self, "connection_state")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.int]:
        """
        Time in epoch milliseconds when this object was created.
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def deactivated(self) -> Optional[_builtins.bool]:
        """
        Whether this private endpoint is deactivated.
        """
        return pulumi.get(self, "deactivated")

    @_builtins.property
    @pulumi.getter(name="deactivatedAt")
    def deactivated_at(self) -> Optional[_builtins.int]:
        """
        Time in epoch milliseconds when this object was deactivated.
        """
        return pulumi.get(self, "deactivated_at")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[_builtins.str]:
        """
        The name of the Azure private endpoint resource.
        """
        return pulumi.get(self, "endpoint_name")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        The sub-resource type (group ID) of the target resource.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="networkConnectivityConfigId")
    def network_connectivity_config_id(self) -> Optional[_builtins.str]:
        """
        The Databricks network connectivity configuration ID.
        """
        return pulumi.get(self, "network_connectivity_config_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The Azure resource ID of the target resource.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[_builtins.str]:
        """
        The ID of a private endpoint rule.
        """
        return pulumi.get(self, "rule_id")

    @_builtins.property
    @pulumi.getter(name="updatedTime")
    def updated_time(self) -> Optional[_builtins.int]:
        """
        Time in epoch milliseconds when the network was updated.
        """
        return pulumi.get(self, "updated_time")


@pulumi.output_type
class GetNodeTypeProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetNotebookPathsNotebookPathListResult(dict):
    def __init__(__self__, *,
                 language: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Path to workspace directory
        """
        if language is not None:
            pulumi.set(__self__, "language", language)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to workspace directory
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetNotebookProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetNotificationDestinationsNotificationDestinationResult(dict):
    def __init__(__self__, *,
                 destination_type: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_type: The type of the notification destination. Possible values are `EMAIL`, `MICROSOFT_TEAMS`, `PAGERDUTY`, `SLACK`, or `WEBHOOK`.
        :param _builtins.str display_name: The display name of the Notification Destination.
        :param _builtins.str id: The unique ID of the Notification Destination.
        """
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        The type of the notification destination. Possible values are `EMAIL`, `MICROSOFT_TEAMS`, `PAGERDUTY`, `SLACK`, or `WEBHOOK`.
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the Notification Destination.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique ID of the Notification Destination.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetNotificationDestinationsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetOnlineStoresOnlineStoreResult(dict):
    def __init__(__self__, *,
                 capacity: _builtins.str,
                 creation_time: _builtins.str,
                 creator: _builtins.str,
                 name: _builtins.str,
                 read_replica_count: _builtins.int,
                 state: _builtins.str):
        """
        :param _builtins.str capacity: (string) - The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        :param _builtins.str creation_time: (string) - The timestamp when the online store was created
        :param _builtins.str creator: (string) - The email of the creator of the online store
        :param _builtins.str name: (string) - The name of the online store. This is the unique identifier for the online store
        :param _builtins.int read_replica_count: (integer) - The number of read replicas for the online store. Defaults to 0
        :param _builtins.str state: (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "creator", creator)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "read_replica_count", read_replica_count)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.str:
        """
        (string) - The capacity of the online store. Valid values are "CU_1", "CU_2", "CU_4", "CU_8"
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> _builtins.str:
        """
        (string) - The timestamp when the online store was created
        """
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> _builtins.str:
        """
        (string) - The email of the creator of the online store
        """
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - The name of the online store. This is the unique identifier for the online store
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="readReplicaCount")
    def read_replica_count(self) -> _builtins.int:
        """
        (integer) - The number of read replicas for the online store. Defaults to 0
        """
        return pulumi.get(self, "read_replica_count")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        (string) - The current state of the online store. Possible values are: `AVAILABLE`, `DELETING`, `FAILING_OVER`, `STARTING`, `STOPPED`, `UPDATING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetPipelinesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetPolicyInfoColumnMaskResult(dict):
    def __init__(__self__, *,
                 function_name: _builtins.str,
                 on_column: _builtins.str,
                 usings: Optional[Sequence['outputs.GetPolicyInfoColumnMaskUsingResult']] = None):
        """
        :param _builtins.str function_name: (string) - The fully qualified name of the row filter function.
               The function is called on each row of the target table. It should return a boolean value
               indicating whether the row should be visible to the user.
               Required on create and update
        :param _builtins.str on_column: (string) - The alias of the column to be masked. The alias must refer to one of matched columns.
               The values of the column is passed to the column mask function as the first argument.
               Required on create and update
        :param Sequence['GetPolicyInfoColumnMaskUsingArgs'] usings: (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
               The type of each column should match the positional argument of the row filter function
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "on_column", on_column)
        if usings is not None:
            pulumi.set(__self__, "usings", usings)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        (string) - The fully qualified name of the row filter function.
        The function is called on each row of the target table. It should return a boolean value
        indicating whether the row should be visible to the user.
        Required on create and update
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="onColumn")
    def on_column(self) -> _builtins.str:
        """
        (string) - The alias of the column to be masked. The alias must refer to one of matched columns.
        The values of the column is passed to the column mask function as the first argument.
        Required on create and update
        """
        return pulumi.get(self, "on_column")

    @_builtins.property
    @pulumi.getter
    def usings(self) -> Optional[Sequence['outputs.GetPolicyInfoColumnMaskUsingResult']]:
        """
        (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
        The type of each column should match the positional argument of the row filter function
        """
        return pulumi.get(self, "usings")


@pulumi.output_type
class GetPolicyInfoColumnMaskUsingResult(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 constant: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: (string) - Optional alias of the matched column
        :param _builtins.str constant: (string) - A constant literal
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if constant is not None:
            pulumi.set(__self__, "constant", constant)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        (string) - Optional alias of the matched column
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def constant(self) -> Optional[_builtins.str]:
        """
        (string) - A constant literal
        """
        return pulumi.get(self, "constant")


@pulumi.output_type
class GetPolicyInfoMatchColumnResult(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 condition: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: (string) - Optional alias of the matched column
        :param _builtins.str condition: (string) - The condition expression used to match a table column
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        (string) - Optional alias of the matched column
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        (string) - The condition expression used to match a table column
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetPolicyInfoRowFilterResult(dict):
    def __init__(__self__, *,
                 function_name: _builtins.str,
                 usings: Optional[Sequence['outputs.GetPolicyInfoRowFilterUsingResult']] = None):
        """
        :param _builtins.str function_name: (string) - The fully qualified name of the row filter function.
               The function is called on each row of the target table. It should return a boolean value
               indicating whether the row should be visible to the user.
               Required on create and update
        :param Sequence['GetPolicyInfoRowFilterUsingArgs'] usings: (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
               The type of each column should match the positional argument of the row filter function
        """
        pulumi.set(__self__, "function_name", function_name)
        if usings is not None:
            pulumi.set(__self__, "usings", usings)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        (string) - The fully qualified name of the row filter function.
        The function is called on each row of the target table. It should return a boolean value
        indicating whether the row should be visible to the user.
        Required on create and update
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter
    def usings(self) -> Optional[Sequence['outputs.GetPolicyInfoRowFilterUsingResult']]:
        """
        (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
        The type of each column should match the positional argument of the row filter function
        """
        return pulumi.get(self, "usings")


@pulumi.output_type
class GetPolicyInfoRowFilterUsingResult(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 constant: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: (string) - Optional alias of the matched column
        :param _builtins.str constant: (string) - A constant literal
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if constant is not None:
            pulumi.set(__self__, "constant", constant)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        (string) - Optional alias of the matched column
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def constant(self) -> Optional[_builtins.str]:
        """
        (string) - A constant literal
        """
        return pulumi.get(self, "constant")


@pulumi.output_type
class GetPolicyInfosPolicyResult(dict):
    def __init__(__self__, *,
                 column_mask: 'outputs.GetPolicyInfosPolicyColumnMaskResult',
                 comment: _builtins.str,
                 created_at: _builtins.int,
                 created_by: _builtins.str,
                 except_principals: Sequence[_builtins.str],
                 for_securable_type: _builtins.str,
                 id: _builtins.str,
                 match_columns: Sequence['outputs.GetPolicyInfosPolicyMatchColumnResult'],
                 name: _builtins.str,
                 on_securable_fullname: _builtins.str,
                 on_securable_type: _builtins.str,
                 policy_type: _builtins.str,
                 row_filter: 'outputs.GetPolicyInfosPolicyRowFilterResult',
                 to_principals: Sequence[_builtins.str],
                 updated_at: _builtins.int,
                 updated_by: _builtins.str,
                 when_condition: _builtins.str):
        """
        :param 'GetPolicyInfosPolicyColumnMaskArgs' column_mask: (ColumnMaskOptions) - Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`.
               Required on create and optional on update. When specified on update,
               the new options will replace the existing options as a whole
        :param _builtins.str comment: (string) - Optional description of the policy
        :param _builtins.int created_at: (integer) - Time at which the policy was created, in epoch milliseconds. Output only
        :param _builtins.str created_by: (string) - Username of the user who created the policy. Output only
        :param Sequence[_builtins.str] except_principals: (list of string) - Optional list of user or group names that should be excluded from the policy
        :param _builtins.str for_securable_type: (string) - Type of securables that the policy should take effect on.
               Only `TABLE` is supported at this moment.
               Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        :param _builtins.str id: (string) - Unique identifier of the policy. This field is output only and is generated by the system
        :param Sequence['GetPolicyInfosPolicyMatchColumnArgs'] match_columns: (list of MatchColumn) - Optional list of condition expressions used to match table columns.
               Only valid when `for_securable_type` is `TABLE`.
               When specified, the policy only applies to tables whose columns satisfy all match conditions
        :param _builtins.str name: (string) - Name of the policy. Required on create and optional on update.
               To rename the policy, set `name` to a different value on update
        :param _builtins.str on_securable_fullname: Required. The fully qualified name of securable to list policies for
        :param _builtins.str on_securable_type: Required. The type of the securable to list policies for
        :param _builtins.str policy_type: (string) - Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
        :param 'GetPolicyInfosPolicyRowFilterArgs' row_filter: (RowFilterOptions) - Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`.
               Required on create and optional on update. When specified on update,
               the new options will replace the existing options as a whole
        :param Sequence[_builtins.str] to_principals: (list of string) - List of user or group names that the policy applies to.
               Required on create and optional on update
        :param _builtins.int updated_at: (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
        :param _builtins.str updated_by: (string) - Username of the user who last modified the policy. Output only
        :param _builtins.str when_condition: (string) - Optional condition when the policy should take effect
        """
        pulumi.set(__self__, "column_mask", column_mask)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "except_principals", except_principals)
        pulumi.set(__self__, "for_securable_type", for_securable_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "match_columns", match_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "on_securable_fullname", on_securable_fullname)
        pulumi.set(__self__, "on_securable_type", on_securable_type)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "row_filter", row_filter)
        pulumi.set(__self__, "to_principals", to_principals)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "updated_by", updated_by)
        pulumi.set(__self__, "when_condition", when_condition)

    @_builtins.property
    @pulumi.getter(name="columnMask")
    def column_mask(self) -> 'outputs.GetPolicyInfosPolicyColumnMaskResult':
        """
        (ColumnMaskOptions) - Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`.
        Required on create and optional on update. When specified on update,
        the new options will replace the existing options as a whole
        """
        return pulumi.get(self, "column_mask")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        (string) - Optional description of the policy
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.int:
        """
        (integer) - Time at which the policy was created, in epoch milliseconds. Output only
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        (string) - Username of the user who created the policy. Output only
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="exceptPrincipals")
    def except_principals(self) -> Sequence[_builtins.str]:
        """
        (list of string) - Optional list of user or group names that should be excluded from the policy
        """
        return pulumi.get(self, "except_principals")

    @_builtins.property
    @pulumi.getter(name="forSecurableType")
    def for_securable_type(self) -> _builtins.str:
        """
        (string) - Type of securables that the policy should take effect on.
        Only `TABLE` is supported at this moment.
        Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        """
        return pulumi.get(self, "for_securable_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (string) - Unique identifier of the policy. This field is output only and is generated by the system
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="matchColumns")
    def match_columns(self) -> Sequence['outputs.GetPolicyInfosPolicyMatchColumnResult']:
        """
        (list of MatchColumn) - Optional list of condition expressions used to match table columns.
        Only valid when `for_securable_type` is `TABLE`.
        When specified, the policy only applies to tables whose columns satisfy all match conditions
        """
        return pulumi.get(self, "match_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name of the policy. Required on create and optional on update.
        To rename the policy, set `name` to a different value on update
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="onSecurableFullname")
    def on_securable_fullname(self) -> _builtins.str:
        """
        Required. The fully qualified name of securable to list policies for
        """
        return pulumi.get(self, "on_securable_fullname")

    @_builtins.property
    @pulumi.getter(name="onSecurableType")
    def on_securable_type(self) -> _builtins.str:
        """
        Required. The type of the securable to list policies for
        """
        return pulumi.get(self, "on_securable_type")

    @_builtins.property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> _builtins.str:
        """
        (string) - Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
        """
        return pulumi.get(self, "policy_type")

    @_builtins.property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> 'outputs.GetPolicyInfosPolicyRowFilterResult':
        """
        (RowFilterOptions) - Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`.
        Required on create and optional on update. When specified on update,
        the new options will replace the existing options as a whole
        """
        return pulumi.get(self, "row_filter")

    @_builtins.property
    @pulumi.getter(name="toPrincipals")
    def to_principals(self) -> Sequence[_builtins.str]:
        """
        (list of string) - List of user or group names that the policy applies to.
        Required on create and optional on update
        """
        return pulumi.get(self, "to_principals")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.int:
        """
        (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> _builtins.str:
        """
        (string) - Username of the user who last modified the policy. Output only
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter(name="whenCondition")
    def when_condition(self) -> _builtins.str:
        """
        (string) - Optional condition when the policy should take effect
        """
        return pulumi.get(self, "when_condition")


@pulumi.output_type
class GetPolicyInfosPolicyColumnMaskResult(dict):
    def __init__(__self__, *,
                 function_name: _builtins.str,
                 on_column: _builtins.str,
                 usings: Optional[Sequence['outputs.GetPolicyInfosPolicyColumnMaskUsingResult']] = None):
        """
        :param _builtins.str function_name: (string) - The fully qualified name of the row filter function.
               The function is called on each row of the target table. It should return a boolean value
               indicating whether the row should be visible to the user.
               Required on create and update
        :param _builtins.str on_column: (string) - The alias of the column to be masked. The alias must refer to one of matched columns.
               The values of the column is passed to the column mask function as the first argument.
               Required on create and update
        :param Sequence['GetPolicyInfosPolicyColumnMaskUsingArgs'] usings: (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
               The type of each column should match the positional argument of the row filter function
        """
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "on_column", on_column)
        if usings is not None:
            pulumi.set(__self__, "usings", usings)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        (string) - The fully qualified name of the row filter function.
        The function is called on each row of the target table. It should return a boolean value
        indicating whether the row should be visible to the user.
        Required on create and update
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="onColumn")
    def on_column(self) -> _builtins.str:
        """
        (string) - The alias of the column to be masked. The alias must refer to one of matched columns.
        The values of the column is passed to the column mask function as the first argument.
        Required on create and update
        """
        return pulumi.get(self, "on_column")

    @_builtins.property
    @pulumi.getter
    def usings(self) -> Optional[Sequence['outputs.GetPolicyInfosPolicyColumnMaskUsingResult']]:
        """
        (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
        The type of each column should match the positional argument of the row filter function
        """
        return pulumi.get(self, "usings")


@pulumi.output_type
class GetPolicyInfosPolicyColumnMaskUsingResult(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 constant: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: (string) - Optional alias of the matched column
        :param _builtins.str constant: (string) - A constant literal
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if constant is not None:
            pulumi.set(__self__, "constant", constant)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        (string) - Optional alias of the matched column
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def constant(self) -> Optional[_builtins.str]:
        """
        (string) - A constant literal
        """
        return pulumi.get(self, "constant")


@pulumi.output_type
class GetPolicyInfosPolicyMatchColumnResult(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 condition: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: (string) - Optional alias of the matched column
        :param _builtins.str condition: (string) - The condition expression used to match a table column
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        (string) - Optional alias of the matched column
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        (string) - The condition expression used to match a table column
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class GetPolicyInfosPolicyRowFilterResult(dict):
    def __init__(__self__, *,
                 function_name: _builtins.str,
                 usings: Optional[Sequence['outputs.GetPolicyInfosPolicyRowFilterUsingResult']] = None):
        """
        :param _builtins.str function_name: (string) - The fully qualified name of the row filter function.
               The function is called on each row of the target table. It should return a boolean value
               indicating whether the row should be visible to the user.
               Required on create and update
        :param Sequence['GetPolicyInfosPolicyRowFilterUsingArgs'] usings: (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
               The type of each column should match the positional argument of the row filter function
        """
        pulumi.set(__self__, "function_name", function_name)
        if usings is not None:
            pulumi.set(__self__, "usings", usings)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        (string) - The fully qualified name of the row filter function.
        The function is called on each row of the target table. It should return a boolean value
        indicating whether the row should be visible to the user.
        Required on create and update
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter
    def usings(self) -> Optional[Sequence['outputs.GetPolicyInfosPolicyRowFilterUsingResult']]:
        """
        (list of FunctionArgument) - Optional list of column aliases or constant literals to be passed as arguments to the row filter function.
        The type of each column should match the positional argument of the row filter function
        """
        return pulumi.get(self, "usings")


@pulumi.output_type
class GetPolicyInfosPolicyRowFilterUsingResult(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 constant: Optional[_builtins.str] = None):
        """
        :param _builtins.str alias: (string) - Optional alias of the matched column
        :param _builtins.str constant: (string) - A constant literal
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if constant is not None:
            pulumi.set(__self__, "constant", constant)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        (string) - Optional alias of the matched column
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def constant(self) -> Optional[_builtins.str]:
        """
        (string) - A constant literal
        """
        return pulumi.get(self, "constant")


@pulumi.output_type
class GetQualityMonitorV2AnomalyDetectionConfigResult(dict):
    def __init__(__self__, *,
                 last_run_id: _builtins.str,
                 latest_run_status: _builtins.str):
        """
        :param _builtins.str last_run_id: (string) - Run id of the last run of the workflow
        :param _builtins.str latest_run_status: (string) - The status of the last run of the workflow. Possible values are: `ANOMALY_DETECTION_RUN_STATUS_CANCELED`, `ANOMALY_DETECTION_RUN_STATUS_FAILED`, `ANOMALY_DETECTION_RUN_STATUS_JOB_DELETED`, `ANOMALY_DETECTION_RUN_STATUS_PENDING`, `ANOMALY_DETECTION_RUN_STATUS_RUNNING`, `ANOMALY_DETECTION_RUN_STATUS_SUCCESS`, `ANOMALY_DETECTION_RUN_STATUS_UNKNOWN`, `ANOMALY_DETECTION_RUN_STATUS_WORKSPACE_MISMATCH_ERROR`
        """
        pulumi.set(__self__, "last_run_id", last_run_id)
        pulumi.set(__self__, "latest_run_status", latest_run_status)

    @_builtins.property
    @pulumi.getter(name="lastRunId")
    def last_run_id(self) -> _builtins.str:
        """
        (string) - Run id of the last run of the workflow
        """
        return pulumi.get(self, "last_run_id")

    @_builtins.property
    @pulumi.getter(name="latestRunStatus")
    def latest_run_status(self) -> _builtins.str:
        """
        (string) - The status of the last run of the workflow. Possible values are: `ANOMALY_DETECTION_RUN_STATUS_CANCELED`, `ANOMALY_DETECTION_RUN_STATUS_FAILED`, `ANOMALY_DETECTION_RUN_STATUS_JOB_DELETED`, `ANOMALY_DETECTION_RUN_STATUS_PENDING`, `ANOMALY_DETECTION_RUN_STATUS_RUNNING`, `ANOMALY_DETECTION_RUN_STATUS_SUCCESS`, `ANOMALY_DETECTION_RUN_STATUS_UNKNOWN`, `ANOMALY_DETECTION_RUN_STATUS_WORKSPACE_MISMATCH_ERROR`
        """
        return pulumi.get(self, "latest_run_status")


@pulumi.output_type
class GetQualityMonitorsV2QualityMonitorResult(dict):
    def __init__(__self__, *,
                 anomaly_detection_config: 'outputs.GetQualityMonitorsV2QualityMonitorAnomalyDetectionConfigResult',
                 object_id: _builtins.str,
                 object_type: _builtins.str):
        """
        :param 'GetQualityMonitorsV2QualityMonitorAnomalyDetectionConfigArgs' anomaly_detection_config: (AnomalyDetectionConfig)
        :param _builtins.str object_id: (string) - The uuid of the request object. For example, schema id
        :param _builtins.str object_type: (string) - The type of the monitored object. Can be one of the following: schema
        """
        pulumi.set(__self__, "anomaly_detection_config", anomaly_detection_config)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "object_type", object_type)

    @_builtins.property
    @pulumi.getter(name="anomalyDetectionConfig")
    def anomaly_detection_config(self) -> 'outputs.GetQualityMonitorsV2QualityMonitorAnomalyDetectionConfigResult':
        """
        (AnomalyDetectionConfig)
        """
        return pulumi.get(self, "anomaly_detection_config")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> _builtins.str:
        """
        (string) - The uuid of the request object. For example, schema id
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        (string) - The type of the monitored object. Can be one of the following: schema
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class GetQualityMonitorsV2QualityMonitorAnomalyDetectionConfigResult(dict):
    def __init__(__self__, *,
                 last_run_id: _builtins.str,
                 latest_run_status: _builtins.str):
        """
        :param _builtins.str last_run_id: (string) - Run id of the last run of the workflow
        :param _builtins.str latest_run_status: (string) - The status of the last run of the workflow. Possible values are: `ANOMALY_DETECTION_RUN_STATUS_CANCELED`, `ANOMALY_DETECTION_RUN_STATUS_FAILED`, `ANOMALY_DETECTION_RUN_STATUS_JOB_DELETED`, `ANOMALY_DETECTION_RUN_STATUS_PENDING`, `ANOMALY_DETECTION_RUN_STATUS_RUNNING`, `ANOMALY_DETECTION_RUN_STATUS_SUCCESS`, `ANOMALY_DETECTION_RUN_STATUS_UNKNOWN`, `ANOMALY_DETECTION_RUN_STATUS_WORKSPACE_MISMATCH_ERROR`
        """
        pulumi.set(__self__, "last_run_id", last_run_id)
        pulumi.set(__self__, "latest_run_status", latest_run_status)

    @_builtins.property
    @pulumi.getter(name="lastRunId")
    def last_run_id(self) -> _builtins.str:
        """
        (string) - Run id of the last run of the workflow
        """
        return pulumi.get(self, "last_run_id")

    @_builtins.property
    @pulumi.getter(name="latestRunStatus")
    def latest_run_status(self) -> _builtins.str:
        """
        (string) - The status of the last run of the workflow. Possible values are: `ANOMALY_DETECTION_RUN_STATUS_CANCELED`, `ANOMALY_DETECTION_RUN_STATUS_FAILED`, `ANOMALY_DETECTION_RUN_STATUS_JOB_DELETED`, `ANOMALY_DETECTION_RUN_STATUS_PENDING`, `ANOMALY_DETECTION_RUN_STATUS_RUNNING`, `ANOMALY_DETECTION_RUN_STATUS_SUCCESS`, `ANOMALY_DETECTION_RUN_STATUS_UNKNOWN`, `ANOMALY_DETECTION_RUN_STATUS_WORKSPACE_MISMATCH_ERROR`
        """
        return pulumi.get(self, "latest_run_status")


@pulumi.output_type
class GetRegisteredModelModelInfoResult(dict):
    def __init__(__self__, *,
                 aliases: Optional[Sequence['outputs.GetRegisteredModelModelInfoAliasResult']] = None,
                 browse_only: Optional[_builtins.bool] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 full_name: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 storage_location: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param Sequence['GetRegisteredModelModelInfoAliasArgs'] aliases: the list of aliases associated with this model. Each item is object consisting of following attributes:
        :param _builtins.str catalog_name: The name of the catalog where the schema and the registered model reside.
        :param _builtins.str comment: The comment attached to the registered model.
        :param _builtins.int created_at: the Unix timestamp at the model's creation
        :param _builtins.str created_by: the identifier of the user who created the model
        :param _builtins.str full_name: The fully-qualified name of the registered model (`catalog_name.schema_name.name`).
        :param _builtins.str metastore_id: the unique identifier of the metastore
        :param _builtins.str name: The name of the registered model.
        :param _builtins.str owner: Name of the registered model owner.
        :param _builtins.str schema_name: The name of the schema where the registered model resides.
        :param _builtins.str storage_location: The storage location under which model version data files are stored.
        :param _builtins.int updated_at: the timestamp of the last time changes were made to the model
        :param _builtins.str updated_by: the identifier of the user who updated the model last time
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence['outputs.GetRegisteredModelModelInfoAliasResult']]:
        """
        the list of aliases associated with this model. Each item is object consisting of following attributes:
        """
        return pulumi.get(self, "aliases")

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog where the schema and the registered model reside.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        The comment attached to the registered model.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        the Unix timestamp at the model's creation
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who created the model
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        The fully-qualified name of the registered model (`catalog_name.schema_name.name`).
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the registered model.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Name of the registered model owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema where the registered model resides.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[_builtins.str]:
        """
        The storage location under which model version data files are stored.
        """
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        the timestamp of the last time changes were made to the model
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who updated the model last time
        """
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class GetRegisteredModelModelInfoAliasResult(dict):
    def __init__(__self__, *,
                 alias_name: Optional[_builtins.str] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 version_num: Optional[_builtins.int] = None):
        """
        :param _builtins.str alias_name: string with the name of alias
        :param _builtins.str catalog_name: The name of the catalog where the schema and the registered model reside.
        :param _builtins.str schema_name: The name of the schema where the registered model resides.
        :param _builtins.int version_num: associated model version
        """
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if version_num is not None:
            pulumi.set(__self__, "version_num", version_num)

    @_builtins.property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[_builtins.str]:
        """
        string with the name of alias
        """
        return pulumi.get(self, "alias_name")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog where the schema and the registered model reside.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema where the registered model resides.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="versionNum")
    def version_num(self) -> Optional[_builtins.int]:
        """
        associated model version
        """
        return pulumi.get(self, "version_num")


@pulumi.output_type
class GetRegisteredModelProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionResult(dict):
    def __init__(__self__, *,
                 aliases: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionAliasResult']] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 model_version_dependencies: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyResult']] = None,
                 run_id: Optional[_builtins.str] = None,
                 run_workspace_id: Optional[_builtins.int] = None,
                 schema_name: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 storage_location: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None,
                 version: Optional[_builtins.int] = None):
        """
        :param Sequence['GetRegisteredModelVersionsModelVersionAliasArgs'] aliases: the list of aliases associated with this model. Each item is object consisting of following attributes:
        :param _builtins.str catalog_name: The name of the catalog where the schema and the registered model reside.
        :param _builtins.str comment: The comment attached to the registered model.
        :param _builtins.int created_at: the Unix timestamp at the model's creation
        :param _builtins.str created_by: the identifier of the user who created the model
        :param _builtins.str id: The unique identifier of the model version
        :param _builtins.str metastore_id: the unique identifier of the metastore
        :param Sequence['GetRegisteredModelVersionsModelVersionModelVersionDependencyArgs'] model_version_dependencies: block describing model version dependencies, for feature-store packaged models. Consists of following attributes:
        :param _builtins.str run_id: MLflow run ID used when creating the model version, if `source` was generated by an experiment run stored in an MLflow tracking server
        :param _builtins.int run_workspace_id: ID of the Databricks workspace containing the MLflow run that generated this model version, if applicable
        :param _builtins.str schema_name: The name of the schema where the registered model resides.
        :param _builtins.str source: URI indicating the location of the source artifacts (files) for the model version.
        :param _builtins.str status: Current status of the model version.
        :param _builtins.str storage_location: The storage location under which model version data files are stored.
        :param _builtins.int updated_at: the timestamp of the last time changes were made to the model
        :param _builtins.str updated_by: the identifier of the user who updated the model last time
        :param _builtins.int version: Integer model version number, used to reference the model version in API requests.
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if model_version_dependencies is not None:
            pulumi.set(__self__, "model_version_dependencies", model_version_dependencies)
        if run_id is not None:
            pulumi.set(__self__, "run_id", run_id)
        if run_workspace_id is not None:
            pulumi.set(__self__, "run_workspace_id", run_workspace_id)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionAliasResult']]:
        """
        the list of aliases associated with this model. Each item is object consisting of following attributes:
        """
        return pulumi.get(self, "aliases")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog where the schema and the registered model reside.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        The comment attached to the registered model.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        the Unix timestamp at the model's creation
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who created the model
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the model version
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="modelVersionDependencies")
    def model_version_dependencies(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyResult']]:
        """
        block describing model version dependencies, for feature-store packaged models. Consists of following attributes:
        """
        return pulumi.get(self, "model_version_dependencies")

    @_builtins.property
    @pulumi.getter(name="runId")
    def run_id(self) -> Optional[_builtins.str]:
        """
        MLflow run ID used when creating the model version, if `source` was generated by an experiment run stored in an MLflow tracking server
        """
        return pulumi.get(self, "run_id")

    @_builtins.property
    @pulumi.getter(name="runWorkspaceId")
    def run_workspace_id(self) -> Optional[_builtins.int]:
        """
        ID of the Databricks workspace containing the MLflow run that generated this model version, if applicable
        """
        return pulumi.get(self, "run_workspace_id")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema where the registered model resides.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        URI indicating the location of the source artifacts (files) for the model version.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Current status of the model version.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[_builtins.str]:
        """
        The storage location under which model version data files are stored.
        """
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        the timestamp of the last time changes were made to the model
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who updated the model last time
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.int]:
        """
        Integer model version number, used to reference the model version in API requests.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionAliasResult(dict):
    def __init__(__self__, *,
                 alias_name: Optional[_builtins.str] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 model_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 version_num: Optional[_builtins.int] = None):
        """
        :param _builtins.str alias_name: string with the name of alias
        :param _builtins.str catalog_name: The name of the catalog where the schema and the registered model reside.
        :param _builtins.str id: The unique identifier of the model version
        :param _builtins.str schema_name: The name of the schema where the registered model resides.
        :param _builtins.int version_num: associated model version
        """
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if version_num is not None:
            pulumi.set(__self__, "version_num", version_num)

    @_builtins.property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[_builtins.str]:
        """
        string with the name of alias
        """
        return pulumi.get(self, "alias_name")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        The name of the catalog where the schema and the registered model reside.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the model version
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The name of the schema where the registered model resides.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="versionNum")
    def version_num(self) -> Optional[_builtins.int]:
        """
        associated model version
        """
        return pulumi.get(self, "version_num")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionModelVersionDependencyResult(dict):
    def __init__(__self__, *,
                 dependencies: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyResult']] = None):
        """
        :param Sequence['GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyArgs'] dependencies: list of dependencies consisting of following attributes:
        """
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyResult']]:
        """
        list of dependencies consisting of following attributes:
        """
        return pulumi.get(self, "dependencies")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyResult(dict):
    def __init__(__self__, *,
                 connections: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyConnectionResult']] = None,
                 credentials: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyCredentialResult']] = None,
                 functions: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyFunctionResult']] = None,
                 tables: Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyTableResult']] = None):
        """
        :param Sequence['GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyFunctionArgs'] functions: A function that is dependent on a SQL object:
        :param Sequence['GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyTableArgs'] tables: A table that is dependent on a SQL object
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyConnectionResult']]:
        return pulumi.get(self, "connections")

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyCredentialResult']]:
        return pulumi.get(self, "credentials")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyFunctionResult']]:
        """
        A function that is dependent on a SQL object:
        """
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyTableResult']]:
        """
        A table that is dependent on a SQL object
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyConnectionResult(dict):
    def __init__(__self__, *,
                 connection_name: Optional[_builtins.str] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: Optional[_builtins.str] = None):
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_name")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyFunctionResult(dict):
    def __init__(__self__, *,
                 function_full_name: _builtins.str):
        """
        :param _builtins.str function_full_name: Full name of the dependent function
        """
        pulumi.set(__self__, "function_full_name", function_full_name)

    @_builtins.property
    @pulumi.getter(name="functionFullName")
    def function_full_name(self) -> _builtins.str:
        """
        Full name of the dependent function
        """
        return pulumi.get(self, "function_full_name")


@pulumi.output_type
class GetRegisteredModelVersionsModelVersionModelVersionDependencyDependencyTableResult(dict):
    def __init__(__self__, *,
                 table_full_name: _builtins.str):
        """
        :param _builtins.str table_full_name: Full name of the dependent table
        """
        pulumi.set(__self__, "table_full_name", table_full_name)

    @_builtins.property
    @pulumi.getter(name="tableFullName")
    def table_full_name(self) -> _builtins.str:
        """
        Full name of the dependent table
        """
        return pulumi.get(self, "table_full_name")


@pulumi.output_type
class GetRegisteredModelVersionsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetRfaAccessRequestDestinationsDestinationResult(dict):
    def __init__(__self__, *,
                 destination_id: Optional[_builtins.str] = None,
                 destination_type: Optional[_builtins.str] = None,
                 special_destination: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_id: (string) - The identifier for the destination. This is the email address for EMAIL destinations, the URL for URL destinations,
               or the unique Databricks notification destination ID for all other external destinations
        :param _builtins.str destination_type: (string) - The type of the destination. Possible values are: `EMAIL`, `GENERIC_WEBHOOK`, `MICROSOFT_TEAMS`, `SLACK`, `URL`
        :param _builtins.str special_destination: (string) - This field is used to denote whether the destination is the email of the owner of the securable object.
               The special destination cannot be assigned to a securable and only represents the default destination of the securable.
               The securable types that support default special destinations are: "catalog", "external_location", "connection", "credential", and "metastore".
               The **destination_type** of a **special_destination** is always EMAIL. Possible values are: `SPECIAL_DESTINATION_CATALOG_OWNER`, `SPECIAL_DESTINATION_CONNECTION_OWNER`, `SPECIAL_DESTINATION_CREDENTIAL_OWNER`, `SPECIAL_DESTINATION_EXTERNAL_LOCATION_OWNER`, `SPECIAL_DESTINATION_METASTORE_OWNER`
        """
        if destination_id is not None:
            pulumi.set(__self__, "destination_id", destination_id)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if special_destination is not None:
            pulumi.set(__self__, "special_destination", special_destination)

    @_builtins.property
    @pulumi.getter(name="destinationId")
    def destination_id(self) -> Optional[_builtins.str]:
        """
        (string) - The identifier for the destination. This is the email address for EMAIL destinations, the URL for URL destinations,
        or the unique Databricks notification destination ID for all other external destinations
        """
        return pulumi.get(self, "destination_id")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[_builtins.str]:
        """
        (string) - The type of the destination. Possible values are: `EMAIL`, `GENERIC_WEBHOOK`, `MICROSOFT_TEAMS`, `SLACK`, `URL`
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="specialDestination")
    def special_destination(self) -> Optional[_builtins.str]:
        """
        (string) - This field is used to denote whether the destination is the email of the owner of the securable object.
        The special destination cannot be assigned to a securable and only represents the default destination of the securable.
        The securable types that support default special destinations are: "catalog", "external_location", "connection", "credential", and "metastore".
        The **destination_type** of a **special_destination** is always EMAIL. Possible values are: `SPECIAL_DESTINATION_CATALOG_OWNER`, `SPECIAL_DESTINATION_CONNECTION_OWNER`, `SPECIAL_DESTINATION_CREDENTIAL_OWNER`, `SPECIAL_DESTINATION_EXTERNAL_LOCATION_OWNER`, `SPECIAL_DESTINATION_METASTORE_OWNER`
        """
        return pulumi.get(self, "special_destination")


@pulumi.output_type
class GetRfaAccessRequestDestinationsSecurableResult(dict):
    def __init__(__self__, *,
                 full_name: Optional[_builtins.str] = None,
                 provider_share: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str full_name: (string) - Required. The full name of the catalog/schema/table.
               Optional if resource_name is present
        :param _builtins.str provider_share: (string) - Optional. The name of the Share object that contains the securable when the securable is
               getting shared in D2D Delta Sharing
        :param _builtins.str type: (string) - Required. The type of securable (catalog/schema/table).
               Optional if resource_name is present. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        """
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if provider_share is not None:
            pulumi.set(__self__, "provider_share", provider_share)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        (string) - Required. The full name of the catalog/schema/table.
        Optional if resource_name is present
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="providerShare")
    def provider_share(self) -> Optional[_builtins.str]:
        """
        (string) - Optional. The name of the Share object that contains the securable when the securable is
        getting shared in D2D Delta Sharing
        """
        return pulumi.get(self, "provider_share")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (string) - Required. The type of securable (catalog/schema/table).
        Optional if resource_name is present. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSchemaProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetSchemaSchemaInfoResult(dict):
    def __init__(__self__, *,
                 browse_only: Optional[_builtins.bool] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 catalog_type: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 effective_predictive_optimization_flag: Optional['outputs.GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagResult'] = None,
                 enable_predictive_optimization: Optional[_builtins.str] = None,
                 full_name: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 schema_id: Optional[_builtins.str] = None,
                 storage_location: Optional[_builtins.str] = None,
                 storage_root: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None):
        """
        :param _builtins.bool browse_only: indicates whether the principal is limited to retrieving metadata for the schema through the BROWSE privilege.
        :param _builtins.str catalog_name: the name of the catalog where the schema is.
        :param _builtins.str catalog_type: the type of the parent catalog.
        :param _builtins.str comment: the comment attached to the volume
        :param _builtins.int created_at: time at which this schema was created, in epoch milliseconds.
        :param _builtins.str created_by: username of schema creator.
        :param 'GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagArgs' effective_predictive_optimization_flag: information about actual state of predictive optimization.
        :param _builtins.str enable_predictive_optimization: whether predictive optimization should be enabled for this object and objects under it.
        :param _builtins.str full_name: the two-level (fully qualified) name of the schema
        :param _builtins.str metastore_id: the unique identifier of the metastore
        :param _builtins.str name: a fully qualified name of databricks_schema: *`catalog`.`schema`*
        :param _builtins.str owner: the identifier of the user who owns the schema
        :param Mapping[str, _builtins.str] properties: map of properties set on the schema
        :param _builtins.str schema_id: the unique identifier of the schema
        :param _builtins.str storage_location: the storage location on the cloud.
        :param _builtins.str storage_root: storage root URL for managed tables within schema.
        :param _builtins.int updated_at: the timestamp of the last time changes were made to the schema
        :param _builtins.str updated_by: the identifier of the user who updated the schema last time
        """
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if catalog_type is not None:
            pulumi.set(__self__, "catalog_type", catalog_type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if effective_predictive_optimization_flag is not None:
            pulumi.set(__self__, "effective_predictive_optimization_flag", effective_predictive_optimization_flag)
        if enable_predictive_optimization is not None:
            pulumi.set(__self__, "enable_predictive_optimization", enable_predictive_optimization)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schema_id is not None:
            pulumi.set(__self__, "schema_id", schema_id)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if storage_root is not None:
            pulumi.set(__self__, "storage_root", storage_root)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        """
        indicates whether the principal is limited to retrieving metadata for the schema through the BROWSE privilege.
        """
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        the name of the catalog where the schema is.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter(name="catalogType")
    def catalog_type(self) -> Optional[_builtins.str]:
        """
        the type of the parent catalog.
        """
        return pulumi.get(self, "catalog_type")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        the comment attached to the volume
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        time at which this schema was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        username of schema creator.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="effectivePredictiveOptimizationFlag")
    def effective_predictive_optimization_flag(self) -> Optional['outputs.GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagResult']:
        """
        information about actual state of predictive optimization.
        """
        return pulumi.get(self, "effective_predictive_optimization_flag")

    @_builtins.property
    @pulumi.getter(name="enablePredictiveOptimization")
    def enable_predictive_optimization(self) -> Optional[_builtins.str]:
        """
        whether predictive optimization should be enabled for this object and objects under it.
        """
        return pulumi.get(self, "enable_predictive_optimization")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        the two-level (fully qualified) name of the schema
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        a fully qualified name of databricks_schema: *`catalog`.`schema`*
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who owns the schema
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        map of properties set on the schema
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional[_builtins.str]:
        """
        the unique identifier of the schema
        """
        return pulumi.get(self, "schema_id")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[_builtins.str]:
        """
        the storage location on the cloud.
        """
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="storageRoot")
    def storage_root(self) -> Optional[_builtins.str]:
        """
        storage root URL for managed tables within schema.
        """
        return pulumi.get(self, "storage_root")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        the timestamp of the last time changes were made to the schema
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who updated the schema last time
        """
        return pulumi.get(self, "updated_by")


@pulumi.output_type
class GetSchemaSchemaInfoEffectivePredictiveOptimizationFlagResult(dict):
    def __init__(__self__, *,
                 value: _builtins.str,
                 inherited_from_name: Optional[_builtins.str] = None,
                 inherited_from_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_name")

    @_builtins.property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_type")


@pulumi.output_type
class GetSchemasProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetServicePrincipalFederationPoliciesPolicyResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 oidc_policy: 'outputs.GetServicePrincipalFederationPoliciesPolicyOidcPolicyResult',
                 policy_id: _builtins.str,
                 service_principal_id: _builtins.int,
                 uid: _builtins.str,
                 update_time: _builtins.str):
        """
        :param _builtins.str create_time: (string) - Creation time of the federation policy
        :param _builtins.str description: (string) - Description of the federation policy
        :param _builtins.str name: (string) - Resource name for the federation policy. Example values include
               `accounts/<account-id>/federationPolicies/my-federation-policy` for Account Federation Policies, and
               `accounts/<account-id>/servicePrincipals/<service-principal-id>/federationPolicies/my-federation-policy`
               for Service Principal Federation Policies. Typically an output parameter, which does not need to be
               specified in create or update requests. If specified in a request, must match the value in the
               request URL
        :param 'GetServicePrincipalFederationPoliciesPolicyOidcPolicyArgs' oidc_policy: (OidcFederationPolicy)
        :param _builtins.str policy_id: (string) - The ID of the federation policy. Output only
        :param _builtins.int service_principal_id: The service principal id for the federation policy
        :param _builtins.str uid: (string) - Unique, immutable id of the federation policy
        :param _builtins.str update_time: (string) - Last update time of the federation policy
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "oidc_policy", oidc_policy)
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "uid", uid)
        pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        (string) - Creation time of the federation policy
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (string) - Description of the federation policy
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Resource name for the federation policy. Example values include
        `accounts/<account-id>/federationPolicies/my-federation-policy` for Account Federation Policies, and
        `accounts/<account-id>/servicePrincipals/<service-principal-id>/federationPolicies/my-federation-policy`
        for Service Principal Federation Policies. Typically an output parameter, which does not need to be
        specified in create or update requests. If specified in a request, must match the value in the
        request URL
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oidcPolicy")
    def oidc_policy(self) -> 'outputs.GetServicePrincipalFederationPoliciesPolicyOidcPolicyResult':
        """
        (OidcFederationPolicy)
        """
        return pulumi.get(self, "oidc_policy")

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        """
        (string) - The ID of the federation policy. Output only
        """
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.int:
        """
        The service principal id for the federation policy
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> _builtins.str:
        """
        (string) - Unique, immutable id of the federation policy
        """
        return pulumi.get(self, "uid")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        (string) - Last update time of the federation policy
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class GetServicePrincipalFederationPoliciesPolicyOidcPolicyResult(dict):
    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_json: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 subject_claim: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] audiences: (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
               The audience identifier is intended to represent the recipient of the token.
               Can be any non-empty string value. As long as the audience in the token matches
               at least one audience in the policy, the token is considered a match. If audiences
               is unspecified, defaults to your Databricks account id
        :param _builtins.str issuer: (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        :param _builtins.str jwks_json: (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
               Most use cases should not need to specify this field. If jwks_uri and jwks_json
               are both unspecified (recommended), Databricks automatically fetches the public
               keys from your issuers well known endpoint. Databricks strongly recommends
               relying on your issuers well known endpoint for discovering public keys
        :param _builtins.str jwks_uri: (string) - URL of the public keys used to validate the signature of federated tokens, in
               JWKS format. Most use cases should not need to specify this field. If jwks_uri
               and jwks_json are both unspecified (recommended), Databricks automatically
               fetches the public keys from your issuers well known endpoint. Databricks
               strongly recommends relying on your issuers well known endpoint for discovering
               public keys
        :param _builtins.str subject: (string) - The required token subject, as specified in the subject claim of federated tokens.
               Must be specified for service principal federation policies. Must not be specified
               for account federation policies
        :param _builtins.str subject_claim: (string) - The claim that contains the subject of the token. If unspecified, the default value
               is 'sub'
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_json is not None:
            pulumi.set(__self__, "jwks_json", jwks_json)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_claim is not None:
            pulumi.set(__self__, "subject_claim", subject_claim)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
        The audience identifier is intended to represent the recipient of the token.
        Can be any non-empty string value. As long as the audience in the token matches
        at least one audience in the policy, the token is considered a match. If audiences
        is unspecified, defaults to your Databricks account id
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksJson")
    def jwks_json(self) -> Optional[_builtins.str]:
        """
        (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
        Most use cases should not need to specify this field. If jwks_uri and jwks_json
        are both unspecified (recommended), Databricks automatically fetches the public
        keys from your issuers well known endpoint. Databricks strongly recommends
        relying on your issuers well known endpoint for discovering public keys
        """
        return pulumi.get(self, "jwks_json")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        (string) - URL of the public keys used to validate the signature of federated tokens, in
        JWKS format. Most use cases should not need to specify this field. If jwks_uri
        and jwks_json are both unspecified (recommended), Databricks automatically
        fetches the public keys from your issuers well known endpoint. Databricks
        strongly recommends relying on your issuers well known endpoint for discovering
        public keys
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        (string) - The required token subject, as specified in the subject claim of federated tokens.
        Must be specified for service principal federation policies. Must not be specified
        for account federation policies
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="subjectClaim")
    def subject_claim(self) -> Optional[_builtins.str]:
        """
        (string) - The claim that contains the subject of the token. If unspecified, the default value
        is 'sub'
        """
        return pulumi.get(self, "subject_claim")


@pulumi.output_type
class GetServicePrincipalFederationPolicyOidcPolicyResult(dict):
    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 issuer: Optional[_builtins.str] = None,
                 jwks_json: Optional[_builtins.str] = None,
                 jwks_uri: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None,
                 subject_claim: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] audiences: (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
               The audience identifier is intended to represent the recipient of the token.
               Can be any non-empty string value. As long as the audience in the token matches
               at least one audience in the policy, the token is considered a match. If audiences
               is unspecified, defaults to your Databricks account id
        :param _builtins.str issuer: (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        :param _builtins.str jwks_json: (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
               Most use cases should not need to specify this field. If jwks_uri and jwks_json
               are both unspecified (recommended), Databricks automatically fetches the public
               keys from your issuers well known endpoint. Databricks strongly recommends
               relying on your issuers well known endpoint for discovering public keys
        :param _builtins.str jwks_uri: (string) - URL of the public keys used to validate the signature of federated tokens, in
               JWKS format. Most use cases should not need to specify this field. If jwks_uri
               and jwks_json are both unspecified (recommended), Databricks automatically
               fetches the public keys from your issuers well known endpoint. Databricks
               strongly recommends relying on your issuers well known endpoint for discovering
               public keys
        :param _builtins.str subject: (string) - The required token subject, as specified in the subject claim of federated tokens.
               Must be specified for service principal federation policies. Must not be specified
               for account federation policies
        :param _builtins.str subject_claim: (string) - The claim that contains the subject of the token. If unspecified, the default value
               is 'sub'
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if jwks_json is not None:
            pulumi.set(__self__, "jwks_json", jwks_json)
        if jwks_uri is not None:
            pulumi.set(__self__, "jwks_uri", jwks_uri)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_claim is not None:
            pulumi.set(__self__, "subject_claim", subject_claim)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string) - The allowed token audiences, as specified in the 'aud' claim of federated tokens.
        The audience identifier is intended to represent the recipient of the token.
        Can be any non-empty string value. As long as the audience in the token matches
        at least one audience in the policy, the token is considered a match. If audiences
        is unspecified, defaults to your Databricks account id
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        (string) - The required token issuer, as specified in the 'iss' claim of federated tokens
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="jwksJson")
    def jwks_json(self) -> Optional[_builtins.str]:
        """
        (string) - The public keys used to validate the signature of federated tokens, in JWKS format.
        Most use cases should not need to specify this field. If jwks_uri and jwks_json
        are both unspecified (recommended), Databricks automatically fetches the public
        keys from your issuers well known endpoint. Databricks strongly recommends
        relying on your issuers well known endpoint for discovering public keys
        """
        return pulumi.get(self, "jwks_json")

    @_builtins.property
    @pulumi.getter(name="jwksUri")
    def jwks_uri(self) -> Optional[_builtins.str]:
        """
        (string) - URL of the public keys used to validate the signature of federated tokens, in
        JWKS format. Most use cases should not need to specify this field. If jwks_uri
        and jwks_json are both unspecified (recommended), Databricks automatically
        fetches the public keys from your issuers well known endpoint. Databricks
        strongly recommends relying on your issuers well known endpoint for discovering
        public keys
        """
        return pulumi.get(self, "jwks_uri")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        """
        (string) - The required token subject, as specified in the subject claim of federated tokens.
        Must be specified for service principal federation policies. Must not be specified
        for account federation policies
        """
        return pulumi.get(self, "subject")

    @_builtins.property
    @pulumi.getter(name="subjectClaim")
    def subject_claim(self) -> Optional[_builtins.str]:
        """
        (string) - The claim that contains the subject of the token. If unspecified, the default value
        is 'sub'
        """
        return pulumi.get(self, "subject_claim")


@pulumi.output_type
class GetServingEndpointsEndpointResult(dict):
    def __init__(__self__, *,
                 ai_gateways: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayResult']] = None,
                 budget_policy_id: Optional[_builtins.str] = None,
                 configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigResult']] = None,
                 creation_timestamp: Optional[_builtins.int] = None,
                 creator: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 last_updated_timestamp: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 states: Optional[Sequence['outputs.GetServingEndpointsEndpointStateResult']] = None,
                 tags: Optional[Sequence['outputs.GetServingEndpointsEndpointTagResult']] = None,
                 task: Optional[_builtins.str] = None,
                 usage_policy_id: Optional[_builtins.str] = None):
        """
        :param Sequence['GetServingEndpointsEndpointAiGatewayArgs'] ai_gateways: A block with AI Gateway configuration for the serving endpoint.
        :param Sequence['GetServingEndpointsEndpointConfigArgs'] configs: The model serving endpoint configuration.
        :param _builtins.str name: The name of the model serving endpoint.
        :param Sequence['GetServingEndpointsEndpointTagArgs'] tags: Tags to be attached to the serving endpoint and automatically propagated to billing logs.
        """
        if ai_gateways is not None:
            pulumi.set(__self__, "ai_gateways", ai_gateways)
        if budget_policy_id is not None:
            pulumi.set(__self__, "budget_policy_id", budget_policy_id)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if creation_timestamp is not None:
            pulumi.set(__self__, "creation_timestamp", creation_timestamp)
        if creator is not None:
            pulumi.set(__self__, "creator", creator)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_updated_timestamp is not None:
            pulumi.set(__self__, "last_updated_timestamp", last_updated_timestamp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if states is not None:
            pulumi.set(__self__, "states", states)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task is not None:
            pulumi.set(__self__, "task", task)
        if usage_policy_id is not None:
            pulumi.set(__self__, "usage_policy_id", usage_policy_id)

    @_builtins.property
    @pulumi.getter(name="aiGateways")
    def ai_gateways(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayResult']]:
        """
        A block with AI Gateway configuration for the serving endpoint.
        """
        return pulumi.get(self, "ai_gateways")

    @_builtins.property
    @pulumi.getter(name="budgetPolicyId")
    def budget_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "budget_policy_id")

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigResult']]:
        """
        The model serving endpoint configuration.
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter(name="creationTimestamp")
    def creation_timestamp(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "creation_timestamp")

    @_builtins.property
    @pulumi.getter
    def creator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "creator")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedTimestamp")
    def last_updated_timestamp(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "last_updated_timestamp")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the model serving endpoint.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def states(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointStateResult']]:
        return pulumi.get(self, "states")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointTagResult']]:
        """
        Tags to be attached to the serving endpoint and automatically propagated to billing logs.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def task(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "task")

    @_builtins.property
    @pulumi.getter(name="usagePolicyId")
    def usage_policy_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "usage_policy_id")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayResult(dict):
    def __init__(__self__, *,
                 fallback_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayFallbackConfigResult']] = None,
                 guardrails: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailResult']] = None,
                 inference_table_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayInferenceTableConfigResult']] = None,
                 rate_limits: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayRateLimitResult']] = None,
                 usage_tracking_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayUsageTrackingConfigResult']] = None):
        """
        :param Sequence['GetServingEndpointsEndpointAiGatewayRateLimitArgs'] rate_limits: A list of rate limit blocks to be applied to the serving endpoint.
        """
        if fallback_configs is not None:
            pulumi.set(__self__, "fallback_configs", fallback_configs)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if inference_table_configs is not None:
            pulumi.set(__self__, "inference_table_configs", inference_table_configs)
        if rate_limits is not None:
            pulumi.set(__self__, "rate_limits", rate_limits)
        if usage_tracking_configs is not None:
            pulumi.set(__self__, "usage_tracking_configs", usage_tracking_configs)

    @_builtins.property
    @pulumi.getter(name="fallbackConfigs")
    def fallback_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayFallbackConfigResult']]:
        return pulumi.get(self, "fallback_configs")

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailResult']]:
        return pulumi.get(self, "guardrails")

    @_builtins.property
    @pulumi.getter(name="inferenceTableConfigs")
    def inference_table_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayInferenceTableConfigResult']]:
        return pulumi.get(self, "inference_table_configs")

    @_builtins.property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayRateLimitResult']]:
        """
        A list of rate limit blocks to be applied to the serving endpoint.
        """
        return pulumi.get(self, "rate_limits")

    @_builtins.property
    @pulumi.getter(name="usageTrackingConfigs")
    def usage_tracking_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayUsageTrackingConfigResult']]:
        return pulumi.get(self, "usage_tracking_configs")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayFallbackConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayGuardrailResult(dict):
    def __init__(__self__, *,
                 input_properties: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyResult']] = None,
                 outputs: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailOutputResult']] = None):
        if input_properties is not None:
            pulumi.set(__self__, "input_properties", input_properties)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @_builtins.property
    @pulumi.getter(name="inputProperties")
    def input_properties(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyResult']]:
        return pulumi.get(self, "input_properties")

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailOutputResult']]:
        return pulumi.get(self, "outputs")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyResult(dict):
    def __init__(__self__, *,
                 invalid_keywords: Optional[Sequence[_builtins.str]] = None,
                 piis: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyPiiResult']] = None,
                 safety: Optional[_builtins.bool] = None,
                 valid_topics: Optional[Sequence[_builtins.str]] = None):
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if piis is not None:
            pulumi.set(__self__, "piis", piis)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @_builtins.property
    @pulumi.getter(name="invalidKeywords")
    def invalid_keywords(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "invalid_keywords")

    @_builtins.property
    @pulumi.getter
    def piis(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyPiiResult']]:
        return pulumi.get(self, "piis")

    @_builtins.property
    @pulumi.getter
    def safety(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safety")

    @_builtins.property
    @pulumi.getter(name="validTopics")
    def valid_topics(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "valid_topics")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayGuardrailInputPropertyPiiResult(dict):
    def __init__(__self__, *,
                 behavior: Optional[_builtins.str] = None):
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "behavior")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayGuardrailOutputResult(dict):
    def __init__(__self__, *,
                 invalid_keywords: Optional[Sequence[_builtins.str]] = None,
                 piis: Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailOutputPiiResult']] = None,
                 safety: Optional[_builtins.bool] = None,
                 valid_topics: Optional[Sequence[_builtins.str]] = None):
        if invalid_keywords is not None:
            pulumi.set(__self__, "invalid_keywords", invalid_keywords)
        if piis is not None:
            pulumi.set(__self__, "piis", piis)
        if safety is not None:
            pulumi.set(__self__, "safety", safety)
        if valid_topics is not None:
            pulumi.set(__self__, "valid_topics", valid_topics)

    @_builtins.property
    @pulumi.getter(name="invalidKeywords")
    def invalid_keywords(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "invalid_keywords")

    @_builtins.property
    @pulumi.getter
    def piis(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointAiGatewayGuardrailOutputPiiResult']]:
        return pulumi.get(self, "piis")

    @_builtins.property
    @pulumi.getter
    def safety(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safety")

    @_builtins.property
    @pulumi.getter(name="validTopics")
    def valid_topics(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "valid_topics")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayGuardrailOutputPiiResult(dict):
    def __init__(__self__, *,
                 behavior: Optional[_builtins.str] = None):
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "behavior")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayInferenceTableConfigResult(dict):
    def __init__(__self__, *,
                 catalog_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 schema_name: Optional[_builtins.str] = None,
                 table_name_prefix: Optional[_builtins.str] = None):
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if table_name_prefix is not None:
            pulumi.set(__self__, "table_name_prefix", table_name_prefix)

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="tableNamePrefix")
    def table_name_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table_name_prefix")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayRateLimitResult(dict):
    def __init__(__self__, *,
                 renewal_period: _builtins.str,
                 calls: Optional[_builtins.int] = None,
                 key: Optional[_builtins.str] = None,
                 principal: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None):
        pulumi.set(__self__, "renewal_period", renewal_period)
        if calls is not None:
            pulumi.set(__self__, "calls", calls)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)

    @_builtins.property
    @pulumi.getter(name="renewalPeriod")
    def renewal_period(self) -> _builtins.str:
        return pulumi.get(self, "renewal_period")

    @_builtins.property
    @pulumi.getter
    def calls(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "calls")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "principal")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "tokens")


@pulumi.output_type
class GetServingEndpointsEndpointAiGatewayUsageTrackingConfigResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetServingEndpointsEndpointConfigResult(dict):
    def __init__(__self__, *,
                 served_entities: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityResult']] = None,
                 served_models: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedModelResult']] = None):
        if served_entities is not None:
            pulumi.set(__self__, "served_entities", served_entities)
        if served_models is not None:
            pulumi.set(__self__, "served_models", served_models)

    @_builtins.property
    @pulumi.getter(name="servedEntities")
    def served_entities(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityResult']]:
        return pulumi.get(self, "served_entities")

    @_builtins.property
    @pulumi.getter(name="servedModels")
    def served_models(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedModelResult']]:
        return pulumi.get(self, "served_models")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityResult(dict):
    def __init__(__self__, *,
                 entity_name: Optional[_builtins.str] = None,
                 entity_version: Optional[_builtins.str] = None,
                 external_models: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelResult']] = None,
                 foundation_models: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityFoundationModelResult']] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the model serving endpoint.
        """
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if entity_version is not None:
            pulumi.set(__self__, "entity_version", entity_version)
        if external_models is not None:
            pulumi.set(__self__, "external_models", external_models)
        if foundation_models is not None:
            pulumi.set(__self__, "foundation_models", foundation_models)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "entity_name")

    @_builtins.property
    @pulumi.getter(name="entityVersion")
    def entity_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "entity_version")

    @_builtins.property
    @pulumi.getter(name="externalModels")
    def external_models(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelResult']]:
        return pulumi.get(self, "external_models")

    @_builtins.property
    @pulumi.getter(name="foundationModels")
    def foundation_models(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityFoundationModelResult']]:
        return pulumi.get(self, "foundation_models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the model serving endpoint.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 provider: _builtins.str,
                 task: _builtins.str,
                 ai21labs_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelAi21labsConfigResult']] = None,
                 amazon_bedrock_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelAmazonBedrockConfigResult']] = None,
                 anthropic_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelAnthropicConfigResult']] = None,
                 cohere_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCohereConfigResult']] = None,
                 custom_provider_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigResult']] = None,
                 databricks_model_serving_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelDatabricksModelServingConfigResult']] = None,
                 google_cloud_vertex_ai_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelGoogleCloudVertexAiConfigResult']] = None,
                 openai_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelOpenaiConfigResult']] = None,
                 palm_configs: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelPalmConfigResult']] = None):
        """
        :param _builtins.str name: The name of the model serving endpoint.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "task", task)
        if ai21labs_configs is not None:
            pulumi.set(__self__, "ai21labs_configs", ai21labs_configs)
        if amazon_bedrock_configs is not None:
            pulumi.set(__self__, "amazon_bedrock_configs", amazon_bedrock_configs)
        if anthropic_configs is not None:
            pulumi.set(__self__, "anthropic_configs", anthropic_configs)
        if cohere_configs is not None:
            pulumi.set(__self__, "cohere_configs", cohere_configs)
        if custom_provider_configs is not None:
            pulumi.set(__self__, "custom_provider_configs", custom_provider_configs)
        if databricks_model_serving_configs is not None:
            pulumi.set(__self__, "databricks_model_serving_configs", databricks_model_serving_configs)
        if google_cloud_vertex_ai_configs is not None:
            pulumi.set(__self__, "google_cloud_vertex_ai_configs", google_cloud_vertex_ai_configs)
        if openai_configs is not None:
            pulumi.set(__self__, "openai_configs", openai_configs)
        if palm_configs is not None:
            pulumi.set(__self__, "palm_configs", palm_configs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the model serving endpoint.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def task(self) -> _builtins.str:
        return pulumi.get(self, "task")

    @_builtins.property
    @pulumi.getter(name="ai21labsConfigs")
    def ai21labs_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelAi21labsConfigResult']]:
        return pulumi.get(self, "ai21labs_configs")

    @_builtins.property
    @pulumi.getter(name="amazonBedrockConfigs")
    def amazon_bedrock_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelAmazonBedrockConfigResult']]:
        return pulumi.get(self, "amazon_bedrock_configs")

    @_builtins.property
    @pulumi.getter(name="anthropicConfigs")
    def anthropic_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelAnthropicConfigResult']]:
        return pulumi.get(self, "anthropic_configs")

    @_builtins.property
    @pulumi.getter(name="cohereConfigs")
    def cohere_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCohereConfigResult']]:
        return pulumi.get(self, "cohere_configs")

    @_builtins.property
    @pulumi.getter(name="customProviderConfigs")
    def custom_provider_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigResult']]:
        return pulumi.get(self, "custom_provider_configs")

    @_builtins.property
    @pulumi.getter(name="databricksModelServingConfigs")
    def databricks_model_serving_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelDatabricksModelServingConfigResult']]:
        return pulumi.get(self, "databricks_model_serving_configs")

    @_builtins.property
    @pulumi.getter(name="googleCloudVertexAiConfigs")
    def google_cloud_vertex_ai_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelGoogleCloudVertexAiConfigResult']]:
        return pulumi.get(self, "google_cloud_vertex_ai_configs")

    @_builtins.property
    @pulumi.getter(name="openaiConfigs")
    def openai_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelOpenaiConfigResult']]:
        return pulumi.get(self, "openai_configs")

    @_builtins.property
    @pulumi.getter(name="palmConfigs")
    def palm_configs(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelPalmConfigResult']]:
        return pulumi.get(self, "palm_configs")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelAi21labsConfigResult(dict):
    def __init__(__self__, *,
                 ai21labs_api_key: Optional[_builtins.str] = None,
                 ai21labs_api_key_plaintext: Optional[_builtins.str] = None):
        if ai21labs_api_key is not None:
            pulumi.set(__self__, "ai21labs_api_key", ai21labs_api_key)
        if ai21labs_api_key_plaintext is not None:
            pulumi.set(__self__, "ai21labs_api_key_plaintext", ai21labs_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="ai21labsApiKey")
    def ai21labs_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ai21labs_api_key")

    @_builtins.property
    @pulumi.getter(name="ai21labsApiKeyPlaintext")
    def ai21labs_api_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ai21labs_api_key_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelAmazonBedrockConfigResult(dict):
    def __init__(__self__, *,
                 aws_region: _builtins.str,
                 bedrock_provider: _builtins.str,
                 aws_access_key_id: Optional[_builtins.str] = None,
                 aws_access_key_id_plaintext: Optional[_builtins.str] = None,
                 aws_secret_access_key: Optional[_builtins.str] = None,
                 aws_secret_access_key_plaintext: Optional[_builtins.str] = None,
                 instance_profile_arn: Optional[_builtins.str] = None):
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "bedrock_provider", bedrock_provider)
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_access_key_id_plaintext is not None:
            pulumi.set(__self__, "aws_access_key_id_plaintext", aws_access_key_id_plaintext)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_secret_access_key_plaintext is not None:
            pulumi.set(__self__, "aws_secret_access_key_plaintext", aws_secret_access_key_plaintext)
        if instance_profile_arn is not None:
            pulumi.set(__self__, "instance_profile_arn", instance_profile_arn)

    @_builtins.property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> _builtins.str:
        return pulumi.get(self, "aws_region")

    @_builtins.property
    @pulumi.getter(name="bedrockProvider")
    def bedrock_provider(self) -> _builtins.str:
        return pulumi.get(self, "bedrock_provider")

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyIdPlaintext")
    def aws_access_key_id_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_access_key_id_plaintext")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKeyPlaintext")
    def aws_secret_access_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_secret_access_key_plaintext")

    @_builtins.property
    @pulumi.getter(name="instanceProfileArn")
    def instance_profile_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instance_profile_arn")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelAnthropicConfigResult(dict):
    def __init__(__self__, *,
                 anthropic_api_key: Optional[_builtins.str] = None,
                 anthropic_api_key_plaintext: Optional[_builtins.str] = None):
        if anthropic_api_key is not None:
            pulumi.set(__self__, "anthropic_api_key", anthropic_api_key)
        if anthropic_api_key_plaintext is not None:
            pulumi.set(__self__, "anthropic_api_key_plaintext", anthropic_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="anthropicApiKey")
    def anthropic_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "anthropic_api_key")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeyPlaintext")
    def anthropic_api_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "anthropic_api_key_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelCohereConfigResult(dict):
    def __init__(__self__, *,
                 cohere_api_base: Optional[_builtins.str] = None,
                 cohere_api_key: Optional[_builtins.str] = None,
                 cohere_api_key_plaintext: Optional[_builtins.str] = None):
        if cohere_api_base is not None:
            pulumi.set(__self__, "cohere_api_base", cohere_api_base)
        if cohere_api_key is not None:
            pulumi.set(__self__, "cohere_api_key", cohere_api_key)
        if cohere_api_key_plaintext is not None:
            pulumi.set(__self__, "cohere_api_key_plaintext", cohere_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="cohereApiBase")
    def cohere_api_base(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cohere_api_base")

    @_builtins.property
    @pulumi.getter(name="cohereApiKey")
    def cohere_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cohere_api_key")

    @_builtins.property
    @pulumi.getter(name="cohereApiKeyPlaintext")
    def cohere_api_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cohere_api_key_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigResult(dict):
    def __init__(__self__, *,
                 custom_provider_url: _builtins.str,
                 api_key_auths: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigApiKeyAuthResult']] = None,
                 bearer_token_auths: Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuthResult']] = None):
        pulumi.set(__self__, "custom_provider_url", custom_provider_url)
        if api_key_auths is not None:
            pulumi.set(__self__, "api_key_auths", api_key_auths)
        if bearer_token_auths is not None:
            pulumi.set(__self__, "bearer_token_auths", bearer_token_auths)

    @_builtins.property
    @pulumi.getter(name="customProviderUrl")
    def custom_provider_url(self) -> _builtins.str:
        return pulumi.get(self, "custom_provider_url")

    @_builtins.property
    @pulumi.getter(name="apiKeyAuths")
    def api_key_auths(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigApiKeyAuthResult']]:
        return pulumi.get(self, "api_key_auths")

    @_builtins.property
    @pulumi.getter(name="bearerTokenAuths")
    def bearer_token_auths(self) -> Optional[Sequence['outputs.GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuthResult']]:
        return pulumi.get(self, "bearer_token_auths")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigApiKeyAuthResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None,
                 value_plaintext: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_plaintext is not None:
            pulumi.set(__self__, "value_plaintext", value_plaintext)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="valuePlaintext")
    def value_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelCustomProviderConfigBearerTokenAuthResult(dict):
    def __init__(__self__, *,
                 token: Optional[_builtins.str] = None,
                 token_plaintext: Optional[_builtins.str] = None):
        if token is not None:
            pulumi.set(__self__, "token", token)
        if token_plaintext is not None:
            pulumi.set(__self__, "token_plaintext", token_plaintext)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="tokenPlaintext")
    def token_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelDatabricksModelServingConfigResult(dict):
    def __init__(__self__, *,
                 databricks_workspace_url: _builtins.str,
                 databricks_api_token: Optional[_builtins.str] = None,
                 databricks_api_token_plaintext: Optional[_builtins.str] = None):
        pulumi.set(__self__, "databricks_workspace_url", databricks_workspace_url)
        if databricks_api_token is not None:
            pulumi.set(__self__, "databricks_api_token", databricks_api_token)
        if databricks_api_token_plaintext is not None:
            pulumi.set(__self__, "databricks_api_token_plaintext", databricks_api_token_plaintext)

    @_builtins.property
    @pulumi.getter(name="databricksWorkspaceUrl")
    def databricks_workspace_url(self) -> _builtins.str:
        return pulumi.get(self, "databricks_workspace_url")

    @_builtins.property
    @pulumi.getter(name="databricksApiToken")
    def databricks_api_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "databricks_api_token")

    @_builtins.property
    @pulumi.getter(name="databricksApiTokenPlaintext")
    def databricks_api_token_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "databricks_api_token_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelGoogleCloudVertexAiConfigResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 private_key: Optional[_builtins.str] = None,
                 private_key_plaintext: Optional[_builtins.str] = None):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_plaintext is not None:
            pulumi.set(__self__, "private_key_plaintext", private_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="privateKeyPlaintext")
    def private_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_key_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelOpenaiConfigResult(dict):
    def __init__(__self__, *,
                 microsoft_entra_client_id: Optional[_builtins.str] = None,
                 microsoft_entra_client_secret: Optional[_builtins.str] = None,
                 microsoft_entra_client_secret_plaintext: Optional[_builtins.str] = None,
                 microsoft_entra_tenant_id: Optional[_builtins.str] = None,
                 openai_api_base: Optional[_builtins.str] = None,
                 openai_api_key: Optional[_builtins.str] = None,
                 openai_api_key_plaintext: Optional[_builtins.str] = None,
                 openai_api_type: Optional[_builtins.str] = None,
                 openai_api_version: Optional[_builtins.str] = None,
                 openai_deployment_name: Optional[_builtins.str] = None,
                 openai_organization: Optional[_builtins.str] = None):
        if microsoft_entra_client_id is not None:
            pulumi.set(__self__, "microsoft_entra_client_id", microsoft_entra_client_id)
        if microsoft_entra_client_secret is not None:
            pulumi.set(__self__, "microsoft_entra_client_secret", microsoft_entra_client_secret)
        if microsoft_entra_client_secret_plaintext is not None:
            pulumi.set(__self__, "microsoft_entra_client_secret_plaintext", microsoft_entra_client_secret_plaintext)
        if microsoft_entra_tenant_id is not None:
            pulumi.set(__self__, "microsoft_entra_tenant_id", microsoft_entra_tenant_id)
        if openai_api_base is not None:
            pulumi.set(__self__, "openai_api_base", openai_api_base)
        if openai_api_key is not None:
            pulumi.set(__self__, "openai_api_key", openai_api_key)
        if openai_api_key_plaintext is not None:
            pulumi.set(__self__, "openai_api_key_plaintext", openai_api_key_plaintext)
        if openai_api_type is not None:
            pulumi.set(__self__, "openai_api_type", openai_api_type)
        if openai_api_version is not None:
            pulumi.set(__self__, "openai_api_version", openai_api_version)
        if openai_deployment_name is not None:
            pulumi.set(__self__, "openai_deployment_name", openai_deployment_name)
        if openai_organization is not None:
            pulumi.set(__self__, "openai_organization", openai_organization)

    @_builtins.property
    @pulumi.getter(name="microsoftEntraClientId")
    def microsoft_entra_client_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "microsoft_entra_client_id")

    @_builtins.property
    @pulumi.getter(name="microsoftEntraClientSecret")
    def microsoft_entra_client_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "microsoft_entra_client_secret")

    @_builtins.property
    @pulumi.getter(name="microsoftEntraClientSecretPlaintext")
    def microsoft_entra_client_secret_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "microsoft_entra_client_secret_plaintext")

    @_builtins.property
    @pulumi.getter(name="microsoftEntraTenantId")
    def microsoft_entra_tenant_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "microsoft_entra_tenant_id")

    @_builtins.property
    @pulumi.getter(name="openaiApiBase")
    def openai_api_base(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_api_base")

    @_builtins.property
    @pulumi.getter(name="openaiApiKey")
    def openai_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_api_key")

    @_builtins.property
    @pulumi.getter(name="openaiApiKeyPlaintext")
    def openai_api_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_api_key_plaintext")

    @_builtins.property
    @pulumi.getter(name="openaiApiType")
    def openai_api_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_api_type")

    @_builtins.property
    @pulumi.getter(name="openaiApiVersion")
    def openai_api_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_api_version")

    @_builtins.property
    @pulumi.getter(name="openaiDeploymentName")
    def openai_deployment_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_deployment_name")

    @_builtins.property
    @pulumi.getter(name="openaiOrganization")
    def openai_organization(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "openai_organization")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityExternalModelPalmConfigResult(dict):
    def __init__(__self__, *,
                 palm_api_key: Optional[_builtins.str] = None,
                 palm_api_key_plaintext: Optional[_builtins.str] = None):
        if palm_api_key is not None:
            pulumi.set(__self__, "palm_api_key", palm_api_key)
        if palm_api_key_plaintext is not None:
            pulumi.set(__self__, "palm_api_key_plaintext", palm_api_key_plaintext)

    @_builtins.property
    @pulumi.getter(name="palmApiKey")
    def palm_api_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "palm_api_key")

    @_builtins.property
    @pulumi.getter(name="palmApiKeyPlaintext")
    def palm_api_key_plaintext(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "palm_api_key_plaintext")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedEntityFoundationModelResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 docs: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the model serving endpoint.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if docs is not None:
            pulumi.set(__self__, "docs", docs)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def docs(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "docs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the model serving endpoint.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServingEndpointsEndpointConfigServedModelResult(dict):
    def __init__(__self__, *,
                 model_name: Optional[_builtins.str] = None,
                 model_version: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the model serving endpoint.
        """
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if model_version is not None:
            pulumi.set(__self__, "model_version", model_version)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "model_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the model serving endpoint.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServingEndpointsEndpointStateResult(dict):
    def __init__(__self__, *,
                 config_update: Optional[_builtins.str] = None,
                 ready: Optional[_builtins.str] = None):
        if config_update is not None:
            pulumi.set(__self__, "config_update", config_update)
        if ready is not None:
            pulumi.set(__self__, "ready", ready)

    @_builtins.property
    @pulumi.getter(name="configUpdate")
    def config_update(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "config_update")

    @_builtins.property
    @pulumi.getter
    def ready(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ready")


@pulumi.output_type
class GetServingEndpointsEndpointTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServingEndpointsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetShareObjectResult(dict):
    def __init__(__self__, *,
                 added_at: _builtins.int,
                 added_by: _builtins.str,
                 effective_cdf_enabled: _builtins.bool,
                 effective_history_data_sharing_status: _builtins.str,
                 effective_shared_as: _builtins.str,
                 effective_start_version: _builtins.int,
                 effective_string_shared_as: _builtins.str,
                 name: _builtins.str,
                 status: _builtins.str,
                 cdf_enabled: Optional[_builtins.bool] = None,
                 comment: Optional[_builtins.str] = None,
                 content: Optional[_builtins.str] = None,
                 data_object_type: Optional[_builtins.str] = None,
                 history_data_sharing_status: Optional[_builtins.str] = None,
                 partitions: Optional[Sequence['outputs.GetShareObjectPartitionResult']] = None,
                 shared_as: Optional[_builtins.str] = None,
                 start_version: Optional[_builtins.int] = None,
                 string_shared_as: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the share
        :param _builtins.str comment: Description about the object.
        :param _builtins.str data_object_type: Type of the object.
        """
        pulumi.set(__self__, "added_at", added_at)
        pulumi.set(__self__, "added_by", added_by)
        pulumi.set(__self__, "effective_cdf_enabled", effective_cdf_enabled)
        pulumi.set(__self__, "effective_history_data_sharing_status", effective_history_data_sharing_status)
        pulumi.set(__self__, "effective_shared_as", effective_shared_as)
        pulumi.set(__self__, "effective_start_version", effective_start_version)
        pulumi.set(__self__, "effective_string_shared_as", effective_string_shared_as)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        if cdf_enabled is not None:
            pulumi.set(__self__, "cdf_enabled", cdf_enabled)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if data_object_type is not None:
            pulumi.set(__self__, "data_object_type", data_object_type)
        if history_data_sharing_status is not None:
            pulumi.set(__self__, "history_data_sharing_status", history_data_sharing_status)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if shared_as is not None:
            pulumi.set(__self__, "shared_as", shared_as)
        if start_version is not None:
            pulumi.set(__self__, "start_version", start_version)
        if string_shared_as is not None:
            pulumi.set(__self__, "string_shared_as", string_shared_as)

    @_builtins.property
    @pulumi.getter(name="addedAt")
    def added_at(self) -> _builtins.int:
        return pulumi.get(self, "added_at")

    @_builtins.property
    @pulumi.getter(name="addedBy")
    def added_by(self) -> _builtins.str:
        return pulumi.get(self, "added_by")

    @_builtins.property
    @pulumi.getter(name="effectiveCdfEnabled")
    def effective_cdf_enabled(self) -> _builtins.bool:
        return pulumi.get(self, "effective_cdf_enabled")

    @_builtins.property
    @pulumi.getter(name="effectiveHistoryDataSharingStatus")
    def effective_history_data_sharing_status(self) -> _builtins.str:
        return pulumi.get(self, "effective_history_data_sharing_status")

    @_builtins.property
    @pulumi.getter(name="effectiveSharedAs")
    def effective_shared_as(self) -> _builtins.str:
        return pulumi.get(self, "effective_shared_as")

    @_builtins.property
    @pulumi.getter(name="effectiveStartVersion")
    def effective_start_version(self) -> _builtins.int:
        return pulumi.get(self, "effective_start_version")

    @_builtins.property
    @pulumi.getter(name="effectiveStringSharedAs")
    def effective_string_shared_as(self) -> _builtins.str:
        return pulumi.get(self, "effective_string_shared_as")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the share
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="cdfEnabled")
    def cdf_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cdf_enabled")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Description about the object.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="dataObjectType")
    def data_object_type(self) -> Optional[_builtins.str]:
        """
        Type of the object.
        """
        return pulumi.get(self, "data_object_type")

    @_builtins.property
    @pulumi.getter(name="historyDataSharingStatus")
    def history_data_sharing_status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "history_data_sharing_status")

    @_builtins.property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.GetShareObjectPartitionResult']]:
        return pulumi.get(self, "partitions")

    @_builtins.property
    @pulumi.getter(name="sharedAs")
    def shared_as(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "shared_as")

    @_builtins.property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "start_version")

    @_builtins.property
    @pulumi.getter(name="stringSharedAs")
    def string_shared_as(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "string_shared_as")


@pulumi.output_type
class GetShareObjectPartitionResult(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.GetShareObjectPartitionValueResult']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.GetShareObjectPartitionValueResult']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetShareObjectPartitionValueResult(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 op: Optional[_builtins.str] = None,
                 recipient_property_key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the share
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if recipient_property_key is not None:
            pulumi.set(__self__, "recipient_property_key", recipient_property_key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the share
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def op(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "op")

    @_builtins.property
    @pulumi.getter(name="recipientPropertyKey")
    def recipient_property_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "recipient_property_key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetShareProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetSharesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetSparkVersionProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetSqlWarehouseChannelResult(dict):
    def __init__(__self__, *,
                 dbsql_version: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the SQL warehouse to search (case-sensitive).
        """
        if dbsql_version is not None:
            pulumi.set(__self__, "dbsql_version", dbsql_version)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dbsqlVersion")
    def dbsql_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dbsql_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the SQL warehouse to search (case-sensitive).
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSqlWarehouseHealthResult(dict):
    def __init__(__self__, *,
                 details: Optional[_builtins.str] = None,
                 failure_reason: Optional['outputs.GetSqlWarehouseHealthFailureReasonResult'] = None,
                 message: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 summary: Optional[_builtins.str] = None):
        if details is not None:
            pulumi.set(__self__, "details", details)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional['outputs.GetSqlWarehouseHealthFailureReasonResult']:
        return pulumi.get(self, "failure_reason")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "summary")


@pulumi.output_type
class GetSqlWarehouseHealthFailureReasonResult(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSqlWarehouseOdbcParamsResult(dict):
    def __init__(__self__, *,
                 hostname: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetSqlWarehouseProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetSqlWarehouseTagsResult(dict):
    def __init__(__self__, *,
                 custom_tags: Optional[Sequence['outputs.GetSqlWarehouseTagsCustomTagResult']] = None):
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Sequence['outputs.GetSqlWarehouseTagsCustomTagResult']]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetSqlWarehouseTagsCustomTagResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSqlWarehousesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetStorageCredentialProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetStorageCredentialStorageCredentialInfoResult(dict):
    def __init__(__self__, *,
                 aws_iam_role: Optional['outputs.GetStorageCredentialStorageCredentialInfoAwsIamRoleResult'] = None,
                 azure_managed_identity: Optional['outputs.GetStorageCredentialStorageCredentialInfoAzureManagedIdentityResult'] = None,
                 azure_service_principal: Optional['outputs.GetStorageCredentialStorageCredentialInfoAzureServicePrincipalResult'] = None,
                 cloudflare_api_token: Optional['outputs.GetStorageCredentialStorageCredentialInfoCloudflareApiTokenResult'] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 databricks_gcp_service_account: Optional['outputs.GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountResult'] = None,
                 full_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 isolation_mode: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None,
                 used_for_managed_storage: Optional[_builtins.bool] = None):
        """
        :param 'GetStorageCredentialStorageCredentialInfoAwsIamRoleArgs' aws_iam_role: credential details for AWS:
        :param 'GetStorageCredentialStorageCredentialInfoAzureManagedIdentityArgs' azure_managed_identity: managed identity credential details for Azure
        :param 'GetStorageCredentialStorageCredentialInfoAzureServicePrincipalArgs' azure_service_principal: service principal credential details for Azure:
        :param _builtins.int created_at: Time at which this catalog was created, in epoch milliseconds.
        :param _builtins.str created_by: Username of catalog creator.
        :param 'GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountArgs' databricks_gcp_service_account: credential details for GCP:
        :param _builtins.str id: Unique ID of storage credential.
        :param _builtins.str metastore_id: Unique identifier of the parent Metastore.
        :param _builtins.str name: The name of the storage credential
        :param _builtins.str owner: Username/groupname/sp application_id of the storage credential owner.
        :param _builtins.bool read_only: Indicates whether the storage credential is only usable for read operations.
        :param _builtins.int updated_at: Time at which this catalog was last modified, in epoch milliseconds.
        :param _builtins.str updated_by: Username of user who last modified catalog.
        """
        if aws_iam_role is not None:
            pulumi.set(__self__, "aws_iam_role", aws_iam_role)
        if azure_managed_identity is not None:
            pulumi.set(__self__, "azure_managed_identity", azure_managed_identity)
        if azure_service_principal is not None:
            pulumi.set(__self__, "azure_service_principal", azure_service_principal)
        if cloudflare_api_token is not None:
            pulumi.set(__self__, "cloudflare_api_token", cloudflare_api_token)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if databricks_gcp_service_account is not None:
            pulumi.set(__self__, "databricks_gcp_service_account", databricks_gcp_service_account)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if isolation_mode is not None:
            pulumi.set(__self__, "isolation_mode", isolation_mode)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if used_for_managed_storage is not None:
            pulumi.set(__self__, "used_for_managed_storage", used_for_managed_storage)

    @_builtins.property
    @pulumi.getter(name="awsIamRole")
    def aws_iam_role(self) -> Optional['outputs.GetStorageCredentialStorageCredentialInfoAwsIamRoleResult']:
        """
        credential details for AWS:
        """
        return pulumi.get(self, "aws_iam_role")

    @_builtins.property
    @pulumi.getter(name="azureManagedIdentity")
    def azure_managed_identity(self) -> Optional['outputs.GetStorageCredentialStorageCredentialInfoAzureManagedIdentityResult']:
        """
        managed identity credential details for Azure
        """
        return pulumi.get(self, "azure_managed_identity")

    @_builtins.property
    @pulumi.getter(name="azureServicePrincipal")
    def azure_service_principal(self) -> Optional['outputs.GetStorageCredentialStorageCredentialInfoAzureServicePrincipalResult']:
        """
        service principal credential details for Azure:
        """
        return pulumi.get(self, "azure_service_principal")

    @_builtins.property
    @pulumi.getter(name="cloudflareApiToken")
    def cloudflare_api_token(self) -> Optional['outputs.GetStorageCredentialStorageCredentialInfoCloudflareApiTokenResult']:
        return pulumi.get(self, "cloudflare_api_token")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        Time at which this catalog was created, in epoch milliseconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Username of catalog creator.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="databricksGcpServiceAccount")
    def databricks_gcp_service_account(self) -> Optional['outputs.GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountResult']:
        """
        credential details for GCP:
        """
        return pulumi.get(self, "databricks_gcp_service_account")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique ID of storage credential.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isolationMode")
    def isolation_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "isolation_mode")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the parent Metastore.
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the storage credential
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Username/groupname/sp application_id of the storage credential owner.
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the storage credential is only usable for read operations.
        """
        return pulumi.get(self, "read_only")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        Time at which this catalog was last modified, in epoch milliseconds.
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        Username of user who last modified catalog.
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter(name="usedForManagedStorage")
    def used_for_managed_storage(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "used_for_managed_storage")


@pulumi.output_type
class GetStorageCredentialStorageCredentialInfoAwsIamRoleResult(dict):
    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 external_id: Optional[_builtins.str] = None,
                 unity_catalog_iam_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str role_arn: The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        :param _builtins.str external_id: (output only) - The external ID used in role assumption to prevent confused deputy problem.
        :param _builtins.str unity_catalog_iam_arn: (output only) - The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if unity_catalog_iam_arn is not None:
            pulumi.set(__self__, "unity_catalog_iam_arn", unity_catalog_iam_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the AWS IAM role for S3 data access, of the form `arn:aws:iam::1234567890:role/MyRole-AJJHDSKSDF`
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        (output only) - The external ID used in role assumption to prevent confused deputy problem.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="unityCatalogIamArn")
    def unity_catalog_iam_arn(self) -> Optional[_builtins.str]:
        """
        (output only) - The Amazon Resource Name (ARN) of the AWS IAM user managed by Databricks. This is the identity that is going to assume the AWS IAM role.
        """
        return pulumi.get(self, "unity_catalog_iam_arn")


@pulumi.output_type
class GetStorageCredentialStorageCredentialInfoAzureManagedIdentityResult(dict):
    def __init__(__self__, *,
                 access_connector_id: _builtins.str,
                 credential_id: Optional[_builtins.str] = None,
                 managed_identity_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_connector_id: The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        :param _builtins.str managed_identity_id: The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
        """
        pulumi.set(__self__, "access_connector_id", access_connector_id)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if managed_identity_id is not None:
            pulumi.set(__self__, "managed_identity_id", managed_identity_id)

    @_builtins.property
    @pulumi.getter(name="accessConnectorId")
    def access_connector_id(self) -> _builtins.str:
        """
        The Resource ID of the Azure Databricks Access Connector resource, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.Databricks/accessConnectors/connector-name`.
        """
        return pulumi.get(self, "access_connector_id")

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter(name="managedIdentityId")
    def managed_identity_id(self) -> Optional[_builtins.str]:
        """
        The Resource ID of the Azure User Assigned Managed Identity associated with Azure Databricks Access Connector, of the form `/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg-name/providers/Microsoft.ManagedIdentity/userAssignedIdentities/user-managed-identity-name`.
        """
        return pulumi.get(self, "managed_identity_id")


@pulumi.output_type
class GetStorageCredentialStorageCredentialInfoAzureServicePrincipalResult(dict):
    def __init__(__self__, *,
                 application_id: _builtins.str,
                 client_secret: _builtins.str,
                 directory_id: _builtins.str):
        """
        :param _builtins.str application_id: The application ID of the application registration within the referenced AAD tenant
        :param _builtins.str directory_id: The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "directory_id", directory_id)

    @_builtins.property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> _builtins.str:
        """
        The application ID of the application registration within the referenced AAD tenant
        """
        return pulumi.get(self, "application_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> _builtins.str:
        """
        The directory ID corresponding to the Azure Active Directory (AAD) tenant of the application
        """
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class GetStorageCredentialStorageCredentialInfoCloudflareApiTokenResult(dict):
    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 account_id: _builtins.str,
                 secret_access_key: _builtins.str):
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class GetStorageCredentialStorageCredentialInfoDatabricksGcpServiceAccountResult(dict):
    def __init__(__self__, *,
                 credential_id: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None):
        """
        :param _builtins.str email: The email of the GCP service account created, to be granted access to relevant buckets.
        """
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @_builtins.property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_id")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email of the GCP service account created, to be granted access to relevant buckets.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class GetStorageCredentialsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetTableProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetTableTableInfoResult(dict):
    def __init__(__self__, *,
                 access_point: Optional[_builtins.str] = None,
                 browse_only: Optional[_builtins.bool] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 columns: Optional[Sequence['outputs.GetTableTableInfoColumnResult']] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 data_access_configuration_id: Optional[_builtins.str] = None,
                 data_source_format: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.int] = None,
                 delta_runtime_properties_kvpairs: Optional['outputs.GetTableTableInfoDeltaRuntimePropertiesKvpairsResult'] = None,
                 effective_predictive_optimization_flag: Optional['outputs.GetTableTableInfoEffectivePredictiveOptimizationFlagResult'] = None,
                 enable_predictive_optimization: Optional[_builtins.str] = None,
                 encryption_details: Optional['outputs.GetTableTableInfoEncryptionDetailsResult'] = None,
                 full_name: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 pipeline_id: Optional[_builtins.str] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 row_filter: Optional['outputs.GetTableTableInfoRowFilterResult'] = None,
                 schema_name: Optional[_builtins.str] = None,
                 securable_kind_manifest: Optional['outputs.GetTableTableInfoSecurableKindManifestResult'] = None,
                 sql_path: Optional[_builtins.str] = None,
                 storage_credential_name: Optional[_builtins.str] = None,
                 storage_location: Optional[_builtins.str] = None,
                 table_constraints: Optional[Sequence['outputs.GetTableTableInfoTableConstraintResult']] = None,
                 table_id: Optional[_builtins.str] = None,
                 table_type: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None,
                 view_definition: Optional[_builtins.str] = None,
                 view_dependencies: Optional['outputs.GetTableTableInfoViewDependenciesResult'] = None):
        """
        :param _builtins.str catalog_name: Name of parent catalog.
        :param Sequence['GetTableTableInfoColumnArgs'] columns: Array of ColumnInfo objects of the table's columns
        :param _builtins.str comment: Free-form text description
        :param _builtins.str data_source_format: Table format, e.g. DELTA, CSV, JSON
        :param _builtins.str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        :param _builtins.str owner: Current owner of the table
        :param _builtins.str schema_name: Name of parent schema relative to its parent catalog.
        :param _builtins.str table_id: The unique identifier of the table.
        :param _builtins.str table_type: Table type, e.g. MANAGED, EXTERNAL, VIEW
        :param _builtins.str view_definition: View definition SQL (when `table_type` is VIEW, MATERIALIZED_VIEW, or STREAMING_TABLE)
        :param 'GetTableTableInfoViewDependenciesArgs' view_dependencies: View dependencies (when `table_type` is VIEW or MATERIALIZED_VIEW, STREAMING_TABLE)
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if data_access_configuration_id is not None:
            pulumi.set(__self__, "data_access_configuration_id", data_access_configuration_id)
        if data_source_format is not None:
            pulumi.set(__self__, "data_source_format", data_source_format)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if delta_runtime_properties_kvpairs is not None:
            pulumi.set(__self__, "delta_runtime_properties_kvpairs", delta_runtime_properties_kvpairs)
        if effective_predictive_optimization_flag is not None:
            pulumi.set(__self__, "effective_predictive_optimization_flag", effective_predictive_optimization_flag)
        if enable_predictive_optimization is not None:
            pulumi.set(__self__, "enable_predictive_optimization", enable_predictive_optimization)
        if encryption_details is not None:
            pulumi.set(__self__, "encryption_details", encryption_details)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if row_filter is not None:
            pulumi.set(__self__, "row_filter", row_filter)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if securable_kind_manifest is not None:
            pulumi.set(__self__, "securable_kind_manifest", securable_kind_manifest)
        if sql_path is not None:
            pulumi.set(__self__, "sql_path", sql_path)
        if storage_credential_name is not None:
            pulumi.set(__self__, "storage_credential_name", storage_credential_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if table_constraints is not None:
            pulumi.set(__self__, "table_constraints", table_constraints)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)
        if table_type is not None:
            pulumi.set(__self__, "table_type", table_type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if view_definition is not None:
            pulumi.set(__self__, "view_definition", view_definition)
        if view_dependencies is not None:
            pulumi.set(__self__, "view_dependencies", view_dependencies)

    @_builtins.property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_point")

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        Name of parent catalog.
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.GetTableTableInfoColumnResult']]:
        """
        Array of ColumnInfo objects of the table's columns
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Free-form text description
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="dataAccessConfigurationId")
    def data_access_configuration_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_access_configuration_id")

    @_builtins.property
    @pulumi.getter(name="dataSourceFormat")
    def data_source_format(self) -> Optional[_builtins.str]:
        """
        Table format, e.g. DELTA, CSV, JSON
        """
        return pulumi.get(self, "data_source_format")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="deltaRuntimePropertiesKvpairs")
    def delta_runtime_properties_kvpairs(self) -> Optional['outputs.GetTableTableInfoDeltaRuntimePropertiesKvpairsResult']:
        return pulumi.get(self, "delta_runtime_properties_kvpairs")

    @_builtins.property
    @pulumi.getter(name="effectivePredictiveOptimizationFlag")
    def effective_predictive_optimization_flag(self) -> Optional['outputs.GetTableTableInfoEffectivePredictiveOptimizationFlagResult']:
        return pulumi.get(self, "effective_predictive_optimization_flag")

    @_builtins.property
    @pulumi.getter(name="enablePredictiveOptimization")
    def enable_predictive_optimization(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "enable_predictive_optimization")

    @_builtins.property
    @pulumi.getter(name="encryptionDetails")
    def encryption_details(self) -> Optional['outputs.GetTableTableInfoEncryptionDetailsResult']:
        return pulumi.get(self, "encryption_details")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        Current owner of the table
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="rowFilter")
    def row_filter(self) -> Optional['outputs.GetTableTableInfoRowFilterResult']:
        return pulumi.get(self, "row_filter")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        Name of parent schema relative to its parent catalog.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="securableKindManifest")
    def securable_kind_manifest(self) -> Optional['outputs.GetTableTableInfoSecurableKindManifestResult']:
        return pulumi.get(self, "securable_kind_manifest")

    @_builtins.property
    @pulumi.getter(name="sqlPath")
    def sql_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sql_path")

    @_builtins.property
    @pulumi.getter(name="storageCredentialName")
    def storage_credential_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_credential_name")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="tableConstraints")
    def table_constraints(self) -> Optional[Sequence['outputs.GetTableTableInfoTableConstraintResult']]:
        return pulumi.get(self, "table_constraints")

    @_builtins.property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the table.
        """
        return pulumi.get(self, "table_id")

    @_builtins.property
    @pulumi.getter(name="tableType")
    def table_type(self) -> Optional[_builtins.str]:
        """
        Table type, e.g. MANAGED, EXTERNAL, VIEW
        """
        return pulumi.get(self, "table_type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter(name="viewDefinition")
    def view_definition(self) -> Optional[_builtins.str]:
        """
        View definition SQL (when `table_type` is VIEW, MATERIALIZED_VIEW, or STREAMING_TABLE)
        """
        return pulumi.get(self, "view_definition")

    @_builtins.property
    @pulumi.getter(name="viewDependencies")
    def view_dependencies(self) -> Optional['outputs.GetTableTableInfoViewDependenciesResult']:
        """
        View dependencies (when `table_type` is VIEW or MATERIALIZED_VIEW, STREAMING_TABLE)
        """
        return pulumi.get(self, "view_dependencies")


@pulumi.output_type
class GetTableTableInfoColumnResult(dict):
    def __init__(__self__, *,
                 comment: Optional[_builtins.str] = None,
                 mask: Optional['outputs.GetTableTableInfoColumnMaskResult'] = None,
                 name: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 partition_index: Optional[_builtins.int] = None,
                 position: Optional[_builtins.int] = None,
                 type_interval_type: Optional[_builtins.str] = None,
                 type_json: Optional[_builtins.str] = None,
                 type_name: Optional[_builtins.str] = None,
                 type_precision: Optional[_builtins.int] = None,
                 type_scale: Optional[_builtins.int] = None,
                 type_text: Optional[_builtins.str] = None):
        """
        :param _builtins.str comment: Free-form text description
        :param _builtins.str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if partition_index is not None:
            pulumi.set(__self__, "partition_index", partition_index)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if type_interval_type is not None:
            pulumi.set(__self__, "type_interval_type", type_interval_type)
        if type_json is not None:
            pulumi.set(__self__, "type_json", type_json)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)
        if type_precision is not None:
            pulumi.set(__self__, "type_precision", type_precision)
        if type_scale is not None:
            pulumi.set(__self__, "type_scale", type_scale)
        if type_text is not None:
            pulumi.set(__self__, "type_text", type_text)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Free-form text description
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def mask(self) -> Optional['outputs.GetTableTableInfoColumnMaskResult']:
        return pulumi.get(self, "mask")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="partitionIndex")
    def partition_index(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "partition_index")

    @_builtins.property
    @pulumi.getter
    def position(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "position")

    @_builtins.property
    @pulumi.getter(name="typeIntervalType")
    def type_interval_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_interval_type")

    @_builtins.property
    @pulumi.getter(name="typeJson")
    def type_json(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_json")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter(name="typePrecision")
    def type_precision(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "type_precision")

    @_builtins.property
    @pulumi.getter(name="typeScale")
    def type_scale(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "type_scale")

    @_builtins.property
    @pulumi.getter(name="typeText")
    def type_text(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type_text")


@pulumi.output_type
class GetTableTableInfoColumnMaskResult(dict):
    def __init__(__self__, *,
                 function_name: Optional[_builtins.str] = None,
                 using_column_names: Optional[Sequence[_builtins.str]] = None):
        if function_name is not None:
            pulumi.set(__self__, "function_name", function_name)
        if using_column_names is not None:
            pulumi.set(__self__, "using_column_names", using_column_names)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="usingColumnNames")
    def using_column_names(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "using_column_names")


@pulumi.output_type
class GetTableTableInfoDeltaRuntimePropertiesKvpairsResult(dict):
    def __init__(__self__, *,
                 delta_runtime_properties: Mapping[str, _builtins.str]):
        pulumi.set(__self__, "delta_runtime_properties", delta_runtime_properties)

    @_builtins.property
    @pulumi.getter(name="deltaRuntimeProperties")
    def delta_runtime_properties(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "delta_runtime_properties")


@pulumi.output_type
class GetTableTableInfoEffectivePredictiveOptimizationFlagResult(dict):
    def __init__(__self__, *,
                 value: _builtins.str,
                 inherited_from_name: Optional[_builtins.str] = None,
                 inherited_from_type: Optional[_builtins.str] = None):
        pulumi.set(__self__, "value", value)
        if inherited_from_name is not None:
            pulumi.set(__self__, "inherited_from_name", inherited_from_name)
        if inherited_from_type is not None:
            pulumi.set(__self__, "inherited_from_type", inherited_from_type)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="inheritedFromName")
    def inherited_from_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_name")

    @_builtins.property
    @pulumi.getter(name="inheritedFromType")
    def inherited_from_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "inherited_from_type")


@pulumi.output_type
class GetTableTableInfoEncryptionDetailsResult(dict):
    def __init__(__self__, *,
                 sse_encryption_details: Optional['outputs.GetTableTableInfoEncryptionDetailsSseEncryptionDetailsResult'] = None):
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @_builtins.property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['outputs.GetTableTableInfoEncryptionDetailsSseEncryptionDetailsResult']:
        return pulumi.get(self, "sse_encryption_details")


@pulumi.output_type
class GetTableTableInfoEncryptionDetailsSseEncryptionDetailsResult(dict):
    def __init__(__self__, *,
                 algorithm: Optional[_builtins.str] = None,
                 aws_kms_key_arn: Optional[_builtins.str] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_kms_key_arn")


@pulumi.output_type
class GetTableTableInfoRowFilterResult(dict):
    def __init__(__self__, *,
                 function_name: _builtins.str,
                 input_column_names: Sequence[_builtins.str]):
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "input_column_names", input_column_names)

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter(name="inputColumnNames")
    def input_column_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "input_column_names")


@pulumi.output_type
class GetTableTableInfoSecurableKindManifestResult(dict):
    def __init__(__self__, *,
                 assignable_privileges: Optional[Sequence[_builtins.str]] = None,
                 capabilities: Optional[Sequence[_builtins.str]] = None,
                 options: Optional[Sequence['outputs.GetTableTableInfoSecurableKindManifestOptionResult']] = None,
                 securable_kind: Optional[_builtins.str] = None,
                 securable_type: Optional[_builtins.str] = None):
        if assignable_privileges is not None:
            pulumi.set(__self__, "assignable_privileges", assignable_privileges)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if securable_kind is not None:
            pulumi.set(__self__, "securable_kind", securable_kind)
        if securable_type is not None:
            pulumi.set(__self__, "securable_type", securable_type)

    @_builtins.property
    @pulumi.getter(name="assignablePrivileges")
    def assignable_privileges(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "assignable_privileges")

    @_builtins.property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "capabilities")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.GetTableTableInfoSecurableKindManifestOptionResult']]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="securableKind")
    def securable_kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "securable_kind")

    @_builtins.property
    @pulumi.getter(name="securableType")
    def securable_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "securable_type")


@pulumi.output_type
class GetTableTableInfoSecurableKindManifestOptionResult(dict):
    def __init__(__self__, *,
                 allowed_values: Optional[Sequence[_builtins.str]] = None,
                 default_value: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 hint: Optional[_builtins.str] = None,
                 is_copiable: Optional[_builtins.bool] = None,
                 is_creatable: Optional[_builtins.bool] = None,
                 is_hidden: Optional[_builtins.bool] = None,
                 is_loggable: Optional[_builtins.bool] = None,
                 is_required: Optional[_builtins.bool] = None,
                 is_secret: Optional[_builtins.bool] = None,
                 is_updatable: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 oauth_stage: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        if allowed_values is not None:
            pulumi.set(__self__, "allowed_values", allowed_values)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if hint is not None:
            pulumi.set(__self__, "hint", hint)
        if is_copiable is not None:
            pulumi.set(__self__, "is_copiable", is_copiable)
        if is_creatable is not None:
            pulumi.set(__self__, "is_creatable", is_creatable)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_loggable is not None:
            pulumi.set(__self__, "is_loggable", is_loggable)
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if is_updatable is not None:
            pulumi.set(__self__, "is_updatable", is_updatable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if oauth_stage is not None:
            pulumi.set(__self__, "oauth_stage", oauth_stage)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_values")

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def hint(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hint")

    @_builtins.property
    @pulumi.getter(name="isCopiable")
    def is_copiable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_copiable")

    @_builtins.property
    @pulumi.getter(name="isCreatable")
    def is_creatable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_creatable")

    @_builtins.property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_hidden")

    @_builtins.property
    @pulumi.getter(name="isLoggable")
    def is_loggable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_loggable")

    @_builtins.property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_required")

    @_builtins.property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_secret")

    @_builtins.property
    @pulumi.getter(name="isUpdatable")
    def is_updatable(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_updatable")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="oauthStage")
    def oauth_stage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "oauth_stage")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTableTableInfoTableConstraintResult(dict):
    def __init__(__self__, *,
                 foreign_key_constraint: Optional['outputs.GetTableTableInfoTableConstraintForeignKeyConstraintResult'] = None,
                 named_table_constraint: Optional['outputs.GetTableTableInfoTableConstraintNamedTableConstraintResult'] = None,
                 primary_key_constraint: Optional['outputs.GetTableTableInfoTableConstraintPrimaryKeyConstraintResult'] = None):
        if foreign_key_constraint is not None:
            pulumi.set(__self__, "foreign_key_constraint", foreign_key_constraint)
        if named_table_constraint is not None:
            pulumi.set(__self__, "named_table_constraint", named_table_constraint)
        if primary_key_constraint is not None:
            pulumi.set(__self__, "primary_key_constraint", primary_key_constraint)

    @_builtins.property
    @pulumi.getter(name="foreignKeyConstraint")
    def foreign_key_constraint(self) -> Optional['outputs.GetTableTableInfoTableConstraintForeignKeyConstraintResult']:
        return pulumi.get(self, "foreign_key_constraint")

    @_builtins.property
    @pulumi.getter(name="namedTableConstraint")
    def named_table_constraint(self) -> Optional['outputs.GetTableTableInfoTableConstraintNamedTableConstraintResult']:
        return pulumi.get(self, "named_table_constraint")

    @_builtins.property
    @pulumi.getter(name="primaryKeyConstraint")
    def primary_key_constraint(self) -> Optional['outputs.GetTableTableInfoTableConstraintPrimaryKeyConstraintResult']:
        return pulumi.get(self, "primary_key_constraint")


@pulumi.output_type
class GetTableTableInfoTableConstraintForeignKeyConstraintResult(dict):
    def __init__(__self__, *,
                 child_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 parent_columns: Sequence[_builtins.str],
                 parent_table: _builtins.str,
                 rely: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        pulumi.set(__self__, "child_columns", child_columns)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_columns", parent_columns)
        pulumi.set(__self__, "parent_table", parent_table)
        if rely is not None:
            pulumi.set(__self__, "rely", rely)

    @_builtins.property
    @pulumi.getter(name="childColumns")
    def child_columns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "child_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentColumns")
    def parent_columns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "parent_columns")

    @_builtins.property
    @pulumi.getter(name="parentTable")
    def parent_table(self) -> _builtins.str:
        return pulumi.get(self, "parent_table")

    @_builtins.property
    @pulumi.getter
    def rely(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "rely")


@pulumi.output_type
class GetTableTableInfoTableConstraintNamedTableConstraintResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetTableTableInfoTableConstraintPrimaryKeyConstraintResult(dict):
    def __init__(__self__, *,
                 child_columns: Sequence[_builtins.str],
                 name: _builtins.str,
                 rely: Optional[_builtins.bool] = None,
                 timeseries_columns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        pulumi.set(__self__, "child_columns", child_columns)
        pulumi.set(__self__, "name", name)
        if rely is not None:
            pulumi.set(__self__, "rely", rely)
        if timeseries_columns is not None:
            pulumi.set(__self__, "timeseries_columns", timeseries_columns)

    @_builtins.property
    @pulumi.getter(name="childColumns")
    def child_columns(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "child_columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Full name of the databricks_table: _`catalog`.`schema`.`table`_
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def rely(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "rely")

    @_builtins.property
    @pulumi.getter(name="timeseriesColumns")
    def timeseries_columns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "timeseries_columns")


@pulumi.output_type
class GetTableTableInfoViewDependenciesResult(dict):
    def __init__(__self__, *,
                 dependencies: Optional[Sequence['outputs.GetTableTableInfoViewDependenciesDependencyResult']] = None):
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['outputs.GetTableTableInfoViewDependenciesDependencyResult']]:
        return pulumi.get(self, "dependencies")


@pulumi.output_type
class GetTableTableInfoViewDependenciesDependencyResult(dict):
    def __init__(__self__, *,
                 connection: Optional['outputs.GetTableTableInfoViewDependenciesDependencyConnectionResult'] = None,
                 credential: Optional['outputs.GetTableTableInfoViewDependenciesDependencyCredentialResult'] = None,
                 function: Optional['outputs.GetTableTableInfoViewDependenciesDependencyFunctionResult'] = None,
                 table: Optional['outputs.GetTableTableInfoViewDependenciesDependencyTableResult'] = None):
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if credential is not None:
            pulumi.set(__self__, "credential", credential)
        if function is not None:
            pulumi.set(__self__, "function", function)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional['outputs.GetTableTableInfoViewDependenciesDependencyConnectionResult']:
        return pulumi.get(self, "connection")

    @_builtins.property
    @pulumi.getter
    def credential(self) -> Optional['outputs.GetTableTableInfoViewDependenciesDependencyCredentialResult']:
        return pulumi.get(self, "credential")

    @_builtins.property
    @pulumi.getter
    def function(self) -> Optional['outputs.GetTableTableInfoViewDependenciesDependencyFunctionResult']:
        return pulumi.get(self, "function")

    @_builtins.property
    @pulumi.getter
    def table(self) -> Optional['outputs.GetTableTableInfoViewDependenciesDependencyTableResult']:
        return pulumi.get(self, "table")


@pulumi.output_type
class GetTableTableInfoViewDependenciesDependencyConnectionResult(dict):
    def __init__(__self__, *,
                 connection_name: Optional[_builtins.str] = None):
        if connection_name is not None:
            pulumi.set(__self__, "connection_name", connection_name)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_name")


@pulumi.output_type
class GetTableTableInfoViewDependenciesDependencyCredentialResult(dict):
    def __init__(__self__, *,
                 credential_name: Optional[_builtins.str] = None):
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)

    @_builtins.property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_name")


@pulumi.output_type
class GetTableTableInfoViewDependenciesDependencyFunctionResult(dict):
    def __init__(__self__, *,
                 function_full_name: _builtins.str):
        pulumi.set(__self__, "function_full_name", function_full_name)

    @_builtins.property
    @pulumi.getter(name="functionFullName")
    def function_full_name(self) -> _builtins.str:
        return pulumi.get(self, "function_full_name")


@pulumi.output_type
class GetTableTableInfoViewDependenciesDependencyTableResult(dict):
    def __init__(__self__, *,
                 table_full_name: _builtins.str):
        pulumi.set(__self__, "table_full_name", table_full_name)

    @_builtins.property
    @pulumi.getter(name="tableFullName")
    def table_full_name(self) -> _builtins.str:
        return pulumi.get(self, "table_full_name")


@pulumi.output_type
class GetTablesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetTagPoliciesTagPolicyResult(dict):
    def __init__(__self__, *,
                 create_time: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 tag_key: _builtins.str,
                 update_time: _builtins.str,
                 values: Sequence['outputs.GetTagPoliciesTagPolicyValueResult']):
        """
        :param _builtins.str create_time: (string) - Timestamp when the tag policy was created
        :param _builtins.str description: (string)
        :param _builtins.str id: (string)
        :param _builtins.str tag_key: (string)
        :param _builtins.str update_time: (string) - Timestamp when the tag policy was last updated
        :param Sequence['GetTagPoliciesTagPolicyValueArgs'] values: (list of Value)
        """
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "update_time", update_time)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        (string) - Timestamp when the tag policy was created
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "tag_key")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> _builtins.str:
        """
        (string) - Timestamp when the tag policy was last updated
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetTagPoliciesTagPolicyValueResult']:
        """
        (list of Value)
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetTagPoliciesTagPolicyValueResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (string)
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetTagPolicyValueResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: (string)
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetViewsProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetVolumeProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetVolumeVolumeInfoResult(dict):
    def __init__(__self__, *,
                 access_point: Optional[_builtins.str] = None,
                 browse_only: Optional[_builtins.bool] = None,
                 catalog_name: Optional[_builtins.str] = None,
                 comment: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.int] = None,
                 created_by: Optional[_builtins.str] = None,
                 encryption_details: Optional['outputs.GetVolumeVolumeInfoEncryptionDetailsResult'] = None,
                 full_name: Optional[_builtins.str] = None,
                 metastore_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 owner: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 storage_location: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.int] = None,
                 updated_by: Optional[_builtins.str] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_point: the AWS access point to use when accessing s3 bucket for this volume's external location
        :param _builtins.bool browse_only: indicates whether the principal is limited to retrieving metadata for the volume through the BROWSE privilege when include_browse is enabled in the request.
        :param _builtins.str catalog_name: the name of the catalog where the schema and the volume are
        :param _builtins.str comment: the comment attached to the volume
        :param _builtins.int created_at: the Unix timestamp at the volume's creation
        :param _builtins.str created_by: the identifier of the user who created the volume
        :param 'GetVolumeVolumeInfoEncryptionDetailsArgs' encryption_details: encryption options that apply to clients connecting to cloud storage
        :param _builtins.str full_name: the three-level (fully qualified) name of the volume
        :param _builtins.str metastore_id: the unique identifier of the metastore
        :param _builtins.str name: a fully qualified name of databricks_volume: *`catalog`.`schema`.`volume`*
        :param _builtins.str owner: the identifier of the user who owns the volume
        :param _builtins.str schema_name: the name of the schema where the volume is
        :param _builtins.str storage_location: the storage location on the cloud
        :param _builtins.int updated_at: the timestamp of the last time changes were made to the volume
        :param _builtins.str updated_by: the identifier of the user who updated the volume last time
        :param _builtins.str volume_id: the unique identifier of the volume
        :param _builtins.str volume_type: whether the volume is `MANAGED` or `EXTERNAL`
        """
        if access_point is not None:
            pulumi.set(__self__, "access_point", access_point)
        if browse_only is not None:
            pulumi.set(__self__, "browse_only", browse_only)
        if catalog_name is not None:
            pulumi.set(__self__, "catalog_name", catalog_name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if encryption_details is not None:
            pulumi.set(__self__, "encryption_details", encryption_details)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if metastore_id is not None:
            pulumi.set(__self__, "metastore_id", metastore_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if updated_by is not None:
            pulumi.set(__self__, "updated_by", updated_by)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="accessPoint")
    def access_point(self) -> Optional[_builtins.str]:
        """
        the AWS access point to use when accessing s3 bucket for this volume's external location
        """
        return pulumi.get(self, "access_point")

    @_builtins.property
    @pulumi.getter(name="browseOnly")
    def browse_only(self) -> Optional[_builtins.bool]:
        """
        indicates whether the principal is limited to retrieving metadata for the volume through the BROWSE privilege when include_browse is enabled in the request.
        """
        return pulumi.get(self, "browse_only")

    @_builtins.property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> Optional[_builtins.str]:
        """
        the name of the catalog where the schema and the volume are
        """
        return pulumi.get(self, "catalog_name")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        the comment attached to the volume
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.int]:
        """
        the Unix timestamp at the volume's creation
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who created the volume
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="encryptionDetails")
    def encryption_details(self) -> Optional['outputs.GetVolumeVolumeInfoEncryptionDetailsResult']:
        """
        encryption options that apply to clients connecting to cloud storage
        """
        return pulumi.get(self, "encryption_details")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        the three-level (fully qualified) name of the volume
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="metastoreId")
    def metastore_id(self) -> Optional[_builtins.str]:
        """
        the unique identifier of the metastore
        """
        return pulumi.get(self, "metastore_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        a fully qualified name of databricks_volume: *`catalog`.`schema`.`volume`*
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who owns the volume
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        the name of the schema where the volume is
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[_builtins.str]:
        """
        the storage location on the cloud
        """
        return pulumi.get(self, "storage_location")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.int]:
        """
        the timestamp of the last time changes were made to the volume
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="updatedBy")
    def updated_by(self) -> Optional[_builtins.str]:
        """
        the identifier of the user who updated the volume last time
        """
        return pulumi.get(self, "updated_by")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        """
        the unique identifier of the volume
        """
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        whether the volume is `MANAGED` or `EXTERNAL`
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetVolumeVolumeInfoEncryptionDetailsResult(dict):
    def __init__(__self__, *,
                 sse_encryption_details: Optional['outputs.GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsResult'] = None):
        if sse_encryption_details is not None:
            pulumi.set(__self__, "sse_encryption_details", sse_encryption_details)

    @_builtins.property
    @pulumi.getter(name="sseEncryptionDetails")
    def sse_encryption_details(self) -> Optional['outputs.GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsResult']:
        return pulumi.get(self, "sse_encryption_details")


@pulumi.output_type
class GetVolumeVolumeInfoEncryptionDetailsSseEncryptionDetailsResult(dict):
    def __init__(__self__, *,
                 algorithm: Optional[_builtins.str] = None,
                 aws_kms_key_arn: Optional[_builtins.str] = None):
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_kms_key_arn is not None:
            pulumi.set(__self__, "aws_kms_key_arn", aws_kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter(name="awsKmsKeyArn")
    def aws_kms_key_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_kms_key_arn")


@pulumi.output_type
class GetVolumesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class GetWorkspaceSettingV2AibiDashboardEmbeddingAccessPolicyResult(dict):
    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class GetWorkspaceSettingV2AibiDashboardEmbeddingApprovedDomainsResult(dict):
    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] approved_domains: (list of string)
        """
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string)
        """
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceResult(dict):
    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult'] = None,
                 maintenance_window: Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool can_toggle: (boolean)
        :param _builtins.bool enabled: (boolean)
        :param 'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsArgs' enablement_details: (ClusterAutoRestartMessageEnablementDetails)
        :param 'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowArgs' maintenance_window: (ClusterAutoRestartMessageMaintenanceWindow)
        :param _builtins.bool restart_even_if_no_updates_available: (boolean)
        """
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult']:
        """
        (ClusterAutoRestartMessageEnablementDetails)
        """
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindow)
        """
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceEnablementDetailsResult(dict):
    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: (boolean) - The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult'] = None):
        """
        :param 'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs' week_day_based_schedule: (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult(dict):
    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult'] = None):
        """
        :param _builtins.str day_of_week: (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        :param 'GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs' window_start_time: (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetWorkspaceSettingV2AutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: (integer)
        :param _builtins.int minutes: (integer)
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetWorkspaceSettingV2BooleanValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAibiDashboardEmbeddingAccessPolicyResult(dict):
    def __init__(__self__, *,
                 access_policy_type: _builtins.str):
        """
        :param _builtins.str access_policy_type: (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        pulumi.set(__self__, "access_policy_type", access_policy_type)

    @_builtins.property
    @pulumi.getter(name="accessPolicyType")
    def access_policy_type(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL_DOMAINS`, `ALLOW_APPROVED_DOMAINS`, `DENY_ALL_DOMAINS`
        """
        return pulumi.get(self, "access_policy_type")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAibiDashboardEmbeddingApprovedDomainsResult(dict):
    def __init__(__self__, *,
                 approved_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] approved_domains: (list of string)
        """
        if approved_domains is not None:
            pulumi.set(__self__, "approved_domains", approved_domains)

    @_builtins.property
    @pulumi.getter(name="approvedDomains")
    def approved_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        (list of string)
        """
        return pulumi.get(self, "approved_domains")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceResult(dict):
    def __init__(__self__, *,
                 can_toggle: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 enablement_details: Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult'] = None,
                 maintenance_window: Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult'] = None,
                 restart_even_if_no_updates_available: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool can_toggle: (boolean)
        :param _builtins.bool enabled: (boolean)
        :param 'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsArgs' enablement_details: (ClusterAutoRestartMessageEnablementDetails)
        :param 'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowArgs' maintenance_window: (ClusterAutoRestartMessageMaintenanceWindow)
        :param _builtins.bool restart_even_if_no_updates_available: (boolean)
        """
        if can_toggle is not None:
            pulumi.set(__self__, "can_toggle", can_toggle)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if enablement_details is not None:
            pulumi.set(__self__, "enablement_details", enablement_details)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if restart_even_if_no_updates_available is not None:
            pulumi.set(__self__, "restart_even_if_no_updates_available", restart_even_if_no_updates_available)

    @_builtins.property
    @pulumi.getter(name="canToggle")
    def can_toggle(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "can_toggle")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="enablementDetails")
    def enablement_details(self) -> Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult']:
        """
        (ClusterAutoRestartMessageEnablementDetails)
        """
        return pulumi.get(self, "enablement_details")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindow)
        """
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="restartEvenIfNoUpdatesAvailable")
    def restart_even_if_no_updates_available(self) -> Optional[_builtins.bool]:
        """
        (boolean)
        """
        return pulumi.get(self, "restart_even_if_no_updates_available")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceEnablementDetailsResult(dict):
    def __init__(__self__, *,
                 forced_for_compliance_mode: Optional[_builtins.bool] = None,
                 unavailable_for_disabled_entitlement: Optional[_builtins.bool] = None,
                 unavailable_for_non_enterprise_tier: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool forced_for_compliance_mode: (boolean) - The feature is force enabled if compliance mode is active
        :param _builtins.bool unavailable_for_disabled_entitlement: (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        :param _builtins.bool unavailable_for_non_enterprise_tier: (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        if forced_for_compliance_mode is not None:
            pulumi.set(__self__, "forced_for_compliance_mode", forced_for_compliance_mode)
        if unavailable_for_disabled_entitlement is not None:
            pulumi.set(__self__, "unavailable_for_disabled_entitlement", unavailable_for_disabled_entitlement)
        if unavailable_for_non_enterprise_tier is not None:
            pulumi.set(__self__, "unavailable_for_non_enterprise_tier", unavailable_for_non_enterprise_tier)

    @_builtins.property
    @pulumi.getter(name="forcedForComplianceMode")
    def forced_for_compliance_mode(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is force enabled if compliance mode is active
        """
        return pulumi.get(self, "forced_for_compliance_mode")

    @_builtins.property
    @pulumi.getter(name="unavailableForDisabledEntitlement")
    def unavailable_for_disabled_entitlement(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the corresponding entitlement disabled (see getShieldEntitlementEnable)
        """
        return pulumi.get(self, "unavailable_for_disabled_entitlement")

    @_builtins.property
    @pulumi.getter(name="unavailableForNonEnterpriseTier")
    def unavailable_for_non_enterprise_tier(self) -> Optional[_builtins.bool]:
        """
        (boolean) - The feature is unavailable if the customer doesn't have enterprise tier
        """
        return pulumi.get(self, "unavailable_for_non_enterprise_tier")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 week_day_based_schedule: Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult'] = None):
        """
        :param 'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleArgs' week_day_based_schedule: (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        if week_day_based_schedule is not None:
            pulumi.set(__self__, "week_day_based_schedule", week_day_based_schedule)

    @_builtins.property
    @pulumi.getter(name="weekDayBasedSchedule")
    def week_day_based_schedule(self) -> Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWeekDayBasedSchedule)
        """
        return pulumi.get(self, "week_day_based_schedule")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleResult(dict):
    def __init__(__self__, *,
                 day_of_week: Optional[_builtins.str] = None,
                 frequency: Optional[_builtins.str] = None,
                 window_start_time: Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult'] = None):
        """
        :param _builtins.str day_of_week: (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        :param _builtins.str frequency: (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        :param 'GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeArgs' window_start_time: (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `FRIDAY`, `MONDAY`, `SATURDAY`, `SUNDAY`, `THURSDAY`, `TUESDAY`, `WEDNESDAY`
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[_builtins.str]:
        """
        (string) - Possible values are: `EVERY_WEEK`, `FIRST_AND_THIRD_OF_MONTH`, `FIRST_OF_MONTH`, `FOURTH_OF_MONTH`, `SECOND_AND_FOURTH_OF_MONTH`, `SECOND_OF_MONTH`, `THIRD_OF_MONTH`
        """
        return pulumi.get(self, "frequency")

    @_builtins.property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional['outputs.GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult']:
        """
        (ClusterAutoRestartMessageMaintenanceWindowWindowStartTime)
        """
        return pulumi.get(self, "window_start_time")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveAutomaticClusterUpdateWorkspaceMaintenanceWindowWeekDayBasedScheduleWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: Optional[_builtins.int] = None,
                 minutes: Optional[_builtins.int] = None):
        """
        :param _builtins.int hours: (integer)
        :param _builtins.int minutes: (integer)
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> Optional[_builtins.int]:
        """
        (integer)
        """
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveBooleanValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveIntegerValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2EffectivePersonalComputeResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveRestrictWorkspaceAdminsResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetWorkspaceSettingV2EffectiveStringValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2IntegerValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2PersonalComputeResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceSettingV2RestrictWorkspaceAdminsResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str):
        """
        :param _builtins.str status: (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        (string) - Possible values are: `ALLOW_ALL`, `RESTRICT_TOKENS_AND_JOB_RUN_AS`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetWorkspaceSettingV2StringValResult(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: (string) - Represents a generic string value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        (string) - Represents a generic string value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetZonesProviderConfigResult(dict):
    def __init__(__self__, *,
                 workspace_id: _builtins.str):
        """
        :param _builtins.str workspace_id: Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> _builtins.str:
        """
        Workspace ID which the resource belongs to. This workspace must be part of the account which the provider is configured with.
        """
        return pulumi.get(self, "workspace_id")


