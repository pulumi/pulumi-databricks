# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'GetFeatureEngineeringKafkaConfigResult',
    'AwaitableGetFeatureEngineeringKafkaConfigResult',
    'get_feature_engineering_kafka_config',
    'get_feature_engineering_kafka_config_output',
]

@pulumi.output_type
class GetFeatureEngineeringKafkaConfigResult:
    """
    A collection of values returned by getFeatureEngineeringKafkaConfig.
    """
    def __init__(__self__, auth_config=None, backfill_source=None, bootstrap_servers=None, extra_options=None, id=None, key_schema=None, name=None, subscription_mode=None, value_schema=None):
        if auth_config and not isinstance(auth_config, dict):
            raise TypeError("Expected argument 'auth_config' to be a dict")
        pulumi.set(__self__, "auth_config", auth_config)
        if backfill_source and not isinstance(backfill_source, dict):
            raise TypeError("Expected argument 'backfill_source' to be a dict")
        pulumi.set(__self__, "backfill_source", backfill_source)
        if bootstrap_servers and not isinstance(bootstrap_servers, str):
            raise TypeError("Expected argument 'bootstrap_servers' to be a str")
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if extra_options and not isinstance(extra_options, dict):
            raise TypeError("Expected argument 'extra_options' to be a dict")
        pulumi.set(__self__, "extra_options", extra_options)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if key_schema and not isinstance(key_schema, dict):
            raise TypeError("Expected argument 'key_schema' to be a dict")
        pulumi.set(__self__, "key_schema", key_schema)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if subscription_mode and not isinstance(subscription_mode, dict):
            raise TypeError("Expected argument 'subscription_mode' to be a dict")
        pulumi.set(__self__, "subscription_mode", subscription_mode)
        if value_schema and not isinstance(value_schema, dict):
            raise TypeError("Expected argument 'value_schema' to be a dict")
        pulumi.set(__self__, "value_schema", value_schema)

    @_builtins.property
    @pulumi.getter(name="authConfig")
    def auth_config(self) -> 'outputs.GetFeatureEngineeringKafkaConfigAuthConfigResult':
        """
        (AuthConfig) - Authentication configuration for connection to topics
        """
        return pulumi.get(self, "auth_config")

    @_builtins.property
    @pulumi.getter(name="backfillSource")
    def backfill_source(self) -> 'outputs.GetFeatureEngineeringKafkaConfigBackfillSourceResult':
        """
        (BackfillSource) - A user-provided and managed source for backfilling data. Historical data is used when creating a training set from streaming features linked to this Kafka config.
        In the future, a separate table will be maintained by Databricks for forward filling data.
        The schema for this source must match exactly that of the key and value schemas specified for this Kafka config
        """
        return pulumi.get(self, "backfill_source")

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> _builtins.str:
        """
        (string) - A comma-separated list of host/port pairs pointing to Kafka cluster
        """
        return pulumi.get(self, "bootstrap_servers")

    @_builtins.property
    @pulumi.getter(name="extraOptions")
    def extra_options(self) -> Mapping[str, _builtins.str]:
        """
        (object) - Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
        """
        return pulumi.get(self, "extra_options")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> 'outputs.GetFeatureEngineeringKafkaConfigKeySchemaResult':
        """
        (SchemaConfig) - Schema configuration for extracting message keys from topics. At least one of key_schema and value_schema must be provided
        """
        return pulumi.get(self, "key_schema")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (string) - Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
        Can be distinct from topic name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="subscriptionMode")
    def subscription_mode(self) -> 'outputs.GetFeatureEngineeringKafkaConfigSubscriptionModeResult':
        """
        (SubscriptionMode) - Options to configure which Kafka topics to pull data from
        """
        return pulumi.get(self, "subscription_mode")

    @_builtins.property
    @pulumi.getter(name="valueSchema")
    def value_schema(self) -> 'outputs.GetFeatureEngineeringKafkaConfigValueSchemaResult':
        """
        (SchemaConfig) - Schema configuration for extracting message values from topics. At least one of key_schema and value_schema must be provided
        """
        return pulumi.get(self, "value_schema")


class AwaitableGetFeatureEngineeringKafkaConfigResult(GetFeatureEngineeringKafkaConfigResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetFeatureEngineeringKafkaConfigResult(
            auth_config=self.auth_config,
            backfill_source=self.backfill_source,
            bootstrap_servers=self.bootstrap_servers,
            extra_options=self.extra_options,
            id=self.id,
            key_schema=self.key_schema,
            name=self.name,
            subscription_mode=self.subscription_mode,
            value_schema=self.value_schema)


def get_feature_engineering_kafka_config(name: Optional[_builtins.str] = None,
                                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetFeatureEngineeringKafkaConfigResult:
    """
    [![Private Preview](https://img.shields.io/badge/Release_Stage-Private_Preview-blueviolet)](https://docs.databricks.com/aws/en/release-notes/release-types)


    :param _builtins.str name: Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
           Can be distinct from topic name
    """
    __args__ = dict()
    __args__['name'] = name
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('databricks:index/getFeatureEngineeringKafkaConfig:getFeatureEngineeringKafkaConfig', __args__, opts=opts, typ=GetFeatureEngineeringKafkaConfigResult).value

    return AwaitableGetFeatureEngineeringKafkaConfigResult(
        auth_config=pulumi.get(__ret__, 'auth_config'),
        backfill_source=pulumi.get(__ret__, 'backfill_source'),
        bootstrap_servers=pulumi.get(__ret__, 'bootstrap_servers'),
        extra_options=pulumi.get(__ret__, 'extra_options'),
        id=pulumi.get(__ret__, 'id'),
        key_schema=pulumi.get(__ret__, 'key_schema'),
        name=pulumi.get(__ret__, 'name'),
        subscription_mode=pulumi.get(__ret__, 'subscription_mode'),
        value_schema=pulumi.get(__ret__, 'value_schema'))
def get_feature_engineering_kafka_config_output(name: Optional[pulumi.Input[_builtins.str]] = None,
                                                opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetFeatureEngineeringKafkaConfigResult]:
    """
    [![Private Preview](https://img.shields.io/badge/Release_Stage-Private_Preview-blueviolet)](https://docs.databricks.com/aws/en/release-notes/release-types)


    :param _builtins.str name: Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
           Can be distinct from topic name
    """
    __args__ = dict()
    __args__['name'] = name
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('databricks:index/getFeatureEngineeringKafkaConfig:getFeatureEngineeringKafkaConfig', __args__, opts=opts, typ=GetFeatureEngineeringKafkaConfigResult)
    return __ret__.apply(lambda __response__: GetFeatureEngineeringKafkaConfigResult(
        auth_config=pulumi.get(__response__, 'auth_config'),
        backfill_source=pulumi.get(__response__, 'backfill_source'),
        bootstrap_servers=pulumi.get(__response__, 'bootstrap_servers'),
        extra_options=pulumi.get(__response__, 'extra_options'),
        id=pulumi.get(__response__, 'id'),
        key_schema=pulumi.get(__response__, 'key_schema'),
        name=pulumi.get(__response__, 'name'),
        subscription_mode=pulumi.get(__response__, 'subscription_mode'),
        value_schema=pulumi.get(__response__, 'value_schema')))
