// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A credential represents an authentication and authorization mechanism for accessing services on your cloud tenant. Each credential is subject to Unity Catalog access-control policies that control which users and groups can access the credential.
//
// > This resource can only be used with a workspace-level provider!
//
// The type of credential to be created is determined by the `purpose` field, which should be either `SERVICE` or `STORAGE`.
// The caller must be a metastore admin or have the metastore privilege `CREATE_STORAGE_CREDENTIAL` for storage credentials, or `CREATE_SERVICE_CREDENTIAL` for service credentials. The user who creates the credential can delegate ownership to another user or group to manage permissions on it
//
// On AWS, the IAM role for a credential requires a trust policy. See [documentation](https://docs.databricks.com/en/connect/unity-catalog/cloud-services/service-credentials.html#step-1-create-an-iam-role) for more details. The data source getAwsUnityCatalogAssumeRolePolicy can be used to create the necessary AWS Unity Catalog assume role policy.
//
// ## Example Usage
//
// # For AWS
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			external, err := databricks.NewCredential(ctx, "external", &databricks.CredentialArgs{
//				Name: pulumi.Any(externalDataAccess.Name),
//				AwsIamRole: &databricks.CredentialAwsIamRoleArgs{
//					RoleArn: pulumi.Any(externalDataAccess.Arn),
//				},
//				Purpose: pulumi.String("SERVICE"),
//				Comment: pulumi.String("Managed by TF"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewGrants(ctx, "external_creds", &databricks.GrantsArgs{
//				Credential: external.ID(),
//				Grants: databricks.GrantsGrantArray{
//					&databricks.GrantsGrantArgs{
//						Principal: pulumi.String("Data Engineers"),
//						Privileges: pulumi.StringArray{
//							pulumi.String("ACCESS"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// # For Azure
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			externalMi, err := databricks.NewCredential(ctx, "external_mi", &databricks.CredentialArgs{
//				Name: pulumi.String("mi_credential"),
//				AzureManagedIdentity: &databricks.CredentialAzureManagedIdentityArgs{
//					AccessConnectorId: pulumi.Any(example.Id),
//				},
//				Purpose: pulumi.String("SERVICE"),
//				Comment: pulumi.String("Managed identity credential managed by TF"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewGrants(ctx, "external_creds", &databricks.GrantsArgs{
//				Credential: externalMi.ID(),
//				Grants: databricks.GrantsGrantArray{
//					&databricks.GrantsGrantArgs{
//						Principal: pulumi.String("Data Engineers"),
//						Privileges: pulumi.StringArray{
//							pulumi.String("ACCESS"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// # For GCP
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			externalGcpSa, err := databricks.NewCredential(ctx, "external_gcp_sa", &databricks.CredentialArgs{
//				Name:                        pulumi.String("gcp_sa_credential"),
//				DatabricksGcpServiceAccount: &databricks.CredentialDatabricksGcpServiceAccountArgs{},
//				Purpose:                     pulumi.String("SERVICE"),
//				Comment:                     pulumi.String("GCP SA credential managed by TF"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewGrants(ctx, "external_creds", &databricks.GrantsArgs{
//				Credential: externalGcpSa.ID(),
//				Grants: databricks.GrantsGrantArray{
//					&databricks.GrantsGrantArgs{
//						Principal: pulumi.String("Data Engineers"),
//						Privileges: pulumi.StringArray{
//							pulumi.String("ACCESS"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// This resource can be imported by name:
//
// bash
//
// ```sh
// $ pulumi import databricks:index/credential:Credential this <name>
// ```
type Credential struct {
	pulumi.CustomResourceState

	AwsIamRole            CredentialAwsIamRolePtrOutput            `pulumi:"awsIamRole"`
	AzureManagedIdentity  CredentialAzureManagedIdentityPtrOutput  `pulumi:"azureManagedIdentity"`
	AzureServicePrincipal CredentialAzureServicePrincipalPtrOutput `pulumi:"azureServicePrincipal"`
	Comment               pulumi.StringPtrOutput                   `pulumi:"comment"`
	CreatedAt             pulumi.IntOutput                         `pulumi:"createdAt"`
	CreatedBy             pulumi.StringOutput                      `pulumi:"createdBy"`
	// Unique ID of the credential.
	CredentialId                pulumi.StringOutput                         `pulumi:"credentialId"`
	DatabricksGcpServiceAccount CredentialDatabricksGcpServiceAccountOutput `pulumi:"databricksGcpServiceAccount"`
	// Delete credential regardless of its dependencies.
	ForceDestroy pulumi.BoolPtrOutput `pulumi:"forceDestroy"`
	// Update credential regardless of its dependents.
	ForceUpdate pulumi.BoolPtrOutput `pulumi:"forceUpdate"`
	FullName    pulumi.StringOutput  `pulumi:"fullName"`
	// Whether the credential is accessible from all workspaces or a specific set of workspaces. Can be `ISOLATION_MODE_ISOLATED` or `ISOLATION_MODE_OPEN`. Setting the credential to `ISOLATION_MODE_ISOLATED` will automatically restrict access to only from the current workspace.
	//
	// `awsIamRole` optional configuration block for credential details for AWS:
	IsolationMode pulumi.StringOutput `pulumi:"isolationMode"`
	MetastoreId   pulumi.StringOutput `pulumi:"metastoreId"`
	// Name of Credentials, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Username/groupname/sp applicationId of the credential owner.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// Indicates the purpose of the credential. Can be `SERVICE` or `STORAGE`.
	Purpose pulumi.StringOutput `pulumi:"purpose"`
	// Indicates whether the credential is only usable for read operations. Only applicable when purpose is `STORAGE`.
	ReadOnly pulumi.BoolPtrOutput `pulumi:"readOnly"`
	// Suppress validation errors if any & force save the credential.
	SkipValidation        pulumi.BoolPtrOutput `pulumi:"skipValidation"`
	UpdatedAt             pulumi.IntOutput     `pulumi:"updatedAt"`
	UpdatedBy             pulumi.StringOutput  `pulumi:"updatedBy"`
	UsedForManagedStorage pulumi.BoolOutput    `pulumi:"usedForManagedStorage"`
}

// NewCredential registers a new resource with the given unique name, arguments, and options.
func NewCredential(ctx *pulumi.Context,
	name string, args *CredentialArgs, opts ...pulumi.ResourceOption) (*Credential, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Purpose == nil {
		return nil, errors.New("invalid value for required argument 'Purpose'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Credential
	err := ctx.RegisterResource("databricks:index/credential:Credential", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCredential gets an existing Credential resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCredential(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CredentialState, opts ...pulumi.ResourceOption) (*Credential, error) {
	var resource Credential
	err := ctx.ReadResource("databricks:index/credential:Credential", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Credential resources.
type credentialState struct {
	AwsIamRole            *CredentialAwsIamRole            `pulumi:"awsIamRole"`
	AzureManagedIdentity  *CredentialAzureManagedIdentity  `pulumi:"azureManagedIdentity"`
	AzureServicePrincipal *CredentialAzureServicePrincipal `pulumi:"azureServicePrincipal"`
	Comment               *string                          `pulumi:"comment"`
	CreatedAt             *int                             `pulumi:"createdAt"`
	CreatedBy             *string                          `pulumi:"createdBy"`
	// Unique ID of the credential.
	CredentialId                *string                                `pulumi:"credentialId"`
	DatabricksGcpServiceAccount *CredentialDatabricksGcpServiceAccount `pulumi:"databricksGcpServiceAccount"`
	// Delete credential regardless of its dependencies.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// Update credential regardless of its dependents.
	ForceUpdate *bool   `pulumi:"forceUpdate"`
	FullName    *string `pulumi:"fullName"`
	// Whether the credential is accessible from all workspaces or a specific set of workspaces. Can be `ISOLATION_MODE_ISOLATED` or `ISOLATION_MODE_OPEN`. Setting the credential to `ISOLATION_MODE_ISOLATED` will automatically restrict access to only from the current workspace.
	//
	// `awsIamRole` optional configuration block for credential details for AWS:
	IsolationMode *string `pulumi:"isolationMode"`
	MetastoreId   *string `pulumi:"metastoreId"`
	// Name of Credentials, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name *string `pulumi:"name"`
	// Username/groupname/sp applicationId of the credential owner.
	Owner *string `pulumi:"owner"`
	// Indicates the purpose of the credential. Can be `SERVICE` or `STORAGE`.
	Purpose *string `pulumi:"purpose"`
	// Indicates whether the credential is only usable for read operations. Only applicable when purpose is `STORAGE`.
	ReadOnly *bool `pulumi:"readOnly"`
	// Suppress validation errors if any & force save the credential.
	SkipValidation        *bool   `pulumi:"skipValidation"`
	UpdatedAt             *int    `pulumi:"updatedAt"`
	UpdatedBy             *string `pulumi:"updatedBy"`
	UsedForManagedStorage *bool   `pulumi:"usedForManagedStorage"`
}

type CredentialState struct {
	AwsIamRole            CredentialAwsIamRolePtrInput
	AzureManagedIdentity  CredentialAzureManagedIdentityPtrInput
	AzureServicePrincipal CredentialAzureServicePrincipalPtrInput
	Comment               pulumi.StringPtrInput
	CreatedAt             pulumi.IntPtrInput
	CreatedBy             pulumi.StringPtrInput
	// Unique ID of the credential.
	CredentialId                pulumi.StringPtrInput
	DatabricksGcpServiceAccount CredentialDatabricksGcpServiceAccountPtrInput
	// Delete credential regardless of its dependencies.
	ForceDestroy pulumi.BoolPtrInput
	// Update credential regardless of its dependents.
	ForceUpdate pulumi.BoolPtrInput
	FullName    pulumi.StringPtrInput
	// Whether the credential is accessible from all workspaces or a specific set of workspaces. Can be `ISOLATION_MODE_ISOLATED` or `ISOLATION_MODE_OPEN`. Setting the credential to `ISOLATION_MODE_ISOLATED` will automatically restrict access to only from the current workspace.
	//
	// `awsIamRole` optional configuration block for credential details for AWS:
	IsolationMode pulumi.StringPtrInput
	MetastoreId   pulumi.StringPtrInput
	// Name of Credentials, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name pulumi.StringPtrInput
	// Username/groupname/sp applicationId of the credential owner.
	Owner pulumi.StringPtrInput
	// Indicates the purpose of the credential. Can be `SERVICE` or `STORAGE`.
	Purpose pulumi.StringPtrInput
	// Indicates whether the credential is only usable for read operations. Only applicable when purpose is `STORAGE`.
	ReadOnly pulumi.BoolPtrInput
	// Suppress validation errors if any & force save the credential.
	SkipValidation        pulumi.BoolPtrInput
	UpdatedAt             pulumi.IntPtrInput
	UpdatedBy             pulumi.StringPtrInput
	UsedForManagedStorage pulumi.BoolPtrInput
}

func (CredentialState) ElementType() reflect.Type {
	return reflect.TypeOf((*credentialState)(nil)).Elem()
}

type credentialArgs struct {
	AwsIamRole                  *CredentialAwsIamRole                  `pulumi:"awsIamRole"`
	AzureManagedIdentity        *CredentialAzureManagedIdentity        `pulumi:"azureManagedIdentity"`
	AzureServicePrincipal       *CredentialAzureServicePrincipal       `pulumi:"azureServicePrincipal"`
	Comment                     *string                                `pulumi:"comment"`
	CreatedAt                   *int                                   `pulumi:"createdAt"`
	CreatedBy                   *string                                `pulumi:"createdBy"`
	DatabricksGcpServiceAccount *CredentialDatabricksGcpServiceAccount `pulumi:"databricksGcpServiceAccount"`
	// Delete credential regardless of its dependencies.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// Update credential regardless of its dependents.
	ForceUpdate *bool   `pulumi:"forceUpdate"`
	FullName    *string `pulumi:"fullName"`
	// Whether the credential is accessible from all workspaces or a specific set of workspaces. Can be `ISOLATION_MODE_ISOLATED` or `ISOLATION_MODE_OPEN`. Setting the credential to `ISOLATION_MODE_ISOLATED` will automatically restrict access to only from the current workspace.
	//
	// `awsIamRole` optional configuration block for credential details for AWS:
	IsolationMode *string `pulumi:"isolationMode"`
	MetastoreId   *string `pulumi:"metastoreId"`
	// Name of Credentials, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name *string `pulumi:"name"`
	// Username/groupname/sp applicationId of the credential owner.
	Owner *string `pulumi:"owner"`
	// Indicates the purpose of the credential. Can be `SERVICE` or `STORAGE`.
	Purpose string `pulumi:"purpose"`
	// Indicates whether the credential is only usable for read operations. Only applicable when purpose is `STORAGE`.
	ReadOnly *bool `pulumi:"readOnly"`
	// Suppress validation errors if any & force save the credential.
	SkipValidation        *bool   `pulumi:"skipValidation"`
	UpdatedAt             *int    `pulumi:"updatedAt"`
	UpdatedBy             *string `pulumi:"updatedBy"`
	UsedForManagedStorage *bool   `pulumi:"usedForManagedStorage"`
}

// The set of arguments for constructing a Credential resource.
type CredentialArgs struct {
	AwsIamRole                  CredentialAwsIamRolePtrInput
	AzureManagedIdentity        CredentialAzureManagedIdentityPtrInput
	AzureServicePrincipal       CredentialAzureServicePrincipalPtrInput
	Comment                     pulumi.StringPtrInput
	CreatedAt                   pulumi.IntPtrInput
	CreatedBy                   pulumi.StringPtrInput
	DatabricksGcpServiceAccount CredentialDatabricksGcpServiceAccountPtrInput
	// Delete credential regardless of its dependencies.
	ForceDestroy pulumi.BoolPtrInput
	// Update credential regardless of its dependents.
	ForceUpdate pulumi.BoolPtrInput
	FullName    pulumi.StringPtrInput
	// Whether the credential is accessible from all workspaces or a specific set of workspaces. Can be `ISOLATION_MODE_ISOLATED` or `ISOLATION_MODE_OPEN`. Setting the credential to `ISOLATION_MODE_ISOLATED` will automatically restrict access to only from the current workspace.
	//
	// `awsIamRole` optional configuration block for credential details for AWS:
	IsolationMode pulumi.StringPtrInput
	MetastoreId   pulumi.StringPtrInput
	// Name of Credentials, which must be unique within the databricks_metastore. Change forces creation of a new resource.
	Name pulumi.StringPtrInput
	// Username/groupname/sp applicationId of the credential owner.
	Owner pulumi.StringPtrInput
	// Indicates the purpose of the credential. Can be `SERVICE` or `STORAGE`.
	Purpose pulumi.StringInput
	// Indicates whether the credential is only usable for read operations. Only applicable when purpose is `STORAGE`.
	ReadOnly pulumi.BoolPtrInput
	// Suppress validation errors if any & force save the credential.
	SkipValidation        pulumi.BoolPtrInput
	UpdatedAt             pulumi.IntPtrInput
	UpdatedBy             pulumi.StringPtrInput
	UsedForManagedStorage pulumi.BoolPtrInput
}

func (CredentialArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*credentialArgs)(nil)).Elem()
}

type CredentialInput interface {
	pulumi.Input

	ToCredentialOutput() CredentialOutput
	ToCredentialOutputWithContext(ctx context.Context) CredentialOutput
}

func (*Credential) ElementType() reflect.Type {
	return reflect.TypeOf((**Credential)(nil)).Elem()
}

func (i *Credential) ToCredentialOutput() CredentialOutput {
	return i.ToCredentialOutputWithContext(context.Background())
}

func (i *Credential) ToCredentialOutputWithContext(ctx context.Context) CredentialOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CredentialOutput)
}

// CredentialArrayInput is an input type that accepts CredentialArray and CredentialArrayOutput values.
// You can construct a concrete instance of `CredentialArrayInput` via:
//
//	CredentialArray{ CredentialArgs{...} }
type CredentialArrayInput interface {
	pulumi.Input

	ToCredentialArrayOutput() CredentialArrayOutput
	ToCredentialArrayOutputWithContext(context.Context) CredentialArrayOutput
}

type CredentialArray []CredentialInput

func (CredentialArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Credential)(nil)).Elem()
}

func (i CredentialArray) ToCredentialArrayOutput() CredentialArrayOutput {
	return i.ToCredentialArrayOutputWithContext(context.Background())
}

func (i CredentialArray) ToCredentialArrayOutputWithContext(ctx context.Context) CredentialArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CredentialArrayOutput)
}

// CredentialMapInput is an input type that accepts CredentialMap and CredentialMapOutput values.
// You can construct a concrete instance of `CredentialMapInput` via:
//
//	CredentialMap{ "key": CredentialArgs{...} }
type CredentialMapInput interface {
	pulumi.Input

	ToCredentialMapOutput() CredentialMapOutput
	ToCredentialMapOutputWithContext(context.Context) CredentialMapOutput
}

type CredentialMap map[string]CredentialInput

func (CredentialMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Credential)(nil)).Elem()
}

func (i CredentialMap) ToCredentialMapOutput() CredentialMapOutput {
	return i.ToCredentialMapOutputWithContext(context.Background())
}

func (i CredentialMap) ToCredentialMapOutputWithContext(ctx context.Context) CredentialMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CredentialMapOutput)
}

type CredentialOutput struct{ *pulumi.OutputState }

func (CredentialOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Credential)(nil)).Elem()
}

func (o CredentialOutput) ToCredentialOutput() CredentialOutput {
	return o
}

func (o CredentialOutput) ToCredentialOutputWithContext(ctx context.Context) CredentialOutput {
	return o
}

func (o CredentialOutput) AwsIamRole() CredentialAwsIamRolePtrOutput {
	return o.ApplyT(func(v *Credential) CredentialAwsIamRolePtrOutput { return v.AwsIamRole }).(CredentialAwsIamRolePtrOutput)
}

func (o CredentialOutput) AzureManagedIdentity() CredentialAzureManagedIdentityPtrOutput {
	return o.ApplyT(func(v *Credential) CredentialAzureManagedIdentityPtrOutput { return v.AzureManagedIdentity }).(CredentialAzureManagedIdentityPtrOutput)
}

func (o CredentialOutput) AzureServicePrincipal() CredentialAzureServicePrincipalPtrOutput {
	return o.ApplyT(func(v *Credential) CredentialAzureServicePrincipalPtrOutput { return v.AzureServicePrincipal }).(CredentialAzureServicePrincipalPtrOutput)
}

func (o CredentialOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

func (o CredentialOutput) CreatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *Credential) pulumi.IntOutput { return v.CreatedAt }).(pulumi.IntOutput)
}

func (o CredentialOutput) CreatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.CreatedBy }).(pulumi.StringOutput)
}

// Unique ID of the credential.
func (o CredentialOutput) CredentialId() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.CredentialId }).(pulumi.StringOutput)
}

func (o CredentialOutput) DatabricksGcpServiceAccount() CredentialDatabricksGcpServiceAccountOutput {
	return o.ApplyT(func(v *Credential) CredentialDatabricksGcpServiceAccountOutput { return v.DatabricksGcpServiceAccount }).(CredentialDatabricksGcpServiceAccountOutput)
}

// Delete credential regardless of its dependencies.
func (o CredentialOutput) ForceDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Credential) pulumi.BoolPtrOutput { return v.ForceDestroy }).(pulumi.BoolPtrOutput)
}

// Update credential regardless of its dependents.
func (o CredentialOutput) ForceUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Credential) pulumi.BoolPtrOutput { return v.ForceUpdate }).(pulumi.BoolPtrOutput)
}

func (o CredentialOutput) FullName() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.FullName }).(pulumi.StringOutput)
}

// Whether the credential is accessible from all workspaces or a specific set of workspaces. Can be `ISOLATION_MODE_ISOLATED` or `ISOLATION_MODE_OPEN`. Setting the credential to `ISOLATION_MODE_ISOLATED` will automatically restrict access to only from the current workspace.
//
// `awsIamRole` optional configuration block for credential details for AWS:
func (o CredentialOutput) IsolationMode() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.IsolationMode }).(pulumi.StringOutput)
}

func (o CredentialOutput) MetastoreId() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.MetastoreId }).(pulumi.StringOutput)
}

// Name of Credentials, which must be unique within the databricks_metastore. Change forces creation of a new resource.
func (o CredentialOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Username/groupname/sp applicationId of the credential owner.
func (o CredentialOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

// Indicates the purpose of the credential. Can be `SERVICE` or `STORAGE`.
func (o CredentialOutput) Purpose() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.Purpose }).(pulumi.StringOutput)
}

// Indicates whether the credential is only usable for read operations. Only applicable when purpose is `STORAGE`.
func (o CredentialOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Credential) pulumi.BoolPtrOutput { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

// Suppress validation errors if any & force save the credential.
func (o CredentialOutput) SkipValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Credential) pulumi.BoolPtrOutput { return v.SkipValidation }).(pulumi.BoolPtrOutput)
}

func (o CredentialOutput) UpdatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *Credential) pulumi.IntOutput { return v.UpdatedAt }).(pulumi.IntOutput)
}

func (o CredentialOutput) UpdatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *Credential) pulumi.StringOutput { return v.UpdatedBy }).(pulumi.StringOutput)
}

func (o CredentialOutput) UsedForManagedStorage() pulumi.BoolOutput {
	return o.ApplyT(func(v *Credential) pulumi.BoolOutput { return v.UsedForManagedStorage }).(pulumi.BoolOutput)
}

type CredentialArrayOutput struct{ *pulumi.OutputState }

func (CredentialArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Credential)(nil)).Elem()
}

func (o CredentialArrayOutput) ToCredentialArrayOutput() CredentialArrayOutput {
	return o
}

func (o CredentialArrayOutput) ToCredentialArrayOutputWithContext(ctx context.Context) CredentialArrayOutput {
	return o
}

func (o CredentialArrayOutput) Index(i pulumi.IntInput) CredentialOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Credential {
		return vs[0].([]*Credential)[vs[1].(int)]
	}).(CredentialOutput)
}

type CredentialMapOutput struct{ *pulumi.OutputState }

func (CredentialMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Credential)(nil)).Elem()
}

func (o CredentialMapOutput) ToCredentialMapOutput() CredentialMapOutput {
	return o
}

func (o CredentialMapOutput) ToCredentialMapOutputWithContext(ctx context.Context) CredentialMapOutput {
	return o
}

func (o CredentialMapOutput) MapIndex(k pulumi.StringInput) CredentialOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Credential {
		return vs[0].(map[string]*Credential)[vs[1].(string)]
	}).(CredentialOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CredentialInput)(nil)).Elem(), &Credential{})
	pulumi.RegisterInputType(reflect.TypeOf((*CredentialArrayInput)(nil)).Elem(), CredentialArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CredentialMapInput)(nil)).Elem(), CredentialMap{})
	pulumi.RegisterOutputType(CredentialOutput{})
	pulumi.RegisterOutputType(CredentialArrayOutput{})
	pulumi.RegisterOutputType(CredentialMapOutput{})
}
