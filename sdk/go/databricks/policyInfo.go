// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// As of Pulumi v1.5, resources can be imported through configuration.
//
// hcl
//
// import {
//
//	id = "on_securable_type,on_securable_fullname,name"
//
//	to = databricks_policy_info.this
//
// }
//
// If you are using an older version of Pulumi, import the resource using the `pulumi import` command as follows:
//
// ```sh
// $ pulumi import databricks:index/policyInfo:PolicyInfo databricks_policy_info "on_securable_type,on_securable_fullname,name"
// ```
type PolicyInfo struct {
	pulumi.CustomResourceState

	// Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	ColumnMask PolicyInfoColumnMaskPtrOutput `pulumi:"columnMask"`
	// Optional description of the policy
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// (integer) - Time at which the policy was created, in epoch milliseconds. Output only
	CreatedAt pulumi.IntOutput `pulumi:"createdAt"`
	// (string) - Username of the user who created the policy. Output only
	CreatedBy pulumi.StringOutput `pulumi:"createdBy"`
	// Optional list of user or group names that should be excluded from the policy
	ExceptPrincipals pulumi.StringArrayOutput `pulumi:"exceptPrincipals"`
	// Type of securables that the policy should take effect on.
	// Only `TABLE` is supported at this moment.
	// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	ForSecurableType pulumi.StringOutput `pulumi:"forSecurableType"`
	// Optional list of condition expressions used to match table columns.
	// Only valid when `forSecurableType` is `TABLE`.
	// When specified, the policy only applies to tables whose columns satisfy all match conditions
	MatchColumns PolicyInfoMatchColumnArrayOutput `pulumi:"matchColumns"`
	// Name of the policy. Required on create and optional on update.
	// To rename the policy, set `name` to a different value on update
	Name pulumi.StringOutput `pulumi:"name"`
	// Full name of the securable on which the policy is defined.
	// Required on create and ignored on update
	OnSecurableFullname pulumi.StringPtrOutput `pulumi:"onSecurableFullname"`
	// Type of the securable on which the policy is defined.
	// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
	// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	OnSecurableType pulumi.StringPtrOutput `pulumi:"onSecurableType"`
	// Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
	PolicyType pulumi.StringOutput `pulumi:"policyType"`
	// Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	RowFilter PolicyInfoRowFilterPtrOutput `pulumi:"rowFilter"`
	// List of user or group names that the policy applies to.
	// Required on create and optional on update
	ToPrincipals pulumi.StringArrayOutput `pulumi:"toPrincipals"`
	// (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
	UpdatedAt pulumi.IntOutput `pulumi:"updatedAt"`
	// (string) - Username of the user who last modified the policy. Output only
	UpdatedBy pulumi.StringOutput `pulumi:"updatedBy"`
	// Optional condition when the policy should take effect
	WhenCondition pulumi.StringPtrOutput `pulumi:"whenCondition"`
	// Workspace ID of the resource
	WorkspaceId pulumi.StringPtrOutput `pulumi:"workspaceId"`
}

// NewPolicyInfo registers a new resource with the given unique name, arguments, and options.
func NewPolicyInfo(ctx *pulumi.Context,
	name string, args *PolicyInfoArgs, opts ...pulumi.ResourceOption) (*PolicyInfo, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ForSecurableType == nil {
		return nil, errors.New("invalid value for required argument 'ForSecurableType'")
	}
	if args.PolicyType == nil {
		return nil, errors.New("invalid value for required argument 'PolicyType'")
	}
	if args.ToPrincipals == nil {
		return nil, errors.New("invalid value for required argument 'ToPrincipals'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PolicyInfo
	err := ctx.RegisterResource("databricks:index/policyInfo:PolicyInfo", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicyInfo gets an existing PolicyInfo resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicyInfo(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyInfoState, opts ...pulumi.ResourceOption) (*PolicyInfo, error) {
	var resource PolicyInfo
	err := ctx.ReadResource("databricks:index/policyInfo:PolicyInfo", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PolicyInfo resources.
type policyInfoState struct {
	// Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	ColumnMask *PolicyInfoColumnMask `pulumi:"columnMask"`
	// Optional description of the policy
	Comment *string `pulumi:"comment"`
	// (integer) - Time at which the policy was created, in epoch milliseconds. Output only
	CreatedAt *int `pulumi:"createdAt"`
	// (string) - Username of the user who created the policy. Output only
	CreatedBy *string `pulumi:"createdBy"`
	// Optional list of user or group names that should be excluded from the policy
	ExceptPrincipals []string `pulumi:"exceptPrincipals"`
	// Type of securables that the policy should take effect on.
	// Only `TABLE` is supported at this moment.
	// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	ForSecurableType *string `pulumi:"forSecurableType"`
	// Optional list of condition expressions used to match table columns.
	// Only valid when `forSecurableType` is `TABLE`.
	// When specified, the policy only applies to tables whose columns satisfy all match conditions
	MatchColumns []PolicyInfoMatchColumn `pulumi:"matchColumns"`
	// Name of the policy. Required on create and optional on update.
	// To rename the policy, set `name` to a different value on update
	Name *string `pulumi:"name"`
	// Full name of the securable on which the policy is defined.
	// Required on create and ignored on update
	OnSecurableFullname *string `pulumi:"onSecurableFullname"`
	// Type of the securable on which the policy is defined.
	// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
	// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	OnSecurableType *string `pulumi:"onSecurableType"`
	// Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
	PolicyType *string `pulumi:"policyType"`
	// Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	RowFilter *PolicyInfoRowFilter `pulumi:"rowFilter"`
	// List of user or group names that the policy applies to.
	// Required on create and optional on update
	ToPrincipals []string `pulumi:"toPrincipals"`
	// (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
	UpdatedAt *int `pulumi:"updatedAt"`
	// (string) - Username of the user who last modified the policy. Output only
	UpdatedBy *string `pulumi:"updatedBy"`
	// Optional condition when the policy should take effect
	WhenCondition *string `pulumi:"whenCondition"`
	// Workspace ID of the resource
	WorkspaceId *string `pulumi:"workspaceId"`
}

type PolicyInfoState struct {
	// Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	ColumnMask PolicyInfoColumnMaskPtrInput
	// Optional description of the policy
	Comment pulumi.StringPtrInput
	// (integer) - Time at which the policy was created, in epoch milliseconds. Output only
	CreatedAt pulumi.IntPtrInput
	// (string) - Username of the user who created the policy. Output only
	CreatedBy pulumi.StringPtrInput
	// Optional list of user or group names that should be excluded from the policy
	ExceptPrincipals pulumi.StringArrayInput
	// Type of securables that the policy should take effect on.
	// Only `TABLE` is supported at this moment.
	// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	ForSecurableType pulumi.StringPtrInput
	// Optional list of condition expressions used to match table columns.
	// Only valid when `forSecurableType` is `TABLE`.
	// When specified, the policy only applies to tables whose columns satisfy all match conditions
	MatchColumns PolicyInfoMatchColumnArrayInput
	// Name of the policy. Required on create and optional on update.
	// To rename the policy, set `name` to a different value on update
	Name pulumi.StringPtrInput
	// Full name of the securable on which the policy is defined.
	// Required on create and ignored on update
	OnSecurableFullname pulumi.StringPtrInput
	// Type of the securable on which the policy is defined.
	// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
	// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	OnSecurableType pulumi.StringPtrInput
	// Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
	PolicyType pulumi.StringPtrInput
	// Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	RowFilter PolicyInfoRowFilterPtrInput
	// List of user or group names that the policy applies to.
	// Required on create and optional on update
	ToPrincipals pulumi.StringArrayInput
	// (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
	UpdatedAt pulumi.IntPtrInput
	// (string) - Username of the user who last modified the policy. Output only
	UpdatedBy pulumi.StringPtrInput
	// Optional condition when the policy should take effect
	WhenCondition pulumi.StringPtrInput
	// Workspace ID of the resource
	WorkspaceId pulumi.StringPtrInput
}

func (PolicyInfoState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyInfoState)(nil)).Elem()
}

type policyInfoArgs struct {
	// Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	ColumnMask *PolicyInfoColumnMask `pulumi:"columnMask"`
	// Optional description of the policy
	Comment *string `pulumi:"comment"`
	// Optional list of user or group names that should be excluded from the policy
	ExceptPrincipals []string `pulumi:"exceptPrincipals"`
	// Type of securables that the policy should take effect on.
	// Only `TABLE` is supported at this moment.
	// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	ForSecurableType string `pulumi:"forSecurableType"`
	// Optional list of condition expressions used to match table columns.
	// Only valid when `forSecurableType` is `TABLE`.
	// When specified, the policy only applies to tables whose columns satisfy all match conditions
	MatchColumns []PolicyInfoMatchColumn `pulumi:"matchColumns"`
	// Name of the policy. Required on create and optional on update.
	// To rename the policy, set `name` to a different value on update
	Name *string `pulumi:"name"`
	// Full name of the securable on which the policy is defined.
	// Required on create and ignored on update
	OnSecurableFullname *string `pulumi:"onSecurableFullname"`
	// Type of the securable on which the policy is defined.
	// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
	// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	OnSecurableType *string `pulumi:"onSecurableType"`
	// Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
	PolicyType string `pulumi:"policyType"`
	// Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	RowFilter *PolicyInfoRowFilter `pulumi:"rowFilter"`
	// List of user or group names that the policy applies to.
	// Required on create and optional on update
	ToPrincipals []string `pulumi:"toPrincipals"`
	// Optional condition when the policy should take effect
	WhenCondition *string `pulumi:"whenCondition"`
	// Workspace ID of the resource
	WorkspaceId *string `pulumi:"workspaceId"`
}

// The set of arguments for constructing a PolicyInfo resource.
type PolicyInfoArgs struct {
	// Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	ColumnMask PolicyInfoColumnMaskPtrInput
	// Optional description of the policy
	Comment pulumi.StringPtrInput
	// Optional list of user or group names that should be excluded from the policy
	ExceptPrincipals pulumi.StringArrayInput
	// Type of securables that the policy should take effect on.
	// Only `TABLE` is supported at this moment.
	// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	ForSecurableType pulumi.StringInput
	// Optional list of condition expressions used to match table columns.
	// Only valid when `forSecurableType` is `TABLE`.
	// When specified, the policy only applies to tables whose columns satisfy all match conditions
	MatchColumns PolicyInfoMatchColumnArrayInput
	// Name of the policy. Required on create and optional on update.
	// To rename the policy, set `name` to a different value on update
	Name pulumi.StringPtrInput
	// Full name of the securable on which the policy is defined.
	// Required on create and ignored on update
	OnSecurableFullname pulumi.StringPtrInput
	// Type of the securable on which the policy is defined.
	// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
	// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
	OnSecurableType pulumi.StringPtrInput
	// Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
	PolicyType pulumi.StringInput
	// Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
	// Required on create and optional on update. When specified on update,
	// the new options will replace the existing options as a whole
	RowFilter PolicyInfoRowFilterPtrInput
	// List of user or group names that the policy applies to.
	// Required on create and optional on update
	ToPrincipals pulumi.StringArrayInput
	// Optional condition when the policy should take effect
	WhenCondition pulumi.StringPtrInput
	// Workspace ID of the resource
	WorkspaceId pulumi.StringPtrInput
}

func (PolicyInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyInfoArgs)(nil)).Elem()
}

type PolicyInfoInput interface {
	pulumi.Input

	ToPolicyInfoOutput() PolicyInfoOutput
	ToPolicyInfoOutputWithContext(ctx context.Context) PolicyInfoOutput
}

func (*PolicyInfo) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyInfo)(nil)).Elem()
}

func (i *PolicyInfo) ToPolicyInfoOutput() PolicyInfoOutput {
	return i.ToPolicyInfoOutputWithContext(context.Background())
}

func (i *PolicyInfo) ToPolicyInfoOutputWithContext(ctx context.Context) PolicyInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyInfoOutput)
}

// PolicyInfoArrayInput is an input type that accepts PolicyInfoArray and PolicyInfoArrayOutput values.
// You can construct a concrete instance of `PolicyInfoArrayInput` via:
//
//	PolicyInfoArray{ PolicyInfoArgs{...} }
type PolicyInfoArrayInput interface {
	pulumi.Input

	ToPolicyInfoArrayOutput() PolicyInfoArrayOutput
	ToPolicyInfoArrayOutputWithContext(context.Context) PolicyInfoArrayOutput
}

type PolicyInfoArray []PolicyInfoInput

func (PolicyInfoArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyInfo)(nil)).Elem()
}

func (i PolicyInfoArray) ToPolicyInfoArrayOutput() PolicyInfoArrayOutput {
	return i.ToPolicyInfoArrayOutputWithContext(context.Background())
}

func (i PolicyInfoArray) ToPolicyInfoArrayOutputWithContext(ctx context.Context) PolicyInfoArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyInfoArrayOutput)
}

// PolicyInfoMapInput is an input type that accepts PolicyInfoMap and PolicyInfoMapOutput values.
// You can construct a concrete instance of `PolicyInfoMapInput` via:
//
//	PolicyInfoMap{ "key": PolicyInfoArgs{...} }
type PolicyInfoMapInput interface {
	pulumi.Input

	ToPolicyInfoMapOutput() PolicyInfoMapOutput
	ToPolicyInfoMapOutputWithContext(context.Context) PolicyInfoMapOutput
}

type PolicyInfoMap map[string]PolicyInfoInput

func (PolicyInfoMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyInfo)(nil)).Elem()
}

func (i PolicyInfoMap) ToPolicyInfoMapOutput() PolicyInfoMapOutput {
	return i.ToPolicyInfoMapOutputWithContext(context.Background())
}

func (i PolicyInfoMap) ToPolicyInfoMapOutputWithContext(ctx context.Context) PolicyInfoMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyInfoMapOutput)
}

type PolicyInfoOutput struct{ *pulumi.OutputState }

func (PolicyInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyInfo)(nil)).Elem()
}

func (o PolicyInfoOutput) ToPolicyInfoOutput() PolicyInfoOutput {
	return o
}

func (o PolicyInfoOutput) ToPolicyInfoOutputWithContext(ctx context.Context) PolicyInfoOutput {
	return o
}

// Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
// Required on create and optional on update. When specified on update,
// the new options will replace the existing options as a whole
func (o PolicyInfoOutput) ColumnMask() PolicyInfoColumnMaskPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) PolicyInfoColumnMaskPtrOutput { return v.ColumnMask }).(PolicyInfoColumnMaskPtrOutput)
}

// Optional description of the policy
func (o PolicyInfoOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// (integer) - Time at which the policy was created, in epoch milliseconds. Output only
func (o PolicyInfoOutput) CreatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.IntOutput { return v.CreatedAt }).(pulumi.IntOutput)
}

// (string) - Username of the user who created the policy. Output only
func (o PolicyInfoOutput) CreatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringOutput { return v.CreatedBy }).(pulumi.StringOutput)
}

// Optional list of user or group names that should be excluded from the policy
func (o PolicyInfoOutput) ExceptPrincipals() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringArrayOutput { return v.ExceptPrincipals }).(pulumi.StringArrayOutput)
}

// Type of securables that the policy should take effect on.
// Only `TABLE` is supported at this moment.
// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
func (o PolicyInfoOutput) ForSecurableType() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringOutput { return v.ForSecurableType }).(pulumi.StringOutput)
}

// Optional list of condition expressions used to match table columns.
// Only valid when `forSecurableType` is `TABLE`.
// When specified, the policy only applies to tables whose columns satisfy all match conditions
func (o PolicyInfoOutput) MatchColumns() PolicyInfoMatchColumnArrayOutput {
	return o.ApplyT(func(v *PolicyInfo) PolicyInfoMatchColumnArrayOutput { return v.MatchColumns }).(PolicyInfoMatchColumnArrayOutput)
}

// Name of the policy. Required on create and optional on update.
// To rename the policy, set `name` to a different value on update
func (o PolicyInfoOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Full name of the securable on which the policy is defined.
// Required on create and ignored on update
func (o PolicyInfoOutput) OnSecurableFullname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringPtrOutput { return v.OnSecurableFullname }).(pulumi.StringPtrOutput)
}

// Type of the securable on which the policy is defined.
// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
func (o PolicyInfoOutput) OnSecurableType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringPtrOutput { return v.OnSecurableType }).(pulumi.StringPtrOutput)
}

// Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
func (o PolicyInfoOutput) PolicyType() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringOutput { return v.PolicyType }).(pulumi.StringOutput)
}

// Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
// Required on create and optional on update. When specified on update,
// the new options will replace the existing options as a whole
func (o PolicyInfoOutput) RowFilter() PolicyInfoRowFilterPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) PolicyInfoRowFilterPtrOutput { return v.RowFilter }).(PolicyInfoRowFilterPtrOutput)
}

// List of user or group names that the policy applies to.
// Required on create and optional on update
func (o PolicyInfoOutput) ToPrincipals() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringArrayOutput { return v.ToPrincipals }).(pulumi.StringArrayOutput)
}

// (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
func (o PolicyInfoOutput) UpdatedAt() pulumi.IntOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.IntOutput { return v.UpdatedAt }).(pulumi.IntOutput)
}

// (string) - Username of the user who last modified the policy. Output only
func (o PolicyInfoOutput) UpdatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringOutput { return v.UpdatedBy }).(pulumi.StringOutput)
}

// Optional condition when the policy should take effect
func (o PolicyInfoOutput) WhenCondition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringPtrOutput { return v.WhenCondition }).(pulumi.StringPtrOutput)
}

// Workspace ID of the resource
func (o PolicyInfoOutput) WorkspaceId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyInfo) pulumi.StringPtrOutput { return v.WorkspaceId }).(pulumi.StringPtrOutput)
}

type PolicyInfoArrayOutput struct{ *pulumi.OutputState }

func (PolicyInfoArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyInfo)(nil)).Elem()
}

func (o PolicyInfoArrayOutput) ToPolicyInfoArrayOutput() PolicyInfoArrayOutput {
	return o
}

func (o PolicyInfoArrayOutput) ToPolicyInfoArrayOutputWithContext(ctx context.Context) PolicyInfoArrayOutput {
	return o
}

func (o PolicyInfoArrayOutput) Index(i pulumi.IntInput) PolicyInfoOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PolicyInfo {
		return vs[0].([]*PolicyInfo)[vs[1].(int)]
	}).(PolicyInfoOutput)
}

type PolicyInfoMapOutput struct{ *pulumi.OutputState }

func (PolicyInfoMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyInfo)(nil)).Elem()
}

func (o PolicyInfoMapOutput) ToPolicyInfoMapOutput() PolicyInfoMapOutput {
	return o
}

func (o PolicyInfoMapOutput) ToPolicyInfoMapOutputWithContext(ctx context.Context) PolicyInfoMapOutput {
	return o
}

func (o PolicyInfoMapOutput) MapIndex(k pulumi.StringInput) PolicyInfoOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PolicyInfo {
		return vs[0].(map[string]*PolicyInfo)[vs[1].(string)]
	}).(PolicyInfoOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyInfoInput)(nil)).Elem(), &PolicyInfo{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyInfoArrayInput)(nil)).Elem(), PolicyInfoArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyInfoMapInput)(nil)).Elem(), PolicyInfoMap{})
	pulumi.RegisterOutputType(PolicyInfoOutput{})
	pulumi.RegisterOutputType(PolicyInfoArrayOutput{})
	pulumi.RegisterOutputType(PolicyInfoMapOutput{})
}
