// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Administrators can use budget policies to ensure that the correct tags appear automatically on serverless resources without depending on users to attach tags manually, allowing for customized cost reporting and chargebacks. Budget policies consist of tags that are applied to any serverless compute activity incurred by a user assigned to the policy. The tags are logged in your billing records, allowing you to attribute serverless usage to specific budgets.
//
// > This resource can only be used with an account-level provider!
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := databricks.NewBudgetPolicy(ctx, "this", &databricks.BudgetPolicyArgs{
//				PolicyName: pulumi.String("my-budget-policy"),
//				CustomTags: databricks.BudgetPolicyCustomTagArray{
//					&databricks.BudgetPolicyCustomTagArgs{
//						Key:   pulumi.String("mykey"),
//						Value: pulumi.String("myvalue"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Access Control
//
// * AccessControlRuleSet can control which groups or individual users can manage or use the given budget policy.
//
// ## Import
//
// This resource can be imported by ID.
//
// ```sh
// $ pulumi import databricks:index/budgetPolicy:BudgetPolicy this policy_id
// ```
type BudgetPolicy struct {
	pulumi.CustomResourceState

	BindingWorkspaceIds pulumi.IntArrayOutput `pulumi:"bindingWorkspaceIds"`
	// A list of tags defined by the customer. At most 20 entries are allowed per policy.
	CustomTags BudgetPolicyCustomTagArrayOutput `pulumi:"customTags"`
	// ID of the budget policy
	PolicyId pulumi.StringOutput `pulumi:"policyId"`
	// The name of the policy. Must be unique among active policies. Can contain only characters from the ISO 8859-1 (latin1) set.
	PolicyName pulumi.StringPtrOutput `pulumi:"policyName"`
}

// NewBudgetPolicy registers a new resource with the given unique name, arguments, and options.
func NewBudgetPolicy(ctx *pulumi.Context,
	name string, args *BudgetPolicyArgs, opts ...pulumi.ResourceOption) (*BudgetPolicy, error) {
	if args == nil {
		args = &BudgetPolicyArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource BudgetPolicy
	err := ctx.RegisterResource("databricks:index/budgetPolicy:BudgetPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBudgetPolicy gets an existing BudgetPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBudgetPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BudgetPolicyState, opts ...pulumi.ResourceOption) (*BudgetPolicy, error) {
	var resource BudgetPolicy
	err := ctx.ReadResource("databricks:index/budgetPolicy:BudgetPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering BudgetPolicy resources.
type budgetPolicyState struct {
	BindingWorkspaceIds []int `pulumi:"bindingWorkspaceIds"`
	// A list of tags defined by the customer. At most 20 entries are allowed per policy.
	CustomTags []BudgetPolicyCustomTag `pulumi:"customTags"`
	// ID of the budget policy
	PolicyId *string `pulumi:"policyId"`
	// The name of the policy. Must be unique among active policies. Can contain only characters from the ISO 8859-1 (latin1) set.
	PolicyName *string `pulumi:"policyName"`
}

type BudgetPolicyState struct {
	BindingWorkspaceIds pulumi.IntArrayInput
	// A list of tags defined by the customer. At most 20 entries are allowed per policy.
	CustomTags BudgetPolicyCustomTagArrayInput
	// ID of the budget policy
	PolicyId pulumi.StringPtrInput
	// The name of the policy. Must be unique among active policies. Can contain only characters from the ISO 8859-1 (latin1) set.
	PolicyName pulumi.StringPtrInput
}

func (BudgetPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*budgetPolicyState)(nil)).Elem()
}

type budgetPolicyArgs struct {
	BindingWorkspaceIds []int `pulumi:"bindingWorkspaceIds"`
	// A list of tags defined by the customer. At most 20 entries are allowed per policy.
	CustomTags []BudgetPolicyCustomTag `pulumi:"customTags"`
	// The name of the policy. Must be unique among active policies. Can contain only characters from the ISO 8859-1 (latin1) set.
	PolicyName *string `pulumi:"policyName"`
}

// The set of arguments for constructing a BudgetPolicy resource.
type BudgetPolicyArgs struct {
	BindingWorkspaceIds pulumi.IntArrayInput
	// A list of tags defined by the customer. At most 20 entries are allowed per policy.
	CustomTags BudgetPolicyCustomTagArrayInput
	// The name of the policy. Must be unique among active policies. Can contain only characters from the ISO 8859-1 (latin1) set.
	PolicyName pulumi.StringPtrInput
}

func (BudgetPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*budgetPolicyArgs)(nil)).Elem()
}

type BudgetPolicyInput interface {
	pulumi.Input

	ToBudgetPolicyOutput() BudgetPolicyOutput
	ToBudgetPolicyOutputWithContext(ctx context.Context) BudgetPolicyOutput
}

func (*BudgetPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**BudgetPolicy)(nil)).Elem()
}

func (i *BudgetPolicy) ToBudgetPolicyOutput() BudgetPolicyOutput {
	return i.ToBudgetPolicyOutputWithContext(context.Background())
}

func (i *BudgetPolicy) ToBudgetPolicyOutputWithContext(ctx context.Context) BudgetPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BudgetPolicyOutput)
}

// BudgetPolicyArrayInput is an input type that accepts BudgetPolicyArray and BudgetPolicyArrayOutput values.
// You can construct a concrete instance of `BudgetPolicyArrayInput` via:
//
//	BudgetPolicyArray{ BudgetPolicyArgs{...} }
type BudgetPolicyArrayInput interface {
	pulumi.Input

	ToBudgetPolicyArrayOutput() BudgetPolicyArrayOutput
	ToBudgetPolicyArrayOutputWithContext(context.Context) BudgetPolicyArrayOutput
}

type BudgetPolicyArray []BudgetPolicyInput

func (BudgetPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BudgetPolicy)(nil)).Elem()
}

func (i BudgetPolicyArray) ToBudgetPolicyArrayOutput() BudgetPolicyArrayOutput {
	return i.ToBudgetPolicyArrayOutputWithContext(context.Background())
}

func (i BudgetPolicyArray) ToBudgetPolicyArrayOutputWithContext(ctx context.Context) BudgetPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BudgetPolicyArrayOutput)
}

// BudgetPolicyMapInput is an input type that accepts BudgetPolicyMap and BudgetPolicyMapOutput values.
// You can construct a concrete instance of `BudgetPolicyMapInput` via:
//
//	BudgetPolicyMap{ "key": BudgetPolicyArgs{...} }
type BudgetPolicyMapInput interface {
	pulumi.Input

	ToBudgetPolicyMapOutput() BudgetPolicyMapOutput
	ToBudgetPolicyMapOutputWithContext(context.Context) BudgetPolicyMapOutput
}

type BudgetPolicyMap map[string]BudgetPolicyInput

func (BudgetPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BudgetPolicy)(nil)).Elem()
}

func (i BudgetPolicyMap) ToBudgetPolicyMapOutput() BudgetPolicyMapOutput {
	return i.ToBudgetPolicyMapOutputWithContext(context.Background())
}

func (i BudgetPolicyMap) ToBudgetPolicyMapOutputWithContext(ctx context.Context) BudgetPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BudgetPolicyMapOutput)
}

type BudgetPolicyOutput struct{ *pulumi.OutputState }

func (BudgetPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BudgetPolicy)(nil)).Elem()
}

func (o BudgetPolicyOutput) ToBudgetPolicyOutput() BudgetPolicyOutput {
	return o
}

func (o BudgetPolicyOutput) ToBudgetPolicyOutputWithContext(ctx context.Context) BudgetPolicyOutput {
	return o
}

func (o BudgetPolicyOutput) BindingWorkspaceIds() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *BudgetPolicy) pulumi.IntArrayOutput { return v.BindingWorkspaceIds }).(pulumi.IntArrayOutput)
}

// A list of tags defined by the customer. At most 20 entries are allowed per policy.
func (o BudgetPolicyOutput) CustomTags() BudgetPolicyCustomTagArrayOutput {
	return o.ApplyT(func(v *BudgetPolicy) BudgetPolicyCustomTagArrayOutput { return v.CustomTags }).(BudgetPolicyCustomTagArrayOutput)
}

// ID of the budget policy
func (o BudgetPolicyOutput) PolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *BudgetPolicy) pulumi.StringOutput { return v.PolicyId }).(pulumi.StringOutput)
}

// The name of the policy. Must be unique among active policies. Can contain only characters from the ISO 8859-1 (latin1) set.
func (o BudgetPolicyOutput) PolicyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BudgetPolicy) pulumi.StringPtrOutput { return v.PolicyName }).(pulumi.StringPtrOutput)
}

type BudgetPolicyArrayOutput struct{ *pulumi.OutputState }

func (BudgetPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*BudgetPolicy)(nil)).Elem()
}

func (o BudgetPolicyArrayOutput) ToBudgetPolicyArrayOutput() BudgetPolicyArrayOutput {
	return o
}

func (o BudgetPolicyArrayOutput) ToBudgetPolicyArrayOutputWithContext(ctx context.Context) BudgetPolicyArrayOutput {
	return o
}

func (o BudgetPolicyArrayOutput) Index(i pulumi.IntInput) BudgetPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *BudgetPolicy {
		return vs[0].([]*BudgetPolicy)[vs[1].(int)]
	}).(BudgetPolicyOutput)
}

type BudgetPolicyMapOutput struct{ *pulumi.OutputState }

func (BudgetPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*BudgetPolicy)(nil)).Elem()
}

func (o BudgetPolicyMapOutput) ToBudgetPolicyMapOutput() BudgetPolicyMapOutput {
	return o
}

func (o BudgetPolicyMapOutput) ToBudgetPolicyMapOutputWithContext(ctx context.Context) BudgetPolicyMapOutput {
	return o
}

func (o BudgetPolicyMapOutput) MapIndex(k pulumi.StringInput) BudgetPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *BudgetPolicy {
		return vs[0].(map[string]*BudgetPolicy)[vs[1].(string)]
	}).(BudgetPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BudgetPolicyInput)(nil)).Elem(), &BudgetPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*BudgetPolicyArrayInput)(nil)).Elem(), BudgetPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BudgetPolicyMapInput)(nil)).Elem(), BudgetPolicyMap{})
	pulumi.RegisterOutputType(BudgetPolicyOutput{})
	pulumi.RegisterOutputType(BudgetPolicyArrayOutput{})
	pulumi.RegisterOutputType(BudgetPolicyMapOutput{})
}
