// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type SqlTable struct {
	pulumi.CustomResourceState

	CatalogName           pulumi.StringOutput       `pulumi:"catalogName"`
	ClusterId             pulumi.StringOutput       `pulumi:"clusterId"`
	ClusterKeys           pulumi.StringArrayOutput  `pulumi:"clusterKeys"`
	Columns               SqlTableColumnArrayOutput `pulumi:"columns"`
	Comment               pulumi.StringPtrOutput    `pulumi:"comment"`
	DataSourceFormat      pulumi.StringPtrOutput    `pulumi:"dataSourceFormat"`
	EffectiveProperties   pulumi.StringMapOutput    `pulumi:"effectiveProperties"`
	Name                  pulumi.StringOutput       `pulumi:"name"`
	Options               pulumi.StringMapOutput    `pulumi:"options"`
	Owner                 pulumi.StringOutput       `pulumi:"owner"`
	Partitions            pulumi.StringArrayOutput  `pulumi:"partitions"`
	Properties            pulumi.StringMapOutput    `pulumi:"properties"`
	SchemaName            pulumi.StringOutput       `pulumi:"schemaName"`
	StorageCredentialName pulumi.StringPtrOutput    `pulumi:"storageCredentialName"`
	StorageLocation       pulumi.StringPtrOutput    `pulumi:"storageLocation"`
	TableType             pulumi.StringOutput       `pulumi:"tableType"`
	ViewDefinition        pulumi.StringPtrOutput    `pulumi:"viewDefinition"`
	WarehouseId           pulumi.StringPtrOutput    `pulumi:"warehouseId"`
}

// NewSqlTable registers a new resource with the given unique name, arguments, and options.
func NewSqlTable(ctx *pulumi.Context,
	name string, args *SqlTableArgs, opts ...pulumi.ResourceOption) (*SqlTable, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CatalogName == nil {
		return nil, errors.New("invalid value for required argument 'CatalogName'")
	}
	if args.SchemaName == nil {
		return nil, errors.New("invalid value for required argument 'SchemaName'")
	}
	if args.TableType == nil {
		return nil, errors.New("invalid value for required argument 'TableType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SqlTable
	err := ctx.RegisterResource("databricks:index/sqlTable:SqlTable", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSqlTable gets an existing SqlTable resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSqlTable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SqlTableState, opts ...pulumi.ResourceOption) (*SqlTable, error) {
	var resource SqlTable
	err := ctx.ReadResource("databricks:index/sqlTable:SqlTable", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SqlTable resources.
type sqlTableState struct {
	CatalogName           *string           `pulumi:"catalogName"`
	ClusterId             *string           `pulumi:"clusterId"`
	ClusterKeys           []string          `pulumi:"clusterKeys"`
	Columns               []SqlTableColumn  `pulumi:"columns"`
	Comment               *string           `pulumi:"comment"`
	DataSourceFormat      *string           `pulumi:"dataSourceFormat"`
	EffectiveProperties   map[string]string `pulumi:"effectiveProperties"`
	Name                  *string           `pulumi:"name"`
	Options               map[string]string `pulumi:"options"`
	Owner                 *string           `pulumi:"owner"`
	Partitions            []string          `pulumi:"partitions"`
	Properties            map[string]string `pulumi:"properties"`
	SchemaName            *string           `pulumi:"schemaName"`
	StorageCredentialName *string           `pulumi:"storageCredentialName"`
	StorageLocation       *string           `pulumi:"storageLocation"`
	TableType             *string           `pulumi:"tableType"`
	ViewDefinition        *string           `pulumi:"viewDefinition"`
	WarehouseId           *string           `pulumi:"warehouseId"`
}

type SqlTableState struct {
	CatalogName           pulumi.StringPtrInput
	ClusterId             pulumi.StringPtrInput
	ClusterKeys           pulumi.StringArrayInput
	Columns               SqlTableColumnArrayInput
	Comment               pulumi.StringPtrInput
	DataSourceFormat      pulumi.StringPtrInput
	EffectiveProperties   pulumi.StringMapInput
	Name                  pulumi.StringPtrInput
	Options               pulumi.StringMapInput
	Owner                 pulumi.StringPtrInput
	Partitions            pulumi.StringArrayInput
	Properties            pulumi.StringMapInput
	SchemaName            pulumi.StringPtrInput
	StorageCredentialName pulumi.StringPtrInput
	StorageLocation       pulumi.StringPtrInput
	TableType             pulumi.StringPtrInput
	ViewDefinition        pulumi.StringPtrInput
	WarehouseId           pulumi.StringPtrInput
}

func (SqlTableState) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTableState)(nil)).Elem()
}

type sqlTableArgs struct {
	CatalogName           string            `pulumi:"catalogName"`
	ClusterId             *string           `pulumi:"clusterId"`
	ClusterKeys           []string          `pulumi:"clusterKeys"`
	Columns               []SqlTableColumn  `pulumi:"columns"`
	Comment               *string           `pulumi:"comment"`
	DataSourceFormat      *string           `pulumi:"dataSourceFormat"`
	Name                  *string           `pulumi:"name"`
	Options               map[string]string `pulumi:"options"`
	Owner                 *string           `pulumi:"owner"`
	Partitions            []string          `pulumi:"partitions"`
	Properties            map[string]string `pulumi:"properties"`
	SchemaName            string            `pulumi:"schemaName"`
	StorageCredentialName *string           `pulumi:"storageCredentialName"`
	StorageLocation       *string           `pulumi:"storageLocation"`
	TableType             string            `pulumi:"tableType"`
	ViewDefinition        *string           `pulumi:"viewDefinition"`
	WarehouseId           *string           `pulumi:"warehouseId"`
}

// The set of arguments for constructing a SqlTable resource.
type SqlTableArgs struct {
	CatalogName           pulumi.StringInput
	ClusterId             pulumi.StringPtrInput
	ClusterKeys           pulumi.StringArrayInput
	Columns               SqlTableColumnArrayInput
	Comment               pulumi.StringPtrInput
	DataSourceFormat      pulumi.StringPtrInput
	Name                  pulumi.StringPtrInput
	Options               pulumi.StringMapInput
	Owner                 pulumi.StringPtrInput
	Partitions            pulumi.StringArrayInput
	Properties            pulumi.StringMapInput
	SchemaName            pulumi.StringInput
	StorageCredentialName pulumi.StringPtrInput
	StorageLocation       pulumi.StringPtrInput
	TableType             pulumi.StringInput
	ViewDefinition        pulumi.StringPtrInput
	WarehouseId           pulumi.StringPtrInput
}

func (SqlTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTableArgs)(nil)).Elem()
}

type SqlTableInput interface {
	pulumi.Input

	ToSqlTableOutput() SqlTableOutput
	ToSqlTableOutputWithContext(ctx context.Context) SqlTableOutput
}

func (*SqlTable) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTable)(nil)).Elem()
}

func (i *SqlTable) ToSqlTableOutput() SqlTableOutput {
	return i.ToSqlTableOutputWithContext(context.Background())
}

func (i *SqlTable) ToSqlTableOutputWithContext(ctx context.Context) SqlTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTableOutput)
}

// SqlTableArrayInput is an input type that accepts SqlTableArray and SqlTableArrayOutput values.
// You can construct a concrete instance of `SqlTableArrayInput` via:
//
//	SqlTableArray{ SqlTableArgs{...} }
type SqlTableArrayInput interface {
	pulumi.Input

	ToSqlTableArrayOutput() SqlTableArrayOutput
	ToSqlTableArrayOutputWithContext(context.Context) SqlTableArrayOutput
}

type SqlTableArray []SqlTableInput

func (SqlTableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTable)(nil)).Elem()
}

func (i SqlTableArray) ToSqlTableArrayOutput() SqlTableArrayOutput {
	return i.ToSqlTableArrayOutputWithContext(context.Background())
}

func (i SqlTableArray) ToSqlTableArrayOutputWithContext(ctx context.Context) SqlTableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTableArrayOutput)
}

// SqlTableMapInput is an input type that accepts SqlTableMap and SqlTableMapOutput values.
// You can construct a concrete instance of `SqlTableMapInput` via:
//
//	SqlTableMap{ "key": SqlTableArgs{...} }
type SqlTableMapInput interface {
	pulumi.Input

	ToSqlTableMapOutput() SqlTableMapOutput
	ToSqlTableMapOutputWithContext(context.Context) SqlTableMapOutput
}

type SqlTableMap map[string]SqlTableInput

func (SqlTableMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTable)(nil)).Elem()
}

func (i SqlTableMap) ToSqlTableMapOutput() SqlTableMapOutput {
	return i.ToSqlTableMapOutputWithContext(context.Background())
}

func (i SqlTableMap) ToSqlTableMapOutputWithContext(ctx context.Context) SqlTableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTableMapOutput)
}

type SqlTableOutput struct{ *pulumi.OutputState }

func (SqlTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTable)(nil)).Elem()
}

func (o SqlTableOutput) ToSqlTableOutput() SqlTableOutput {
	return o
}

func (o SqlTableOutput) ToSqlTableOutputWithContext(ctx context.Context) SqlTableOutput {
	return o
}

func (o SqlTableOutput) CatalogName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.CatalogName }).(pulumi.StringOutput)
}

func (o SqlTableOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

func (o SqlTableOutput) ClusterKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringArrayOutput { return v.ClusterKeys }).(pulumi.StringArrayOutput)
}

func (o SqlTableOutput) Columns() SqlTableColumnArrayOutput {
	return o.ApplyT(func(v *SqlTable) SqlTableColumnArrayOutput { return v.Columns }).(SqlTableColumnArrayOutput)
}

func (o SqlTableOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

func (o SqlTableOutput) DataSourceFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.DataSourceFormat }).(pulumi.StringPtrOutput)
}

func (o SqlTableOutput) EffectiveProperties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringMapOutput { return v.EffectiveProperties }).(pulumi.StringMapOutput)
}

func (o SqlTableOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o SqlTableOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringMapOutput { return v.Options }).(pulumi.StringMapOutput)
}

func (o SqlTableOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

func (o SqlTableOutput) Partitions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringArrayOutput { return v.Partitions }).(pulumi.StringArrayOutput)
}

func (o SqlTableOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringMapOutput { return v.Properties }).(pulumi.StringMapOutput)
}

func (o SqlTableOutput) SchemaName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.SchemaName }).(pulumi.StringOutput)
}

func (o SqlTableOutput) StorageCredentialName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.StorageCredentialName }).(pulumi.StringPtrOutput)
}

func (o SqlTableOutput) StorageLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.StorageLocation }).(pulumi.StringPtrOutput)
}

func (o SqlTableOutput) TableType() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.TableType }).(pulumi.StringOutput)
}

func (o SqlTableOutput) ViewDefinition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.ViewDefinition }).(pulumi.StringPtrOutput)
}

func (o SqlTableOutput) WarehouseId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.WarehouseId }).(pulumi.StringPtrOutput)
}

type SqlTableArrayOutput struct{ *pulumi.OutputState }

func (SqlTableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTable)(nil)).Elem()
}

func (o SqlTableArrayOutput) ToSqlTableArrayOutput() SqlTableArrayOutput {
	return o
}

func (o SqlTableArrayOutput) ToSqlTableArrayOutputWithContext(ctx context.Context) SqlTableArrayOutput {
	return o
}

func (o SqlTableArrayOutput) Index(i pulumi.IntInput) SqlTableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SqlTable {
		return vs[0].([]*SqlTable)[vs[1].(int)]
	}).(SqlTableOutput)
}

type SqlTableMapOutput struct{ *pulumi.OutputState }

func (SqlTableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTable)(nil)).Elem()
}

func (o SqlTableMapOutput) ToSqlTableMapOutput() SqlTableMapOutput {
	return o
}

func (o SqlTableMapOutput) ToSqlTableMapOutputWithContext(ctx context.Context) SqlTableMapOutput {
	return o
}

func (o SqlTableMapOutput) MapIndex(k pulumi.StringInput) SqlTableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SqlTable {
		return vs[0].(map[string]*SqlTable)[vs[1].(string)]
	}).(SqlTableOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTableInput)(nil)).Elem(), &SqlTable{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTableArrayInput)(nil)).Elem(), SqlTableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTableMapInput)(nil)).Elem(), SqlTableMap{})
	pulumi.RegisterOutputType(SqlTableOutput{})
	pulumi.RegisterOutputType(SqlTableArrayOutput{})
	pulumi.RegisterOutputType(SqlTableMapOutput{})
}
