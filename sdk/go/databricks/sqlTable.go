// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Within a metastore, Unity Catalog provides a 3-level namespace for organizing data: Catalogs, databases (also called schemas), and tables/views.
//
// A `SqlTable` is contained within databricks_schema, and can represent either a managed table, an external table, or a view.
//
// This resource creates and updates the Unity Catalog table/view by executing the necessary SQL queries on a special auto-terminating cluster it would create for this operation. You could also specify a SQL warehouse or cluster for the queries to be executed on.
//
// > This resource can only be used with a workspace-level provider!
//
// > This resource doesn't handle complex cases of schema evolution due to the limitations of Pulumi itself.  If you need to implement schema evolution it's recommended to use specialized tools, such as, [Liquibase](https://medium.com/dbsql-sme-engineering/advanced-schema-management-on-databricks-with-liquibase-1900e9f7b9c0) and [Flyway](https://medium.com/dbsql-sme-engineering/databricks-schema-management-with-flyway-527c4a9f5d67).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			sandbox, err := databricks.NewCatalog(ctx, "sandbox", &databricks.CatalogArgs{
//				Name:    pulumi.String("sandbox"),
//				Comment: pulumi.String("this catalog is managed by terraform"),
//				Properties: pulumi.StringMap{
//					"purpose": pulumi.String("testing"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			things, err := databricks.NewSchema(ctx, "things", &databricks.SchemaArgs{
//				CatalogName: sandbox.ID(),
//				Name:        pulumi.String("things"),
//				Comment:     pulumi.String("this database is managed by terraform"),
//				Properties: pulumi.StringMap{
//					"kind": pulumi.String("various"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			thing, err := databricks.NewSqlTable(ctx, "thing", &databricks.SqlTableArgs{
//				Name:        pulumi.String("quickstart_table"),
//				CatalogName: sandbox.Name,
//				SchemaName:  things.Name,
//				TableType:   pulumi.String("MANAGED"),
//				Columns: databricks.SqlTableColumnArray{
//					&databricks.SqlTableColumnArgs{
//						Name: pulumi.String("id"),
//						Type: pulumi.String("int"),
//					},
//					&databricks.SqlTableColumnArgs{
//						Name:    pulumi.String("name"),
//						Type:    pulumi.String("string"),
//						Comment: pulumi.String("name of thing"),
//					},
//				},
//				Comment: pulumi.String("this table is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			invokeFormat, err := std.Format(ctx, &std.FormatArgs{
//				Input: "SELECT name FROM %s WHERE id == 1",
//				Args: pulumi.StringArray{
//					thing.ID(),
//				},
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewSqlTable(ctx, "thing_view", &databricks.SqlTableArgs{
//				Name:           pulumi.String("quickstart_table_view"),
//				CatalogName:    sandbox.Name,
//				SchemaName:     things.Name,
//				TableType:      pulumi.String("VIEW"),
//				ClusterId:      pulumi.String("0423-201305-xsrt82qn"),
//				ViewDefinition: pulumi.String(invokeFormat.Result),
//				Comment:        pulumi.String("this view is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Use an existing warehouse to create a table
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			this, err := databricks.NewSqlEndpoint(ctx, "this", &databricks.SqlEndpointArgs{
//				Name:           pulumi.String("endpoint"),
//				ClusterSize:    pulumi.String("2X-Small"),
//				MaxNumClusters: pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			thing, err := databricks.NewSqlTable(ctx, "thing", &databricks.SqlTableArgs{
//				Name:        pulumi.String("quickstart_table"),
//				CatalogName: pulumi.Any(sandbox.Name),
//				SchemaName:  pulumi.Any(things.Name),
//				TableType:   pulumi.String("MANAGED"),
//				WarehouseId: this.ID(),
//				Columns: databricks.SqlTableColumnArray{
//					&databricks.SqlTableColumnArgs{
//						Name: pulumi.String("id"),
//						Type: pulumi.String("int"),
//					},
//					&databricks.SqlTableColumnArgs{
//						Name:    pulumi.String("name"),
//						Type:    pulumi.String("string"),
//						Comment: pulumi.String("name of thing"),
//					},
//				},
//				Comment: pulumi.String("this table is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			invokeFormat, err := std.Format(ctx, &std.FormatArgs{
//				Input: "SELECT name FROM %s WHERE id == 1",
//				Args: pulumi.StringArray{
//					thing.ID(),
//				},
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewSqlTable(ctx, "thing_view", &databricks.SqlTableArgs{
//				Name:           pulumi.String("quickstart_table_view"),
//				CatalogName:    pulumi.Any(sandbox.Name),
//				SchemaName:     pulumi.Any(things.Name),
//				TableType:      pulumi.String("VIEW"),
//				WarehouseId:    this.ID(),
//				ViewDefinition: pulumi.String(invokeFormat.Result),
//				Comment:        pulumi.String("this view is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Use an Identity Column
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			sandbox, err := databricks.NewCatalog(ctx, "sandbox", &databricks.CatalogArgs{
//				Name:    pulumi.String("sandbox"),
//				Comment: pulumi.String("this catalog is managed by terraform"),
//				Properties: pulumi.StringMap{
//					"purpose": pulumi.String("testing"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			things, err := databricks.NewSchema(ctx, "things", &databricks.SchemaArgs{
//				CatalogName: sandbox.ID(),
//				Name:        pulumi.String("things"),
//				Comment:     pulumi.String("this database is managed by terraform"),
//				Properties: pulumi.StringMap{
//					"kind": pulumi.String("various"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewSqlTable(ctx, "thing", &databricks.SqlTableArgs{
//				Name:        pulumi.String("identity_table"),
//				CatalogName: sandbox.Name,
//				SchemaName:  things.Name,
//				TableType:   pulumi.String("MANAGED"),
//				Columns: databricks.SqlTableColumnArray{
//					&databricks.SqlTableColumnArgs{
//						Name:     pulumi.String("id"),
//						Type:     pulumi.String("bigint"),
//						Identity: pulumi.String("default"),
//					},
//					&databricks.SqlTableColumnArgs{
//						Name:    pulumi.String("name"),
//						Type:    pulumi.String("string"),
//						Comment: pulumi.String("name of thing"),
//					},
//				},
//				Comment: pulumi.String("this table is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Enable automatic clustering
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := databricks.NewSqlTable(ctx, "thing", &databricks.SqlTableArgs{
//				Name:        pulumi.String("auto_cluster_table"),
//				CatalogName: pulumi.Any(sandbox.Name),
//				SchemaName:  pulumi.Any(things.Name),
//				TableType:   pulumi.String("MANAGED"),
//				ClusterKeys: pulumi.StringArray{
//					pulumi.String("AUTO"),
//				},
//				Columns: databricks.SqlTableColumnArray{
//					&databricks.SqlTableColumnArgs{
//						Name:    pulumi.String("name"),
//						Type:    pulumi.String("string"),
//						Comment: pulumi.String("name of thing"),
//					},
//				},
//				Comment: pulumi.String("this table is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Migration from `Table`
//
// The `Table` resource has been deprecated in favor of `SqlTable`. To migrate from `Table` to `SqlTable`:
//
// 1. Define a `SqlTable` resource with arguments corresponding to `Table`.
// 2. Add a `removed` block to remove the `Table` resource without deleting the existing table by using the `lifecycle` block. If you're using Pulumi version below v1.7.0, you will need to use the `terraform state rm` command instead.
// 3. Add an `import` block to add the `SqlTable` resource, corresponding to the existing table. If you're using Pulumi version below v1.5.0, you will need to use `pulumi import` command instead.
//
// For example, suppose we have the following `Table` resource:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := databricks.NewTable(ctx, "this", &databricks.TableArgs{
//				CatalogName:      pulumi.String("catalog"),
//				SchemaName:       pulumi.String("schema"),
//				Name:             pulumi.String("table"),
//				TableType:        pulumi.String("MANAGED"),
//				DataSourceFormat: pulumi.String("DELTA"),
//				Columns: databricks.TableColumnArray{
//					&databricks.TableColumnArgs{
//						Name:     pulumi.String("col1"),
//						TypeName: pulumi.String("STRING"),
//						TypeJson: pulumi.String("{\"type\":\"STRING\"}"),
//						Comment:  pulumi.String("comment"),
//						Nullable: pulumi.Bool(true),
//					},
//				},
//				Comment: pulumi.String("comment"),
//				Properties: pulumi.StringMap{
//					"key": pulumi.String("value"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// The migration would look like this:
type SqlTable struct {
	pulumi.CustomResourceState

	// Name of parent catalog. Change forces the creation of a new resource.
	CatalogName pulumi.StringOutput `pulumi:"catalogName"`
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
	ClusterKeys pulumi.StringArrayOutput  `pulumi:"clusterKeys"`
	Columns     SqlTableColumnArrayOutput `pulumi:"columns"`
	// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
	DataSourceFormat    pulumi.StringPtrOutput `pulumi:"dataSourceFormat"`
	EffectiveProperties pulumi.StringMapOutput `pulumi:"effectiveProperties"`
	// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Map of user defined table options. Change forces creation of a new resource.
	Options pulumi.StringMapOutput `pulumi:"options"`
	// User name/group name/sp applicationId of the table owner.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
	Partitions pulumi.StringArrayOutput `pulumi:"partitions"`
	// A map of table properties.
	Properties pulumi.StringMapOutput `pulumi:"properties"`
	// Configure the provider for management through account provider. This block consists of the following fields:
	ProviderConfig SqlTableProviderConfigPtrOutput `pulumi:"providerConfig"`
	// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
	SchemaName pulumi.StringOutput `pulumi:"schemaName"`
	// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
	StorageCredentialName pulumi.StringPtrOutput `pulumi:"storageCredentialName"`
	// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
	StorageLocation pulumi.StringPtrOutput `pulumi:"storageLocation"`
	// The unique identifier of the table.
	TableId pulumi.StringOutput `pulumi:"tableId"`
	// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
	TableType pulumi.StringOutput `pulumi:"tableType"`
	// SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
	ViewDefinition pulumi.StringPtrOutput `pulumi:"viewDefinition"`
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
	WarehouseId pulumi.StringPtrOutput `pulumi:"warehouseId"`
}

// NewSqlTable registers a new resource with the given unique name, arguments, and options.
func NewSqlTable(ctx *pulumi.Context,
	name string, args *SqlTableArgs, opts ...pulumi.ResourceOption) (*SqlTable, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CatalogName == nil {
		return nil, errors.New("invalid value for required argument 'CatalogName'")
	}
	if args.SchemaName == nil {
		return nil, errors.New("invalid value for required argument 'SchemaName'")
	}
	if args.TableType == nil {
		return nil, errors.New("invalid value for required argument 'TableType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SqlTable
	err := ctx.RegisterResource("databricks:index/sqlTable:SqlTable", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSqlTable gets an existing SqlTable resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSqlTable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SqlTableState, opts ...pulumi.ResourceOption) (*SqlTable, error) {
	var resource SqlTable
	err := ctx.ReadResource("databricks:index/sqlTable:SqlTable", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SqlTable resources.
type sqlTableState struct {
	// Name of parent catalog. Change forces the creation of a new resource.
	CatalogName *string `pulumi:"catalogName"`
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
	ClusterId *string `pulumi:"clusterId"`
	// a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
	ClusterKeys []string         `pulumi:"clusterKeys"`
	Columns     []SqlTableColumn `pulumi:"columns"`
	// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
	Comment *string `pulumi:"comment"`
	// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
	DataSourceFormat    *string           `pulumi:"dataSourceFormat"`
	EffectiveProperties map[string]string `pulumi:"effectiveProperties"`
	// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
	Name *string `pulumi:"name"`
	// Map of user defined table options. Change forces creation of a new resource.
	Options map[string]string `pulumi:"options"`
	// User name/group name/sp applicationId of the table owner.
	Owner *string `pulumi:"owner"`
	// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
	Partitions []string `pulumi:"partitions"`
	// A map of table properties.
	Properties map[string]string `pulumi:"properties"`
	// Configure the provider for management through account provider. This block consists of the following fields:
	ProviderConfig *SqlTableProviderConfig `pulumi:"providerConfig"`
	// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
	SchemaName *string `pulumi:"schemaName"`
	// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
	StorageCredentialName *string `pulumi:"storageCredentialName"`
	// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
	StorageLocation *string `pulumi:"storageLocation"`
	// The unique identifier of the table.
	TableId *string `pulumi:"tableId"`
	// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
	TableType *string `pulumi:"tableType"`
	// SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
	ViewDefinition *string `pulumi:"viewDefinition"`
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
	WarehouseId *string `pulumi:"warehouseId"`
}

type SqlTableState struct {
	// Name of parent catalog. Change forces the creation of a new resource.
	CatalogName pulumi.StringPtrInput
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
	ClusterId pulumi.StringPtrInput
	// a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
	ClusterKeys pulumi.StringArrayInput
	Columns     SqlTableColumnArrayInput
	// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
	Comment pulumi.StringPtrInput
	// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
	DataSourceFormat    pulumi.StringPtrInput
	EffectiveProperties pulumi.StringMapInput
	// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
	Name pulumi.StringPtrInput
	// Map of user defined table options. Change forces creation of a new resource.
	Options pulumi.StringMapInput
	// User name/group name/sp applicationId of the table owner.
	Owner pulumi.StringPtrInput
	// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
	Partitions pulumi.StringArrayInput
	// A map of table properties.
	Properties pulumi.StringMapInput
	// Configure the provider for management through account provider. This block consists of the following fields:
	ProviderConfig SqlTableProviderConfigPtrInput
	// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
	SchemaName pulumi.StringPtrInput
	// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
	StorageCredentialName pulumi.StringPtrInput
	// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
	StorageLocation pulumi.StringPtrInput
	// The unique identifier of the table.
	TableId pulumi.StringPtrInput
	// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
	TableType pulumi.StringPtrInput
	// SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
	ViewDefinition pulumi.StringPtrInput
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
	WarehouseId pulumi.StringPtrInput
}

func (SqlTableState) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTableState)(nil)).Elem()
}

type sqlTableArgs struct {
	// Name of parent catalog. Change forces the creation of a new resource.
	CatalogName string `pulumi:"catalogName"`
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
	ClusterId *string `pulumi:"clusterId"`
	// a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
	ClusterKeys []string         `pulumi:"clusterKeys"`
	Columns     []SqlTableColumn `pulumi:"columns"`
	// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
	Comment *string `pulumi:"comment"`
	// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
	DataSourceFormat *string `pulumi:"dataSourceFormat"`
	// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
	Name *string `pulumi:"name"`
	// Map of user defined table options. Change forces creation of a new resource.
	Options map[string]string `pulumi:"options"`
	// User name/group name/sp applicationId of the table owner.
	Owner *string `pulumi:"owner"`
	// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
	Partitions []string `pulumi:"partitions"`
	// A map of table properties.
	Properties map[string]string `pulumi:"properties"`
	// Configure the provider for management through account provider. This block consists of the following fields:
	ProviderConfig *SqlTableProviderConfig `pulumi:"providerConfig"`
	// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
	SchemaName string `pulumi:"schemaName"`
	// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
	StorageCredentialName *string `pulumi:"storageCredentialName"`
	// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
	StorageLocation *string `pulumi:"storageLocation"`
	// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
	TableType string `pulumi:"tableType"`
	// SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
	ViewDefinition *string `pulumi:"viewDefinition"`
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
	WarehouseId *string `pulumi:"warehouseId"`
}

// The set of arguments for constructing a SqlTable resource.
type SqlTableArgs struct {
	// Name of parent catalog. Change forces the creation of a new resource.
	CatalogName pulumi.StringInput
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
	ClusterId pulumi.StringPtrInput
	// a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
	ClusterKeys pulumi.StringArrayInput
	Columns     SqlTableColumnArrayInput
	// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
	Comment pulumi.StringPtrInput
	// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
	DataSourceFormat pulumi.StringPtrInput
	// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
	Name pulumi.StringPtrInput
	// Map of user defined table options. Change forces creation of a new resource.
	Options pulumi.StringMapInput
	// User name/group name/sp applicationId of the table owner.
	Owner pulumi.StringPtrInput
	// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
	Partitions pulumi.StringArrayInput
	// A map of table properties.
	Properties pulumi.StringMapInput
	// Configure the provider for management through account provider. This block consists of the following fields:
	ProviderConfig SqlTableProviderConfigPtrInput
	// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
	SchemaName pulumi.StringInput
	// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
	StorageCredentialName pulumi.StringPtrInput
	// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
	StorageLocation pulumi.StringPtrInput
	// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
	TableType pulumi.StringInput
	// SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
	ViewDefinition pulumi.StringPtrInput
	// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
	WarehouseId pulumi.StringPtrInput
}

func (SqlTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sqlTableArgs)(nil)).Elem()
}

type SqlTableInput interface {
	pulumi.Input

	ToSqlTableOutput() SqlTableOutput
	ToSqlTableOutputWithContext(ctx context.Context) SqlTableOutput
}

func (*SqlTable) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTable)(nil)).Elem()
}

func (i *SqlTable) ToSqlTableOutput() SqlTableOutput {
	return i.ToSqlTableOutputWithContext(context.Background())
}

func (i *SqlTable) ToSqlTableOutputWithContext(ctx context.Context) SqlTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTableOutput)
}

// SqlTableArrayInput is an input type that accepts SqlTableArray and SqlTableArrayOutput values.
// You can construct a concrete instance of `SqlTableArrayInput` via:
//
//	SqlTableArray{ SqlTableArgs{...} }
type SqlTableArrayInput interface {
	pulumi.Input

	ToSqlTableArrayOutput() SqlTableArrayOutput
	ToSqlTableArrayOutputWithContext(context.Context) SqlTableArrayOutput
}

type SqlTableArray []SqlTableInput

func (SqlTableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTable)(nil)).Elem()
}

func (i SqlTableArray) ToSqlTableArrayOutput() SqlTableArrayOutput {
	return i.ToSqlTableArrayOutputWithContext(context.Background())
}

func (i SqlTableArray) ToSqlTableArrayOutputWithContext(ctx context.Context) SqlTableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTableArrayOutput)
}

// SqlTableMapInput is an input type that accepts SqlTableMap and SqlTableMapOutput values.
// You can construct a concrete instance of `SqlTableMapInput` via:
//
//	SqlTableMap{ "key": SqlTableArgs{...} }
type SqlTableMapInput interface {
	pulumi.Input

	ToSqlTableMapOutput() SqlTableMapOutput
	ToSqlTableMapOutputWithContext(context.Context) SqlTableMapOutput
}

type SqlTableMap map[string]SqlTableInput

func (SqlTableMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTable)(nil)).Elem()
}

func (i SqlTableMap) ToSqlTableMapOutput() SqlTableMapOutput {
	return i.ToSqlTableMapOutputWithContext(context.Background())
}

func (i SqlTableMap) ToSqlTableMapOutputWithContext(ctx context.Context) SqlTableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SqlTableMapOutput)
}

type SqlTableOutput struct{ *pulumi.OutputState }

func (SqlTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SqlTable)(nil)).Elem()
}

func (o SqlTableOutput) ToSqlTableOutput() SqlTableOutput {
	return o
}

func (o SqlTableOutput) ToSqlTableOutputWithContext(ctx context.Context) SqlTableOutput {
	return o
}

// Name of parent catalog. Change forces the creation of a new resource.
func (o SqlTableOutput) CatalogName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.CatalogName }).(pulumi.StringOutput)
}

// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
func (o SqlTableOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
func (o SqlTableOutput) ClusterKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringArrayOutput { return v.ClusterKeys }).(pulumi.StringArrayOutput)
}

func (o SqlTableOutput) Columns() SqlTableColumnArrayOutput {
	return o.ApplyT(func(v *SqlTable) SqlTableColumnArrayOutput { return v.Columns }).(SqlTableColumnArrayOutput)
}

// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
func (o SqlTableOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
func (o SqlTableOutput) DataSourceFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.DataSourceFormat }).(pulumi.StringPtrOutput)
}

func (o SqlTableOutput) EffectiveProperties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringMapOutput { return v.EffectiveProperties }).(pulumi.StringMapOutput)
}

// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
func (o SqlTableOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Map of user defined table options. Change forces creation of a new resource.
func (o SqlTableOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringMapOutput { return v.Options }).(pulumi.StringMapOutput)
}

// User name/group name/sp applicationId of the table owner.
func (o SqlTableOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
func (o SqlTableOutput) Partitions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringArrayOutput { return v.Partitions }).(pulumi.StringArrayOutput)
}

// A map of table properties.
func (o SqlTableOutput) Properties() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringMapOutput { return v.Properties }).(pulumi.StringMapOutput)
}

// Configure the provider for management through account provider. This block consists of the following fields:
func (o SqlTableOutput) ProviderConfig() SqlTableProviderConfigPtrOutput {
	return o.ApplyT(func(v *SqlTable) SqlTableProviderConfigPtrOutput { return v.ProviderConfig }).(SqlTableProviderConfigPtrOutput)
}

// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
func (o SqlTableOutput) SchemaName() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.SchemaName }).(pulumi.StringOutput)
}

// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
func (o SqlTableOutput) StorageCredentialName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.StorageCredentialName }).(pulumi.StringPtrOutput)
}

// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
func (o SqlTableOutput) StorageLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.StorageLocation }).(pulumi.StringPtrOutput)
}

// The unique identifier of the table.
func (o SqlTableOutput) TableId() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.TableId }).(pulumi.StringOutput)
}

// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
func (o SqlTableOutput) TableType() pulumi.StringOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringOutput { return v.TableType }).(pulumi.StringOutput)
}

// SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
func (o SqlTableOutput) ViewDefinition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.ViewDefinition }).(pulumi.StringPtrOutput)
}

// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
func (o SqlTableOutput) WarehouseId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SqlTable) pulumi.StringPtrOutput { return v.WarehouseId }).(pulumi.StringPtrOutput)
}

type SqlTableArrayOutput struct{ *pulumi.OutputState }

func (SqlTableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SqlTable)(nil)).Elem()
}

func (o SqlTableArrayOutput) ToSqlTableArrayOutput() SqlTableArrayOutput {
	return o
}

func (o SqlTableArrayOutput) ToSqlTableArrayOutputWithContext(ctx context.Context) SqlTableArrayOutput {
	return o
}

func (o SqlTableArrayOutput) Index(i pulumi.IntInput) SqlTableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SqlTable {
		return vs[0].([]*SqlTable)[vs[1].(int)]
	}).(SqlTableOutput)
}

type SqlTableMapOutput struct{ *pulumi.OutputState }

func (SqlTableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SqlTable)(nil)).Elem()
}

func (o SqlTableMapOutput) ToSqlTableMapOutput() SqlTableMapOutput {
	return o
}

func (o SqlTableMapOutput) ToSqlTableMapOutputWithContext(ctx context.Context) SqlTableMapOutput {
	return o
}

func (o SqlTableMapOutput) MapIndex(k pulumi.StringInput) SqlTableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SqlTable {
		return vs[0].(map[string]*SqlTable)[vs[1].(string)]
	}).(SqlTableOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTableInput)(nil)).Elem(), &SqlTable{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTableArrayInput)(nil)).Elem(), SqlTableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SqlTableMapInput)(nil)).Elem(), SqlTableMap{})
	pulumi.RegisterOutputType(SqlTableOutput{})
	pulumi.RegisterOutputType(SqlTableArrayOutput{})
	pulumi.RegisterOutputType(SqlTableMapOutput{})
}
