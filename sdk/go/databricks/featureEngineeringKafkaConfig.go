// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [![Private Preview](https://img.shields.io/badge/Release_Stage-Private_Preview-blueviolet)](https://docs.databricks.com/aws/en/release-notes/release-types)
//
// ## Import
//
// As of Pulumi v1.5, resources can be imported through configuration.
//
// hcl
//
// import {
//
//	id = "name"
//
//	to = databricks_feature_engineering_kafka_config.this
//
// }
//
// If you are using an older version of Pulumi, import the resource using the `pulumi import` command as follows:
//
// ```sh
// $ pulumi import databricks:index/featureEngineeringKafkaConfig:FeatureEngineeringKafkaConfig this "name"
// ```
type FeatureEngineeringKafkaConfig struct {
	pulumi.CustomResourceState

	// Authentication configuration for connection to topics
	AuthConfig FeatureEngineeringKafkaConfigAuthConfigOutput `pulumi:"authConfig"`
	// A comma-separated list of host/port pairs pointing to Kafka cluster
	BootstrapServers pulumi.StringOutput `pulumi:"bootstrapServers"`
	// Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
	ExtraOptions pulumi.StringMapOutput `pulumi:"extraOptions"`
	// Schema configuration for extracting message keys from topics. At least one of keySchema and valueSchema must be provided
	KeySchema FeatureEngineeringKafkaConfigKeySchemaPtrOutput `pulumi:"keySchema"`
	// (string) - Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
	// Can be distinct from topic name
	Name pulumi.StringOutput `pulumi:"name"`
	// Options to configure which Kafka topics to pull data from
	SubscriptionMode FeatureEngineeringKafkaConfigSubscriptionModeOutput `pulumi:"subscriptionMode"`
	// Schema configuration for extracting message values from topics. At least one of keySchema and valueSchema must be provided
	ValueSchema FeatureEngineeringKafkaConfigValueSchemaPtrOutput `pulumi:"valueSchema"`
}

// NewFeatureEngineeringKafkaConfig registers a new resource with the given unique name, arguments, and options.
func NewFeatureEngineeringKafkaConfig(ctx *pulumi.Context,
	name string, args *FeatureEngineeringKafkaConfigArgs, opts ...pulumi.ResourceOption) (*FeatureEngineeringKafkaConfig, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AuthConfig == nil {
		return nil, errors.New("invalid value for required argument 'AuthConfig'")
	}
	if args.BootstrapServers == nil {
		return nil, errors.New("invalid value for required argument 'BootstrapServers'")
	}
	if args.SubscriptionMode == nil {
		return nil, errors.New("invalid value for required argument 'SubscriptionMode'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FeatureEngineeringKafkaConfig
	err := ctx.RegisterResource("databricks:index/featureEngineeringKafkaConfig:FeatureEngineeringKafkaConfig", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFeatureEngineeringKafkaConfig gets an existing FeatureEngineeringKafkaConfig resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFeatureEngineeringKafkaConfig(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FeatureEngineeringKafkaConfigState, opts ...pulumi.ResourceOption) (*FeatureEngineeringKafkaConfig, error) {
	var resource FeatureEngineeringKafkaConfig
	err := ctx.ReadResource("databricks:index/featureEngineeringKafkaConfig:FeatureEngineeringKafkaConfig", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering FeatureEngineeringKafkaConfig resources.
type featureEngineeringKafkaConfigState struct {
	// Authentication configuration for connection to topics
	AuthConfig *FeatureEngineeringKafkaConfigAuthConfig `pulumi:"authConfig"`
	// A comma-separated list of host/port pairs pointing to Kafka cluster
	BootstrapServers *string `pulumi:"bootstrapServers"`
	// Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
	ExtraOptions map[string]string `pulumi:"extraOptions"`
	// Schema configuration for extracting message keys from topics. At least one of keySchema and valueSchema must be provided
	KeySchema *FeatureEngineeringKafkaConfigKeySchema `pulumi:"keySchema"`
	// (string) - Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
	// Can be distinct from topic name
	Name *string `pulumi:"name"`
	// Options to configure which Kafka topics to pull data from
	SubscriptionMode *FeatureEngineeringKafkaConfigSubscriptionMode `pulumi:"subscriptionMode"`
	// Schema configuration for extracting message values from topics. At least one of keySchema and valueSchema must be provided
	ValueSchema *FeatureEngineeringKafkaConfigValueSchema `pulumi:"valueSchema"`
}

type FeatureEngineeringKafkaConfigState struct {
	// Authentication configuration for connection to topics
	AuthConfig FeatureEngineeringKafkaConfigAuthConfigPtrInput
	// A comma-separated list of host/port pairs pointing to Kafka cluster
	BootstrapServers pulumi.StringPtrInput
	// Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
	ExtraOptions pulumi.StringMapInput
	// Schema configuration for extracting message keys from topics. At least one of keySchema and valueSchema must be provided
	KeySchema FeatureEngineeringKafkaConfigKeySchemaPtrInput
	// (string) - Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
	// Can be distinct from topic name
	Name pulumi.StringPtrInput
	// Options to configure which Kafka topics to pull data from
	SubscriptionMode FeatureEngineeringKafkaConfigSubscriptionModePtrInput
	// Schema configuration for extracting message values from topics. At least one of keySchema and valueSchema must be provided
	ValueSchema FeatureEngineeringKafkaConfigValueSchemaPtrInput
}

func (FeatureEngineeringKafkaConfigState) ElementType() reflect.Type {
	return reflect.TypeOf((*featureEngineeringKafkaConfigState)(nil)).Elem()
}

type featureEngineeringKafkaConfigArgs struct {
	// Authentication configuration for connection to topics
	AuthConfig FeatureEngineeringKafkaConfigAuthConfig `pulumi:"authConfig"`
	// A comma-separated list of host/port pairs pointing to Kafka cluster
	BootstrapServers string `pulumi:"bootstrapServers"`
	// Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
	ExtraOptions map[string]string `pulumi:"extraOptions"`
	// Schema configuration for extracting message keys from topics. At least one of keySchema and valueSchema must be provided
	KeySchema *FeatureEngineeringKafkaConfigKeySchema `pulumi:"keySchema"`
	// Options to configure which Kafka topics to pull data from
	SubscriptionMode FeatureEngineeringKafkaConfigSubscriptionMode `pulumi:"subscriptionMode"`
	// Schema configuration for extracting message values from topics. At least one of keySchema and valueSchema must be provided
	ValueSchema *FeatureEngineeringKafkaConfigValueSchema `pulumi:"valueSchema"`
}

// The set of arguments for constructing a FeatureEngineeringKafkaConfig resource.
type FeatureEngineeringKafkaConfigArgs struct {
	// Authentication configuration for connection to topics
	AuthConfig FeatureEngineeringKafkaConfigAuthConfigInput
	// A comma-separated list of host/port pairs pointing to Kafka cluster
	BootstrapServers pulumi.StringInput
	// Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
	ExtraOptions pulumi.StringMapInput
	// Schema configuration for extracting message keys from topics. At least one of keySchema and valueSchema must be provided
	KeySchema FeatureEngineeringKafkaConfigKeySchemaPtrInput
	// Options to configure which Kafka topics to pull data from
	SubscriptionMode FeatureEngineeringKafkaConfigSubscriptionModeInput
	// Schema configuration for extracting message values from topics. At least one of keySchema and valueSchema must be provided
	ValueSchema FeatureEngineeringKafkaConfigValueSchemaPtrInput
}

func (FeatureEngineeringKafkaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*featureEngineeringKafkaConfigArgs)(nil)).Elem()
}

type FeatureEngineeringKafkaConfigInput interface {
	pulumi.Input

	ToFeatureEngineeringKafkaConfigOutput() FeatureEngineeringKafkaConfigOutput
	ToFeatureEngineeringKafkaConfigOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigOutput
}

func (*FeatureEngineeringKafkaConfig) ElementType() reflect.Type {
	return reflect.TypeOf((**FeatureEngineeringKafkaConfig)(nil)).Elem()
}

func (i *FeatureEngineeringKafkaConfig) ToFeatureEngineeringKafkaConfigOutput() FeatureEngineeringKafkaConfigOutput {
	return i.ToFeatureEngineeringKafkaConfigOutputWithContext(context.Background())
}

func (i *FeatureEngineeringKafkaConfig) ToFeatureEngineeringKafkaConfigOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureEngineeringKafkaConfigOutput)
}

// FeatureEngineeringKafkaConfigArrayInput is an input type that accepts FeatureEngineeringKafkaConfigArray and FeatureEngineeringKafkaConfigArrayOutput values.
// You can construct a concrete instance of `FeatureEngineeringKafkaConfigArrayInput` via:
//
//	FeatureEngineeringKafkaConfigArray{ FeatureEngineeringKafkaConfigArgs{...} }
type FeatureEngineeringKafkaConfigArrayInput interface {
	pulumi.Input

	ToFeatureEngineeringKafkaConfigArrayOutput() FeatureEngineeringKafkaConfigArrayOutput
	ToFeatureEngineeringKafkaConfigArrayOutputWithContext(context.Context) FeatureEngineeringKafkaConfigArrayOutput
}

type FeatureEngineeringKafkaConfigArray []FeatureEngineeringKafkaConfigInput

func (FeatureEngineeringKafkaConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FeatureEngineeringKafkaConfig)(nil)).Elem()
}

func (i FeatureEngineeringKafkaConfigArray) ToFeatureEngineeringKafkaConfigArrayOutput() FeatureEngineeringKafkaConfigArrayOutput {
	return i.ToFeatureEngineeringKafkaConfigArrayOutputWithContext(context.Background())
}

func (i FeatureEngineeringKafkaConfigArray) ToFeatureEngineeringKafkaConfigArrayOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureEngineeringKafkaConfigArrayOutput)
}

// FeatureEngineeringKafkaConfigMapInput is an input type that accepts FeatureEngineeringKafkaConfigMap and FeatureEngineeringKafkaConfigMapOutput values.
// You can construct a concrete instance of `FeatureEngineeringKafkaConfigMapInput` via:
//
//	FeatureEngineeringKafkaConfigMap{ "key": FeatureEngineeringKafkaConfigArgs{...} }
type FeatureEngineeringKafkaConfigMapInput interface {
	pulumi.Input

	ToFeatureEngineeringKafkaConfigMapOutput() FeatureEngineeringKafkaConfigMapOutput
	ToFeatureEngineeringKafkaConfigMapOutputWithContext(context.Context) FeatureEngineeringKafkaConfigMapOutput
}

type FeatureEngineeringKafkaConfigMap map[string]FeatureEngineeringKafkaConfigInput

func (FeatureEngineeringKafkaConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FeatureEngineeringKafkaConfig)(nil)).Elem()
}

func (i FeatureEngineeringKafkaConfigMap) ToFeatureEngineeringKafkaConfigMapOutput() FeatureEngineeringKafkaConfigMapOutput {
	return i.ToFeatureEngineeringKafkaConfigMapOutputWithContext(context.Background())
}

func (i FeatureEngineeringKafkaConfigMap) ToFeatureEngineeringKafkaConfigMapOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeatureEngineeringKafkaConfigMapOutput)
}

type FeatureEngineeringKafkaConfigOutput struct{ *pulumi.OutputState }

func (FeatureEngineeringKafkaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FeatureEngineeringKafkaConfig)(nil)).Elem()
}

func (o FeatureEngineeringKafkaConfigOutput) ToFeatureEngineeringKafkaConfigOutput() FeatureEngineeringKafkaConfigOutput {
	return o
}

func (o FeatureEngineeringKafkaConfigOutput) ToFeatureEngineeringKafkaConfigOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigOutput {
	return o
}

// Authentication configuration for connection to topics
func (o FeatureEngineeringKafkaConfigOutput) AuthConfig() FeatureEngineeringKafkaConfigAuthConfigOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) FeatureEngineeringKafkaConfigAuthConfigOutput {
		return v.AuthConfig
	}).(FeatureEngineeringKafkaConfigAuthConfigOutput)
}

// A comma-separated list of host/port pairs pointing to Kafka cluster
func (o FeatureEngineeringKafkaConfigOutput) BootstrapServers() pulumi.StringOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) pulumi.StringOutput { return v.BootstrapServers }).(pulumi.StringOutput)
}

// Catch-all for miscellaneous options. Keys should be source options or Kafka consumer options (kafka.*)
func (o FeatureEngineeringKafkaConfigOutput) ExtraOptions() pulumi.StringMapOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) pulumi.StringMapOutput { return v.ExtraOptions }).(pulumi.StringMapOutput)
}

// Schema configuration for extracting message keys from topics. At least one of keySchema and valueSchema must be provided
func (o FeatureEngineeringKafkaConfigOutput) KeySchema() FeatureEngineeringKafkaConfigKeySchemaPtrOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) FeatureEngineeringKafkaConfigKeySchemaPtrOutput {
		return v.KeySchema
	}).(FeatureEngineeringKafkaConfigKeySchemaPtrOutput)
}

// (string) - Name that uniquely identifies this Kafka config within the metastore. This will be the identifier used from the Feature object to reference these configs for a feature.
// Can be distinct from topic name
func (o FeatureEngineeringKafkaConfigOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Options to configure which Kafka topics to pull data from
func (o FeatureEngineeringKafkaConfigOutput) SubscriptionMode() FeatureEngineeringKafkaConfigSubscriptionModeOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) FeatureEngineeringKafkaConfigSubscriptionModeOutput {
		return v.SubscriptionMode
	}).(FeatureEngineeringKafkaConfigSubscriptionModeOutput)
}

// Schema configuration for extracting message values from topics. At least one of keySchema and valueSchema must be provided
func (o FeatureEngineeringKafkaConfigOutput) ValueSchema() FeatureEngineeringKafkaConfigValueSchemaPtrOutput {
	return o.ApplyT(func(v *FeatureEngineeringKafkaConfig) FeatureEngineeringKafkaConfigValueSchemaPtrOutput {
		return v.ValueSchema
	}).(FeatureEngineeringKafkaConfigValueSchemaPtrOutput)
}

type FeatureEngineeringKafkaConfigArrayOutput struct{ *pulumi.OutputState }

func (FeatureEngineeringKafkaConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FeatureEngineeringKafkaConfig)(nil)).Elem()
}

func (o FeatureEngineeringKafkaConfigArrayOutput) ToFeatureEngineeringKafkaConfigArrayOutput() FeatureEngineeringKafkaConfigArrayOutput {
	return o
}

func (o FeatureEngineeringKafkaConfigArrayOutput) ToFeatureEngineeringKafkaConfigArrayOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigArrayOutput {
	return o
}

func (o FeatureEngineeringKafkaConfigArrayOutput) Index(i pulumi.IntInput) FeatureEngineeringKafkaConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FeatureEngineeringKafkaConfig {
		return vs[0].([]*FeatureEngineeringKafkaConfig)[vs[1].(int)]
	}).(FeatureEngineeringKafkaConfigOutput)
}

type FeatureEngineeringKafkaConfigMapOutput struct{ *pulumi.OutputState }

func (FeatureEngineeringKafkaConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FeatureEngineeringKafkaConfig)(nil)).Elem()
}

func (o FeatureEngineeringKafkaConfigMapOutput) ToFeatureEngineeringKafkaConfigMapOutput() FeatureEngineeringKafkaConfigMapOutput {
	return o
}

func (o FeatureEngineeringKafkaConfigMapOutput) ToFeatureEngineeringKafkaConfigMapOutputWithContext(ctx context.Context) FeatureEngineeringKafkaConfigMapOutput {
	return o
}

func (o FeatureEngineeringKafkaConfigMapOutput) MapIndex(k pulumi.StringInput) FeatureEngineeringKafkaConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FeatureEngineeringKafkaConfig {
		return vs[0].(map[string]*FeatureEngineeringKafkaConfig)[vs[1].(string)]
	}).(FeatureEngineeringKafkaConfigOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FeatureEngineeringKafkaConfigInput)(nil)).Elem(), &FeatureEngineeringKafkaConfig{})
	pulumi.RegisterInputType(reflect.TypeOf((*FeatureEngineeringKafkaConfigArrayInput)(nil)).Elem(), FeatureEngineeringKafkaConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FeatureEngineeringKafkaConfigMapInput)(nil)).Elem(), FeatureEngineeringKafkaConfigMap{})
	pulumi.RegisterOutputType(FeatureEngineeringKafkaConfigOutput{})
	pulumi.RegisterOutputType(FeatureEngineeringKafkaConfigArrayOutput{})
	pulumi.RegisterOutputType(FeatureEngineeringKafkaConfigMapOutput{})
}
