// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// > **Note** This resource could be used with account or workspace-level provider.
//
// Optionally, each Metastore can have a default StorageCredential defined as `MetastoreDataAccess`. This will be used by Unity Catalog to access data in the root storage location if defined.
//
// ## Example Usage
//
// # For AWS
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			this, err := databricks.NewMetastore(ctx, "this", &databricks.MetastoreArgs{
//				Name:         pulumi.String("primary"),
//				StorageRoot:  pulumi.String(fmt.Sprintf("s3://%v/metastore", metastore.Id)),
//				Owner:        pulumi.String("uc admins"),
//				Region:       pulumi.String("us-east-1"),
//				ForceDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewMetastoreDataAccess(ctx, "this", &databricks.MetastoreDataAccessArgs{
//				MetastoreId: this.ID(),
//				Name:        pulumi.Any(metastoreDataAccess.Name),
//				AwsIamRole: &databricks.MetastoreDataAccessAwsIamRoleArgs{
//					RoleArn: pulumi.Any(metastoreDataAccess.Arn),
//				},
//				IsDefault: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// For Azure using managed identity as credential (recommended)
//
// ## Import
//
// This resource can be imported by combination of metastore id and the data access name.
//
// bash
//
// ```sh
// $ pulumi import databricks:index/metastoreDataAccess:MetastoreDataAccess this '<metastore_id>|<name>'
// ```
type MetastoreDataAccess struct {
	pulumi.CustomResourceState

	AwsIamRole                  MetastoreDataAccessAwsIamRolePtrOutput               `pulumi:"awsIamRole"`
	AzureManagedIdentity        MetastoreDataAccessAzureManagedIdentityPtrOutput     `pulumi:"azureManagedIdentity"`
	AzureServicePrincipal       MetastoreDataAccessAzureServicePrincipalPtrOutput    `pulumi:"azureServicePrincipal"`
	Comment                     pulumi.StringPtrOutput                               `pulumi:"comment"`
	DatabricksGcpServiceAccount MetastoreDataAccessDatabricksGcpServiceAccountOutput `pulumi:"databricksGcpServiceAccount"`
	ForceDestroy                pulumi.BoolPtrOutput                                 `pulumi:"forceDestroy"`
	ForceUpdate                 pulumi.BoolPtrOutput                                 `pulumi:"forceUpdate"`
	GcpServiceAccountKey        MetastoreDataAccessGcpServiceAccountKeyPtrOutput     `pulumi:"gcpServiceAccountKey"`
	// whether to set this credential as the default for the metastore. In practice, this should always be true.
	IsDefault      pulumi.BoolPtrOutput `pulumi:"isDefault"`
	MetastoreId    pulumi.StringOutput  `pulumi:"metastoreId"`
	Name           pulumi.StringOutput  `pulumi:"name"`
	Owner          pulumi.StringOutput  `pulumi:"owner"`
	ReadOnly       pulumi.BoolPtrOutput `pulumi:"readOnly"`
	SkipValidation pulumi.BoolPtrOutput `pulumi:"skipValidation"`
}

// NewMetastoreDataAccess registers a new resource with the given unique name, arguments, and options.
func NewMetastoreDataAccess(ctx *pulumi.Context,
	name string, args *MetastoreDataAccessArgs, opts ...pulumi.ResourceOption) (*MetastoreDataAccess, error) {
	if args == nil {
		args = &MetastoreDataAccessArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource MetastoreDataAccess
	err := ctx.RegisterResource("databricks:index/metastoreDataAccess:MetastoreDataAccess", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetastoreDataAccess gets an existing MetastoreDataAccess resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetastoreDataAccess(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetastoreDataAccessState, opts ...pulumi.ResourceOption) (*MetastoreDataAccess, error) {
	var resource MetastoreDataAccess
	err := ctx.ReadResource("databricks:index/metastoreDataAccess:MetastoreDataAccess", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetastoreDataAccess resources.
type metastoreDataAccessState struct {
	AwsIamRole                  *MetastoreDataAccessAwsIamRole                  `pulumi:"awsIamRole"`
	AzureManagedIdentity        *MetastoreDataAccessAzureManagedIdentity        `pulumi:"azureManagedIdentity"`
	AzureServicePrincipal       *MetastoreDataAccessAzureServicePrincipal       `pulumi:"azureServicePrincipal"`
	Comment                     *string                                         `pulumi:"comment"`
	DatabricksGcpServiceAccount *MetastoreDataAccessDatabricksGcpServiceAccount `pulumi:"databricksGcpServiceAccount"`
	ForceDestroy                *bool                                           `pulumi:"forceDestroy"`
	ForceUpdate                 *bool                                           `pulumi:"forceUpdate"`
	GcpServiceAccountKey        *MetastoreDataAccessGcpServiceAccountKey        `pulumi:"gcpServiceAccountKey"`
	// whether to set this credential as the default for the metastore. In practice, this should always be true.
	IsDefault      *bool   `pulumi:"isDefault"`
	MetastoreId    *string `pulumi:"metastoreId"`
	Name           *string `pulumi:"name"`
	Owner          *string `pulumi:"owner"`
	ReadOnly       *bool   `pulumi:"readOnly"`
	SkipValidation *bool   `pulumi:"skipValidation"`
}

type MetastoreDataAccessState struct {
	AwsIamRole                  MetastoreDataAccessAwsIamRolePtrInput
	AzureManagedIdentity        MetastoreDataAccessAzureManagedIdentityPtrInput
	AzureServicePrincipal       MetastoreDataAccessAzureServicePrincipalPtrInput
	Comment                     pulumi.StringPtrInput
	DatabricksGcpServiceAccount MetastoreDataAccessDatabricksGcpServiceAccountPtrInput
	ForceDestroy                pulumi.BoolPtrInput
	ForceUpdate                 pulumi.BoolPtrInput
	GcpServiceAccountKey        MetastoreDataAccessGcpServiceAccountKeyPtrInput
	// whether to set this credential as the default for the metastore. In practice, this should always be true.
	IsDefault      pulumi.BoolPtrInput
	MetastoreId    pulumi.StringPtrInput
	Name           pulumi.StringPtrInput
	Owner          pulumi.StringPtrInput
	ReadOnly       pulumi.BoolPtrInput
	SkipValidation pulumi.BoolPtrInput
}

func (MetastoreDataAccessState) ElementType() reflect.Type {
	return reflect.TypeOf((*metastoreDataAccessState)(nil)).Elem()
}

type metastoreDataAccessArgs struct {
	AwsIamRole                  *MetastoreDataAccessAwsIamRole                  `pulumi:"awsIamRole"`
	AzureManagedIdentity        *MetastoreDataAccessAzureManagedIdentity        `pulumi:"azureManagedIdentity"`
	AzureServicePrincipal       *MetastoreDataAccessAzureServicePrincipal       `pulumi:"azureServicePrincipal"`
	Comment                     *string                                         `pulumi:"comment"`
	DatabricksGcpServiceAccount *MetastoreDataAccessDatabricksGcpServiceAccount `pulumi:"databricksGcpServiceAccount"`
	ForceDestroy                *bool                                           `pulumi:"forceDestroy"`
	ForceUpdate                 *bool                                           `pulumi:"forceUpdate"`
	GcpServiceAccountKey        *MetastoreDataAccessGcpServiceAccountKey        `pulumi:"gcpServiceAccountKey"`
	// whether to set this credential as the default for the metastore. In practice, this should always be true.
	IsDefault      *bool   `pulumi:"isDefault"`
	MetastoreId    *string `pulumi:"metastoreId"`
	Name           *string `pulumi:"name"`
	Owner          *string `pulumi:"owner"`
	ReadOnly       *bool   `pulumi:"readOnly"`
	SkipValidation *bool   `pulumi:"skipValidation"`
}

// The set of arguments for constructing a MetastoreDataAccess resource.
type MetastoreDataAccessArgs struct {
	AwsIamRole                  MetastoreDataAccessAwsIamRolePtrInput
	AzureManagedIdentity        MetastoreDataAccessAzureManagedIdentityPtrInput
	AzureServicePrincipal       MetastoreDataAccessAzureServicePrincipalPtrInput
	Comment                     pulumi.StringPtrInput
	DatabricksGcpServiceAccount MetastoreDataAccessDatabricksGcpServiceAccountPtrInput
	ForceDestroy                pulumi.BoolPtrInput
	ForceUpdate                 pulumi.BoolPtrInput
	GcpServiceAccountKey        MetastoreDataAccessGcpServiceAccountKeyPtrInput
	// whether to set this credential as the default for the metastore. In practice, this should always be true.
	IsDefault      pulumi.BoolPtrInput
	MetastoreId    pulumi.StringPtrInput
	Name           pulumi.StringPtrInput
	Owner          pulumi.StringPtrInput
	ReadOnly       pulumi.BoolPtrInput
	SkipValidation pulumi.BoolPtrInput
}

func (MetastoreDataAccessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metastoreDataAccessArgs)(nil)).Elem()
}

type MetastoreDataAccessInput interface {
	pulumi.Input

	ToMetastoreDataAccessOutput() MetastoreDataAccessOutput
	ToMetastoreDataAccessOutputWithContext(ctx context.Context) MetastoreDataAccessOutput
}

func (*MetastoreDataAccess) ElementType() reflect.Type {
	return reflect.TypeOf((**MetastoreDataAccess)(nil)).Elem()
}

func (i *MetastoreDataAccess) ToMetastoreDataAccessOutput() MetastoreDataAccessOutput {
	return i.ToMetastoreDataAccessOutputWithContext(context.Background())
}

func (i *MetastoreDataAccess) ToMetastoreDataAccessOutputWithContext(ctx context.Context) MetastoreDataAccessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetastoreDataAccessOutput)
}

// MetastoreDataAccessArrayInput is an input type that accepts MetastoreDataAccessArray and MetastoreDataAccessArrayOutput values.
// You can construct a concrete instance of `MetastoreDataAccessArrayInput` via:
//
//	MetastoreDataAccessArray{ MetastoreDataAccessArgs{...} }
type MetastoreDataAccessArrayInput interface {
	pulumi.Input

	ToMetastoreDataAccessArrayOutput() MetastoreDataAccessArrayOutput
	ToMetastoreDataAccessArrayOutputWithContext(context.Context) MetastoreDataAccessArrayOutput
}

type MetastoreDataAccessArray []MetastoreDataAccessInput

func (MetastoreDataAccessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetastoreDataAccess)(nil)).Elem()
}

func (i MetastoreDataAccessArray) ToMetastoreDataAccessArrayOutput() MetastoreDataAccessArrayOutput {
	return i.ToMetastoreDataAccessArrayOutputWithContext(context.Background())
}

func (i MetastoreDataAccessArray) ToMetastoreDataAccessArrayOutputWithContext(ctx context.Context) MetastoreDataAccessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetastoreDataAccessArrayOutput)
}

// MetastoreDataAccessMapInput is an input type that accepts MetastoreDataAccessMap and MetastoreDataAccessMapOutput values.
// You can construct a concrete instance of `MetastoreDataAccessMapInput` via:
//
//	MetastoreDataAccessMap{ "key": MetastoreDataAccessArgs{...} }
type MetastoreDataAccessMapInput interface {
	pulumi.Input

	ToMetastoreDataAccessMapOutput() MetastoreDataAccessMapOutput
	ToMetastoreDataAccessMapOutputWithContext(context.Context) MetastoreDataAccessMapOutput
}

type MetastoreDataAccessMap map[string]MetastoreDataAccessInput

func (MetastoreDataAccessMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetastoreDataAccess)(nil)).Elem()
}

func (i MetastoreDataAccessMap) ToMetastoreDataAccessMapOutput() MetastoreDataAccessMapOutput {
	return i.ToMetastoreDataAccessMapOutputWithContext(context.Background())
}

func (i MetastoreDataAccessMap) ToMetastoreDataAccessMapOutputWithContext(ctx context.Context) MetastoreDataAccessMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetastoreDataAccessMapOutput)
}

type MetastoreDataAccessOutput struct{ *pulumi.OutputState }

func (MetastoreDataAccessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetastoreDataAccess)(nil)).Elem()
}

func (o MetastoreDataAccessOutput) ToMetastoreDataAccessOutput() MetastoreDataAccessOutput {
	return o
}

func (o MetastoreDataAccessOutput) ToMetastoreDataAccessOutputWithContext(ctx context.Context) MetastoreDataAccessOutput {
	return o
}

func (o MetastoreDataAccessOutput) AwsIamRole() MetastoreDataAccessAwsIamRolePtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) MetastoreDataAccessAwsIamRolePtrOutput { return v.AwsIamRole }).(MetastoreDataAccessAwsIamRolePtrOutput)
}

func (o MetastoreDataAccessOutput) AzureManagedIdentity() MetastoreDataAccessAzureManagedIdentityPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) MetastoreDataAccessAzureManagedIdentityPtrOutput {
		return v.AzureManagedIdentity
	}).(MetastoreDataAccessAzureManagedIdentityPtrOutput)
}

func (o MetastoreDataAccessOutput) AzureServicePrincipal() MetastoreDataAccessAzureServicePrincipalPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) MetastoreDataAccessAzureServicePrincipalPtrOutput {
		return v.AzureServicePrincipal
	}).(MetastoreDataAccessAzureServicePrincipalPtrOutput)
}

func (o MetastoreDataAccessOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

func (o MetastoreDataAccessOutput) DatabricksGcpServiceAccount() MetastoreDataAccessDatabricksGcpServiceAccountOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) MetastoreDataAccessDatabricksGcpServiceAccountOutput {
		return v.DatabricksGcpServiceAccount
	}).(MetastoreDataAccessDatabricksGcpServiceAccountOutput)
}

func (o MetastoreDataAccessOutput) ForceDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.BoolPtrOutput { return v.ForceDestroy }).(pulumi.BoolPtrOutput)
}

func (o MetastoreDataAccessOutput) ForceUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.BoolPtrOutput { return v.ForceUpdate }).(pulumi.BoolPtrOutput)
}

func (o MetastoreDataAccessOutput) GcpServiceAccountKey() MetastoreDataAccessGcpServiceAccountKeyPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) MetastoreDataAccessGcpServiceAccountKeyPtrOutput {
		return v.GcpServiceAccountKey
	}).(MetastoreDataAccessGcpServiceAccountKeyPtrOutput)
}

// whether to set this credential as the default for the metastore. In practice, this should always be true.
func (o MetastoreDataAccessOutput) IsDefault() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.BoolPtrOutput { return v.IsDefault }).(pulumi.BoolPtrOutput)
}

func (o MetastoreDataAccessOutput) MetastoreId() pulumi.StringOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.StringOutput { return v.MetastoreId }).(pulumi.StringOutput)
}

func (o MetastoreDataAccessOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o MetastoreDataAccessOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

func (o MetastoreDataAccessOutput) ReadOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.BoolPtrOutput { return v.ReadOnly }).(pulumi.BoolPtrOutput)
}

func (o MetastoreDataAccessOutput) SkipValidation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *MetastoreDataAccess) pulumi.BoolPtrOutput { return v.SkipValidation }).(pulumi.BoolPtrOutput)
}

type MetastoreDataAccessArrayOutput struct{ *pulumi.OutputState }

func (MetastoreDataAccessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MetastoreDataAccess)(nil)).Elem()
}

func (o MetastoreDataAccessArrayOutput) ToMetastoreDataAccessArrayOutput() MetastoreDataAccessArrayOutput {
	return o
}

func (o MetastoreDataAccessArrayOutput) ToMetastoreDataAccessArrayOutputWithContext(ctx context.Context) MetastoreDataAccessArrayOutput {
	return o
}

func (o MetastoreDataAccessArrayOutput) Index(i pulumi.IntInput) MetastoreDataAccessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MetastoreDataAccess {
		return vs[0].([]*MetastoreDataAccess)[vs[1].(int)]
	}).(MetastoreDataAccessOutput)
}

type MetastoreDataAccessMapOutput struct{ *pulumi.OutputState }

func (MetastoreDataAccessMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MetastoreDataAccess)(nil)).Elem()
}

func (o MetastoreDataAccessMapOutput) ToMetastoreDataAccessMapOutput() MetastoreDataAccessMapOutput {
	return o
}

func (o MetastoreDataAccessMapOutput) ToMetastoreDataAccessMapOutputWithContext(ctx context.Context) MetastoreDataAccessMapOutput {
	return o
}

func (o MetastoreDataAccessMapOutput) MapIndex(k pulumi.StringInput) MetastoreDataAccessOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MetastoreDataAccess {
		return vs[0].(map[string]*MetastoreDataAccess)[vs[1].(string)]
	}).(MetastoreDataAccessOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetastoreDataAccessInput)(nil)).Elem(), &MetastoreDataAccess{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetastoreDataAccessArrayInput)(nil)).Elem(), MetastoreDataAccessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetastoreDataAccessMapInput)(nil)).Elem(), MetastoreDataAccessMap{})
	pulumi.RegisterOutputType(MetastoreDataAccessOutput{})
	pulumi.RegisterOutputType(MetastoreDataAccessArrayOutput{})
	pulumi.RegisterOutputType(MetastoreDataAccessMapOutput{})
}
