// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-databricks/sdk/go/databricks/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// > **Public Preview** This feature is in [Public Preview](https://docs.databricks.com/release-notes/release-types.html).
//
// Volumes are Unity Catalog objects representing a logical volume of storage in a cloud object storage location. Volumes provide capabilities for accessing, storing, governing, and organizing files. While tables provide governance over tabular datasets, volumes add governance over non-tabular datasets. You can use volumes to store and access files in any format, including structured, semi-structured, and unstructured data.
//
// A volume resides in the third layer of Unity Catalogâ€™s three-level namespace. Volumes are siblings to tables, views, and other objects organized under a schema in Unity Catalog.
//
// A volume can be **managed** or **external**.
//
// A **managed volume** is a Unity Catalog-governed storage volume created within the default storage location of the containing schema. Managed volumes allow the creation of governed storage for working with files without the overhead of external locations and storage credentials. You do not need to specify a location when creating a managed volume, and all file access for data in managed volumes is through paths managed by Unity Catalog.
//
// An **external volume** is a Unity Catalog-governed storage volume registered against a directory within an external location.
//
// A volume can be referenced using its identifier: ```<catalogName>.<schemaName>.<volumeName>```, where:
//
// * ```<catalogName>```: The name of the catalog containing the Volume.
// * ```<schemaName>```: The name of the schema containing the Volume.
// * ```<volumeName>```: The name of the Volume. It identifies the volume object.
//
// The path to access files in volumes uses the following format:
//
// This resource manages Volumes in Unity Catalog.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-databricks/sdk/go/databricks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			sandbox, err := databricks.NewCatalog(ctx, "sandbox", &databricks.CatalogArgs{
//				MetastoreId: pulumi.Any(databricks_metastore.This.Id),
//				Comment:     pulumi.String("this catalog is managed by terraform"),
//				Properties: pulumi.Map{
//					"purpose": pulumi.Any("testing"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			things, err := databricks.NewSchema(ctx, "things", &databricks.SchemaArgs{
//				CatalogName: sandbox.Name,
//				Comment:     pulumi.String("this schema is managed by terraform"),
//				Properties: pulumi.Map{
//					"kind": pulumi.Any("various"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			external, err := databricks.NewStorageCredential(ctx, "external", &databricks.StorageCredentialArgs{
//				AwsIamRole: &databricks.StorageCredentialAwsIamRoleArgs{
//					RoleArn: pulumi.Any(aws_iam_role.External_data_access.Arn),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			some, err := databricks.NewExternalLocation(ctx, "some", &databricks.ExternalLocationArgs{
//				Url:            pulumi.String(fmt.Sprintf("s3://%v/some", aws_s3_bucket.External.Id)),
//				CredentialName: external.Name,
//			})
//			if err != nil {
//				return err
//			}
//			_, err = databricks.NewVolume(ctx, "this", &databricks.VolumeArgs{
//				CatalogName:     sandbox.Name,
//				SchemaName:      things.Name,
//				VolumeType:      pulumi.String("EXTERNAL"),
//				StorageLocation: some.Url,
//				Comment:         pulumi.String("this volume is managed by terraform"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// This resource can be imported by `full_name` which is the 3-level Volume identifier`<catalog>.<schema>.<name>` bash
//
// ```sh
//
//	$ pulumi import databricks:index/volume:Volume this <catalog_name>.<schema_name>.<name>
//
// ```
type Volume struct {
	pulumi.CustomResourceState

	// Name of parent Catalog. Change forces creation of a new resource.
	CatalogName pulumi.StringOutput `pulumi:"catalogName"`
	// Free-form text.
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// Name of the Volume
	Name pulumi.StringOutput `pulumi:"name"`
	// Name of the volume owner.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
	SchemaName pulumi.StringOutput `pulumi:"schemaName"`
	// Path inside an External Location. Only used for `EXTERNAL` Volumes. Change forces creation of a new resource.
	StorageLocation pulumi.StringPtrOutput `pulumi:"storageLocation"`
	// Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
	VolumeType pulumi.StringOutput `pulumi:"volumeType"`
}

// NewVolume registers a new resource with the given unique name, arguments, and options.
func NewVolume(ctx *pulumi.Context,
	name string, args *VolumeArgs, opts ...pulumi.ResourceOption) (*Volume, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CatalogName == nil {
		return nil, errors.New("invalid value for required argument 'CatalogName'")
	}
	if args.SchemaName == nil {
		return nil, errors.New("invalid value for required argument 'SchemaName'")
	}
	if args.VolumeType == nil {
		return nil, errors.New("invalid value for required argument 'VolumeType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Volume
	err := ctx.RegisterResource("databricks:index/volume:Volume", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVolume gets an existing Volume resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVolume(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VolumeState, opts ...pulumi.ResourceOption) (*Volume, error) {
	var resource Volume
	err := ctx.ReadResource("databricks:index/volume:Volume", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Volume resources.
type volumeState struct {
	// Name of parent Catalog. Change forces creation of a new resource.
	CatalogName *string `pulumi:"catalogName"`
	// Free-form text.
	Comment *string `pulumi:"comment"`
	// Name of the Volume
	Name *string `pulumi:"name"`
	// Name of the volume owner.
	Owner *string `pulumi:"owner"`
	// Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
	SchemaName *string `pulumi:"schemaName"`
	// Path inside an External Location. Only used for `EXTERNAL` Volumes. Change forces creation of a new resource.
	StorageLocation *string `pulumi:"storageLocation"`
	// Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
	VolumeType *string `pulumi:"volumeType"`
}

type VolumeState struct {
	// Name of parent Catalog. Change forces creation of a new resource.
	CatalogName pulumi.StringPtrInput
	// Free-form text.
	Comment pulumi.StringPtrInput
	// Name of the Volume
	Name pulumi.StringPtrInput
	// Name of the volume owner.
	Owner pulumi.StringPtrInput
	// Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
	SchemaName pulumi.StringPtrInput
	// Path inside an External Location. Only used for `EXTERNAL` Volumes. Change forces creation of a new resource.
	StorageLocation pulumi.StringPtrInput
	// Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
	VolumeType pulumi.StringPtrInput
}

func (VolumeState) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeState)(nil)).Elem()
}

type volumeArgs struct {
	// Name of parent Catalog. Change forces creation of a new resource.
	CatalogName string `pulumi:"catalogName"`
	// Free-form text.
	Comment *string `pulumi:"comment"`
	// Name of the Volume
	Name *string `pulumi:"name"`
	// Name of the volume owner.
	Owner *string `pulumi:"owner"`
	// Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
	SchemaName string `pulumi:"schemaName"`
	// Path inside an External Location. Only used for `EXTERNAL` Volumes. Change forces creation of a new resource.
	StorageLocation *string `pulumi:"storageLocation"`
	// Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
	VolumeType string `pulumi:"volumeType"`
}

// The set of arguments for constructing a Volume resource.
type VolumeArgs struct {
	// Name of parent Catalog. Change forces creation of a new resource.
	CatalogName pulumi.StringInput
	// Free-form text.
	Comment pulumi.StringPtrInput
	// Name of the Volume
	Name pulumi.StringPtrInput
	// Name of the volume owner.
	Owner pulumi.StringPtrInput
	// Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
	SchemaName pulumi.StringInput
	// Path inside an External Location. Only used for `EXTERNAL` Volumes. Change forces creation of a new resource.
	StorageLocation pulumi.StringPtrInput
	// Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
	VolumeType pulumi.StringInput
}

func (VolumeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*volumeArgs)(nil)).Elem()
}

type VolumeInput interface {
	pulumi.Input

	ToVolumeOutput() VolumeOutput
	ToVolumeOutputWithContext(ctx context.Context) VolumeOutput
}

func (*Volume) ElementType() reflect.Type {
	return reflect.TypeOf((**Volume)(nil)).Elem()
}

func (i *Volume) ToVolumeOutput() VolumeOutput {
	return i.ToVolumeOutputWithContext(context.Background())
}

func (i *Volume) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeOutput)
}

// VolumeArrayInput is an input type that accepts VolumeArray and VolumeArrayOutput values.
// You can construct a concrete instance of `VolumeArrayInput` via:
//
//	VolumeArray{ VolumeArgs{...} }
type VolumeArrayInput interface {
	pulumi.Input

	ToVolumeArrayOutput() VolumeArrayOutput
	ToVolumeArrayOutputWithContext(context.Context) VolumeArrayOutput
}

type VolumeArray []VolumeInput

func (VolumeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Volume)(nil)).Elem()
}

func (i VolumeArray) ToVolumeArrayOutput() VolumeArrayOutput {
	return i.ToVolumeArrayOutputWithContext(context.Background())
}

func (i VolumeArray) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeArrayOutput)
}

// VolumeMapInput is an input type that accepts VolumeMap and VolumeMapOutput values.
// You can construct a concrete instance of `VolumeMapInput` via:
//
//	VolumeMap{ "key": VolumeArgs{...} }
type VolumeMapInput interface {
	pulumi.Input

	ToVolumeMapOutput() VolumeMapOutput
	ToVolumeMapOutputWithContext(context.Context) VolumeMapOutput
}

type VolumeMap map[string]VolumeInput

func (VolumeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Volume)(nil)).Elem()
}

func (i VolumeMap) ToVolumeMapOutput() VolumeMapOutput {
	return i.ToVolumeMapOutputWithContext(context.Background())
}

func (i VolumeMap) ToVolumeMapOutputWithContext(ctx context.Context) VolumeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeMapOutput)
}

type VolumeOutput struct{ *pulumi.OutputState }

func (VolumeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Volume)(nil)).Elem()
}

func (o VolumeOutput) ToVolumeOutput() VolumeOutput {
	return o
}

func (o VolumeOutput) ToVolumeOutputWithContext(ctx context.Context) VolumeOutput {
	return o
}

// Name of parent Catalog. Change forces creation of a new resource.
func (o VolumeOutput) CatalogName() pulumi.StringOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringOutput { return v.CatalogName }).(pulumi.StringOutput)
}

// Free-form text.
func (o VolumeOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// Name of the Volume
func (o VolumeOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Name of the volume owner.
func (o VolumeOutput) Owner() pulumi.StringOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringOutput { return v.Owner }).(pulumi.StringOutput)
}

// Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
func (o VolumeOutput) SchemaName() pulumi.StringOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringOutput { return v.SchemaName }).(pulumi.StringOutput)
}

// Path inside an External Location. Only used for `EXTERNAL` Volumes. Change forces creation of a new resource.
func (o VolumeOutput) StorageLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringPtrOutput { return v.StorageLocation }).(pulumi.StringPtrOutput)
}

// Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
func (o VolumeOutput) VolumeType() pulumi.StringOutput {
	return o.ApplyT(func(v *Volume) pulumi.StringOutput { return v.VolumeType }).(pulumi.StringOutput)
}

type VolumeArrayOutput struct{ *pulumi.OutputState }

func (VolumeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Volume)(nil)).Elem()
}

func (o VolumeArrayOutput) ToVolumeArrayOutput() VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) ToVolumeArrayOutputWithContext(ctx context.Context) VolumeArrayOutput {
	return o
}

func (o VolumeArrayOutput) Index(i pulumi.IntInput) VolumeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Volume {
		return vs[0].([]*Volume)[vs[1].(int)]
	}).(VolumeOutput)
}

type VolumeMapOutput struct{ *pulumi.OutputState }

func (VolumeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Volume)(nil)).Elem()
}

func (o VolumeMapOutput) ToVolumeMapOutput() VolumeMapOutput {
	return o
}

func (o VolumeMapOutput) ToVolumeMapOutputWithContext(ctx context.Context) VolumeMapOutput {
	return o
}

func (o VolumeMapOutput) MapIndex(k pulumi.StringInput) VolumeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Volume {
		return vs[0].(map[string]*Volume)[vs[1].(string)]
	}).(VolumeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeInput)(nil)).Elem(), &Volume{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeArrayInput)(nil)).Elem(), VolumeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeMapInput)(nil)).Elem(), VolumeMap{})
	pulumi.RegisterOutputType(VolumeOutput{})
	pulumi.RegisterOutputType(VolumeArrayOutput{})
	pulumi.RegisterOutputType(VolumeMapOutput{})
}
