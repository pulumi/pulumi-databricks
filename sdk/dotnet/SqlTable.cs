// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Databricks
{
    /// <summary>
    /// Within a metastore, Unity Catalog provides a 3-level namespace for organizing data: Catalogs, databases (also called schemas), and tables/views.
    /// 
    /// A `databricks.SqlTable` is contained within databricks_schema, and can represent either a managed table, an external table, or a view.
    /// 
    /// This resource creates and updates the Unity Catalog table/view by executing the necessary SQL queries on a special auto-terminating cluster it would create for this operation. You could also specify a SQL warehouse or cluster for the queries to be executed on.
    /// 
    /// &gt; This resource can only be used with a workspace-level provider!
    /// 
    /// &gt; This resource doesn't handle complex cases of schema evolution due to the limitations of Pulumi itself.  If you need to implement schema evolution it's recommended to use specialized tools, such as, [Liquibase](https://medium.com/dbsql-sme-engineering/advanced-schema-management-on-databricks-with-liquibase-1900e9f7b9c0) and [Flyway](https://medium.com/dbsql-sme-engineering/databricks-schema-management-with-flyway-527c4a9f5d67).
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// using Std = Pulumi.Std;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sandbox = new Databricks.Catalog("sandbox", new()
    ///     {
    ///         Name = "sandbox",
    ///         Comment = "this catalog is managed by terraform",
    ///         Properties = 
    ///         {
    ///             { "purpose", "testing" },
    ///         },
    ///     });
    /// 
    ///     var things = new Databricks.Schema("things", new()
    ///     {
    ///         CatalogName = sandbox.Id,
    ///         Name = "things",
    ///         Comment = "this database is managed by terraform",
    ///         Properties = 
    ///         {
    ///             { "kind", "various" },
    ///         },
    ///     });
    /// 
    ///     var thing = new Databricks.SqlTable("thing", new()
    ///     {
    ///         Name = "quickstart_table",
    ///         CatalogName = sandbox.Name,
    ///         SchemaName = things.Name,
    ///         TableType = "MANAGED",
    ///         Columns = new[]
    ///         {
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "id",
    ///                 Type = "int",
    ///             },
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "name",
    ///                 Type = "string",
    ///                 Comment = "name of thing",
    ///             },
    ///         },
    ///         Comment = "this table is managed by terraform",
    ///     });
    /// 
    ///     var thingView = new Databricks.SqlTable("thing_view", new()
    ///     {
    ///         Name = "quickstart_table_view",
    ///         CatalogName = sandbox.Name,
    ///         SchemaName = things.Name,
    ///         TableType = "VIEW",
    ///         ClusterId = "0423-201305-xsrt82qn",
    ///         ViewDefinition = Std.Format.Invoke(new()
    ///         {
    ///             Input = "SELECT name FROM %s WHERE id == 1",
    ///             Args = new[]
    ///             {
    ///                 thing.Id,
    ///             },
    ///         }).Apply(invoke =&gt; invoke.Result),
    ///         Comment = "this view is managed by terraform",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Use an existing warehouse to create a table
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// using Std = Pulumi.Std;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Databricks.SqlEndpoint("this", new()
    ///     {
    ///         Name = "endpoint",
    ///         ClusterSize = "2X-Small",
    ///         MaxNumClusters = 1,
    ///     });
    /// 
    ///     var thing = new Databricks.SqlTable("thing", new()
    ///     {
    ///         Name = "quickstart_table",
    ///         CatalogName = sandbox.Name,
    ///         SchemaName = things.Name,
    ///         TableType = "MANAGED",
    ///         WarehouseId = @this.Id,
    ///         Columns = new[]
    ///         {
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "id",
    ///                 Type = "int",
    ///             },
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "name",
    ///                 Type = "string",
    ///                 Comment = "name of thing",
    ///             },
    ///         },
    ///         Comment = "this table is managed by terraform",
    ///     });
    /// 
    ///     var thingView = new Databricks.SqlTable("thing_view", new()
    ///     {
    ///         Name = "quickstart_table_view",
    ///         CatalogName = sandbox.Name,
    ///         SchemaName = things.Name,
    ///         TableType = "VIEW",
    ///         WarehouseId = @this.Id,
    ///         ViewDefinition = Std.Format.Invoke(new()
    ///         {
    ///             Input = "SELECT name FROM %s WHERE id == 1",
    ///             Args = new[]
    ///             {
    ///                 thing.Id,
    ///             },
    ///         }).Apply(invoke =&gt; invoke.Result),
    ///         Comment = "this view is managed by terraform",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Use an Identity Column
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sandbox = new Databricks.Catalog("sandbox", new()
    ///     {
    ///         Name = "sandbox",
    ///         Comment = "this catalog is managed by terraform",
    ///         Properties = 
    ///         {
    ///             { "purpose", "testing" },
    ///         },
    ///     });
    /// 
    ///     var things = new Databricks.Schema("things", new()
    ///     {
    ///         CatalogName = sandbox.Id,
    ///         Name = "things",
    ///         Comment = "this database is managed by terraform",
    ///         Properties = 
    ///         {
    ///             { "kind", "various" },
    ///         },
    ///     });
    /// 
    ///     var thing = new Databricks.SqlTable("thing", new()
    ///     {
    ///         Name = "identity_table",
    ///         CatalogName = sandbox.Name,
    ///         SchemaName = things.Name,
    ///         TableType = "MANAGED",
    ///         Columns = new[]
    ///         {
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "id",
    ///                 Type = "bigint",
    ///                 Identity = "default",
    ///             },
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "name",
    ///                 Type = "string",
    ///                 Comment = "name of thing",
    ///             },
    ///         },
    ///         Comment = "this table is managed by terraform",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Enable automatic clustering
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var thing = new Databricks.SqlTable("thing", new()
    ///     {
    ///         Name = "auto_cluster_table",
    ///         CatalogName = sandbox.Name,
    ///         SchemaName = things.Name,
    ///         TableType = "MANAGED",
    ///         ClusterKeys = new[]
    ///         {
    ///             "AUTO",
    ///         },
    ///         Columns = new[]
    ///         {
    ///             new Databricks.Inputs.SqlTableColumnArgs
    ///             {
    ///                 Name = "name",
    ///                 Type = "string",
    ///                 Comment = "name of thing",
    ///             },
    ///         },
    ///         Comment = "this table is managed by terraform",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Migration from `databricks.Table`
    /// 
    /// The `databricks.Table` resource has been deprecated in favor of `databricks.SqlTable`. To migrate from `databricks.Table` to `databricks.SqlTable`:
    /// 
    /// 1. Define a `databricks.SqlTable` resource with arguments corresponding to `databricks.Table`.
    /// 2. Add a `Removed` block to remove the `databricks.Table` resource without deleting the existing table by using the `Lifecycle` block. If you're using Pulumi version below v1.7.0, you will need to use the `terraform state rm` command instead.
    /// 3. Add an `Import` block to add the `databricks.SqlTable` resource, corresponding to the existing table. If you're using Pulumi version below v1.5.0, you will need to use `pulumi import` command instead.
    /// 
    /// For example, suppose we have the following `databricks.Table` resource:
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var @this = new Databricks.Table("this", new()
    ///     {
    ///         CatalogName = "catalog",
    ///         SchemaName = "schema",
    ///         Name = "table",
    ///         TableType = "MANAGED",
    ///         DataSourceFormat = "DELTA",
    ///         Columns = new[]
    ///         {
    ///             new Databricks.Inputs.TableColumnArgs
    ///             {
    ///                 Name = "col1",
    ///                 TypeName = "STRING",
    ///                 TypeJson = "{\"type\":\"STRING\"}",
    ///                 Comment = "comment",
    ///                 Nullable = true,
    ///             },
    ///         },
    ///         Comment = "comment",
    ///         Properties = 
    ///         {
    ///             { "key", "value" },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// The migration would look like this:
    /// </summary>
    [DatabricksResourceType("databricks:index/sqlTable:SqlTable")]
    public partial class SqlTable : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Name of parent catalog. Change forces the creation of a new resource.
        /// </summary>
        [Output("catalogName")]
        public Output<string> CatalogName { get; private set; } = null!;

        /// <summary>
        /// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a ClusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `WarehouseId`.
        /// </summary>
        [Output("clusterId")]
        public Output<string> ClusterId { get; private set; } = null!;

        /// <summary>
        /// a subset of columns to liquid cluster the table by. For automatic clustering, set `ClusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `Partitions`.
        /// </summary>
        [Output("clusterKeys")]
        public Output<ImmutableArray<string>> ClusterKeys { get; private set; } = null!;

        [Output("columns")]
        public Output<ImmutableArray<Outputs.SqlTableColumn>> Columns { get; private set; } = null!;

        /// <summary>
        /// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
        /// </summary>
        [Output("comment")]
        public Output<string?> Comment { get; private set; } = null!;

        /// <summary>
        /// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
        /// </summary>
        [Output("dataSourceFormat")]
        public Output<string?> DataSourceFormat { get; private set; } = null!;

        [Output("effectiveProperties")]
        public Output<ImmutableDictionary<string, string>> EffectiveProperties { get; private set; } = null!;

        /// <summary>
        /// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Map of user defined table options. Change forces creation of a new resource.
        /// </summary>
        [Output("options")]
        public Output<ImmutableDictionary<string, string>?> Options { get; private set; } = null!;

        /// <summary>
        /// User name/group name/sp ApplicationId of the table owner.
        /// </summary>
        [Output("owner")]
        public Output<string> Owner { get; private set; } = null!;

        /// <summary>
        /// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `ClusterKeys`.
        /// </summary>
        [Output("partitions")]
        public Output<ImmutableArray<string>> Partitions { get; private set; } = null!;

        /// <summary>
        /// A map of table properties.
        /// </summary>
        [Output("properties")]
        public Output<ImmutableDictionary<string, string>?> Properties { get; private set; } = null!;

        /// <summary>
        /// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
        /// </summary>
        [Output("schemaName")]
        public Output<string> SchemaName { get; private set; } = null!;

        /// <summary>
        /// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
        /// </summary>
        [Output("storageCredentialName")]
        public Output<string?> StorageCredentialName { get; private set; } = null!;

        /// <summary>
        /// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&amp;`, etc., they should be percent-encoded (space &gt; `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
        /// </summary>
        [Output("storageLocation")]
        public Output<string?> StorageLocation { get; private set; } = null!;

        /// <summary>
        /// The unique identifier of the table.
        /// </summary>
        [Output("tableId")]
        public Output<string> TableId { get; private set; } = null!;

        /// <summary>
        /// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
        /// </summary>
        [Output("tableType")]
        public Output<string> TableType { get; private set; } = null!;

        /// <summary>
        /// SQL text defining the view (for `TableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
        /// </summary>
        [Output("viewDefinition")]
        public Output<string?> ViewDefinition { get; private set; } = null!;

        /// <summary>
        /// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `WarehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `ClusterId`.
        /// </summary>
        [Output("warehouseId")]
        public Output<string?> WarehouseId { get; private set; } = null!;


        /// <summary>
        /// Create a SqlTable resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public SqlTable(string name, SqlTableArgs args, CustomResourceOptions? options = null)
            : base("databricks:index/sqlTable:SqlTable", name, args ?? new SqlTableArgs(), MakeResourceOptions(options, ""))
        {
        }

        private SqlTable(string name, Input<string> id, SqlTableState? state = null, CustomResourceOptions? options = null)
            : base("databricks:index/sqlTable:SqlTable", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing SqlTable resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static SqlTable Get(string name, Input<string> id, SqlTableState? state = null, CustomResourceOptions? options = null)
        {
            return new SqlTable(name, id, state, options);
        }
    }

    public sealed class SqlTableArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of parent catalog. Change forces the creation of a new resource.
        /// </summary>
        [Input("catalogName", required: true)]
        public Input<string> CatalogName { get; set; } = null!;

        /// <summary>
        /// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a ClusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `WarehouseId`.
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        [Input("clusterKeys")]
        private InputList<string>? _clusterKeys;

        /// <summary>
        /// a subset of columns to liquid cluster the table by. For automatic clustering, set `ClusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `Partitions`.
        /// </summary>
        public InputList<string> ClusterKeys
        {
            get => _clusterKeys ?? (_clusterKeys = new InputList<string>());
            set => _clusterKeys = value;
        }

        [Input("columns")]
        private InputList<Inputs.SqlTableColumnArgs>? _columns;
        public InputList<Inputs.SqlTableColumnArgs> Columns
        {
            get => _columns ?? (_columns = new InputList<Inputs.SqlTableColumnArgs>());
            set => _columns = value;
        }

        /// <summary>
        /// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
        /// </summary>
        [Input("comment")]
        public Input<string>? Comment { get; set; }

        /// <summary>
        /// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
        /// </summary>
        [Input("dataSourceFormat")]
        public Input<string>? DataSourceFormat { get; set; }

        /// <summary>
        /// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("options")]
        private InputMap<string>? _options;

        /// <summary>
        /// Map of user defined table options. Change forces creation of a new resource.
        /// </summary>
        public InputMap<string> Options
        {
            get => _options ?? (_options = new InputMap<string>());
            set => _options = value;
        }

        /// <summary>
        /// User name/group name/sp ApplicationId of the table owner.
        /// </summary>
        [Input("owner")]
        public Input<string>? Owner { get; set; }

        [Input("partitions")]
        private InputList<string>? _partitions;

        /// <summary>
        /// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `ClusterKeys`.
        /// </summary>
        public InputList<string> Partitions
        {
            get => _partitions ?? (_partitions = new InputList<string>());
            set => _partitions = value;
        }

        [Input("properties")]
        private InputMap<string>? _properties;

        /// <summary>
        /// A map of table properties.
        /// </summary>
        public InputMap<string> Properties
        {
            get => _properties ?? (_properties = new InputMap<string>());
            set => _properties = value;
        }

        /// <summary>
        /// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
        /// </summary>
        [Input("schemaName", required: true)]
        public Input<string> SchemaName { get; set; } = null!;

        /// <summary>
        /// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
        /// </summary>
        [Input("storageCredentialName")]
        public Input<string>? StorageCredentialName { get; set; }

        /// <summary>
        /// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&amp;`, etc., they should be percent-encoded (space &gt; `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
        /// </summary>
        [Input("storageLocation")]
        public Input<string>? StorageLocation { get; set; }

        /// <summary>
        /// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
        /// </summary>
        [Input("tableType", required: true)]
        public Input<string> TableType { get; set; } = null!;

        /// <summary>
        /// SQL text defining the view (for `TableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
        /// </summary>
        [Input("viewDefinition")]
        public Input<string>? ViewDefinition { get; set; }

        /// <summary>
        /// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `WarehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `ClusterId`.
        /// </summary>
        [Input("warehouseId")]
        public Input<string>? WarehouseId { get; set; }

        public SqlTableArgs()
        {
        }
        public static new SqlTableArgs Empty => new SqlTableArgs();
    }

    public sealed class SqlTableState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Name of parent catalog. Change forces the creation of a new resource.
        /// </summary>
        [Input("catalogName")]
        public Input<string>? CatalogName { get; set; }

        /// <summary>
        /// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a ClusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `WarehouseId`.
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        [Input("clusterKeys")]
        private InputList<string>? _clusterKeys;

        /// <summary>
        /// a subset of columns to liquid cluster the table by. For automatic clustering, set `ClusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `Partitions`.
        /// </summary>
        public InputList<string> ClusterKeys
        {
            get => _clusterKeys ?? (_clusterKeys = new InputList<string>());
            set => _clusterKeys = value;
        }

        [Input("columns")]
        private InputList<Inputs.SqlTableColumnGetArgs>? _columns;
        public InputList<Inputs.SqlTableColumnGetArgs> Columns
        {
            get => _columns ?? (_columns = new InputList<Inputs.SqlTableColumnGetArgs>());
            set => _columns = value;
        }

        /// <summary>
        /// User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
        /// </summary>
        [Input("comment")]
        public Input<string>? Comment { get; set; }

        /// <summary>
        /// External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
        /// </summary>
        [Input("dataSourceFormat")]
        public Input<string>? DataSourceFormat { get; set; }

        [Input("effectiveProperties")]
        private InputMap<string>? _effectiveProperties;
        public InputMap<string> EffectiveProperties
        {
            get => _effectiveProperties ?? (_effectiveProperties = new InputMap<string>());
            set => _effectiveProperties = value;
        }

        /// <summary>
        /// Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("options")]
        private InputMap<string>? _options;

        /// <summary>
        /// Map of user defined table options. Change forces creation of a new resource.
        /// </summary>
        public InputMap<string> Options
        {
            get => _options ?? (_options = new InputMap<string>());
            set => _options = value;
        }

        /// <summary>
        /// User name/group name/sp ApplicationId of the table owner.
        /// </summary>
        [Input("owner")]
        public Input<string>? Owner { get; set; }

        [Input("partitions")]
        private InputList<string>? _partitions;

        /// <summary>
        /// a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `ClusterKeys`.
        /// </summary>
        public InputList<string> Partitions
        {
            get => _partitions ?? (_partitions = new InputList<string>());
            set => _partitions = value;
        }

        [Input("properties")]
        private InputMap<string>? _properties;

        /// <summary>
        /// A map of table properties.
        /// </summary>
        public InputMap<string> Properties
        {
            get => _properties ?? (_properties = new InputMap<string>());
            set => _properties = value;
        }

        /// <summary>
        /// Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
        /// </summary>
        [Input("schemaName")]
        public Input<string>? SchemaName { get; set; }

        /// <summary>
        /// For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
        /// </summary>
        [Input("storageCredentialName")]
        public Input<string>? StorageCredentialName { get; set; }

        /// <summary>
        /// URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&amp;`, etc., they should be percent-encoded (space &gt; `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
        /// </summary>
        [Input("storageLocation")]
        public Input<string>? StorageLocation { get; set; }

        /// <summary>
        /// The unique identifier of the table.
        /// </summary>
        [Input("tableId")]
        public Input<string>? TableId { get; set; }

        /// <summary>
        /// Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
        /// </summary>
        [Input("tableType")]
        public Input<string>? TableType { get; set; }

        /// <summary>
        /// SQL text defining the view (for `TableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
        /// </summary>
        [Input("viewDefinition")]
        public Input<string>? ViewDefinition { get; set; }

        /// <summary>
        /// All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `WarehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `ClusterId`.
        /// </summary>
        [Input("warehouseId")]
        public Input<string>? WarehouseId { get; set; }

        public SqlTableState()
        {
        }
        public static new SqlTableState Empty => new SqlTableState();
    }
}
