// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Databricks
{
    public static class GetPolicyInfo
    {
        public static Task<GetPolicyInfoResult> InvokeAsync(GetPolicyInfoArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetPolicyInfoResult>("databricks:index/getPolicyInfo:getPolicyInfo", args ?? new GetPolicyInfoArgs(), options.WithDefaults());

        public static Output<GetPolicyInfoResult> Invoke(GetPolicyInfoInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetPolicyInfoResult>("databricks:index/getPolicyInfo:getPolicyInfo", args ?? new GetPolicyInfoInvokeArgs(), options.WithDefaults());

        public static Output<GetPolicyInfoResult> Invoke(GetPolicyInfoInvokeArgs args, InvokeOutputOptions options)
            => global::Pulumi.Deployment.Instance.Invoke<GetPolicyInfoResult>("databricks:index/getPolicyInfo:getPolicyInfo", args ?? new GetPolicyInfoInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetPolicyInfoArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// (ColumnMaskOptions) - Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`.
        /// Required on create and optional on update. When specified on update,
        /// the new options will replace the existing options as a whole
        /// </summary>
        [Input("columnMask")]
        public Inputs.GetPolicyInfoColumnMaskArgs? ColumnMask { get; set; }

        /// <summary>
        /// (string) - Optional description of the policy
        /// </summary>
        [Input("comment")]
        public string? Comment { get; set; }

        [Input("exceptPrincipals")]
        private List<string>? _exceptPrincipals;

        /// <summary>
        /// (list of string) - Optional list of user or group names that should be excluded from the policy
        /// </summary>
        public List<string> ExceptPrincipals
        {
            get => _exceptPrincipals ?? (_exceptPrincipals = new List<string>());
            set => _exceptPrincipals = value;
        }

        /// <summary>
        /// (string) - Type of securables that the policy should take effect on.
        /// Only `TABLE` is supported at this moment.
        /// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        /// </summary>
        [Input("forSecurableType", required: true)]
        public string ForSecurableType { get; set; } = null!;

        [Input("matchColumns")]
        private List<Inputs.GetPolicyInfoMatchColumnArgs>? _matchColumns;

        /// <summary>
        /// (list of MatchColumn) - Optional list of condition expressions used to match table columns.
        /// Only valid when `for_securable_type` is `TABLE`.
        /// When specified, the policy only applies to tables whose columns satisfy all match conditions
        /// </summary>
        public List<Inputs.GetPolicyInfoMatchColumnArgs> MatchColumns
        {
            get => _matchColumns ?? (_matchColumns = new List<Inputs.GetPolicyInfoMatchColumnArgs>());
            set => _matchColumns = value;
        }

        /// <summary>
        /// Name of the policy. Required on create and optional on update.
        /// To rename the policy, set `name` to a different value on update
        /// </summary>
        [Input("name")]
        public string? Name { get; set; }

        /// <summary>
        /// Full name of the securable on which the policy is defined.
        /// Required on create and ignored on update
        /// </summary>
        [Input("onSecurableFullname")]
        public string? OnSecurableFullname { get; set; }

        /// <summary>
        /// Type of the securable on which the policy is defined.
        /// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
        /// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        /// </summary>
        [Input("onSecurableType")]
        public string? OnSecurableType { get; set; }

        /// <summary>
        /// (string) - Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
        /// </summary>
        [Input("policyType", required: true)]
        public string PolicyType { get; set; } = null!;

        /// <summary>
        /// (RowFilterOptions) - Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`.
        /// Required on create and optional on update. When specified on update,
        /// the new options will replace the existing options as a whole
        /// </summary>
        [Input("rowFilter")]
        public Inputs.GetPolicyInfoRowFilterArgs? RowFilter { get; set; }

        [Input("toPrincipals", required: true)]
        private List<string>? _toPrincipals;

        /// <summary>
        /// (list of string) - List of user or group names that the policy applies to.
        /// Required on create and optional on update
        /// </summary>
        public List<string> ToPrincipals
        {
            get => _toPrincipals ?? (_toPrincipals = new List<string>());
            set => _toPrincipals = value;
        }

        /// <summary>
        /// (string) - Optional condition when the policy should take effect
        /// </summary>
        [Input("whenCondition")]
        public string? WhenCondition { get; set; }

        /// <summary>
        /// Workspace ID of the resource
        /// </summary>
        [Input("workspaceId")]
        public string? WorkspaceId { get; set; }

        public GetPolicyInfoArgs()
        {
        }
        public static new GetPolicyInfoArgs Empty => new GetPolicyInfoArgs();
    }

    public sealed class GetPolicyInfoInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// (ColumnMaskOptions) - Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`.
        /// Required on create and optional on update. When specified on update,
        /// the new options will replace the existing options as a whole
        /// </summary>
        [Input("columnMask")]
        public Input<Inputs.GetPolicyInfoColumnMaskInputArgs>? ColumnMask { get; set; }

        /// <summary>
        /// (string) - Optional description of the policy
        /// </summary>
        [Input("comment")]
        public Input<string>? Comment { get; set; }

        [Input("exceptPrincipals")]
        private InputList<string>? _exceptPrincipals;

        /// <summary>
        /// (list of string) - Optional list of user or group names that should be excluded from the policy
        /// </summary>
        public InputList<string> ExceptPrincipals
        {
            get => _exceptPrincipals ?? (_exceptPrincipals = new InputList<string>());
            set => _exceptPrincipals = value;
        }

        /// <summary>
        /// (string) - Type of securables that the policy should take effect on.
        /// Only `TABLE` is supported at this moment.
        /// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        /// </summary>
        [Input("forSecurableType", required: true)]
        public Input<string> ForSecurableType { get; set; } = null!;

        [Input("matchColumns")]
        private InputList<Inputs.GetPolicyInfoMatchColumnInputArgs>? _matchColumns;

        /// <summary>
        /// (list of MatchColumn) - Optional list of condition expressions used to match table columns.
        /// Only valid when `for_securable_type` is `TABLE`.
        /// When specified, the policy only applies to tables whose columns satisfy all match conditions
        /// </summary>
        public InputList<Inputs.GetPolicyInfoMatchColumnInputArgs> MatchColumns
        {
            get => _matchColumns ?? (_matchColumns = new InputList<Inputs.GetPolicyInfoMatchColumnInputArgs>());
            set => _matchColumns = value;
        }

        /// <summary>
        /// Name of the policy. Required on create and optional on update.
        /// To rename the policy, set `name` to a different value on update
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Full name of the securable on which the policy is defined.
        /// Required on create and ignored on update
        /// </summary>
        [Input("onSecurableFullname")]
        public Input<string>? OnSecurableFullname { get; set; }

        /// <summary>
        /// Type of the securable on which the policy is defined.
        /// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
        /// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        /// </summary>
        [Input("onSecurableType")]
        public Input<string>? OnSecurableType { get; set; }

        /// <summary>
        /// (string) - Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
        /// </summary>
        [Input("policyType", required: true)]
        public Input<string> PolicyType { get; set; } = null!;

        /// <summary>
        /// (RowFilterOptions) - Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`.
        /// Required on create and optional on update. When specified on update,
        /// the new options will replace the existing options as a whole
        /// </summary>
        [Input("rowFilter")]
        public Input<Inputs.GetPolicyInfoRowFilterInputArgs>? RowFilter { get; set; }

        [Input("toPrincipals", required: true)]
        private InputList<string>? _toPrincipals;

        /// <summary>
        /// (list of string) - List of user or group names that the policy applies to.
        /// Required on create and optional on update
        /// </summary>
        public InputList<string> ToPrincipals
        {
            get => _toPrincipals ?? (_toPrincipals = new InputList<string>());
            set => _toPrincipals = value;
        }

        /// <summary>
        /// (string) - Optional condition when the policy should take effect
        /// </summary>
        [Input("whenCondition")]
        public Input<string>? WhenCondition { get; set; }

        /// <summary>
        /// Workspace ID of the resource
        /// </summary>
        [Input("workspaceId")]
        public Input<string>? WorkspaceId { get; set; }

        public GetPolicyInfoInvokeArgs()
        {
        }
        public static new GetPolicyInfoInvokeArgs Empty => new GetPolicyInfoInvokeArgs();
    }


    [OutputType]
    public sealed class GetPolicyInfoResult
    {
        /// <summary>
        /// (ColumnMaskOptions) - Options for column mask policies. Valid only if `policy_type` is `POLICY_TYPE_COLUMN_MASK`.
        /// Required on create and optional on update. When specified on update,
        /// the new options will replace the existing options as a whole
        /// </summary>
        public readonly Outputs.GetPolicyInfoColumnMaskResult? ColumnMask;
        /// <summary>
        /// (string) - Optional description of the policy
        /// </summary>
        public readonly string? Comment;
        /// <summary>
        /// (integer) - Time at which the policy was created, in epoch milliseconds. Output only
        /// </summary>
        public readonly int CreatedAt;
        /// <summary>
        /// (string) - Username of the user who created the policy. Output only
        /// </summary>
        public readonly string CreatedBy;
        /// <summary>
        /// (list of string) - Optional list of user or group names that should be excluded from the policy
        /// </summary>
        public readonly ImmutableArray<string> ExceptPrincipals;
        /// <summary>
        /// (string) - Type of securables that the policy should take effect on.
        /// Only `TABLE` is supported at this moment.
        /// Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        /// </summary>
        public readonly string ForSecurableType;
        /// <summary>
        /// (string) - Unique identifier of the policy. This field is output only and is generated by the system
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// (list of MatchColumn) - Optional list of condition expressions used to match table columns.
        /// Only valid when `for_securable_type` is `TABLE`.
        /// When specified, the policy only applies to tables whose columns satisfy all match conditions
        /// </summary>
        public readonly ImmutableArray<Outputs.GetPolicyInfoMatchColumnResult> MatchColumns;
        /// <summary>
        /// (string) - Name of the policy. Required on create and optional on update.
        /// To rename the policy, set `name` to a different value on update
        /// </summary>
        public readonly string? Name;
        /// <summary>
        /// (string) - Full name of the securable on which the policy is defined.
        /// Required on create and ignored on update
        /// </summary>
        public readonly string? OnSecurableFullname;
        /// <summary>
        /// (string) - Type of the securable on which the policy is defined.
        /// Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
        /// Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
        /// </summary>
        public readonly string? OnSecurableType;
        /// <summary>
        /// (string) - Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
        /// </summary>
        public readonly string PolicyType;
        /// <summary>
        /// (RowFilterOptions) - Options for row filter policies. Valid only if `policy_type` is `POLICY_TYPE_ROW_FILTER`.
        /// Required on create and optional on update. When specified on update,
        /// the new options will replace the existing options as a whole
        /// </summary>
        public readonly Outputs.GetPolicyInfoRowFilterResult? RowFilter;
        /// <summary>
        /// (list of string) - List of user or group names that the policy applies to.
        /// Required on create and optional on update
        /// </summary>
        public readonly ImmutableArray<string> ToPrincipals;
        /// <summary>
        /// (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
        /// </summary>
        public readonly int UpdatedAt;
        /// <summary>
        /// (string) - Username of the user who last modified the policy. Output only
        /// </summary>
        public readonly string UpdatedBy;
        /// <summary>
        /// (string) - Optional condition when the policy should take effect
        /// </summary>
        public readonly string? WhenCondition;
        public readonly string? WorkspaceId;

        [OutputConstructor]
        private GetPolicyInfoResult(
            Outputs.GetPolicyInfoColumnMaskResult? columnMask,

            string? comment,

            int createdAt,

            string createdBy,

            ImmutableArray<string> exceptPrincipals,

            string forSecurableType,

            string id,

            ImmutableArray<Outputs.GetPolicyInfoMatchColumnResult> matchColumns,

            string? name,

            string? onSecurableFullname,

            string? onSecurableType,

            string policyType,

            Outputs.GetPolicyInfoRowFilterResult? rowFilter,

            ImmutableArray<string> toPrincipals,

            int updatedAt,

            string updatedBy,

            string? whenCondition,

            string? workspaceId)
        {
            ColumnMask = columnMask;
            Comment = comment;
            CreatedAt = createdAt;
            CreatedBy = createdBy;
            ExceptPrincipals = exceptPrincipals;
            ForSecurableType = forSecurableType;
            Id = id;
            MatchColumns = matchColumns;
            Name = name;
            OnSecurableFullname = onSecurableFullname;
            OnSecurableType = onSecurableType;
            PolicyType = policyType;
            RowFilter = rowFilter;
            ToPrincipals = toPrincipals;
            UpdatedAt = updatedAt;
            UpdatedBy = updatedBy;
            WhenCondition = whenCondition;
            WorkspaceId = workspaceId;
        }
    }
}
