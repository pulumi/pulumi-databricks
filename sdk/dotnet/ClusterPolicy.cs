// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Databricks
{
    /// <summary>
    /// This resource creates a cluster policy, which limits the ability to create clusters based on a set of rules. The policy rules limit the attributes or attribute values available for cluster creation. cluster policies have ACLs that limit their use to specific users and groups. Only admin users can create, edit, and delete policies. Admin users also have access to all policies.
    /// 
    /// &gt; This resource can only be used with a workspace-level provider!
    /// 
    /// Cluster policies let you:
    /// 
    /// * Limit users to create clusters with prescribed settings.
    /// * Simplify the user interface and enable more users to create their own clusters (by fixing and hiding some values).
    /// * Control cost by limiting per cluster maximum cost (by setting limits on attributes whose values contribute to hourly price).
    /// 
    /// Cluster policy permissions limit which policies a user can select in the Policy drop-down when the user creates a cluster:
    /// 
    /// * If no policies have been created in the workspace, the Policy drop-down does not display.
    /// * A user who has cluster create permission can select the `Free form` policy and create fully-configurable clusters.
    /// * A user who has both cluster create permission and access to cluster policies can select the Free form policy and policies they have access to.
    /// * A user that has access to only cluster policies, can select the policies they have access to.
    /// 
    /// ## Example Usage
    /// 
    /// Let us take a look at an example of how you can manage two teams: Marketing and Data Engineering. In the following scenario we want the marketing team to have a really good query experience, so we enabled delta cache for them. On the other hand we want the data engineering team to be able to utilize bigger clusters so we increased the dbus per hour that they can spend. This strategy allows your marketing users and data engineering users to use Databricks in a self service manner but have a different experience in regards to security and performance. And down the line if you need to add more global settings you can propagate them through the "base cluster policy".
    /// 
    /// `modules/base-cluster-policy/main.tf` could look like:
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// using Std = Pulumi.Std;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     // Team that performs the work
    ///     var team = config.RequireObject&lt;dynamic&gt;("team");
    ///     // Cluster policy overrides
    ///     var policyOverrides = config.RequireObject&lt;dynamic&gt;("policyOverrides");
    ///     var defaultPolicy = 
    ///     {
    ///         { "dbus_per_hour", 
    ///         {
    ///             { "type", "range" },
    ///             { "maxValue", 10 },
    ///         } },
    ///         { "autotermination_minutes", 
    ///         {
    ///             { "type", "fixed" },
    ///             { "value", 20 },
    ///             { "hidden", true },
    ///         } },
    ///         { "custom_tags.Team", 
    ///         {
    ///             { "type", "fixed" },
    ///             { "value", team },
    ///         } },
    ///     };
    /// 
    ///     var fairUse = new Databricks.ClusterPolicy("fair_use", new()
    ///     {
    ///         Name = $"{team} cluster policy",
    ///         Definition = JsonSerializer.Serialize(Std.Merge.Invoke(new()
    ///         {
    ///             Input = new[]
    ///             {
    ///                 defaultPolicy,
    ///                 policyOverrides,
    ///             },
    ///         }).Apply(invoke =&gt; invoke.Result)),
    ///         Libraries = new[]
    ///         {
    ///             new Databricks.Inputs.ClusterPolicyLibraryArgs
    ///             {
    ///                 Pypi = new Databricks.Inputs.ClusterPolicyLibraryPypiArgs
    ///                 {
    ///                     Package = "databricks-sdk==0.12.0",
    ///                 },
    ///             },
    ///             new Databricks.Inputs.ClusterPolicyLibraryArgs
    ///             {
    ///                 Maven = new Databricks.Inputs.ClusterPolicyLibraryMavenArgs
    ///                 {
    ///                     Coordinates = "com.oracle.database.jdbc:ojdbc8:XXXX",
    ///                 },
    ///             },
    ///         },
    ///     });
    /// 
    ///     var canUseClusterPolicyinstanceProfile = new Databricks.Permissions("can_use_cluster_policyinstance_profile", new()
    ///     {
    ///         ClusterPolicyId = fairUse.Id,
    ///         AccessControls = new[]
    ///         {
    ///             new Databricks.Inputs.PermissionsAccessControlArgs
    ///             {
    ///                 GroupName = team,
    ///                 PermissionLevel = "CAN_USE",
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// And custom instances of that base policy module for our marketing and data engineering teams would look like:
    /// 
    /// ### Overriding the built-in cluster policies
    /// 
    /// You can override built-in cluster policies by creating a `databricks.ClusterPolicy` resource with following attributes:
    /// 
    /// * `Name` - the name of the built-in cluster policy.
    /// * `PolicyFamilyId` - the ID of the cluster policy family used for built-in cluster policy.
    /// * `PolicyFamilyDefinitionOverrides` - settings to override in the built-in cluster policy.
    /// 
    /// You can obtain the list of defined cluster policies families using the `databricks policy-families list` command of the new [Databricks CLI](https://docs.databricks.com/en/dev-tools/cli/index.html), or via [list policy families](https://docs.databricks.com/api/workspace/policyfamilies/list) REST API.
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using System.Text.Json;
    /// using Pulumi;
    /// using Databricks = Pulumi.Databricks;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var personalVmOverride = 
    ///     {
    ///         { "autotermination_minutes", 
    ///         {
    ///             { "type", "fixed" },
    ///             { "value", 220 },
    ///             { "hidden", true },
    ///         } },
    ///         { "custom_tags.Team", 
    ///         {
    ///             { "type", "fixed" },
    ///             { "value", team },
    ///         } },
    ///     };
    /// 
    ///     var personalVm = new Databricks.ClusterPolicy("personal_vm", new()
    ///     {
    ///         PolicyFamilyId = "personal-vm",
    ///         PolicyFamilyDefinitionOverrides = JsonSerializer.Serialize(personalVmOverride),
    ///         Name = "Personal Compute",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Related Resources
    /// 
    /// The following resources are often used in the same context:
    /// 
    /// * Dynamic Passthrough Clusters for a Group guide.
    /// * End to end workspace management guide.
    /// * databricks.getClusters data to retrieve a list of databricks.Cluster ids.
    /// * databricks.Cluster to create [Databricks Clusters](https://docs.databricks.com/clusters/index.html).
    /// * databricks.getCurrentUser data to retrieve information about databricks.User or databricks_service_principal, that is calling Databricks REST API.
    /// * databricks.GlobalInitScript to manage [global init scripts](https://docs.databricks.com/clusters/init-scripts.html#global-init-scripts), which are run on all databricks.Cluster and databricks_job.
    /// * databricks.InstancePool to manage [instance pools](https://docs.databricks.com/clusters/instance-pools/index.html) to reduce cluster start and auto-scaling times by maintaining a set of idle, ready-to-use instances.
    /// * databricks.InstanceProfile to manage AWS EC2 instance profiles that users can launch databricks.Cluster and access data, like databricks_mount.
    /// * databricks.IpAccessList to allow access from [predefined IP ranges](https://docs.databricks.com/security/network/ip-access-list.html).
    /// * databricks.Library to install a [library](https://docs.databricks.com/libraries/index.html) on databricks_cluster.
    /// * databricks.getNodeType data to get the smallest node type for databricks.Cluster that fits search criteria, like amount of RAM or number of cores.
    /// * databricks.Permissions to manage [access control](https://docs.databricks.com/security/access-control/index.html) in Databricks workspace.
    /// * databricks.getSparkVersion data to get [Databricks Runtime (DBR)](https://docs.databricks.com/runtime/dbr.html) version that could be used for `SparkVersion` parameter in databricks.Cluster and other resources.
    /// * databricks.UserInstanceProfile to attach databricks.InstanceProfile (AWS) to databricks_user.
    /// * databricks.WorkspaceConf to manage workspace configuration for expert usage.
    /// </summary>
    [DatabricksResourceType("databricks:index/clusterPolicy:ClusterPolicy")]
    public partial class ClusterPolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Policy definition: JSON document expressed in [Databricks Policy Definition Language](https://docs.databricks.com/administration-guide/clusters/policies.html#cluster-policy-definition). Cannot be used with `PolicyFamilyId`
        /// </summary>
        [Output("definition")]
        public Output<string> Definition { get; private set; } = null!;

        /// <summary>
        /// Additional human-readable description of the cluster policy.
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        [Output("libraries")]
        public Output<ImmutableArray<Outputs.ClusterPolicyLibrary>> Libraries { get; private set; } = null!;

        /// <summary>
        /// Maximum number of clusters allowed per user. When omitted, there is no limit. If specified, value must be greater than zero.
        /// </summary>
        [Output("maxClustersPerUser")]
        public Output<int?> MaxClustersPerUser { get; private set; } = null!;

        /// <summary>
        /// Cluster policy name. This must be unique. Length must be between 1 and 100 characters.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Policy definition JSON document expressed in Databricks Policy Definition Language. The JSON document must be passed as a string and cannot be embedded in the requests. You can use this to customize the policy definition inherited from the policy family. Policy rules specified here are merged into the inherited policy definition.
        /// </summary>
        [Output("policyFamilyDefinitionOverrides")]
        public Output<string?> PolicyFamilyDefinitionOverrides { get; private set; } = null!;

        /// <summary>
        /// ID of the policy family. The cluster policy's policy definition inherits the policy family's policy definition. Cannot be used with `Definition`. Use `PolicyFamilyDefinitionOverrides` instead to customize the policy definition.
        /// </summary>
        [Output("policyFamilyId")]
        public Output<string?> PolicyFamilyId { get; private set; } = null!;

        /// <summary>
        /// Canonical unique identifier for the cluster policy.
        /// </summary>
        [Output("policyId")]
        public Output<string> PolicyId { get; private set; } = null!;

        [Output("providerConfig")]
        public Output<Outputs.ClusterPolicyProviderConfig?> ProviderConfig { get; private set; } = null!;


        /// <summary>
        /// Create a ClusterPolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ClusterPolicy(string name, ClusterPolicyArgs? args = null, CustomResourceOptions? options = null)
            : base("databricks:index/clusterPolicy:ClusterPolicy", name, args ?? new ClusterPolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ClusterPolicy(string name, Input<string> id, ClusterPolicyState? state = null, CustomResourceOptions? options = null)
            : base("databricks:index/clusterPolicy:ClusterPolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ClusterPolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ClusterPolicy Get(string name, Input<string> id, ClusterPolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new ClusterPolicy(name, id, state, options);
        }
    }

    public sealed class ClusterPolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Policy definition: JSON document expressed in [Databricks Policy Definition Language](https://docs.databricks.com/administration-guide/clusters/policies.html#cluster-policy-definition). Cannot be used with `PolicyFamilyId`
        /// </summary>
        [Input("definition")]
        public Input<string>? Definition { get; set; }

        /// <summary>
        /// Additional human-readable description of the cluster policy.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("libraries")]
        private InputList<Inputs.ClusterPolicyLibraryArgs>? _libraries;
        public InputList<Inputs.ClusterPolicyLibraryArgs> Libraries
        {
            get => _libraries ?? (_libraries = new InputList<Inputs.ClusterPolicyLibraryArgs>());
            set => _libraries = value;
        }

        /// <summary>
        /// Maximum number of clusters allowed per user. When omitted, there is no limit. If specified, value must be greater than zero.
        /// </summary>
        [Input("maxClustersPerUser")]
        public Input<int>? MaxClustersPerUser { get; set; }

        /// <summary>
        /// Cluster policy name. This must be unique. Length must be between 1 and 100 characters.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Policy definition JSON document expressed in Databricks Policy Definition Language. The JSON document must be passed as a string and cannot be embedded in the requests. You can use this to customize the policy definition inherited from the policy family. Policy rules specified here are merged into the inherited policy definition.
        /// </summary>
        [Input("policyFamilyDefinitionOverrides")]
        public Input<string>? PolicyFamilyDefinitionOverrides { get; set; }

        /// <summary>
        /// ID of the policy family. The cluster policy's policy definition inherits the policy family's policy definition. Cannot be used with `Definition`. Use `PolicyFamilyDefinitionOverrides` instead to customize the policy definition.
        /// </summary>
        [Input("policyFamilyId")]
        public Input<string>? PolicyFamilyId { get; set; }

        [Input("providerConfig")]
        public Input<Inputs.ClusterPolicyProviderConfigArgs>? ProviderConfig { get; set; }

        public ClusterPolicyArgs()
        {
        }
        public static new ClusterPolicyArgs Empty => new ClusterPolicyArgs();
    }

    public sealed class ClusterPolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Policy definition: JSON document expressed in [Databricks Policy Definition Language](https://docs.databricks.com/administration-guide/clusters/policies.html#cluster-policy-definition). Cannot be used with `PolicyFamilyId`
        /// </summary>
        [Input("definition")]
        public Input<string>? Definition { get; set; }

        /// <summary>
        /// Additional human-readable description of the cluster policy.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("libraries")]
        private InputList<Inputs.ClusterPolicyLibraryGetArgs>? _libraries;
        public InputList<Inputs.ClusterPolicyLibraryGetArgs> Libraries
        {
            get => _libraries ?? (_libraries = new InputList<Inputs.ClusterPolicyLibraryGetArgs>());
            set => _libraries = value;
        }

        /// <summary>
        /// Maximum number of clusters allowed per user. When omitted, there is no limit. If specified, value must be greater than zero.
        /// </summary>
        [Input("maxClustersPerUser")]
        public Input<int>? MaxClustersPerUser { get; set; }

        /// <summary>
        /// Cluster policy name. This must be unique. Length must be between 1 and 100 characters.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Policy definition JSON document expressed in Databricks Policy Definition Language. The JSON document must be passed as a string and cannot be embedded in the requests. You can use this to customize the policy definition inherited from the policy family. Policy rules specified here are merged into the inherited policy definition.
        /// </summary>
        [Input("policyFamilyDefinitionOverrides")]
        public Input<string>? PolicyFamilyDefinitionOverrides { get; set; }

        /// <summary>
        /// ID of the policy family. The cluster policy's policy definition inherits the policy family's policy definition. Cannot be used with `Definition`. Use `PolicyFamilyDefinitionOverrides` instead to customize the policy definition.
        /// </summary>
        [Input("policyFamilyId")]
        public Input<string>? PolicyFamilyId { get; set; }

        /// <summary>
        /// Canonical unique identifier for the cluster policy.
        /// </summary>
        [Input("policyId")]
        public Input<string>? PolicyId { get; set; }

        [Input("providerConfig")]
        public Input<Inputs.ClusterPolicyProviderConfigGetArgs>? ProviderConfig { get; set; }

        public ClusterPolicyState()
        {
        }
        public static new ClusterPolicyState Empty => new ClusterPolicyState();
    }
}
