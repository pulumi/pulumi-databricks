// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Within a metastore, Unity Catalog provides a 3-level namespace for organizing data: Catalogs, databases (also called schemas), and tables/views.
 *
 * A `databricks.SqlTable` is contained within databricks_schema, and can represent either a managed table, an external table, or a view.
 *
 * This resource creates and updates the Unity Catalog table/view by executing the necessary SQL queries on a special auto-terminating cluster it would create for this operation. You could also specify a SQL warehouse or cluster for the queries to be executed on.
 *
 * > This resource can only be used with a workspace-level provider!
 *
 * > This resource doesn't handle complex cases of schema evolution due to the limitations of Pulumi itself.  If you need to implement schema evolution it's recommended to use specialized tools, such as, [Liquibase](https://medium.com/dbsql-sme-engineering/advanced-schema-management-on-databricks-with-liquibase-1900e9f7b9c0) and [Flyway](https://medium.com/dbsql-sme-engineering/databricks-schema-management-with-flyway-527c4a9f5d67).
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 * import * as std from "@pulumi/std";
 *
 * const sandbox = new databricks.Catalog("sandbox", {
 *     name: "sandbox",
 *     comment: "this catalog is managed by terraform",
 *     properties: {
 *         purpose: "testing",
 *     },
 * });
 * const things = new databricks.Schema("things", {
 *     catalogName: sandbox.id,
 *     name: "things",
 *     comment: "this database is managed by terraform",
 *     properties: {
 *         kind: "various",
 *     },
 * });
 * const thing = new databricks.SqlTable("thing", {
 *     name: "quickstart_table",
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     tableType: "MANAGED",
 *     columns: [
 *         {
 *             name: "id",
 *             type: "int",
 *         },
 *         {
 *             name: "name",
 *             type: "string",
 *             comment: "name of thing",
 *         },
 *     ],
 *     comment: "this table is managed by terraform",
 * });
 * const thingView = new databricks.SqlTable("thing_view", {
 *     name: "quickstart_table_view",
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     tableType: "VIEW",
 *     clusterId: "0423-201305-xsrt82qn",
 *     viewDefinition: std.format({
 *         input: "SELECT name FROM %s WHERE id == 1",
 *         args: [thing.id],
 *     }).then(invoke => invoke.result),
 *     comment: "this view is managed by terraform",
 * });
 * ```
 *
 * ### Use an existing warehouse to create a table
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 * import * as std from "@pulumi/std";
 *
 * const _this = new databricks.SqlEndpoint("this", {
 *     name: "endpoint",
 *     clusterSize: "2X-Small",
 *     maxNumClusters: 1,
 * });
 * const thing = new databricks.SqlTable("thing", {
 *     name: "quickstart_table",
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     tableType: "MANAGED",
 *     warehouseId: _this.id,
 *     columns: [
 *         {
 *             name: "id",
 *             type: "int",
 *         },
 *         {
 *             name: "name",
 *             type: "string",
 *             comment: "name of thing",
 *         },
 *     ],
 *     comment: "this table is managed by terraform",
 * });
 * const thingView = new databricks.SqlTable("thing_view", {
 *     name: "quickstart_table_view",
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     tableType: "VIEW",
 *     warehouseId: _this.id,
 *     viewDefinition: std.format({
 *         input: "SELECT name FROM %s WHERE id == 1",
 *         args: [thing.id],
 *     }).then(invoke => invoke.result),
 *     comment: "this view is managed by terraform",
 * });
 * ```
 *
 * ## Use an Identity Column
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const sandbox = new databricks.Catalog("sandbox", {
 *     name: "sandbox",
 *     comment: "this catalog is managed by terraform",
 *     properties: {
 *         purpose: "testing",
 *     },
 * });
 * const things = new databricks.Schema("things", {
 *     catalogName: sandbox.id,
 *     name: "things",
 *     comment: "this database is managed by terraform",
 *     properties: {
 *         kind: "various",
 *     },
 * });
 * const thing = new databricks.SqlTable("thing", {
 *     name: "identity_table",
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     tableType: "MANAGED",
 *     columns: [
 *         {
 *             name: "id",
 *             type: "bigint",
 *             identity: "default",
 *         },
 *         {
 *             name: "name",
 *             type: "string",
 *             comment: "name of thing",
 *         },
 *     ],
 *     comment: "this table is managed by terraform",
 * });
 * ```
 *
 * ## Enable automatic clustering
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const thing = new databricks.SqlTable("thing", {
 *     name: "auto_cluster_table",
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     tableType: "MANAGED",
 *     clusterKeys: ["AUTO"],
 *     columns: [{
 *         name: "name",
 *         type: "string",
 *         comment: "name of thing",
 *     }],
 *     comment: "this table is managed by terraform",
 * });
 * ```
 *
 * ## Migration from `databricks.Table`
 *
 * The `databricks.Table` resource has been deprecated in favor of `databricks.SqlTable`. To migrate from `databricks.Table` to `databricks.SqlTable`:
 *
 * 1. Define a `databricks.SqlTable` resource with arguments corresponding to `databricks.Table`.
 * 2. Add a `removed` block to remove the `databricks.Table` resource without deleting the existing table by using the `lifecycle` block. If you're using Pulumi version below v1.7.0, you will need to use the `terraform state rm` command instead.
 * 3. Add an `import` block to add the `databricks.SqlTable` resource, corresponding to the existing table. If you're using Pulumi version below v1.5.0, you will need to use `pulumi import` command instead.
 *
 * For example, suppose we have the following `databricks.Table` resource:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const _this = new databricks.Table("this", {
 *     catalogName: "catalog",
 *     schemaName: "schema",
 *     name: "table",
 *     tableType: "MANAGED",
 *     dataSourceFormat: "DELTA",
 *     columns: [{
 *         name: "col1",
 *         typeName: "STRING",
 *         typeJson: "{\"type\":\"STRING\"}",
 *         comment: "comment",
 *         nullable: true,
 *     }],
 *     comment: "comment",
 *     properties: {
 *         key: "value",
 *     },
 * });
 * ```
 *
 * The migration would look like this:
 */
export class SqlTable extends pulumi.CustomResource {
    /**
     * Get an existing SqlTable resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: SqlTableState, opts?: pulumi.CustomResourceOptions): SqlTable {
        return new SqlTable(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'databricks:index/sqlTable:SqlTable';

    /**
     * Returns true if the given object is an instance of SqlTable.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is SqlTable {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === SqlTable.__pulumiType;
    }

    /**
     * Name of parent catalog. Change forces the creation of a new resource.
     */
    declare public readonly catalogName: pulumi.Output<string>;
    /**
     * All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
     */
    declare public readonly clusterId: pulumi.Output<string>;
    /**
     * a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
     */
    declare public readonly clusterKeys: pulumi.Output<string[] | undefined>;
    declare public readonly columns: pulumi.Output<outputs.SqlTableColumn[]>;
    /**
     * User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
     */
    declare public readonly comment: pulumi.Output<string | undefined>;
    /**
     * External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
     */
    declare public readonly dataSourceFormat: pulumi.Output<string | undefined>;
    declare public /*out*/ readonly effectiveProperties: pulumi.Output<{[key: string]: string}>;
    /**
     * Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Map of user defined table options. Change forces creation of a new resource.
     */
    declare public readonly options: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * User name/group name/sp applicationId of the table owner.
     */
    declare public readonly owner: pulumi.Output<string>;
    /**
     * a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
     */
    declare public readonly partitions: pulumi.Output<string[]>;
    /**
     * A map of table properties.
     */
    declare public readonly properties: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Configure the provider for management through account provider. This block consists of the following fields:
     */
    declare public readonly providerConfig: pulumi.Output<outputs.SqlTableProviderConfig | undefined>;
    /**
     * Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
     */
    declare public readonly schemaName: pulumi.Output<string>;
    /**
     * For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
     */
    declare public readonly storageCredentialName: pulumi.Output<string | undefined>;
    /**
     * URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
     */
    declare public readonly storageLocation: pulumi.Output<string | undefined>;
    /**
     * The unique identifier of the table.
     */
    declare public /*out*/ readonly tableId: pulumi.Output<string>;
    /**
     * Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
     */
    declare public readonly tableType: pulumi.Output<string>;
    /**
     * SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
     */
    declare public readonly viewDefinition: pulumi.Output<string | undefined>;
    /**
     * All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
     */
    declare public readonly warehouseId: pulumi.Output<string | undefined>;

    /**
     * Create a SqlTable resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: SqlTableArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: SqlTableArgs | SqlTableState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as SqlTableState | undefined;
            resourceInputs["catalogName"] = state?.catalogName;
            resourceInputs["clusterId"] = state?.clusterId;
            resourceInputs["clusterKeys"] = state?.clusterKeys;
            resourceInputs["columns"] = state?.columns;
            resourceInputs["comment"] = state?.comment;
            resourceInputs["dataSourceFormat"] = state?.dataSourceFormat;
            resourceInputs["effectiveProperties"] = state?.effectiveProperties;
            resourceInputs["name"] = state?.name;
            resourceInputs["options"] = state?.options;
            resourceInputs["owner"] = state?.owner;
            resourceInputs["partitions"] = state?.partitions;
            resourceInputs["properties"] = state?.properties;
            resourceInputs["providerConfig"] = state?.providerConfig;
            resourceInputs["schemaName"] = state?.schemaName;
            resourceInputs["storageCredentialName"] = state?.storageCredentialName;
            resourceInputs["storageLocation"] = state?.storageLocation;
            resourceInputs["tableId"] = state?.tableId;
            resourceInputs["tableType"] = state?.tableType;
            resourceInputs["viewDefinition"] = state?.viewDefinition;
            resourceInputs["warehouseId"] = state?.warehouseId;
        } else {
            const args = argsOrState as SqlTableArgs | undefined;
            if (args?.catalogName === undefined && !opts.urn) {
                throw new Error("Missing required property 'catalogName'");
            }
            if (args?.schemaName === undefined && !opts.urn) {
                throw new Error("Missing required property 'schemaName'");
            }
            if (args?.tableType === undefined && !opts.urn) {
                throw new Error("Missing required property 'tableType'");
            }
            resourceInputs["catalogName"] = args?.catalogName;
            resourceInputs["clusterId"] = args?.clusterId;
            resourceInputs["clusterKeys"] = args?.clusterKeys;
            resourceInputs["columns"] = args?.columns;
            resourceInputs["comment"] = args?.comment;
            resourceInputs["dataSourceFormat"] = args?.dataSourceFormat;
            resourceInputs["name"] = args?.name;
            resourceInputs["options"] = args?.options;
            resourceInputs["owner"] = args?.owner;
            resourceInputs["partitions"] = args?.partitions;
            resourceInputs["properties"] = args?.properties;
            resourceInputs["providerConfig"] = args?.providerConfig;
            resourceInputs["schemaName"] = args?.schemaName;
            resourceInputs["storageCredentialName"] = args?.storageCredentialName;
            resourceInputs["storageLocation"] = args?.storageLocation;
            resourceInputs["tableType"] = args?.tableType;
            resourceInputs["viewDefinition"] = args?.viewDefinition;
            resourceInputs["warehouseId"] = args?.warehouseId;
            resourceInputs["effectiveProperties"] = undefined /*out*/;
            resourceInputs["tableId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(SqlTable.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering SqlTable resources.
 */
export interface SqlTableState {
    /**
     * Name of parent catalog. Change forces the creation of a new resource.
     */
    catalogName?: pulumi.Input<string>;
    /**
     * All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
     */
    clusterId?: pulumi.Input<string>;
    /**
     * a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
     */
    clusterKeys?: pulumi.Input<pulumi.Input<string>[]>;
    columns?: pulumi.Input<pulumi.Input<inputs.SqlTableColumn>[]>;
    /**
     * User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
     */
    comment?: pulumi.Input<string>;
    /**
     * External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
     */
    dataSourceFormat?: pulumi.Input<string>;
    effectiveProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
     */
    name?: pulumi.Input<string>;
    /**
     * Map of user defined table options. Change forces creation of a new resource.
     */
    options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * User name/group name/sp applicationId of the table owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
     */
    partitions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A map of table properties.
     */
    properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Configure the provider for management through account provider. This block consists of the following fields:
     */
    providerConfig?: pulumi.Input<inputs.SqlTableProviderConfig>;
    /**
     * Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
     */
    schemaName?: pulumi.Input<string>;
    /**
     * For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
     */
    storageCredentialName?: pulumi.Input<string>;
    /**
     * URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
     */
    storageLocation?: pulumi.Input<string>;
    /**
     * The unique identifier of the table.
     */
    tableId?: pulumi.Input<string>;
    /**
     * Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
     */
    tableType?: pulumi.Input<string>;
    /**
     * SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
     */
    viewDefinition?: pulumi.Input<string>;
    /**
     * All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
     */
    warehouseId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a SqlTable resource.
 */
export interface SqlTableArgs {
    /**
     * Name of parent catalog. Change forces the creation of a new resource.
     */
    catalogName: pulumi.Input<string>;
    /**
     * All table CRUD operations must be executed on a running cluster or SQL warehouse. If a clusterId is specified, it will be used to execute SQL commands to manage this table. If empty, a cluster will be created automatically with the name `terraform-sql-table`. Conflicts with `warehouseId`.
     */
    clusterId?: pulumi.Input<string>;
    /**
     * a subset of columns to liquid cluster the table by. For automatic clustering, set `clusterKeys` to `["AUTO"]`. To turn off clustering, set it to `["NONE"]`. Conflicts with `partitions`.
     */
    clusterKeys?: pulumi.Input<pulumi.Input<string>[]>;
    columns?: pulumi.Input<pulumi.Input<inputs.SqlTableColumn>[]>;
    /**
     * User-supplied free-form text. Changing the comment is not currently supported on the `VIEW` table type.
     */
    comment?: pulumi.Input<string>;
    /**
     * External tables are supported in multiple data source formats. The string constants identifying these formats are `DELTA`, `CSV`, `JSON`, `AVRO`, `PARQUET`, `ORC`, and `TEXT`. Change forces the creation of a new resource. Not supported for `MANAGED` tables or `VIEW`.
     */
    dataSourceFormat?: pulumi.Input<string>;
    /**
     * Name of table relative to parent catalog and schema. Change forces the creation of a new resource.
     */
    name?: pulumi.Input<string>;
    /**
     * Map of user defined table options. Change forces creation of a new resource.
     */
    options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * User name/group name/sp applicationId of the table owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * a subset of columns to partition the table by. Change forces the creation of a new resource. Conflicts with `clusterKeys`.
     */
    partitions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A map of table properties.
     */
    properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Configure the provider for management through account provider. This block consists of the following fields:
     */
    providerConfig?: pulumi.Input<inputs.SqlTableProviderConfig>;
    /**
     * Name of parent Schema relative to parent Catalog. Change forces the creation of a new resource.
     */
    schemaName: pulumi.Input<string>;
    /**
     * For EXTERNAL Tables only: the name of storage credential to use. Change forces the creation of a new resource.
     */
    storageCredentialName?: pulumi.Input<string>;
    /**
     * URL of storage location for Table data (required for EXTERNAL Tables).  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.).  Not supported for `VIEW` or `MANAGED` table_type.
     */
    storageLocation?: pulumi.Input<string>;
    /**
     * Distinguishes a view vs. managed/external Table. `MANAGED`, `EXTERNAL` or `VIEW`. Change forces the creation of a new resource.
     */
    tableType: pulumi.Input<string>;
    /**
     * SQL text defining the view (for `tableType == "VIEW"`). Not supported for `MANAGED` or `EXTERNAL` table_type.
     */
    viewDefinition?: pulumi.Input<string>;
    /**
     * All table CRUD operations must be executed on a running cluster or SQL warehouse. If a `warehouseId` is specified, that SQL warehouse will be used to execute SQL commands to manage this table. Conflicts with `clusterId`.
     */
    warehouseId?: pulumi.Input<string>;
}
