// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Lakebase Synced Database Tables are Postgres tables automatically synced from a source table inside Unity Catalog.
 * They can be used to serve realtime queries without the operational overhead of managing ETL pipelines.
 *
 * Synced Database Tables can be configured inside either Database Catalogs or Standard Catalogs. Multiple
 * Synced Database Tables can be bin packed inside a single pipeline to optimize costs.
 *
 * ## Example Usage
 *
 * ### Creating a Synced Database Table inside a Database Catalog
 *
 * This example creates a Synced Database Table inside a Database Catalog.
 *
 * ### Creating a Synced Database Table inside a Standard Catalog
 *
 * This example creates a Synced Database Table inside a Standard Catalog.
 *
 * ### Creating multiple Synced Database Tables and bin packing them into a single pipeline
 *
 * This example creates two Synced Database Tables. The first one specifies a new pipeline spec,
 * which generates a new pipeline. The second one utilizes the pipeline ID of the first table.
 *
 * ## Import
 *
 * As of Pulumi v1.5, resources can be imported through configuration.
 *
 * hcl
 *
 * import {
 *
 *   id = "name"
 *
 *   to = databricks_database_synced_database_table.this
 *
 * }
 *
 * If you are using an older version of Pulumi, import the resource using the `pulumi import` command as follows:
 *
 * ```sh
 * $ pulumi import databricks:index/databaseSyncedDatabaseTable:DatabaseSyncedDatabaseTable databricks_database_synced_database_table "name"
 * ```
 */
export class DatabaseSyncedDatabaseTable extends pulumi.CustomResource {
    /**
     * Get an existing DatabaseSyncedDatabaseTable resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DatabaseSyncedDatabaseTableState, opts?: pulumi.CustomResourceOptions): DatabaseSyncedDatabaseTable {
        return new DatabaseSyncedDatabaseTable(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'databricks:index/databaseSyncedDatabaseTable:DatabaseSyncedDatabaseTable';

    /**
     * Returns true if the given object is an instance of DatabaseSyncedDatabaseTable.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DatabaseSyncedDatabaseTable {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DatabaseSyncedDatabaseTable.__pulumiType;
    }

    /**
     * (SyncedTableStatus) - Synced Table data synchronization status
     */
    declare public /*out*/ readonly dataSynchronizationStatus: pulumi.Output<outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatus>;
    /**
     * Name of the target database instance. This is required when creating synced database tables in standard catalogs.
     * This is optional when creating synced database tables in registered catalogs. If this field is specified
     * when creating synced database tables in registered catalogs, the database instance name MUST
     * match that of the registered catalog (or the request will be rejected)
     */
    declare public readonly databaseInstanceName: pulumi.Output<string>;
    /**
     * (string) - The name of the database instance that this table is registered to. This field is always returned, and for
     * tables inside database catalogs is inferred database instance associated with the catalog
     */
    declare public /*out*/ readonly effectiveDatabaseInstanceName: pulumi.Output<string>;
    /**
     * (string) - The name of the logical database that this table is registered to
     */
    declare public /*out*/ readonly effectiveLogicalDatabaseName: pulumi.Output<string>;
    /**
     * Target Postgres database object (logical database) name for this table.
     *
     * When creating a synced table in a registered Postgres catalog, the
     * target Postgres database name is inferred to be that of the registered catalog.
     * If this field is specified in this scenario, the Postgres database name MUST
     * match that of the registered catalog (or the request will be rejected).
     *
     * When creating a synced table in a standard catalog, this field is required.
     * In this scenario, specifying this field will allow targeting an arbitrary postgres database.
     * Note that this has implications for the `createDatabaseObjectsIsMissing` field in `spec`
     */
    declare public readonly logicalDatabaseName: pulumi.Output<string>;
    /**
     * Full three-part (catalog, schema, table) name of the table
     */
    declare public readonly name: pulumi.Output<string>;
    declare public readonly spec: pulumi.Output<outputs.DatabaseSyncedDatabaseTableSpec | undefined>;
    /**
     * (string) - The provisioning state of the synced table entity in Unity Catalog. This is distinct from the
     * state of the data synchronization pipeline (i.e. the table may be in "ACTIVE" but the pipeline
     * may be in "PROVISIONING" as it runs asynchronously). Possible values are: `ACTIVE`, `DEGRADED`, `DELETING`, `FAILED`, `PROVISIONING`, `UPDATING`
     */
    declare public /*out*/ readonly unityCatalogProvisioningState: pulumi.Output<string>;
    /**
     * Workspace ID of the resource
     */
    declare public readonly workspaceId: pulumi.Output<string | undefined>;

    /**
     * Create a DatabaseSyncedDatabaseTable resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: DatabaseSyncedDatabaseTableArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DatabaseSyncedDatabaseTableArgs | DatabaseSyncedDatabaseTableState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DatabaseSyncedDatabaseTableState | undefined;
            resourceInputs["dataSynchronizationStatus"] = state?.dataSynchronizationStatus;
            resourceInputs["databaseInstanceName"] = state?.databaseInstanceName;
            resourceInputs["effectiveDatabaseInstanceName"] = state?.effectiveDatabaseInstanceName;
            resourceInputs["effectiveLogicalDatabaseName"] = state?.effectiveLogicalDatabaseName;
            resourceInputs["logicalDatabaseName"] = state?.logicalDatabaseName;
            resourceInputs["name"] = state?.name;
            resourceInputs["spec"] = state?.spec;
            resourceInputs["unityCatalogProvisioningState"] = state?.unityCatalogProvisioningState;
            resourceInputs["workspaceId"] = state?.workspaceId;
        } else {
            const args = argsOrState as DatabaseSyncedDatabaseTableArgs | undefined;
            resourceInputs["databaseInstanceName"] = args?.databaseInstanceName;
            resourceInputs["logicalDatabaseName"] = args?.logicalDatabaseName;
            resourceInputs["name"] = args?.name;
            resourceInputs["spec"] = args?.spec;
            resourceInputs["workspaceId"] = args?.workspaceId;
            resourceInputs["dataSynchronizationStatus"] = undefined /*out*/;
            resourceInputs["effectiveDatabaseInstanceName"] = undefined /*out*/;
            resourceInputs["effectiveLogicalDatabaseName"] = undefined /*out*/;
            resourceInputs["unityCatalogProvisioningState"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DatabaseSyncedDatabaseTable.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DatabaseSyncedDatabaseTable resources.
 */
export interface DatabaseSyncedDatabaseTableState {
    /**
     * (SyncedTableStatus) - Synced Table data synchronization status
     */
    dataSynchronizationStatus?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableDataSynchronizationStatus>;
    /**
     * Name of the target database instance. This is required when creating synced database tables in standard catalogs.
     * This is optional when creating synced database tables in registered catalogs. If this field is specified
     * when creating synced database tables in registered catalogs, the database instance name MUST
     * match that of the registered catalog (or the request will be rejected)
     */
    databaseInstanceName?: pulumi.Input<string>;
    /**
     * (string) - The name of the database instance that this table is registered to. This field is always returned, and for
     * tables inside database catalogs is inferred database instance associated with the catalog
     */
    effectiveDatabaseInstanceName?: pulumi.Input<string>;
    /**
     * (string) - The name of the logical database that this table is registered to
     */
    effectiveLogicalDatabaseName?: pulumi.Input<string>;
    /**
     * Target Postgres database object (logical database) name for this table.
     *
     * When creating a synced table in a registered Postgres catalog, the
     * target Postgres database name is inferred to be that of the registered catalog.
     * If this field is specified in this scenario, the Postgres database name MUST
     * match that of the registered catalog (or the request will be rejected).
     *
     * When creating a synced table in a standard catalog, this field is required.
     * In this scenario, specifying this field will allow targeting an arbitrary postgres database.
     * Note that this has implications for the `createDatabaseObjectsIsMissing` field in `spec`
     */
    logicalDatabaseName?: pulumi.Input<string>;
    /**
     * Full three-part (catalog, schema, table) name of the table
     */
    name?: pulumi.Input<string>;
    spec?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableSpec>;
    /**
     * (string) - The provisioning state of the synced table entity in Unity Catalog. This is distinct from the
     * state of the data synchronization pipeline (i.e. the table may be in "ACTIVE" but the pipeline
     * may be in "PROVISIONING" as it runs asynchronously). Possible values are: `ACTIVE`, `DEGRADED`, `DELETING`, `FAILED`, `PROVISIONING`, `UPDATING`
     */
    unityCatalogProvisioningState?: pulumi.Input<string>;
    /**
     * Workspace ID of the resource
     */
    workspaceId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DatabaseSyncedDatabaseTable resource.
 */
export interface DatabaseSyncedDatabaseTableArgs {
    /**
     * Name of the target database instance. This is required when creating synced database tables in standard catalogs.
     * This is optional when creating synced database tables in registered catalogs. If this field is specified
     * when creating synced database tables in registered catalogs, the database instance name MUST
     * match that of the registered catalog (or the request will be rejected)
     */
    databaseInstanceName?: pulumi.Input<string>;
    /**
     * Target Postgres database object (logical database) name for this table.
     *
     * When creating a synced table in a registered Postgres catalog, the
     * target Postgres database name is inferred to be that of the registered catalog.
     * If this field is specified in this scenario, the Postgres database name MUST
     * match that of the registered catalog (or the request will be rejected).
     *
     * When creating a synced table in a standard catalog, this field is required.
     * In this scenario, specifying this field will allow targeting an arbitrary postgres database.
     * Note that this has implications for the `createDatabaseObjectsIsMissing` field in `spec`
     */
    logicalDatabaseName?: pulumi.Input<string>;
    /**
     * Full three-part (catalog, schema, table) name of the table
     */
    name?: pulumi.Input<string>;
    spec?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableSpec>;
    /**
     * Workspace ID of the resource
     */
    workspaceId?: pulumi.Input<string>;
}
