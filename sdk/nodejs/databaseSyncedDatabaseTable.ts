// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * [![Private Preview](https://img.shields.io/badge/Release_Stage-Private_Preview-blueviolet)](https://docs.databricks.com/aws/en/release-notes/release-types)
 *
 * Lakebase Synced Database Tables are Postgres tables automatically synced from a source table inside Unity Catalog.
 * They can be used to serve realtime queries without the operational overhead of managing ETL pipelines.
 *
 * Synced Database Tables can be configured inside either Database Catalogs or Standard Catalogs. Multiple
 * Synced Database Tables can be bin packed inside a single pipeline to optimize costs.
 *
 * ## Example Usage
 *
 * ### Creating a Synced Database Table inside a Database Catalog
 *
 * This example creates a Synced Database Table inside a Database Catalog.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const _this = new databricks.DatabaseSyncedDatabaseTable("this", {
 *     name: "my_database_catalog.public.synced_table",
 *     logicalDatabaseName: "databricks_postgres",
 *     spec: {
 *         schedulingPolicy: "SNAPSHOT",
 *         sourceTableFullName: "source_delta.tpch.customer",
 *         primaryKeyColumns: ["c_custkey"],
 *         createDatabaseObjectsIfMissing: true,
 *         newPipelineSpec: {
 *             storageCatalog: "source_delta",
 *             storageSchema: "tpch",
 *         },
 *     },
 * });
 * ```
 *
 * ### Creating a Synced Database Table inside a Standard Catalog
 *
 * This example creates a Synced Database Table inside a Standard Catalog.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const _this = new databricks.DatabaseSyncedDatabaseTable("this", {
 *     name: "my_standard_catalog.public.synced_table",
 *     logicalDatabaseName: "databricks_postgres",
 *     databaseInstanceName: "my-database-instance",
 *     spec: {
 *         schedulingPolicy: "SNAPSHOT",
 *         sourceTableFullName: "source_delta.tpch.customer",
 *         primaryKeyColumns: ["c_custkey"],
 *         createDatabaseObjectsIfMissing: true,
 *         newPipelineSpec: {
 *             storageCatalog: "source_delta",
 *             storageSchema: "tpch",
 *         },
 *     },
 * });
 * ```
 *
 * ### Creating multiple Synced Database Tables and bin packing them into a single pipeline
 *
 * This example creates two Synced Database Tables. The first one specifies a new pipeline spec,
 * which generates a new pipeline. The second one utilizes the pipeline ID of the first table.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const instance = new databricks.DatabaseInstance("instance", {
 *     name: "my-database-instance",
 *     capacity: "CU_1",
 * });
 * const syncedTable1 = new databricks.DatabaseSyncedDatabaseTable("synced_table_1", {
 *     name: "my_standard_catalog.public.synced_table1",
 *     logicalDatabaseName: "databricks_postgres",
 *     databaseInstanceName: instance.name,
 *     spec: {
 *         schedulingPolicy: "SNAPSHOT",
 *         sourceTableFullName: "source_delta.tpch.customer",
 *         primaryKeyColumns: ["c_custkey"],
 *         createDatabaseObjectsIfMissing: true,
 *         newPipelineSpec: {
 *             storageCatalog: "source_delta",
 *             storageSchema: "tpch",
 *         },
 *     },
 * });
 * const syncedTable2 = new databricks.DatabaseSyncedDatabaseTable("synced_table_2", {
 *     name: "my_standard_catalog.public.synced_table2",
 *     logicalDatabaseName: "databricks_postgres",
 *     databaseInstanceName: instance.name,
 *     spec: {
 *         schedulingPolicy: "SNAPSHOT",
 *         sourceTableFullName: "source_delta.tpch.customer",
 *         primaryKeyColumns: ["c_custkey"],
 *         createDatabaseObjectsIfMissing: true,
 *         existingPipelineId: syncedTable1.dataSynchronizationStatus.apply(dataSynchronizationStatus => dataSynchronizationStatus.pipelineId),
 *     },
 * });
 * ```
 *
 * ### Creating a Synced Database Table with a custom Jobs schedule
 *
 * This example creates a Synced Database Table and customizes the pipeline schedule. It assumes you already have
 *
 * - A database instance named `"my-database-instance"`
 * - A standard catalog named `"myStandardCatalog"`
 * - A schema in the standard catalog named `"default"`
 * - A source delta table named `"source_delta.schema.customer"` with the primary key `"cCustkey"`
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const syncedTable = new databricks.DatabaseSyncedDatabaseTable("synced_table", {
 *     name: "my_standard_catalog.default.my_synced_table",
 *     logicalDatabaseName: "terraform_test_db",
 *     databaseInstanceName: "my-database-instance",
 *     spec: {
 *         schedulingPolicy: "SNAPSHOT",
 *         sourceTableFullName: "source_delta.schema.customer",
 *         primaryKeyColumns: ["c_custkey"],
 *         createDatabaseObjectsIfMissing: true,
 *         newPipelineSpec: {
 *             storageCatalog: "source_delta",
 *             storageSchema: "schema",
 *         },
 *     },
 * });
 * const syncPipelineScheduleJob = new databricks.Job("sync_pipeline_schedule_job", {
 *     name: "Synced Pipeline Refresh",
 *     description: "Job to schedule synced database table pipeline. ",
 *     tasks: [{
 *         taskKey: "synced-table-pipeline",
 *         pipelineTask: {
 *             pipelineId: syncedTable.dataSynchronizationStatus.apply(dataSynchronizationStatus => dataSynchronizationStatus.pipelineId),
 *         },
 *     }],
 *     schedule: {
 *         quartzCronExpression: "0 0 0 * * ?",
 *         timezoneId: "Europe/Helsinki",
 *     },
 * });
 * ```
 */
export class DatabaseSyncedDatabaseTable extends pulumi.CustomResource {
    /**
     * Get an existing DatabaseSyncedDatabaseTable resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DatabaseSyncedDatabaseTableState, opts?: pulumi.CustomResourceOptions): DatabaseSyncedDatabaseTable {
        return new DatabaseSyncedDatabaseTable(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'databricks:index/databaseSyncedDatabaseTable:DatabaseSyncedDatabaseTable';

    /**
     * Returns true if the given object is an instance of DatabaseSyncedDatabaseTable.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DatabaseSyncedDatabaseTable {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DatabaseSyncedDatabaseTable.__pulumiType;
    }

    /**
     * (SyncedTableStatus) - Synced Table data synchronization status
     */
    declare public /*out*/ readonly dataSynchronizationStatus: pulumi.Output<outputs.DatabaseSyncedDatabaseTableDataSynchronizationStatus>;
    /**
     * Name of the target database instance. This is required when creating synced database tables in standard catalogs.
     * This is optional when creating synced database tables in registered catalogs. If this field is specified
     * when creating synced database tables in registered catalogs, the database instance name MUST
     * match that of the registered catalog (or the request will be rejected)
     */
    declare public readonly databaseInstanceName: pulumi.Output<string>;
    /**
     * (string) - The name of the database instance that this table is registered to. This field is always returned, and for
     * tables inside database catalogs is inferred database instance associated with the catalog.
     * This is an output only field that contains the value computed from the input field combined with
     * server side defaults. Use the field without the effective_ prefix to set the value
     */
    declare public /*out*/ readonly effectiveDatabaseInstanceName: pulumi.Output<string>;
    /**
     * (string) - The name of the logical database that this table is registered to.
     * This is an output only field that contains the value computed from the input field combined with
     * server side defaults. Use the field without the effective_ prefix to set the value
     */
    declare public /*out*/ readonly effectiveLogicalDatabaseName: pulumi.Output<string>;
    /**
     * Target Postgres database object (logical database) name for this table.
     *
     * When creating a synced table in a registered Postgres catalog, the
     * target Postgres database name is inferred to be that of the registered catalog.
     * If this field is specified in this scenario, the Postgres database name MUST
     * match that of the registered catalog (or the request will be rejected).
     *
     * When creating a synced table in a standard catalog, this field is required.
     * In this scenario, specifying this field will allow targeting an arbitrary postgres database.
     * Note that this has implications for the `createDatabaseObjectsIsMissing` field in `spec`
     */
    declare public readonly logicalDatabaseName: pulumi.Output<string>;
    /**
     * Full three-part (catalog, schema, table) name of the table
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Configure the provider for management through account provider.
     */
    declare public readonly providerConfig: pulumi.Output<outputs.DatabaseSyncedDatabaseTableProviderConfig | undefined>;
    declare public readonly spec: pulumi.Output<outputs.DatabaseSyncedDatabaseTableSpec | undefined>;
    /**
     * (string) - The provisioning state of the synced table entity in Unity Catalog. This is distinct from the
     * state of the data synchronization pipeline (i.e. the table may be in "ACTIVE" but the pipeline
     * may be in "PROVISIONING" as it runs asynchronously). Possible values are: `ACTIVE`, `DEGRADED`, `DELETING`, `FAILED`, `PROVISIONING`, `UPDATING`
     */
    declare public /*out*/ readonly unityCatalogProvisioningState: pulumi.Output<string>;

    /**
     * Create a DatabaseSyncedDatabaseTable resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: DatabaseSyncedDatabaseTableArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DatabaseSyncedDatabaseTableArgs | DatabaseSyncedDatabaseTableState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DatabaseSyncedDatabaseTableState | undefined;
            resourceInputs["dataSynchronizationStatus"] = state?.dataSynchronizationStatus;
            resourceInputs["databaseInstanceName"] = state?.databaseInstanceName;
            resourceInputs["effectiveDatabaseInstanceName"] = state?.effectiveDatabaseInstanceName;
            resourceInputs["effectiveLogicalDatabaseName"] = state?.effectiveLogicalDatabaseName;
            resourceInputs["logicalDatabaseName"] = state?.logicalDatabaseName;
            resourceInputs["name"] = state?.name;
            resourceInputs["providerConfig"] = state?.providerConfig;
            resourceInputs["spec"] = state?.spec;
            resourceInputs["unityCatalogProvisioningState"] = state?.unityCatalogProvisioningState;
        } else {
            const args = argsOrState as DatabaseSyncedDatabaseTableArgs | undefined;
            resourceInputs["databaseInstanceName"] = args?.databaseInstanceName;
            resourceInputs["logicalDatabaseName"] = args?.logicalDatabaseName;
            resourceInputs["name"] = args?.name;
            resourceInputs["providerConfig"] = args?.providerConfig;
            resourceInputs["spec"] = args?.spec;
            resourceInputs["dataSynchronizationStatus"] = undefined /*out*/;
            resourceInputs["effectiveDatabaseInstanceName"] = undefined /*out*/;
            resourceInputs["effectiveLogicalDatabaseName"] = undefined /*out*/;
            resourceInputs["unityCatalogProvisioningState"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DatabaseSyncedDatabaseTable.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DatabaseSyncedDatabaseTable resources.
 */
export interface DatabaseSyncedDatabaseTableState {
    /**
     * (SyncedTableStatus) - Synced Table data synchronization status
     */
    dataSynchronizationStatus?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableDataSynchronizationStatus>;
    /**
     * Name of the target database instance. This is required when creating synced database tables in standard catalogs.
     * This is optional when creating synced database tables in registered catalogs. If this field is specified
     * when creating synced database tables in registered catalogs, the database instance name MUST
     * match that of the registered catalog (or the request will be rejected)
     */
    databaseInstanceName?: pulumi.Input<string>;
    /**
     * (string) - The name of the database instance that this table is registered to. This field is always returned, and for
     * tables inside database catalogs is inferred database instance associated with the catalog.
     * This is an output only field that contains the value computed from the input field combined with
     * server side defaults. Use the field without the effective_ prefix to set the value
     */
    effectiveDatabaseInstanceName?: pulumi.Input<string>;
    /**
     * (string) - The name of the logical database that this table is registered to.
     * This is an output only field that contains the value computed from the input field combined with
     * server side defaults. Use the field without the effective_ prefix to set the value
     */
    effectiveLogicalDatabaseName?: pulumi.Input<string>;
    /**
     * Target Postgres database object (logical database) name for this table.
     *
     * When creating a synced table in a registered Postgres catalog, the
     * target Postgres database name is inferred to be that of the registered catalog.
     * If this field is specified in this scenario, the Postgres database name MUST
     * match that of the registered catalog (or the request will be rejected).
     *
     * When creating a synced table in a standard catalog, this field is required.
     * In this scenario, specifying this field will allow targeting an arbitrary postgres database.
     * Note that this has implications for the `createDatabaseObjectsIsMissing` field in `spec`
     */
    logicalDatabaseName?: pulumi.Input<string>;
    /**
     * Full three-part (catalog, schema, table) name of the table
     */
    name?: pulumi.Input<string>;
    /**
     * Configure the provider for management through account provider.
     */
    providerConfig?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableProviderConfig>;
    spec?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableSpec>;
    /**
     * (string) - The provisioning state of the synced table entity in Unity Catalog. This is distinct from the
     * state of the data synchronization pipeline (i.e. the table may be in "ACTIVE" but the pipeline
     * may be in "PROVISIONING" as it runs asynchronously). Possible values are: `ACTIVE`, `DEGRADED`, `DELETING`, `FAILED`, `PROVISIONING`, `UPDATING`
     */
    unityCatalogProvisioningState?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DatabaseSyncedDatabaseTable resource.
 */
export interface DatabaseSyncedDatabaseTableArgs {
    /**
     * Name of the target database instance. This is required when creating synced database tables in standard catalogs.
     * This is optional when creating synced database tables in registered catalogs. If this field is specified
     * when creating synced database tables in registered catalogs, the database instance name MUST
     * match that of the registered catalog (or the request will be rejected)
     */
    databaseInstanceName?: pulumi.Input<string>;
    /**
     * Target Postgres database object (logical database) name for this table.
     *
     * When creating a synced table in a registered Postgres catalog, the
     * target Postgres database name is inferred to be that of the registered catalog.
     * If this field is specified in this scenario, the Postgres database name MUST
     * match that of the registered catalog (or the request will be rejected).
     *
     * When creating a synced table in a standard catalog, this field is required.
     * In this scenario, specifying this field will allow targeting an arbitrary postgres database.
     * Note that this has implications for the `createDatabaseObjectsIsMissing` field in `spec`
     */
    logicalDatabaseName?: pulumi.Input<string>;
    /**
     * Full three-part (catalog, schema, table) name of the table
     */
    name?: pulumi.Input<string>;
    /**
     * Configure the provider for management through account provider.
     */
    providerConfig?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableProviderConfig>;
    spec?: pulumi.Input<inputs.DatabaseSyncedDatabaseTableSpec>;
}
