// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * Volumes are a new Unity Catalog (UC) capability for accessing, storing, governing, and organizing files. Volumes unlock new processing capabilities for data governed by the Unity Catalog, including support for most machine learning and data science workloads. You can use volumes to store and access files in any format; data can be structured, semi-structured, or unstructured.
 *
 * Volumes are organized under a 3-level namespace: `<catalog>.<schema>.<volume>`.
 *
 * This resource manages Volumes in Unity Catalog.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const sandbox = new databricks.Catalog("sandbox", {
 *     metastoreId: databricks_metastore["this"].id,
 *     comment: "this catalog is managed by terraform",
 *     properties: {
 *         purpose: "testing",
 *     },
 * });
 * const things = new databricks.Schema("things", {
 *     catalogName: sandbox.name,
 *     comment: "this schema is managed by terraform",
 *     properties: {
 *         kind: "various",
 *     },
 * });
 * const external = new databricks.StorageCredential("external", {awsIamRole: {
 *     roleArn: aws_iam_role.external_data_access.arn,
 * }});
 * const some = new databricks.ExternalLocation("some", {
 *     url: `s3://${aws_s3_bucket.external.id}/some`,
 *     credentialName: external.name,
 * });
 * const _this = new databricks.Volume("this", {
 *     catalogName: sandbox.name,
 *     schemaName: things.name,
 *     volumeType: "EXTERNAL",
 *     storageLocation: some.url,
 *     comment: "this volume is managed by terraform",
 * });
 * ```
 *
 * ## Import
 *
 * This resource can be imported by `full_name` which is the 3-level Volume identifier`<catalog>.<schema>.<volume>` bash
 *
 * ```sh
 *  $ pulumi import databricks:index/volume:Volume this <catalog_name>.<schema_name>.<name>
 * ```
 */
export class Volume extends pulumi.CustomResource {
    /**
     * Get an existing Volume resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: VolumeState, opts?: pulumi.CustomResourceOptions): Volume {
        return new Volume(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'databricks:index/volume:Volume';

    /**
     * Returns true if the given object is an instance of Volume.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Volume {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Volume.__pulumiType;
    }

    /**
     * Name of parent Catalog
     */
    public readonly catalogName!: pulumi.Output<string>;
    /**
     * Free-form text.
     */
    public readonly comment!: pulumi.Output<string | undefined>;
    /**
     * Name of the Volume
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Name of the volume owner.
     */
    public readonly owner!: pulumi.Output<string>;
    /**
     * Name of parent Schema relative to parent Catalog
     */
    public readonly schemaName!: pulumi.Output<string>;
    /**
     * Path inside an External Location. Only used for `EXTERNAL` Volumes.
     */
    public readonly storageLocation!: pulumi.Output<string | undefined>;
    /**
     * Volume type. `EXTERNAL` or `MANAGED`.
     */
    public readonly volumeType!: pulumi.Output<string>;

    /**
     * Create a Volume resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: VolumeArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: VolumeArgs | VolumeState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as VolumeState | undefined;
            resourceInputs["catalogName"] = state ? state.catalogName : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["owner"] = state ? state.owner : undefined;
            resourceInputs["schemaName"] = state ? state.schemaName : undefined;
            resourceInputs["storageLocation"] = state ? state.storageLocation : undefined;
            resourceInputs["volumeType"] = state ? state.volumeType : undefined;
        } else {
            const args = argsOrState as VolumeArgs | undefined;
            if ((!args || args.catalogName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'catalogName'");
            }
            if ((!args || args.schemaName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'schemaName'");
            }
            if ((!args || args.volumeType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'volumeType'");
            }
            resourceInputs["catalogName"] = args ? args.catalogName : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["owner"] = args ? args.owner : undefined;
            resourceInputs["schemaName"] = args ? args.schemaName : undefined;
            resourceInputs["storageLocation"] = args ? args.storageLocation : undefined;
            resourceInputs["volumeType"] = args ? args.volumeType : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Volume.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Volume resources.
 */
export interface VolumeState {
    /**
     * Name of parent Catalog
     */
    catalogName?: pulumi.Input<string>;
    /**
     * Free-form text.
     */
    comment?: pulumi.Input<string>;
    /**
     * Name of the Volume
     */
    name?: pulumi.Input<string>;
    /**
     * Name of the volume owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * Name of parent Schema relative to parent Catalog
     */
    schemaName?: pulumi.Input<string>;
    /**
     * Path inside an External Location. Only used for `EXTERNAL` Volumes.
     */
    storageLocation?: pulumi.Input<string>;
    /**
     * Volume type. `EXTERNAL` or `MANAGED`.
     */
    volumeType?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Volume resource.
 */
export interface VolumeArgs {
    /**
     * Name of parent Catalog
     */
    catalogName: pulumi.Input<string>;
    /**
     * Free-form text.
     */
    comment?: pulumi.Input<string>;
    /**
     * Name of the Volume
     */
    name?: pulumi.Input<string>;
    /**
     * Name of the volume owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * Name of parent Schema relative to parent Catalog
     */
    schemaName: pulumi.Input<string>;
    /**
     * Path inside an External Location. Only used for `EXTERNAL` Volumes.
     */
    storageLocation?: pulumi.Input<string>;
    /**
     * Volume type. `EXTERNAL` or `MANAGED`.
     */
    volumeType: pulumi.Input<string>;
}
