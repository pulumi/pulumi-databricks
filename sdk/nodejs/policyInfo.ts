// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Import
 *
 * As of Pulumi v1.5, resources can be imported through configuration.
 *
 * hcl
 *
 * import {
 *
 *   id = "on_securable_type,on_securable_fullname,name"
 *
 *   to = databricks_policy_info.this
 *
 * }
 *
 * If you are using an older version of Pulumi, import the resource using the `pulumi import` command as follows:
 *
 * ```sh
 * $ pulumi import databricks:index/policyInfo:PolicyInfo databricks_policy_info "on_securable_type,on_securable_fullname,name"
 * ```
 */
export class PolicyInfo extends pulumi.CustomResource {
    /**
     * Get an existing PolicyInfo resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: PolicyInfoState, opts?: pulumi.CustomResourceOptions): PolicyInfo {
        return new PolicyInfo(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'databricks:index/policyInfo:PolicyInfo';

    /**
     * Returns true if the given object is an instance of PolicyInfo.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is PolicyInfo {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === PolicyInfo.__pulumiType;
    }

    /**
     * Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
     * Required on create and optional on update. When specified on update,
     * the new options will replace the existing options as a whole
     */
    declare public readonly columnMask: pulumi.Output<outputs.PolicyInfoColumnMask | undefined>;
    /**
     * Optional description of the policy
     */
    declare public readonly comment: pulumi.Output<string | undefined>;
    /**
     * (integer) - Time at which the policy was created, in epoch milliseconds. Output only
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<number>;
    /**
     * (string) - Username of the user who created the policy. Output only
     */
    declare public /*out*/ readonly createdBy: pulumi.Output<string>;
    /**
     * Optional list of user or group names that should be excluded from the policy
     */
    declare public readonly exceptPrincipals: pulumi.Output<string[] | undefined>;
    /**
     * Type of securables that the policy should take effect on.
     * Only `TABLE` is supported at this moment.
     * Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
     */
    declare public readonly forSecurableType: pulumi.Output<string>;
    /**
     * Optional list of condition expressions used to match table columns.
     * Only valid when `forSecurableType` is `TABLE`.
     * When specified, the policy only applies to tables whose columns satisfy all match conditions
     */
    declare public readonly matchColumns: pulumi.Output<outputs.PolicyInfoMatchColumn[] | undefined>;
    /**
     * Name of the policy. Required on create and optional on update.
     * To rename the policy, set `name` to a different value on update
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Full name of the securable on which the policy is defined.
     * Required on create and ignored on update
     */
    declare public readonly onSecurableFullname: pulumi.Output<string | undefined>;
    /**
     * Type of the securable on which the policy is defined.
     * Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
     * Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
     */
    declare public readonly onSecurableType: pulumi.Output<string | undefined>;
    /**
     * Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
     */
    declare public readonly policyType: pulumi.Output<string>;
    /**
     * Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
     * Required on create and optional on update. When specified on update,
     * the new options will replace the existing options as a whole
     */
    declare public readonly rowFilter: pulumi.Output<outputs.PolicyInfoRowFilter | undefined>;
    /**
     * List of user or group names that the policy applies to.
     * Required on create and optional on update
     */
    declare public readonly toPrincipals: pulumi.Output<string[]>;
    /**
     * (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
     */
    declare public /*out*/ readonly updatedAt: pulumi.Output<number>;
    /**
     * (string) - Username of the user who last modified the policy. Output only
     */
    declare public /*out*/ readonly updatedBy: pulumi.Output<string>;
    /**
     * Optional condition when the policy should take effect
     */
    declare public readonly whenCondition: pulumi.Output<string | undefined>;
    /**
     * Workspace ID of the resource
     */
    declare public readonly workspaceId: pulumi.Output<string | undefined>;

    /**
     * Create a PolicyInfo resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: PolicyInfoArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: PolicyInfoArgs | PolicyInfoState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as PolicyInfoState | undefined;
            resourceInputs["columnMask"] = state?.columnMask;
            resourceInputs["comment"] = state?.comment;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["createdBy"] = state?.createdBy;
            resourceInputs["exceptPrincipals"] = state?.exceptPrincipals;
            resourceInputs["forSecurableType"] = state?.forSecurableType;
            resourceInputs["matchColumns"] = state?.matchColumns;
            resourceInputs["name"] = state?.name;
            resourceInputs["onSecurableFullname"] = state?.onSecurableFullname;
            resourceInputs["onSecurableType"] = state?.onSecurableType;
            resourceInputs["policyType"] = state?.policyType;
            resourceInputs["rowFilter"] = state?.rowFilter;
            resourceInputs["toPrincipals"] = state?.toPrincipals;
            resourceInputs["updatedAt"] = state?.updatedAt;
            resourceInputs["updatedBy"] = state?.updatedBy;
            resourceInputs["whenCondition"] = state?.whenCondition;
            resourceInputs["workspaceId"] = state?.workspaceId;
        } else {
            const args = argsOrState as PolicyInfoArgs | undefined;
            if (args?.forSecurableType === undefined && !opts.urn) {
                throw new Error("Missing required property 'forSecurableType'");
            }
            if (args?.policyType === undefined && !opts.urn) {
                throw new Error("Missing required property 'policyType'");
            }
            if (args?.toPrincipals === undefined && !opts.urn) {
                throw new Error("Missing required property 'toPrincipals'");
            }
            resourceInputs["columnMask"] = args?.columnMask;
            resourceInputs["comment"] = args?.comment;
            resourceInputs["exceptPrincipals"] = args?.exceptPrincipals;
            resourceInputs["forSecurableType"] = args?.forSecurableType;
            resourceInputs["matchColumns"] = args?.matchColumns;
            resourceInputs["name"] = args?.name;
            resourceInputs["onSecurableFullname"] = args?.onSecurableFullname;
            resourceInputs["onSecurableType"] = args?.onSecurableType;
            resourceInputs["policyType"] = args?.policyType;
            resourceInputs["rowFilter"] = args?.rowFilter;
            resourceInputs["toPrincipals"] = args?.toPrincipals;
            resourceInputs["whenCondition"] = args?.whenCondition;
            resourceInputs["workspaceId"] = args?.workspaceId;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["createdBy"] = undefined /*out*/;
            resourceInputs["updatedAt"] = undefined /*out*/;
            resourceInputs["updatedBy"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(PolicyInfo.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering PolicyInfo resources.
 */
export interface PolicyInfoState {
    /**
     * Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
     * Required on create and optional on update. When specified on update,
     * the new options will replace the existing options as a whole
     */
    columnMask?: pulumi.Input<inputs.PolicyInfoColumnMask>;
    /**
     * Optional description of the policy
     */
    comment?: pulumi.Input<string>;
    /**
     * (integer) - Time at which the policy was created, in epoch milliseconds. Output only
     */
    createdAt?: pulumi.Input<number>;
    /**
     * (string) - Username of the user who created the policy. Output only
     */
    createdBy?: pulumi.Input<string>;
    /**
     * Optional list of user or group names that should be excluded from the policy
     */
    exceptPrincipals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Type of securables that the policy should take effect on.
     * Only `TABLE` is supported at this moment.
     * Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
     */
    forSecurableType?: pulumi.Input<string>;
    /**
     * Optional list of condition expressions used to match table columns.
     * Only valid when `forSecurableType` is `TABLE`.
     * When specified, the policy only applies to tables whose columns satisfy all match conditions
     */
    matchColumns?: pulumi.Input<pulumi.Input<inputs.PolicyInfoMatchColumn>[]>;
    /**
     * Name of the policy. Required on create and optional on update.
     * To rename the policy, set `name` to a different value on update
     */
    name?: pulumi.Input<string>;
    /**
     * Full name of the securable on which the policy is defined.
     * Required on create and ignored on update
     */
    onSecurableFullname?: pulumi.Input<string>;
    /**
     * Type of the securable on which the policy is defined.
     * Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
     * Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
     */
    onSecurableType?: pulumi.Input<string>;
    /**
     * Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
     */
    policyType?: pulumi.Input<string>;
    /**
     * Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
     * Required on create and optional on update. When specified on update,
     * the new options will replace the existing options as a whole
     */
    rowFilter?: pulumi.Input<inputs.PolicyInfoRowFilter>;
    /**
     * List of user or group names that the policy applies to.
     * Required on create and optional on update
     */
    toPrincipals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * (integer) - Time at which the policy was last modified, in epoch milliseconds. Output only
     */
    updatedAt?: pulumi.Input<number>;
    /**
     * (string) - Username of the user who last modified the policy. Output only
     */
    updatedBy?: pulumi.Input<string>;
    /**
     * Optional condition when the policy should take effect
     */
    whenCondition?: pulumi.Input<string>;
    /**
     * Workspace ID of the resource
     */
    workspaceId?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a PolicyInfo resource.
 */
export interface PolicyInfoArgs {
    /**
     * Options for column mask policies. Valid only if `policyType` is `POLICY_TYPE_COLUMN_MASK`.
     * Required on create and optional on update. When specified on update,
     * the new options will replace the existing options as a whole
     */
    columnMask?: pulumi.Input<inputs.PolicyInfoColumnMask>;
    /**
     * Optional description of the policy
     */
    comment?: pulumi.Input<string>;
    /**
     * Optional list of user or group names that should be excluded from the policy
     */
    exceptPrincipals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Type of securables that the policy should take effect on.
     * Only `TABLE` is supported at this moment.
     * Required on create and optional on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
     */
    forSecurableType: pulumi.Input<string>;
    /**
     * Optional list of condition expressions used to match table columns.
     * Only valid when `forSecurableType` is `TABLE`.
     * When specified, the policy only applies to tables whose columns satisfy all match conditions
     */
    matchColumns?: pulumi.Input<pulumi.Input<inputs.PolicyInfoMatchColumn>[]>;
    /**
     * Name of the policy. Required on create and optional on update.
     * To rename the policy, set `name` to a different value on update
     */
    name?: pulumi.Input<string>;
    /**
     * Full name of the securable on which the policy is defined.
     * Required on create and ignored on update
     */
    onSecurableFullname?: pulumi.Input<string>;
    /**
     * Type of the securable on which the policy is defined.
     * Only `CATALOG`, `SCHEMA` and `TABLE` are supported at this moment.
     * Required on create and ignored on update. Possible values are: `CATALOG`, `CLEAN_ROOM`, `CONNECTION`, `CREDENTIAL`, `EXTERNAL_LOCATION`, `EXTERNAL_METADATA`, `FUNCTION`, `METASTORE`, `PIPELINE`, `PROVIDER`, `RECIPIENT`, `SCHEMA`, `SHARE`, `STAGING_TABLE`, `STORAGE_CREDENTIAL`, `TABLE`, `VOLUME`
     */
    onSecurableType?: pulumi.Input<string>;
    /**
     * Type of the policy. Required on create and ignored on update. Possible values are: `POLICY_TYPE_COLUMN_MASK`, `POLICY_TYPE_ROW_FILTER`
     */
    policyType: pulumi.Input<string>;
    /**
     * Options for row filter policies. Valid only if `policyType` is `POLICY_TYPE_ROW_FILTER`.
     * Required on create and optional on update. When specified on update,
     * the new options will replace the existing options as a whole
     */
    rowFilter?: pulumi.Input<inputs.PolicyInfoRowFilter>;
    /**
     * List of user or group names that the policy applies to.
     * Required on create and optional on update
     */
    toPrincipals: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Optional condition when the policy should take effect
     */
    whenCondition?: pulumi.Input<string>;
    /**
     * Workspace ID of the resource
     */
    workspaceId?: pulumi.Input<string>;
}
