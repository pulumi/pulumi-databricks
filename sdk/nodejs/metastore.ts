// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

/**
 * > This resource can be used with an account or workspace-level provider.
 *
 * A metastore is the top-level container of objects in Unity Catalog. It stores data assets (tables and views) and the permissions that govern access to them. Databricks account admins can create metastores and assign them to Databricks workspaces in order to control which workloads use each metastore.
 *
 * Unity Catalog offers a new metastore with built in security and auditing. This is distinct to the metastore used in previous versions of Databricks (based on the Hive Metastore).
 *
 * A Unity Catalog metastore can be created without a root location & credential to maintain strict separation of storage across catalogs or environments.
 *
 * ## Example Usage
 *
 * For AWS
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const _this = new databricks.Metastore("this", {
 *     name: "primary",
 *     storageRoot: `s3://${metastore.id}/metastore`,
 *     owner: "uc admins",
 *     region: "us-east-1",
 *     forceDestroy: true,
 * });
 * const thisMetastoreAssignment = new databricks.MetastoreAssignment("this", {
 *     metastoreId: _this.id,
 *     workspaceId: workspaceId,
 * });
 * ```
 *
 * For Azure
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 * import * as std from "@pulumi/std";
 *
 * const _this = new databricks.Metastore("this", {
 *     name: "primary",
 *     storageRoot: std.format({
 *         input: "abfss://%s@%s.dfs.core.windows.net/",
 *         args: [
 *             unityCatalog.name,
 *             unityCatalogAzurermStorageAccount.name,
 *         ],
 *     }).then(invoke => invoke.result),
 *     owner: "uc admins",
 *     region: "eastus",
 *     forceDestroy: true,
 * });
 * const thisMetastoreAssignment = new databricks.MetastoreAssignment("this", {
 *     metastoreId: _this.id,
 *     workspaceId: workspaceId,
 * });
 * ```
 *
 * For GCP
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as databricks from "@pulumi/databricks";
 *
 * const _this = new databricks.Metastore("this", {
 *     name: "primary",
 *     storageRoot: `gs://${unityMetastore.name}`,
 *     owner: "uc admins",
 *     region: us_east1,
 *     forceDestroy: true,
 * });
 * const thisMetastoreAssignment = new databricks.MetastoreAssignment("this", {
 *     metastoreId: _this.id,
 *     workspaceId: workspaceId,
 * });
 * ```
 *
 * ## Import
 *
 * This resource can be imported by ID:
 *
 * hcl
 *
 * import {
 *
 *   to = databricks_metastore.this
 *
 *   id = "<id>"
 *
 * }
 *
 * Alternatively, when using `terraform` version 1.4 or earlier, import using the `pulumi import` command:
 *
 * bash
 *
 * ```sh
 * $ pulumi import databricks:index/metastore:Metastore this <id>
 * ```
 */
export class Metastore extends pulumi.CustomResource {
    /**
     * Get an existing Metastore resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: MetastoreState, opts?: pulumi.CustomResourceOptions): Metastore {
        return new Metastore(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'databricks:index/metastore:Metastore';

    /**
     * Returns true if the given object is an instance of Metastore.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Metastore {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Metastore.__pulumiType;
    }

    declare public readonly cloud: pulumi.Output<string>;
    declare public readonly createdAt: pulumi.Output<number>;
    declare public readonly createdBy: pulumi.Output<string>;
    declare public readonly defaultDataAccessConfigId: pulumi.Output<string | undefined>;
    /**
     * The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing. Once this is set it cannot be removed and can only be modified to another valid value. To delete this value please taint and recreate the resource.
     */
    declare public readonly deltaSharingOrganizationName: pulumi.Output<string | undefined>;
    /**
     * Required along with `deltaSharingScope`. Used to set expiration duration in seconds on recipient data access tokens. Set to 0 for unlimited duration.
     */
    declare public readonly deltaSharingRecipientTokenLifetimeInSeconds: pulumi.Output<number | undefined>;
    /**
     * Required along with `deltaSharingRecipientTokenLifetimeInSeconds`. Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL.  INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
     */
    declare public readonly deltaSharingScope: pulumi.Output<string | undefined>;
    /**
     * Destroy metastore regardless of its contents.
     */
    declare public readonly forceDestroy: pulumi.Output<boolean | undefined>;
    declare public readonly globalMetastoreId: pulumi.Output<string>;
    declare public readonly metastoreId: pulumi.Output<string>;
    /**
     * Name of metastore.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * Username/groupname/sp applicationId of the metastore owner.
     */
    declare public readonly owner: pulumi.Output<string>;
    /**
     * The region of the metastore
     */
    declare public readonly region: pulumi.Output<string>;
    /**
     * Path on cloud storage account, where managed `databricks.Table` are stored.  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.). Change forces creation of a new resource. If no `storageRoot` is defined for the metastore, each catalog must have a `storageRoot` defined.
     */
    declare public readonly storageRoot: pulumi.Output<string | undefined>;
    declare public readonly storageRootCredentialId: pulumi.Output<string | undefined>;
    declare public readonly updatedAt: pulumi.Output<number>;
    declare public readonly updatedBy: pulumi.Output<string>;

    /**
     * Create a Metastore resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: MetastoreArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: MetastoreArgs | MetastoreState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as MetastoreState | undefined;
            resourceInputs["cloud"] = state?.cloud;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["createdBy"] = state?.createdBy;
            resourceInputs["defaultDataAccessConfigId"] = state?.defaultDataAccessConfigId;
            resourceInputs["deltaSharingOrganizationName"] = state?.deltaSharingOrganizationName;
            resourceInputs["deltaSharingRecipientTokenLifetimeInSeconds"] = state?.deltaSharingRecipientTokenLifetimeInSeconds;
            resourceInputs["deltaSharingScope"] = state?.deltaSharingScope;
            resourceInputs["forceDestroy"] = state?.forceDestroy;
            resourceInputs["globalMetastoreId"] = state?.globalMetastoreId;
            resourceInputs["metastoreId"] = state?.metastoreId;
            resourceInputs["name"] = state?.name;
            resourceInputs["owner"] = state?.owner;
            resourceInputs["region"] = state?.region;
            resourceInputs["storageRoot"] = state?.storageRoot;
            resourceInputs["storageRootCredentialId"] = state?.storageRootCredentialId;
            resourceInputs["updatedAt"] = state?.updatedAt;
            resourceInputs["updatedBy"] = state?.updatedBy;
        } else {
            const args = argsOrState as MetastoreArgs | undefined;
            resourceInputs["cloud"] = args?.cloud;
            resourceInputs["createdAt"] = args?.createdAt;
            resourceInputs["createdBy"] = args?.createdBy;
            resourceInputs["defaultDataAccessConfigId"] = args?.defaultDataAccessConfigId;
            resourceInputs["deltaSharingOrganizationName"] = args?.deltaSharingOrganizationName;
            resourceInputs["deltaSharingRecipientTokenLifetimeInSeconds"] = args?.deltaSharingRecipientTokenLifetimeInSeconds;
            resourceInputs["deltaSharingScope"] = args?.deltaSharingScope;
            resourceInputs["forceDestroy"] = args?.forceDestroy;
            resourceInputs["globalMetastoreId"] = args?.globalMetastoreId;
            resourceInputs["metastoreId"] = args?.metastoreId;
            resourceInputs["name"] = args?.name;
            resourceInputs["owner"] = args?.owner;
            resourceInputs["region"] = args?.region;
            resourceInputs["storageRoot"] = args?.storageRoot;
            resourceInputs["storageRootCredentialId"] = args?.storageRootCredentialId;
            resourceInputs["updatedAt"] = args?.updatedAt;
            resourceInputs["updatedBy"] = args?.updatedBy;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Metastore.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Metastore resources.
 */
export interface MetastoreState {
    cloud?: pulumi.Input<string>;
    createdAt?: pulumi.Input<number>;
    createdBy?: pulumi.Input<string>;
    defaultDataAccessConfigId?: pulumi.Input<string>;
    /**
     * The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing. Once this is set it cannot be removed and can only be modified to another valid value. To delete this value please taint and recreate the resource.
     */
    deltaSharingOrganizationName?: pulumi.Input<string>;
    /**
     * Required along with `deltaSharingScope`. Used to set expiration duration in seconds on recipient data access tokens. Set to 0 for unlimited duration.
     */
    deltaSharingRecipientTokenLifetimeInSeconds?: pulumi.Input<number>;
    /**
     * Required along with `deltaSharingRecipientTokenLifetimeInSeconds`. Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL.  INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
     */
    deltaSharingScope?: pulumi.Input<string>;
    /**
     * Destroy metastore regardless of its contents.
     */
    forceDestroy?: pulumi.Input<boolean>;
    globalMetastoreId?: pulumi.Input<string>;
    metastoreId?: pulumi.Input<string>;
    /**
     * Name of metastore.
     */
    name?: pulumi.Input<string>;
    /**
     * Username/groupname/sp applicationId of the metastore owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * The region of the metastore
     */
    region?: pulumi.Input<string>;
    /**
     * Path on cloud storage account, where managed `databricks.Table` are stored.  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.). Change forces creation of a new resource. If no `storageRoot` is defined for the metastore, each catalog must have a `storageRoot` defined.
     */
    storageRoot?: pulumi.Input<string>;
    storageRootCredentialId?: pulumi.Input<string>;
    updatedAt?: pulumi.Input<number>;
    updatedBy?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Metastore resource.
 */
export interface MetastoreArgs {
    cloud?: pulumi.Input<string>;
    createdAt?: pulumi.Input<number>;
    createdBy?: pulumi.Input<string>;
    defaultDataAccessConfigId?: pulumi.Input<string>;
    /**
     * The organization name of a Delta Sharing entity. This field is used for Databricks to Databricks sharing. Once this is set it cannot be removed and can only be modified to another valid value. To delete this value please taint and recreate the resource.
     */
    deltaSharingOrganizationName?: pulumi.Input<string>;
    /**
     * Required along with `deltaSharingScope`. Used to set expiration duration in seconds on recipient data access tokens. Set to 0 for unlimited duration.
     */
    deltaSharingRecipientTokenLifetimeInSeconds?: pulumi.Input<number>;
    /**
     * Required along with `deltaSharingRecipientTokenLifetimeInSeconds`. Used to enable delta sharing on the metastore. Valid values: INTERNAL, INTERNAL_AND_EXTERNAL.  INTERNAL only allows sharing within the same account, and INTERNAL_AND_EXTERNAL allows cross account sharing and token based sharing.
     */
    deltaSharingScope?: pulumi.Input<string>;
    /**
     * Destroy metastore regardless of its contents.
     */
    forceDestroy?: pulumi.Input<boolean>;
    globalMetastoreId?: pulumi.Input<string>;
    metastoreId?: pulumi.Input<string>;
    /**
     * Name of metastore.
     */
    name?: pulumi.Input<string>;
    /**
     * Username/groupname/sp applicationId of the metastore owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * The region of the metastore
     */
    region?: pulumi.Input<string>;
    /**
     * Path on cloud storage account, where managed `databricks.Table` are stored.  If the URL contains special characters, such as space, `&`, etc., they should be percent-encoded (space > `%20`, etc.). Change forces creation of a new resource. If no `storageRoot` is defined for the metastore, each catalog must have a `storageRoot` defined.
     */
    storageRoot?: pulumi.Input<string>;
    storageRootCredentialId?: pulumi.Input<string>;
    updatedAt?: pulumi.Input<number>;
    updatedBy?: pulumi.Input<string>;
}
