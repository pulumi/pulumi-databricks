// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.databricks;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.databricks.ClusterArgs;
import com.pulumi.databricks.Utilities;
import com.pulumi.databricks.inputs.ClusterState;
import com.pulumi.databricks.outputs.ClusterAutoscale;
import com.pulumi.databricks.outputs.ClusterAwsAttributes;
import com.pulumi.databricks.outputs.ClusterAzureAttributes;
import com.pulumi.databricks.outputs.ClusterCloneFrom;
import com.pulumi.databricks.outputs.ClusterClusterLogConf;
import com.pulumi.databricks.outputs.ClusterClusterMountInfo;
import com.pulumi.databricks.outputs.ClusterDockerImage;
import com.pulumi.databricks.outputs.ClusterGcpAttributes;
import com.pulumi.databricks.outputs.ClusterInitScript;
import com.pulumi.databricks.outputs.ClusterLibrary;
import com.pulumi.databricks.outputs.ClusterWorkloadType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * This resource allows you to manage [Databricks Clusters](https://docs.databricks.com/clusters/index.html).
 * 
 * &gt; **Note** In case of `Cannot access cluster ####-######-####### that was terminated or unpinned more than 30 days ago` command.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.databricks.DatabricksFunctions;
 * import com.pulumi.databricks.inputs.GetNodeTypeArgs;
 * import com.pulumi.databricks.inputs.GetSparkVersionArgs;
 * import com.pulumi.databricks.Cluster;
 * import com.pulumi.databricks.ClusterArgs;
 * import com.pulumi.databricks.inputs.ClusterAutoscaleArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var smallest = DatabricksFunctions.getNodeType(GetNodeTypeArgs.builder()
 *             .localDisk(true)
 *             .build());
 * 
 *         final var latestLts = DatabricksFunctions.getSparkVersion(GetSparkVersionArgs.builder()
 *             .longTermSupport(true)
 *             .build());
 * 
 *         var sharedAutoscaling = new Cluster(&#34;sharedAutoscaling&#34;, ClusterArgs.builder()        
 *             .clusterName(&#34;Shared Autoscaling&#34;)
 *             .sparkVersion(latestLts.applyValue(getSparkVersionResult -&gt; getSparkVersionResult.id()))
 *             .nodeTypeId(smallest.applyValue(getNodeTypeResult -&gt; getNodeTypeResult.id()))
 *             .autoterminationMinutes(20)
 *             .autoscale(ClusterAutoscaleArgs.builder()
 *                 .minWorkers(1)
 *                 .maxWorkers(50)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * ```
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Access Control
 * 
 * * databricks.Group and databricks.User can control which groups or individual users can create clusters.
 * * databricks.ClusterPolicy can control which kinds of clusters users can create.
 * * Users, who have access to Cluster Policy, but do not have an `allow_cluster_create` argument set would still be able to create clusters, but within the boundary of the policy.
 * * databricks.Permissions can control which groups or individual users can *Manage*, *Restart* or *Attach to* individual clusters.
 * * `instance_profile_arn` *(AWS only)* can control which data a given cluster can access through cloud-native controls.
 * 
 * ## Related Resources
 * 
 * The following resources are often used in the same context:
 * 
 * * Dynamic Passthrough Clusters for a Group guide.
 * * End to end workspace management guide.
 * * databricks.getClusters data to retrieve a list of databricks.Cluster ids.
 * * databricks.ClusterPolicy to create a databricks.Cluster policy, which limits the ability to create clusters based on a set of rules.
 * * databricks.getCurrentUser data to retrieve information about databricks.User or databricks_service_principal, that is calling Databricks REST API.
 * * databricks.GlobalInitScript to manage [global init scripts](https://docs.databricks.com/clusters/init-scripts.html#global-init-scripts), which are run on all databricks.Cluster and databricks_job.
 * * databricks.InstancePool to manage [instance pools](https://docs.databricks.com/clusters/instance-pools/index.html) to reduce cluster start and auto-scaling times by maintaining a set of idle, ready-to-use instances.
 * * databricks.InstanceProfile to manage AWS EC2 instance profiles that users can launch databricks.Cluster and access data, like databricks_mount.
 * * databricks.Job to manage [Databricks Jobs](https://docs.databricks.com/jobs.html) to run non-interactive code in a databricks_cluster.
 * * databricks.Library to install a [library](https://docs.databricks.com/libraries/index.html) on databricks_cluster.
 * * databricks.Mount to [mount your cloud storage](https://docs.databricks.com/data/databricks-file-system.html#mount-object-storage-to-dbfs) on `dbfs:/mnt/name`.
 * * databricks.getNodeType data to get the smallest node type for databricks.Cluster that fits search criteria, like amount of RAM or number of cores.
 * * databricks.Pipeline to deploy [Delta Live Tables](https://docs.databricks.com/data-engineering/delta-live-tables/index.html).
 * * databricks.getSparkVersion data to get [Databricks Runtime (DBR)](https://docs.databricks.com/runtime/dbr.html) version that could be used for `spark_version` parameter in databricks.Cluster and other resources.
 * * databricks.getZones data to fetch all available AWS availability zones on your workspace on AWS.
 * 
 * ## Import
 * 
 * The resource cluster can be imported using cluster id.
 * 
 * bash
 * 
 * ```sh
 * $ pulumi import databricks:index/cluster:Cluster this &lt;cluster-id&gt;
 * ```
 * 
 */
@ResourceType(type="databricks:index/cluster:Cluster")
public class Cluster extends com.pulumi.resources.CustomResource {
    /**
     * Whether to use policy default values for missing cluster attributes.
     * 
     */
    @Export(name="applyPolicyDefaultValues", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> applyPolicyDefaultValues;

    /**
     * @return Whether to use policy default values for missing cluster attributes.
     * 
     */
    public Output<Optional<Boolean>> applyPolicyDefaultValues() {
        return Codegen.optional(this.applyPolicyDefaultValues);
    }
    @Export(name="autoscale", refs={ClusterAutoscale.class}, tree="[0]")
    private Output</* @Nullable */ ClusterAutoscale> autoscale;

    public Output<Optional<ClusterAutoscale>> autoscale() {
        return Codegen.optional(this.autoscale);
    }
    /**
     * Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination. Defaults to `60`.  *We highly recommend having this setting present for Interactive/BI clusters.*
     * 
     */
    @Export(name="autoterminationMinutes", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> autoterminationMinutes;

    /**
     * @return Automatically terminate the cluster after being inactive for this time in minutes. If specified, the threshold must be between 10 and 10000 minutes. You can also set this value to 0 to explicitly disable automatic termination. Defaults to `60`.  *We highly recommend having this setting present for Interactive/BI clusters.*
     * 
     */
    public Output<Optional<Integer>> autoterminationMinutes() {
        return Codegen.optional(this.autoterminationMinutes);
    }
    @Export(name="awsAttributes", refs={ClusterAwsAttributes.class}, tree="[0]")
    private Output</* @Nullable */ ClusterAwsAttributes> awsAttributes;

    public Output<Optional<ClusterAwsAttributes>> awsAttributes() {
        return Codegen.optional(this.awsAttributes);
    }
    @Export(name="azureAttributes", refs={ClusterAzureAttributes.class}, tree="[0]")
    private Output</* @Nullable */ ClusterAzureAttributes> azureAttributes;

    public Output<Optional<ClusterAzureAttributes>> azureAttributes() {
        return Codegen.optional(this.azureAttributes);
    }
    @Export(name="cloneFrom", refs={ClusterCloneFrom.class}, tree="[0]")
    private Output</* @Nullable */ ClusterCloneFrom> cloneFrom;

    public Output<Optional<ClusterCloneFrom>> cloneFrom() {
        return Codegen.optional(this.cloneFrom);
    }
    @Export(name="clusterId", refs={String.class}, tree="[0]")
    private Output<String> clusterId;

    public Output<String> clusterId() {
        return this.clusterId;
    }
    @Export(name="clusterLogConf", refs={ClusterClusterLogConf.class}, tree="[0]")
    private Output</* @Nullable */ ClusterClusterLogConf> clusterLogConf;

    public Output<Optional<ClusterClusterLogConf>> clusterLogConf() {
        return Codegen.optional(this.clusterLogConf);
    }
    @Export(name="clusterMountInfos", refs={List.class,ClusterClusterMountInfo.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterClusterMountInfo>> clusterMountInfos;

    public Output<Optional<List<ClusterClusterMountInfo>>> clusterMountInfos() {
        return Codegen.optional(this.clusterMountInfos);
    }
    /**
     * Cluster name, which doesnâ€™t have to be unique. If not specified at creation, the cluster name will be an empty string.
     * 
     */
    @Export(name="clusterName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> clusterName;

    /**
     * @return Cluster name, which doesnâ€™t have to be unique. If not specified at creation, the cluster name will be an empty string.
     * 
     */
    public Output<Optional<String>> clusterName() {
        return Codegen.optional(this.clusterName);
    }
    @Export(name="clusterSource", refs={String.class}, tree="[0]")
    private Output<String> clusterSource;

    public Output<String> clusterSource() {
        return this.clusterSource;
    }
    /**
     * should have tag `ResourceClass` set to value `Serverless`
     * 
     * For example:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.databricks.Cluster;
     * import com.pulumi.databricks.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var clusterWithTableAccessControl = new Cluster(&#34;clusterWithTableAccessControl&#34;, ClusterArgs.builder()        
     *             .clusterName(&#34;Shared High-Concurrency&#34;)
     *             .sparkVersion(latestLts.id())
     *             .nodeTypeId(smallest.id())
     *             .autoterminationMinutes(20)
     *             .sparkConf(Map.ofEntries(
     *                 Map.entry(&#34;spark.databricks.repl.allowedLanguages&#34;, &#34;python,sql&#34;),
     *                 Map.entry(&#34;spark.databricks.cluster.profile&#34;, &#34;serverless&#34;)
     *             ))
     *             .customTags(Map.of(&#34;ResourceClass&#34;, &#34;Serverless&#34;))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    @Export(name="customTags", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,Object>> customTags;

    /**
     * @return should have tag `ResourceClass` set to value `Serverless`
     * 
     * For example:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.databricks.Cluster;
     * import com.pulumi.databricks.ClusterArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         var clusterWithTableAccessControl = new Cluster(&#34;clusterWithTableAccessControl&#34;, ClusterArgs.builder()        
     *             .clusterName(&#34;Shared High-Concurrency&#34;)
     *             .sparkVersion(latestLts.id())
     *             .nodeTypeId(smallest.id())
     *             .autoterminationMinutes(20)
     *             .sparkConf(Map.ofEntries(
     *                 Map.entry(&#34;spark.databricks.repl.allowedLanguages&#34;, &#34;python,sql&#34;),
     *                 Map.entry(&#34;spark.databricks.cluster.profile&#34;, &#34;serverless&#34;)
     *             ))
     *             .customTags(Map.of(&#34;ResourceClass&#34;, &#34;Serverless&#34;))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public Output<Optional<Map<String,Object>>> customTags() {
        return Codegen.optional(this.customTags);
    }
    /**
     * Select the security features of the cluster. [Unity Catalog requires](https://docs.databricks.com/data-governance/unity-catalog/compute.html#create-clusters--sql-warehouses-with-unity-catalog-access) `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. If omitted, no security features are enabled. In the Databricks UI, this has been recently been renamed *Access Mode* and `USER_ISOLATION` has been renamed *Shared*, but use these terms here.
     * 
     */
    @Export(name="dataSecurityMode", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> dataSecurityMode;

    /**
     * @return Select the security features of the cluster. [Unity Catalog requires](https://docs.databricks.com/data-governance/unity-catalog/compute.html#create-clusters--sql-warehouses-with-unity-catalog-access) `SINGLE_USER` or `USER_ISOLATION` mode. `LEGACY_PASSTHROUGH` for passthrough cluster and `LEGACY_TABLE_ACL` for Table ACL cluster. If omitted, no security features are enabled. In the Databricks UI, this has been recently been renamed *Access Mode* and `USER_ISOLATION` has been renamed *Shared*, but use these terms here.
     * 
     */
    public Output<Optional<String>> dataSecurityMode() {
        return Codegen.optional(this.dataSecurityMode);
    }
    /**
     * (map) Tags that are added by Databricks by default, regardless of any `custom_tags` that may have been added. These include: Vendor: Databricks, Creator: &lt;username_of_creator&gt;, ClusterName: &lt;name_of_cluster&gt;, ClusterId: &lt;id_of_cluster&gt;, Name: &lt;Databricks internal use&gt;, and any workspace and pool tags.
     * 
     */
    @Export(name="defaultTags", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output<Map<String,Object>> defaultTags;

    /**
     * @return (map) Tags that are added by Databricks by default, regardless of any `custom_tags` that may have been added. These include: Vendor: Databricks, Creator: &lt;username_of_creator&gt;, ClusterName: &lt;name_of_cluster&gt;, ClusterId: &lt;id_of_cluster&gt;, Name: &lt;Databricks internal use&gt;, and any workspace and pool tags.
     * 
     */
    public Output<Map<String,Object>> defaultTags() {
        return this.defaultTags;
    }
    @Export(name="dockerImage", refs={ClusterDockerImage.class}, tree="[0]")
    private Output</* @Nullable */ ClusterDockerImage> dockerImage;

    public Output<Optional<ClusterDockerImage>> dockerImage() {
        return Codegen.optional(this.dockerImage);
    }
    /**
     * similar to `instance_pool_id`, but for driver node. If omitted, and `instance_pool_id` is specified, then the driver will be allocated from that pool.
     * 
     */
    @Export(name="driverInstancePoolId", refs={String.class}, tree="[0]")
    private Output<String> driverInstancePoolId;

    /**
     * @return similar to `instance_pool_id`, but for driver node. If omitted, and `instance_pool_id` is specified, then the driver will be allocated from that pool.
     * 
     */
    public Output<String> driverInstancePoolId() {
        return this.driverInstancePoolId;
    }
    /**
     * The node type of the Spark driver. This field is optional; if unset, API will set the driver node type to the same value as `node_type_id` defined above.
     * 
     */
    @Export(name="driverNodeTypeId", refs={String.class}, tree="[0]")
    private Output<String> driverNodeTypeId;

    /**
     * @return The node type of the Spark driver. This field is optional; if unset, API will set the driver node type to the same value as `node_type_id` defined above.
     * 
     */
    public Output<String> driverNodeTypeId() {
        return this.driverNodeTypeId;
    }
    /**
     * If you donâ€™t want to allocate a fixed number of EBS volumes at cluster creation time, use autoscaling local storage. With autoscaling local storage, Databricks monitors the amount of free disk space available on your clusterâ€™s Spark workers. If a worker begins to run too low on disk, Databricks automatically attaches a new EBS volume to the worker before it runs out of disk space. EBS volumes are attached up to a limit of 5 TB of total disk space per instance (including the instanceâ€™s local storage). To scale down EBS usage, make sure you have `autotermination_minutes` and `autoscale` attributes set. More documentation available at [cluster configuration page](https://docs.databricks.com/clusters/configure.html#autoscaling-local-storage-1).
     * 
     */
    @Export(name="enableElasticDisk", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableElasticDisk;

    /**
     * @return If you donâ€™t want to allocate a fixed number of EBS volumes at cluster creation time, use autoscaling local storage. With autoscaling local storage, Databricks monitors the amount of free disk space available on your clusterâ€™s Spark workers. If a worker begins to run too low on disk, Databricks automatically attaches a new EBS volume to the worker before it runs out of disk space. EBS volumes are attached up to a limit of 5 TB of total disk space per instance (including the instanceâ€™s local storage). To scale down EBS usage, make sure you have `autotermination_minutes` and `autoscale` attributes set. More documentation available at [cluster configuration page](https://docs.databricks.com/clusters/configure.html#autoscaling-local-storage-1).
     * 
     */
    public Output<Boolean> enableElasticDisk() {
        return this.enableElasticDisk;
    }
    /**
     * Some instance types you use to run clusters may have locally attached disks. Databricks may store shuffle data or temporary data on these locally attached disks. To ensure that all data at rest is encrypted for all storage types, including shuffle data stored temporarily on your clusterâ€™s local disks, you can enable local disk encryption. When local disk encryption is enabled, Databricks generates an encryption key locally unique to each cluster node and uses it to encrypt all data stored on local disks. The scope of the key is local to each cluster node and is destroyed along with the cluster node itself. During its lifetime, the key resides in memory for encryption and decryption and is stored encrypted on the disk. *Your workloads may run more slowly because of the performance impact of reading and writing encrypted data to and from local volumes. This feature is not available for all Azure Databricks subscriptions. Contact your Microsoft or Databricks account representative to request access.*
     * 
     */
    @Export(name="enableLocalDiskEncryption", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enableLocalDiskEncryption;

    /**
     * @return Some instance types you use to run clusters may have locally attached disks. Databricks may store shuffle data or temporary data on these locally attached disks. To ensure that all data at rest is encrypted for all storage types, including shuffle data stored temporarily on your clusterâ€™s local disks, you can enable local disk encryption. When local disk encryption is enabled, Databricks generates an encryption key locally unique to each cluster node and uses it to encrypt all data stored on local disks. The scope of the key is local to each cluster node and is destroyed along with the cluster node itself. During its lifetime, the key resides in memory for encryption and decryption and is stored encrypted on the disk. *Your workloads may run more slowly because of the performance impact of reading and writing encrypted data to and from local volumes. This feature is not available for all Azure Databricks subscriptions. Contact your Microsoft or Databricks account representative to request access.*
     * 
     */
    public Output<Boolean> enableLocalDiskEncryption() {
        return this.enableLocalDiskEncryption;
    }
    @Export(name="gcpAttributes", refs={ClusterGcpAttributes.class}, tree="[0]")
    private Output</* @Nullable */ ClusterGcpAttributes> gcpAttributes;

    public Output<Optional<ClusterGcpAttributes>> gcpAttributes() {
        return Codegen.optional(this.gcpAttributes);
    }
    /**
     * An optional token to guarantee the idempotency of cluster creation requests. If an active cluster with the provided token already exists, the request will not create a new cluster, but it will return the existing running cluster&#39;s ID instead. If you specify the idempotency token, upon failure, you can retry until the request succeeds. Databricks platform guarantees to launch exactly one cluster with that idempotency token. This token should have at most 64 characters.
     * 
     */
    @Export(name="idempotencyToken", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> idempotencyToken;

    /**
     * @return An optional token to guarantee the idempotency of cluster creation requests. If an active cluster with the provided token already exists, the request will not create a new cluster, but it will return the existing running cluster&#39;s ID instead. If you specify the idempotency token, upon failure, you can retry until the request succeeds. Databricks platform guarantees to launch exactly one cluster with that idempotency token. This token should have at most 64 characters.
     * 
     */
    public Output<Optional<String>> idempotencyToken() {
        return Codegen.optional(this.idempotencyToken);
    }
    @Export(name="initScripts", refs={List.class,ClusterInitScript.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterInitScript>> initScripts;

    public Output<Optional<List<ClusterInitScript>>> initScripts() {
        return Codegen.optional(this.initScripts);
    }
    /**
     * To reduce cluster start time, you can attach a cluster to a predefined pool of idle instances. When attached to a pool, a cluster allocates its driver and worker nodes from the pool. If the pool does not have sufficient idle resources to accommodate the clusterâ€™s request, it expands by allocating new instances from the instance provider. When an attached cluster changes its state to `TERMINATED`, the instances it used are returned to the pool and reused by a different cluster.
     * 
     */
    @Export(name="instancePoolId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> instancePoolId;

    /**
     * @return To reduce cluster start time, you can attach a cluster to a predefined pool of idle instances. When attached to a pool, a cluster allocates its driver and worker nodes from the pool. If the pool does not have sufficient idle resources to accommodate the clusterâ€™s request, it expands by allocating new instances from the instance provider. When an attached cluster changes its state to `TERMINATED`, the instances it used are returned to the pool and reused by a different cluster.
     * 
     */
    public Output<Optional<String>> instancePoolId() {
        return Codegen.optional(this.instancePoolId);
    }
    /**
     * boolean value specifying if the cluster is pinned (not pinned by default). You must be a Databricks administrator to use this.  The pinned clusters&#39; maximum number is [limited to 100](https://docs.databricks.com/clusters/clusters-manage.html#pin-a-cluster), so `apply` may fail if you have more than that (this number may change over time, so check Databricks documentation for actual number).
     * 
     * The following example demonstrates how to create an autoscaling cluster with [Delta Cache](https://docs.databricks.com/delta/optimizations/delta-cache.html) enabled:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.databricks.DatabricksFunctions;
     * import com.pulumi.databricks.inputs.GetNodeTypeArgs;
     * import com.pulumi.databricks.inputs.GetSparkVersionArgs;
     * import com.pulumi.databricks.Cluster;
     * import com.pulumi.databricks.ClusterArgs;
     * import com.pulumi.databricks.inputs.ClusterAutoscaleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var smallest = DatabricksFunctions.getNodeType(GetNodeTypeArgs.builder()
     *             .localDisk(true)
     *             .build());
     * 
     *         final var latestLts = DatabricksFunctions.getSparkVersion(GetSparkVersionArgs.builder()
     *             .longTermSupport(true)
     *             .build());
     * 
     *         var sharedAutoscaling = new Cluster(&#34;sharedAutoscaling&#34;, ClusterArgs.builder()        
     *             .clusterName(&#34;Shared Autoscaling&#34;)
     *             .sparkVersion(latestLts.applyValue(getSparkVersionResult -&gt; getSparkVersionResult.id()))
     *             .nodeTypeId(smallest.applyValue(getNodeTypeResult -&gt; getNodeTypeResult.id()))
     *             .autoterminationMinutes(20)
     *             .autoscale(ClusterAutoscaleArgs.builder()
     *                 .minWorkers(1)
     *                 .maxWorkers(50)
     *                 .build())
     *             .sparkConf(Map.ofEntries(
     *                 Map.entry(&#34;spark.databricks.io.cache.enabled&#34;, true),
     *                 Map.entry(&#34;spark.databricks.io.cache.maxDiskUsage&#34;, &#34;50g&#34;),
     *                 Map.entry(&#34;spark.databricks.io.cache.maxMetaDataCache&#34;, &#34;1g&#34;)
     *             ))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    @Export(name="isPinned", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> isPinned;

    /**
     * @return boolean value specifying if the cluster is pinned (not pinned by default). You must be a Databricks administrator to use this.  The pinned clusters&#39; maximum number is [limited to 100](https://docs.databricks.com/clusters/clusters-manage.html#pin-a-cluster), so `apply` may fail if you have more than that (this number may change over time, so check Databricks documentation for actual number).
     * 
     * The following example demonstrates how to create an autoscaling cluster with [Delta Cache](https://docs.databricks.com/delta/optimizations/delta-cache.html) enabled:
     * 
     * &lt;!--Start PulumiCodeChooser --&gt;
     * ```java
     * package generated_program;
     * 
     * import com.pulumi.Context;
     * import com.pulumi.Pulumi;
     * import com.pulumi.core.Output;
     * import com.pulumi.databricks.DatabricksFunctions;
     * import com.pulumi.databricks.inputs.GetNodeTypeArgs;
     * import com.pulumi.databricks.inputs.GetSparkVersionArgs;
     * import com.pulumi.databricks.Cluster;
     * import com.pulumi.databricks.ClusterArgs;
     * import com.pulumi.databricks.inputs.ClusterAutoscaleArgs;
     * import java.util.List;
     * import java.util.ArrayList;
     * import java.util.Map;
     * import java.io.File;
     * import java.nio.file.Files;
     * import java.nio.file.Paths;
     * 
     * public class App {
     *     public static void main(String[] args) {
     *         Pulumi.run(App::stack);
     *     }
     * 
     *     public static void stack(Context ctx) {
     *         final var smallest = DatabricksFunctions.getNodeType(GetNodeTypeArgs.builder()
     *             .localDisk(true)
     *             .build());
     * 
     *         final var latestLts = DatabricksFunctions.getSparkVersion(GetSparkVersionArgs.builder()
     *             .longTermSupport(true)
     *             .build());
     * 
     *         var sharedAutoscaling = new Cluster(&#34;sharedAutoscaling&#34;, ClusterArgs.builder()        
     *             .clusterName(&#34;Shared Autoscaling&#34;)
     *             .sparkVersion(latestLts.applyValue(getSparkVersionResult -&gt; getSparkVersionResult.id()))
     *             .nodeTypeId(smallest.applyValue(getNodeTypeResult -&gt; getNodeTypeResult.id()))
     *             .autoterminationMinutes(20)
     *             .autoscale(ClusterAutoscaleArgs.builder()
     *                 .minWorkers(1)
     *                 .maxWorkers(50)
     *                 .build())
     *             .sparkConf(Map.ofEntries(
     *                 Map.entry(&#34;spark.databricks.io.cache.enabled&#34;, true),
     *                 Map.entry(&#34;spark.databricks.io.cache.maxDiskUsage&#34;, &#34;50g&#34;),
     *                 Map.entry(&#34;spark.databricks.io.cache.maxMetaDataCache&#34;, &#34;1g&#34;)
     *             ))
     *             .build());
     * 
     *     }
     * }
     * ```
     * &lt;!--End PulumiCodeChooser --&gt;
     * 
     */
    public Output<Optional<Boolean>> isPinned() {
        return Codegen.optional(this.isPinned);
    }
    @Export(name="libraries", refs={List.class,ClusterLibrary.class}, tree="[0,1]")
    private Output</* @Nullable */ List<ClusterLibrary>> libraries;

    public Output<Optional<List<ClusterLibrary>>> libraries() {
        return Codegen.optional(this.libraries);
    }
    /**
     * Any supported databricks.getNodeType id. If `instance_pool_id` is specified, this field is not needed.
     * 
     */
    @Export(name="nodeTypeId", refs={String.class}, tree="[0]")
    private Output<String> nodeTypeId;

    /**
     * @return Any supported databricks.getNodeType id. If `instance_pool_id` is specified, this field is not needed.
     * 
     */
    public Output<String> nodeTypeId() {
        return this.nodeTypeId;
    }
    /**
     * Number of worker nodes that this cluster should have. A cluster has one Spark driver and `num_workers` executors for a total of `num_workers` + 1 Spark nodes.
     * 
     */
    @Export(name="numWorkers", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> numWorkers;

    /**
     * @return Number of worker nodes that this cluster should have. A cluster has one Spark driver and `num_workers` executors for a total of `num_workers` + 1 Spark nodes.
     * 
     */
    public Output<Optional<Integer>> numWorkers() {
        return Codegen.optional(this.numWorkers);
    }
    @Export(name="policyId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> policyId;

    public Output<Optional<String>> policyId() {
        return Codegen.optional(this.policyId);
    }
    /**
     * The type of runtime engine to use. If not specified, the runtime engine type is inferred based on the spark_version value. Allowed values include: `PHOTON`, `STANDARD`.
     * 
     */
    @Export(name="runtimeEngine", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> runtimeEngine;

    /**
     * @return The type of runtime engine to use. If not specified, the runtime engine type is inferred based on the spark_version value. Allowed values include: `PHOTON`, `STANDARD`.
     * 
     */
    public Output<Optional<String>> runtimeEngine() {
        return Codegen.optional(this.runtimeEngine);
    }
    /**
     * The optional user name of the user to assign to an interactive cluster. This field is required when using `data_security_mode` set to `SINGLE_USER` or AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
     * 
     */
    @Export(name="singleUserName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> singleUserName;

    /**
     * @return The optional user name of the user to assign to an interactive cluster. This field is required when using `data_security_mode` set to `SINGLE_USER` or AAD Passthrough for Azure Data Lake Storage (ADLS) with a single-user cluster (i.e., not high-concurrency clusters).
     * 
     */
    public Output<Optional<String>> singleUserName() {
        return Codegen.optional(this.singleUserName);
    }
    /**
     * should have following items:
     * * `spark.databricks.repl.allowedLanguages` set to a list of supported languages, for example: `python,sql`, or `python,sql,r`.  Scala is not supported!
     * * `spark.databricks.cluster.profile` set to `serverless`
     * 
     */
    @Export(name="sparkConf", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,Object>> sparkConf;

    /**
     * @return should have following items:
     * * `spark.databricks.repl.allowedLanguages` set to a list of supported languages, for example: `python,sql`, or `python,sql,r`.  Scala is not supported!
     * * `spark.databricks.cluster.profile` set to `serverless`
     * 
     */
    public Output<Optional<Map<String,Object>>> sparkConf() {
        return Codegen.optional(this.sparkConf);
    }
    /**
     * Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X=&#39;Y&#39;) while launching the driver and workers.
     * 
     */
    @Export(name="sparkEnvVars", refs={Map.class,String.class,Object.class}, tree="[0,1,2]")
    private Output</* @Nullable */ Map<String,Object>> sparkEnvVars;

    /**
     * @return Map with environment variable key-value pairs to fine-tune Spark clusters. Key-value pairs of the form (X,Y) are exported (i.e., X=&#39;Y&#39;) while launching the driver and workers.
     * 
     */
    public Output<Optional<Map<String,Object>>> sparkEnvVars() {
        return Codegen.optional(this.sparkEnvVars);
    }
    /**
     * [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster. Any supported databricks.getSparkVersion id.  We advise using Cluster Policies to restrict the list of versions for simplicity while maintaining enough control.
     * 
     */
    @Export(name="sparkVersion", refs={String.class}, tree="[0]")
    private Output<String> sparkVersion;

    /**
     * @return [Runtime version](https://docs.databricks.com/runtime/index.html) of the cluster. Any supported databricks.getSparkVersion id.  We advise using Cluster Policies to restrict the list of versions for simplicity while maintaining enough control.
     * 
     */
    public Output<String> sparkVersion() {
        return this.sparkVersion;
    }
    /**
     * SSH public key contents that will be added to each Spark node in this cluster. The corresponding private keys can be used to login with the user name ubuntu on port 2200. You can specify up to 10 keys.
     * 
     */
    @Export(name="sshPublicKeys", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> sshPublicKeys;

    /**
     * @return SSH public key contents that will be added to each Spark node in this cluster. The corresponding private keys can be used to login with the user name ubuntu on port 2200. You can specify up to 10 keys.
     * 
     */
    public Output<Optional<List<String>>> sshPublicKeys() {
        return Codegen.optional(this.sshPublicKeys);
    }
    /**
     * (string) State of the cluster.
     * 
     */
    @Export(name="state", refs={String.class}, tree="[0]")
    private Output<String> state;

    /**
     * @return (string) State of the cluster.
     * 
     */
    public Output<String> state() {
        return this.state;
    }
    @Export(name="url", refs={String.class}, tree="[0]")
    private Output<String> url;

    public Output<String> url() {
        return this.url;
    }
    @Export(name="workloadType", refs={ClusterWorkloadType.class}, tree="[0]")
    private Output</* @Nullable */ ClusterWorkloadType> workloadType;

    public Output<Optional<ClusterWorkloadType>> workloadType() {
        return Codegen.optional(this.workloadType);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Cluster(String name) {
        this(name, ClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Cluster(String name, ClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Cluster(String name, ClusterArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("databricks:index/cluster:Cluster", name, args == null ? ClusterArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Cluster(String name, Output<String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("databricks:index/cluster:Cluster", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Cluster get(String name, Output<String> id, @Nullable ClusterState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Cluster(name, id, state, options);
    }
}
