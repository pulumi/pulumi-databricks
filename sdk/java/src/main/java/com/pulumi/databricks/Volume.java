// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.databricks;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.databricks.Utilities;
import com.pulumi.databricks.VolumeArgs;
import com.pulumi.databricks.inputs.VolumeState;
import java.lang.String;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Volumes are Unity Catalog objects representing a logical volume of storage in a cloud object storage location. Volumes provide capabilities for accessing, storing, governing, and organizing files. While tables provide governance over tabular datasets, volumes add governance over non-tabular datasets. You can use volumes to store and access files in any format, including structured, semi-structured, and unstructured data.
 * 
 * &gt; This resource can only be used with a workspace-level provider!
 * 
 * A volume resides in the third layer of Unity Catalog&#39;s three-level namespace. Volumes are siblings to tables, views, and other objects organized under a schema in Unity Catalog.
 * 
 * A volume can be **managed** or **external**.
 * 
 * A **managed volume** is a Unity Catalog-governed storage volume created within the default storage location of the containing schema. Managed volumes allow the creation of governed storage for working with files without the overhead of external locations and storage credentials. You do not need to specify a location when creating a managed volume, and all file access for data in managed volumes is through paths managed by Unity Catalog.
 * 
 * An **external volume** is a Unity Catalog-governed storage volume registered against a directory within an external location.
 * 
 * A volume can be referenced using its identifier: ```&lt;catalogName&gt;.&lt;schemaName&gt;.&lt;volumeName&gt;```, where:
 * 
 * * ```&lt;catalogName&gt;```: The name of the catalog containing the Volume.
 * * ```&lt;schemaName&gt;```: The name of the schema containing the Volume.
 * * ```&lt;volumeName&gt;```: The name of the Volume. It identifies the volume object.
 * 
 * The path to access files in volumes uses the following format:
 * 
 * ```/Volumes/&lt;catalog&gt;/&lt;schema&gt;/&lt;volume&gt;/&lt;path&gt;/&lt;file_name&gt;```
 * 
 * Databricks also supports an optional ```dbfs:/``` scheme, so the following path also works:
 * 
 * ```dbfs:/Volumes/&lt;catalog&gt;/&lt;schema&gt;/&lt;volume&gt;/&lt;path&gt;/&lt;file_name&gt;```
 * 
 * This resource manages Volumes in Unity Catalog.
 * 
 * ## Example Usage
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.databricks.Catalog;
 * import com.pulumi.databricks.CatalogArgs;
 * import com.pulumi.databricks.Schema;
 * import com.pulumi.databricks.SchemaArgs;
 * import com.pulumi.databricks.StorageCredential;
 * import com.pulumi.databricks.StorageCredentialArgs;
 * import com.pulumi.databricks.inputs.StorageCredentialAwsIamRoleArgs;
 * import com.pulumi.databricks.ExternalLocation;
 * import com.pulumi.databricks.ExternalLocationArgs;
 * import com.pulumi.databricks.Volume;
 * import com.pulumi.databricks.VolumeArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var sandbox = new Catalog("sandbox", CatalogArgs.builder()
 *             .name("sandbox")
 *             .comment("this catalog is managed by terraform")
 *             .properties(Map.of("purpose", "testing"))
 *             .build());
 * 
 *         var things = new Schema("things", SchemaArgs.builder()
 *             .catalogName(sandbox.name())
 *             .name("things")
 *             .comment("this schema is managed by terraform")
 *             .properties(Map.of("kind", "various"))
 *             .build());
 * 
 *         var external = new StorageCredential("external", StorageCredentialArgs.builder()
 *             .name("creds")
 *             .awsIamRole(StorageCredentialAwsIamRoleArgs.builder()
 *                 .roleArn(externalDataAccess.arn())
 *                 .build())
 *             .build());
 * 
 *         var some = new ExternalLocation("some", ExternalLocationArgs.builder()
 *             .name("external_location")
 *             .url(String.format("s3://%s/some", externalAwsS3Bucket.id()))
 *             .credentialName(external.name())
 *             .build());
 * 
 *         var this_ = new Volume("this", VolumeArgs.builder()
 *             .name("quickstart_volume")
 *             .catalogName(sandbox.name())
 *             .schemaName(things.name())
 *             .volumeType("EXTERNAL")
 *             .storageLocation(some.url())
 *             .comment("this volume is managed by terraform")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ## Import
 * 
 * This resource can be imported by `full_name` which is the 3-level Volume identifier: `&lt;catalog&gt;.&lt;schema&gt;.&lt;name&gt;`
 * 
 * hcl
 * 
 * import {
 * 
 *   to = databricks_volume.this
 * 
 *   id = &#34;&lt;catalog_name&gt;.&lt;schema_name&gt;.&lt;name&gt;&#34;
 * 
 * }
 * 
 * Alternatively, when using `terraform` version 1.4 or earlier, import using the `pulumi import` command:
 * 
 * bash
 * 
 * ```sh
 * $ pulumi import databricks:index/volume:Volume this &lt;catalog_name&gt;.&lt;schema_name&gt;.&lt;name&gt;
 * ```
 * 
 */
@ResourceType(type="databricks:index/volume:Volume")
public class Volume extends com.pulumi.resources.CustomResource {
    /**
     * Name of parent Catalog. Change forces creation of a new resource.
     * 
     */
    @Export(name="catalogName", refs={String.class}, tree="[0]")
    private Output<String> catalogName;

    /**
     * @return Name of parent Catalog. Change forces creation of a new resource.
     * 
     */
    public Output<String> catalogName() {
        return this.catalogName;
    }
    /**
     * Free-form text.
     * 
     */
    @Export(name="comment", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> comment;

    /**
     * @return Free-form text.
     * 
     */
    public Output<Optional<String>> comment() {
        return Codegen.optional(this.comment);
    }
    /**
     * Name of the Volume
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return Name of the Volume
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Name of the volume owner.
     * 
     */
    @Export(name="owner", refs={String.class}, tree="[0]")
    private Output<String> owner;

    /**
     * @return Name of the volume owner.
     * 
     */
    public Output<String> owner() {
        return this.owner;
    }
    /**
     * Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
     * 
     */
    @Export(name="schemaName", refs={String.class}, tree="[0]")
    private Output<String> schemaName;

    /**
     * @return Name of parent Schema relative to parent Catalog. Change forces creation of a new resource.
     * 
     */
    public Output<String> schemaName() {
        return this.schemaName;
    }
    /**
     * URL for the volume (should be inside of an existing External Location). Only used for `EXTERNAL` Volumes.  If the URL contains special characters, such as space, `&amp;`, etc., they should be percent-encoded (space &gt; `%20`, etc.). Change forces creation of a new resource.
     * 
     */
    @Export(name="storageLocation", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> storageLocation;

    /**
     * @return URL for the volume (should be inside of an existing External Location). Only used for `EXTERNAL` Volumes.  If the URL contains special characters, such as space, `&amp;`, etc., they should be percent-encoded (space &gt; `%20`, etc.). Change forces creation of a new resource.
     * 
     */
    public Output<Optional<String>> storageLocation() {
        return Codegen.optional(this.storageLocation);
    }
    /**
     * base file path for this Unity Catalog Volume in form of `/Volumes/&lt;catalog&gt;/&lt;schema&gt;/&lt;name&gt;`.
     * 
     */
    @Export(name="volumePath", refs={String.class}, tree="[0]")
    private Output<String> volumePath;

    /**
     * @return base file path for this Unity Catalog Volume in form of `/Volumes/&lt;catalog&gt;/&lt;schema&gt;/&lt;name&gt;`.
     * 
     */
    public Output<String> volumePath() {
        return this.volumePath;
    }
    /**
     * Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
     * 
     */
    @Export(name="volumeType", refs={String.class}, tree="[0]")
    private Output<String> volumeType;

    /**
     * @return Volume type. `EXTERNAL` or `MANAGED`. Change forces creation of a new resource.
     * 
     */
    public Output<String> volumeType() {
        return this.volumeType;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Volume(java.lang.String name) {
        this(name, VolumeArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Volume(java.lang.String name, VolumeArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Volume(java.lang.String name, VolumeArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("databricks:index/volume:Volume", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Volume(java.lang.String name, Output<java.lang.String> id, @Nullable VolumeState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("databricks:index/volume:Volume", name, state, makeResourceOptions(options, id), false);
    }

    private static VolumeArgs makeArgs(VolumeArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? VolumeArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Volume get(java.lang.String name, Output<java.lang.String> id, @Nullable VolumeState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Volume(name, id, state, options);
    }
}
