// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.databricks.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskCleanRoomsNotebookTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskConditionTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskDashboardTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskDbtCloudTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskDbtPlatformTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskDbtTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskDependsOnArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskEmailNotificationsArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskGenAiComputeTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskHealthArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskLibraryArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskNewClusterArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskNotebookTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskNotificationSettingsArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskPipelineTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskPowerBiTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskPythonWheelTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskRunJobTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskSparkJarTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskSparkPythonTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskSparkSubmitTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskSqlTaskArgs;
import com.pulumi.databricks.inputs.JobTaskForEachTaskTaskWebhookNotificationsArgs;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class JobTaskForEachTaskTaskArgs extends com.pulumi.resources.ResourceArgs {

    public static final JobTaskForEachTaskTaskArgs Empty = new JobTaskForEachTaskTaskArgs();

    @Import(name="cleanRoomsNotebookTask")
    private @Nullable Output<JobTaskForEachTaskTaskCleanRoomsNotebookTaskArgs> cleanRoomsNotebookTask;

    public Optional<Output<JobTaskForEachTaskTaskCleanRoomsNotebookTaskArgs>> cleanRoomsNotebookTask() {
        return Optional.ofNullable(this.cleanRoomsNotebookTask);
    }

    @Import(name="conditionTask")
    private @Nullable Output<JobTaskForEachTaskTaskConditionTaskArgs> conditionTask;

    public Optional<Output<JobTaskForEachTaskTaskConditionTaskArgs>> conditionTask() {
        return Optional.ofNullable(this.conditionTask);
    }

    @Import(name="dashboardTask")
    private @Nullable Output<JobTaskForEachTaskTaskDashboardTaskArgs> dashboardTask;

    public Optional<Output<JobTaskForEachTaskTaskDashboardTaskArgs>> dashboardTask() {
        return Optional.ofNullable(this.dashboardTask);
    }

    @Import(name="dbtCloudTask")
    private @Nullable Output<JobTaskForEachTaskTaskDbtCloudTaskArgs> dbtCloudTask;

    public Optional<Output<JobTaskForEachTaskTaskDbtCloudTaskArgs>> dbtCloudTask() {
        return Optional.ofNullable(this.dbtCloudTask);
    }

    @Import(name="dbtPlatformTask")
    private @Nullable Output<JobTaskForEachTaskTaskDbtPlatformTaskArgs> dbtPlatformTask;

    public Optional<Output<JobTaskForEachTaskTaskDbtPlatformTaskArgs>> dbtPlatformTask() {
        return Optional.ofNullable(this.dbtPlatformTask);
    }

    @Import(name="dbtTask")
    private @Nullable Output<JobTaskForEachTaskTaskDbtTaskArgs> dbtTask;

    public Optional<Output<JobTaskForEachTaskTaskDbtTaskArgs>> dbtTask() {
        return Optional.ofNullable(this.dbtTask);
    }

    /**
     * block specifying dependency(-ies) for a given task.
     * 
     */
    @Import(name="dependsOns")
    private @Nullable Output<List<JobTaskForEachTaskTaskDependsOnArgs>> dependsOns;

    /**
     * @return block specifying dependency(-ies) for a given task.
     * 
     */
    public Optional<Output<List<JobTaskForEachTaskTaskDependsOnArgs>>> dependsOns() {
        return Optional.ofNullable(this.dependsOns);
    }

    /**
     * description for this task.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return description for this task.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * A flag to disable auto optimization in serverless tasks.
     * 
     */
    @Import(name="disableAutoOptimization")
    private @Nullable Output<Boolean> disableAutoOptimization;

    /**
     * @return A flag to disable auto optimization in serverless tasks.
     * 
     */
    public Optional<Output<Boolean>> disableAutoOptimization() {
        return Optional.ofNullable(this.disableAutoOptimization);
    }

    /**
     * An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
     * 
     */
    @Import(name="emailNotifications")
    private @Nullable Output<JobTaskForEachTaskTaskEmailNotificationsArgs> emailNotifications;

    /**
     * @return An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
     * 
     */
    public Optional<Output<JobTaskForEachTaskTaskEmailNotificationsArgs>> emailNotifications() {
        return Optional.ofNullable(this.emailNotifications);
    }

    /**
     * identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`sparkPythonTask`, `pythonWheelTask`, ...) running on serverless compute.
     * 
     */
    @Import(name="environmentKey")
    private @Nullable Output<String> environmentKey;

    /**
     * @return identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`sparkPythonTask`, `pythonWheelTask`, ...) running on serverless compute.
     * 
     */
    public Optional<Output<String>> environmentKey() {
        return Optional.ofNullable(this.environmentKey);
    }

    /**
     * Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
     * 
     */
    @Import(name="existingClusterId")
    private @Nullable Output<String> existingClusterId;

    /**
     * @return Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
     * 
     */
    public Optional<Output<String>> existingClusterId() {
        return Optional.ofNullable(this.existingClusterId);
    }

    @Import(name="genAiComputeTask")
    private @Nullable Output<JobTaskForEachTaskTaskGenAiComputeTaskArgs> genAiComputeTask;

    public Optional<Output<JobTaskForEachTaskTaskGenAiComputeTaskArgs>> genAiComputeTask() {
        return Optional.ofNullable(this.genAiComputeTask);
    }

    /**
     * block described below that specifies health conditions for a given task.
     * 
     */
    @Import(name="health")
    private @Nullable Output<JobTaskForEachTaskTaskHealthArgs> health;

    /**
     * @return block described below that specifies health conditions for a given task.
     * 
     */
    public Optional<Output<JobTaskForEachTaskTaskHealthArgs>> health() {
        return Optional.ofNullable(this.health);
    }

    /**
     * Identifier of the Job cluster specified in the `jobCluster` block.
     * 
     */
    @Import(name="jobClusterKey")
    private @Nullable Output<String> jobClusterKey;

    /**
     * @return Identifier of the Job cluster specified in the `jobCluster` block.
     * 
     */
    public Optional<Output<String>> jobClusterKey() {
        return Optional.ofNullable(this.jobClusterKey);
    }

    /**
     * (Set) An optional list of libraries to be installed on the cluster that will execute the job.
     * 
     */
    @Import(name="libraries")
    private @Nullable Output<List<JobTaskForEachTaskTaskLibraryArgs>> libraries;

    /**
     * @return (Set) An optional list of libraries to be installed on the cluster that will execute the job.
     * 
     */
    public Optional<Output<List<JobTaskForEachTaskTaskLibraryArgs>>> libraries() {
        return Optional.ofNullable(this.libraries);
    }

    /**
     * (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
     * 
     */
    @Import(name="maxRetries")
    private @Nullable Output<Integer> maxRetries;

    /**
     * @return (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
     * 
     */
    public Optional<Output<Integer>> maxRetries() {
        return Optional.ofNullable(this.maxRetries);
    }

    /**
     * (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
     * 
     */
    @Import(name="minRetryIntervalMillis")
    private @Nullable Output<Integer> minRetryIntervalMillis;

    /**
     * @return (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
     * 
     */
    public Optional<Output<Integer>> minRetryIntervalMillis() {
        return Optional.ofNullable(this.minRetryIntervalMillis);
    }

    /**
     * Task will run on a dedicated cluster.  See databricks.Cluster documentation for specification. *Some parameters, such as `autoterminationMinutes`, `isPinned`, `workloadType` aren&#39;t supported!*
     * 
     */
    @Import(name="newCluster")
    private @Nullable Output<JobTaskForEachTaskTaskNewClusterArgs> newCluster;

    /**
     * @return Task will run on a dedicated cluster.  See databricks.Cluster documentation for specification. *Some parameters, such as `autoterminationMinutes`, `isPinned`, `workloadType` aren&#39;t supported!*
     * 
     */
    public Optional<Output<JobTaskForEachTaskTaskNewClusterArgs>> newCluster() {
        return Optional.ofNullable(this.newCluster);
    }

    @Import(name="notebookTask")
    private @Nullable Output<JobTaskForEachTaskTaskNotebookTaskArgs> notebookTask;

    public Optional<Output<JobTaskForEachTaskTaskNotebookTaskArgs>> notebookTask() {
        return Optional.ofNullable(this.notebookTask);
    }

    /**
     * An optional block controlling the notification settings on the job level documented below.
     * 
     */
    @Import(name="notificationSettings")
    private @Nullable Output<JobTaskForEachTaskTaskNotificationSettingsArgs> notificationSettings;

    /**
     * @return An optional block controlling the notification settings on the job level documented below.
     * 
     */
    public Optional<Output<JobTaskForEachTaskTaskNotificationSettingsArgs>> notificationSettings() {
        return Optional.ofNullable(this.notificationSettings);
    }

    @Import(name="pipelineTask")
    private @Nullable Output<JobTaskForEachTaskTaskPipelineTaskArgs> pipelineTask;

    public Optional<Output<JobTaskForEachTaskTaskPipelineTaskArgs>> pipelineTask() {
        return Optional.ofNullable(this.pipelineTask);
    }

    @Import(name="powerBiTask")
    private @Nullable Output<JobTaskForEachTaskTaskPowerBiTaskArgs> powerBiTask;

    public Optional<Output<JobTaskForEachTaskTaskPowerBiTaskArgs>> powerBiTask() {
        return Optional.ofNullable(this.powerBiTask);
    }

    @Import(name="pythonWheelTask")
    private @Nullable Output<JobTaskForEachTaskTaskPythonWheelTaskArgs> pythonWheelTask;

    public Optional<Output<JobTaskForEachTaskTaskPythonWheelTaskArgs>> pythonWheelTask() {
        return Optional.ofNullable(this.pythonWheelTask);
    }

    /**
     * (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
     * 
     */
    @Import(name="retryOnTimeout")
    private @Nullable Output<Boolean> retryOnTimeout;

    /**
     * @return (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
     * 
     */
    public Optional<Output<Boolean>> retryOnTimeout() {
        return Optional.ofNullable(this.retryOnTimeout);
    }

    /**
     * An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
     * 
     */
    @Import(name="runIf")
    private @Nullable Output<String> runIf;

    /**
     * @return An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
     * 
     */
    public Optional<Output<String>> runIf() {
        return Optional.ofNullable(this.runIf);
    }

    @Import(name="runJobTask")
    private @Nullable Output<JobTaskForEachTaskTaskRunJobTaskArgs> runJobTask;

    public Optional<Output<JobTaskForEachTaskTaskRunJobTaskArgs>> runJobTask() {
        return Optional.ofNullable(this.runJobTask);
    }

    @Import(name="sparkJarTask")
    private @Nullable Output<JobTaskForEachTaskTaskSparkJarTaskArgs> sparkJarTask;

    public Optional<Output<JobTaskForEachTaskTaskSparkJarTaskArgs>> sparkJarTask() {
        return Optional.ofNullable(this.sparkJarTask);
    }

    @Import(name="sparkPythonTask")
    private @Nullable Output<JobTaskForEachTaskTaskSparkPythonTaskArgs> sparkPythonTask;

    public Optional<Output<JobTaskForEachTaskTaskSparkPythonTaskArgs>> sparkPythonTask() {
        return Optional.ofNullable(this.sparkPythonTask);
    }

    @Import(name="sparkSubmitTask")
    private @Nullable Output<JobTaskForEachTaskTaskSparkSubmitTaskArgs> sparkSubmitTask;

    public Optional<Output<JobTaskForEachTaskTaskSparkSubmitTaskArgs>> sparkSubmitTask() {
        return Optional.ofNullable(this.sparkSubmitTask);
    }

    @Import(name="sqlTask")
    private @Nullable Output<JobTaskForEachTaskTaskSqlTaskArgs> sqlTask;

    public Optional<Output<JobTaskForEachTaskTaskSqlTaskArgs>> sqlTask() {
        return Optional.ofNullable(this.sqlTask);
    }

    /**
     * string specifying an unique key for a given task.
     * * `*_task` - (Required) one of the specific task blocks described below:
     * 
     */
    @Import(name="taskKey", required=true)
    private Output<String> taskKey;

    /**
     * @return string specifying an unique key for a given task.
     * * `*_task` - (Required) one of the specific task blocks described below:
     * 
     */
    public Output<String> taskKey() {
        return this.taskKey;
    }

    /**
     * (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
     * 
     */
    @Import(name="timeoutSeconds")
    private @Nullable Output<Integer> timeoutSeconds;

    /**
     * @return (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
     * 
     */
    public Optional<Output<Integer>> timeoutSeconds() {
        return Optional.ofNullable(this.timeoutSeconds);
    }

    /**
     * (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
     * 
     * &gt; If no `jobClusterKey`, `existingClusterId`, or `newCluster` were specified in task definition, then task will executed using serverless compute.
     * 
     */
    @Import(name="webhookNotifications")
    private @Nullable Output<JobTaskForEachTaskTaskWebhookNotificationsArgs> webhookNotifications;

    /**
     * @return (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
     * 
     * &gt; If no `jobClusterKey`, `existingClusterId`, or `newCluster` were specified in task definition, then task will executed using serverless compute.
     * 
     */
    public Optional<Output<JobTaskForEachTaskTaskWebhookNotificationsArgs>> webhookNotifications() {
        return Optional.ofNullable(this.webhookNotifications);
    }

    private JobTaskForEachTaskTaskArgs() {}

    private JobTaskForEachTaskTaskArgs(JobTaskForEachTaskTaskArgs $) {
        this.cleanRoomsNotebookTask = $.cleanRoomsNotebookTask;
        this.conditionTask = $.conditionTask;
        this.dashboardTask = $.dashboardTask;
        this.dbtCloudTask = $.dbtCloudTask;
        this.dbtPlatformTask = $.dbtPlatformTask;
        this.dbtTask = $.dbtTask;
        this.dependsOns = $.dependsOns;
        this.description = $.description;
        this.disableAutoOptimization = $.disableAutoOptimization;
        this.emailNotifications = $.emailNotifications;
        this.environmentKey = $.environmentKey;
        this.existingClusterId = $.existingClusterId;
        this.genAiComputeTask = $.genAiComputeTask;
        this.health = $.health;
        this.jobClusterKey = $.jobClusterKey;
        this.libraries = $.libraries;
        this.maxRetries = $.maxRetries;
        this.minRetryIntervalMillis = $.minRetryIntervalMillis;
        this.newCluster = $.newCluster;
        this.notebookTask = $.notebookTask;
        this.notificationSettings = $.notificationSettings;
        this.pipelineTask = $.pipelineTask;
        this.powerBiTask = $.powerBiTask;
        this.pythonWheelTask = $.pythonWheelTask;
        this.retryOnTimeout = $.retryOnTimeout;
        this.runIf = $.runIf;
        this.runJobTask = $.runJobTask;
        this.sparkJarTask = $.sparkJarTask;
        this.sparkPythonTask = $.sparkPythonTask;
        this.sparkSubmitTask = $.sparkSubmitTask;
        this.sqlTask = $.sqlTask;
        this.taskKey = $.taskKey;
        this.timeoutSeconds = $.timeoutSeconds;
        this.webhookNotifications = $.webhookNotifications;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(JobTaskForEachTaskTaskArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private JobTaskForEachTaskTaskArgs $;

        public Builder() {
            $ = new JobTaskForEachTaskTaskArgs();
        }

        public Builder(JobTaskForEachTaskTaskArgs defaults) {
            $ = new JobTaskForEachTaskTaskArgs(Objects.requireNonNull(defaults));
        }

        public Builder cleanRoomsNotebookTask(@Nullable Output<JobTaskForEachTaskTaskCleanRoomsNotebookTaskArgs> cleanRoomsNotebookTask) {
            $.cleanRoomsNotebookTask = cleanRoomsNotebookTask;
            return this;
        }

        public Builder cleanRoomsNotebookTask(JobTaskForEachTaskTaskCleanRoomsNotebookTaskArgs cleanRoomsNotebookTask) {
            return cleanRoomsNotebookTask(Output.of(cleanRoomsNotebookTask));
        }

        public Builder conditionTask(@Nullable Output<JobTaskForEachTaskTaskConditionTaskArgs> conditionTask) {
            $.conditionTask = conditionTask;
            return this;
        }

        public Builder conditionTask(JobTaskForEachTaskTaskConditionTaskArgs conditionTask) {
            return conditionTask(Output.of(conditionTask));
        }

        public Builder dashboardTask(@Nullable Output<JobTaskForEachTaskTaskDashboardTaskArgs> dashboardTask) {
            $.dashboardTask = dashboardTask;
            return this;
        }

        public Builder dashboardTask(JobTaskForEachTaskTaskDashboardTaskArgs dashboardTask) {
            return dashboardTask(Output.of(dashboardTask));
        }

        public Builder dbtCloudTask(@Nullable Output<JobTaskForEachTaskTaskDbtCloudTaskArgs> dbtCloudTask) {
            $.dbtCloudTask = dbtCloudTask;
            return this;
        }

        public Builder dbtCloudTask(JobTaskForEachTaskTaskDbtCloudTaskArgs dbtCloudTask) {
            return dbtCloudTask(Output.of(dbtCloudTask));
        }

        public Builder dbtPlatformTask(@Nullable Output<JobTaskForEachTaskTaskDbtPlatformTaskArgs> dbtPlatformTask) {
            $.dbtPlatformTask = dbtPlatformTask;
            return this;
        }

        public Builder dbtPlatformTask(JobTaskForEachTaskTaskDbtPlatformTaskArgs dbtPlatformTask) {
            return dbtPlatformTask(Output.of(dbtPlatformTask));
        }

        public Builder dbtTask(@Nullable Output<JobTaskForEachTaskTaskDbtTaskArgs> dbtTask) {
            $.dbtTask = dbtTask;
            return this;
        }

        public Builder dbtTask(JobTaskForEachTaskTaskDbtTaskArgs dbtTask) {
            return dbtTask(Output.of(dbtTask));
        }

        /**
         * @param dependsOns block specifying dependency(-ies) for a given task.
         * 
         * @return builder
         * 
         */
        public Builder dependsOns(@Nullable Output<List<JobTaskForEachTaskTaskDependsOnArgs>> dependsOns) {
            $.dependsOns = dependsOns;
            return this;
        }

        /**
         * @param dependsOns block specifying dependency(-ies) for a given task.
         * 
         * @return builder
         * 
         */
        public Builder dependsOns(List<JobTaskForEachTaskTaskDependsOnArgs> dependsOns) {
            return dependsOns(Output.of(dependsOns));
        }

        /**
         * @param dependsOns block specifying dependency(-ies) for a given task.
         * 
         * @return builder
         * 
         */
        public Builder dependsOns(JobTaskForEachTaskTaskDependsOnArgs... dependsOns) {
            return dependsOns(List.of(dependsOns));
        }

        /**
         * @param description description for this task.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description description for this task.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param disableAutoOptimization A flag to disable auto optimization in serverless tasks.
         * 
         * @return builder
         * 
         */
        public Builder disableAutoOptimization(@Nullable Output<Boolean> disableAutoOptimization) {
            $.disableAutoOptimization = disableAutoOptimization;
            return this;
        }

        /**
         * @param disableAutoOptimization A flag to disable auto optimization in serverless tasks.
         * 
         * @return builder
         * 
         */
        public Builder disableAutoOptimization(Boolean disableAutoOptimization) {
            return disableAutoOptimization(Output.of(disableAutoOptimization));
        }

        /**
         * @param emailNotifications An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
         * 
         * @return builder
         * 
         */
        public Builder emailNotifications(@Nullable Output<JobTaskForEachTaskTaskEmailNotificationsArgs> emailNotifications) {
            $.emailNotifications = emailNotifications;
            return this;
        }

        /**
         * @param emailNotifications An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
         * 
         * @return builder
         * 
         */
        public Builder emailNotifications(JobTaskForEachTaskTaskEmailNotificationsArgs emailNotifications) {
            return emailNotifications(Output.of(emailNotifications));
        }

        /**
         * @param environmentKey identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`sparkPythonTask`, `pythonWheelTask`, ...) running on serverless compute.
         * 
         * @return builder
         * 
         */
        public Builder environmentKey(@Nullable Output<String> environmentKey) {
            $.environmentKey = environmentKey;
            return this;
        }

        /**
         * @param environmentKey identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`sparkPythonTask`, `pythonWheelTask`, ...) running on serverless compute.
         * 
         * @return builder
         * 
         */
        public Builder environmentKey(String environmentKey) {
            return environmentKey(Output.of(environmentKey));
        }

        /**
         * @param existingClusterId Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
         * 
         * @return builder
         * 
         */
        public Builder existingClusterId(@Nullable Output<String> existingClusterId) {
            $.existingClusterId = existingClusterId;
            return this;
        }

        /**
         * @param existingClusterId Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
         * 
         * @return builder
         * 
         */
        public Builder existingClusterId(String existingClusterId) {
            return existingClusterId(Output.of(existingClusterId));
        }

        public Builder genAiComputeTask(@Nullable Output<JobTaskForEachTaskTaskGenAiComputeTaskArgs> genAiComputeTask) {
            $.genAiComputeTask = genAiComputeTask;
            return this;
        }

        public Builder genAiComputeTask(JobTaskForEachTaskTaskGenAiComputeTaskArgs genAiComputeTask) {
            return genAiComputeTask(Output.of(genAiComputeTask));
        }

        /**
         * @param health block described below that specifies health conditions for a given task.
         * 
         * @return builder
         * 
         */
        public Builder health(@Nullable Output<JobTaskForEachTaskTaskHealthArgs> health) {
            $.health = health;
            return this;
        }

        /**
         * @param health block described below that specifies health conditions for a given task.
         * 
         * @return builder
         * 
         */
        public Builder health(JobTaskForEachTaskTaskHealthArgs health) {
            return health(Output.of(health));
        }

        /**
         * @param jobClusterKey Identifier of the Job cluster specified in the `jobCluster` block.
         * 
         * @return builder
         * 
         */
        public Builder jobClusterKey(@Nullable Output<String> jobClusterKey) {
            $.jobClusterKey = jobClusterKey;
            return this;
        }

        /**
         * @param jobClusterKey Identifier of the Job cluster specified in the `jobCluster` block.
         * 
         * @return builder
         * 
         */
        public Builder jobClusterKey(String jobClusterKey) {
            return jobClusterKey(Output.of(jobClusterKey));
        }

        /**
         * @param libraries (Set) An optional list of libraries to be installed on the cluster that will execute the job.
         * 
         * @return builder
         * 
         */
        public Builder libraries(@Nullable Output<List<JobTaskForEachTaskTaskLibraryArgs>> libraries) {
            $.libraries = libraries;
            return this;
        }

        /**
         * @param libraries (Set) An optional list of libraries to be installed on the cluster that will execute the job.
         * 
         * @return builder
         * 
         */
        public Builder libraries(List<JobTaskForEachTaskTaskLibraryArgs> libraries) {
            return libraries(Output.of(libraries));
        }

        /**
         * @param libraries (Set) An optional list of libraries to be installed on the cluster that will execute the job.
         * 
         * @return builder
         * 
         */
        public Builder libraries(JobTaskForEachTaskTaskLibraryArgs... libraries) {
            return libraries(List.of(libraries));
        }

        /**
         * @param maxRetries (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
         * 
         * @return builder
         * 
         */
        public Builder maxRetries(@Nullable Output<Integer> maxRetries) {
            $.maxRetries = maxRetries;
            return this;
        }

        /**
         * @param maxRetries (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
         * 
         * @return builder
         * 
         */
        public Builder maxRetries(Integer maxRetries) {
            return maxRetries(Output.of(maxRetries));
        }

        /**
         * @param minRetryIntervalMillis (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
         * 
         * @return builder
         * 
         */
        public Builder minRetryIntervalMillis(@Nullable Output<Integer> minRetryIntervalMillis) {
            $.minRetryIntervalMillis = minRetryIntervalMillis;
            return this;
        }

        /**
         * @param minRetryIntervalMillis (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
         * 
         * @return builder
         * 
         */
        public Builder minRetryIntervalMillis(Integer minRetryIntervalMillis) {
            return minRetryIntervalMillis(Output.of(minRetryIntervalMillis));
        }

        /**
         * @param newCluster Task will run on a dedicated cluster.  See databricks.Cluster documentation for specification. *Some parameters, such as `autoterminationMinutes`, `isPinned`, `workloadType` aren&#39;t supported!*
         * 
         * @return builder
         * 
         */
        public Builder newCluster(@Nullable Output<JobTaskForEachTaskTaskNewClusterArgs> newCluster) {
            $.newCluster = newCluster;
            return this;
        }

        /**
         * @param newCluster Task will run on a dedicated cluster.  See databricks.Cluster documentation for specification. *Some parameters, such as `autoterminationMinutes`, `isPinned`, `workloadType` aren&#39;t supported!*
         * 
         * @return builder
         * 
         */
        public Builder newCluster(JobTaskForEachTaskTaskNewClusterArgs newCluster) {
            return newCluster(Output.of(newCluster));
        }

        public Builder notebookTask(@Nullable Output<JobTaskForEachTaskTaskNotebookTaskArgs> notebookTask) {
            $.notebookTask = notebookTask;
            return this;
        }

        public Builder notebookTask(JobTaskForEachTaskTaskNotebookTaskArgs notebookTask) {
            return notebookTask(Output.of(notebookTask));
        }

        /**
         * @param notificationSettings An optional block controlling the notification settings on the job level documented below.
         * 
         * @return builder
         * 
         */
        public Builder notificationSettings(@Nullable Output<JobTaskForEachTaskTaskNotificationSettingsArgs> notificationSettings) {
            $.notificationSettings = notificationSettings;
            return this;
        }

        /**
         * @param notificationSettings An optional block controlling the notification settings on the job level documented below.
         * 
         * @return builder
         * 
         */
        public Builder notificationSettings(JobTaskForEachTaskTaskNotificationSettingsArgs notificationSettings) {
            return notificationSettings(Output.of(notificationSettings));
        }

        public Builder pipelineTask(@Nullable Output<JobTaskForEachTaskTaskPipelineTaskArgs> pipelineTask) {
            $.pipelineTask = pipelineTask;
            return this;
        }

        public Builder pipelineTask(JobTaskForEachTaskTaskPipelineTaskArgs pipelineTask) {
            return pipelineTask(Output.of(pipelineTask));
        }

        public Builder powerBiTask(@Nullable Output<JobTaskForEachTaskTaskPowerBiTaskArgs> powerBiTask) {
            $.powerBiTask = powerBiTask;
            return this;
        }

        public Builder powerBiTask(JobTaskForEachTaskTaskPowerBiTaskArgs powerBiTask) {
            return powerBiTask(Output.of(powerBiTask));
        }

        public Builder pythonWheelTask(@Nullable Output<JobTaskForEachTaskTaskPythonWheelTaskArgs> pythonWheelTask) {
            $.pythonWheelTask = pythonWheelTask;
            return this;
        }

        public Builder pythonWheelTask(JobTaskForEachTaskTaskPythonWheelTaskArgs pythonWheelTask) {
            return pythonWheelTask(Output.of(pythonWheelTask));
        }

        /**
         * @param retryOnTimeout (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
         * 
         * @return builder
         * 
         */
        public Builder retryOnTimeout(@Nullable Output<Boolean> retryOnTimeout) {
            $.retryOnTimeout = retryOnTimeout;
            return this;
        }

        /**
         * @param retryOnTimeout (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
         * 
         * @return builder
         * 
         */
        public Builder retryOnTimeout(Boolean retryOnTimeout) {
            return retryOnTimeout(Output.of(retryOnTimeout));
        }

        /**
         * @param runIf An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
         * 
         * @return builder
         * 
         */
        public Builder runIf(@Nullable Output<String> runIf) {
            $.runIf = runIf;
            return this;
        }

        /**
         * @param runIf An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
         * 
         * @return builder
         * 
         */
        public Builder runIf(String runIf) {
            return runIf(Output.of(runIf));
        }

        public Builder runJobTask(@Nullable Output<JobTaskForEachTaskTaskRunJobTaskArgs> runJobTask) {
            $.runJobTask = runJobTask;
            return this;
        }

        public Builder runJobTask(JobTaskForEachTaskTaskRunJobTaskArgs runJobTask) {
            return runJobTask(Output.of(runJobTask));
        }

        public Builder sparkJarTask(@Nullable Output<JobTaskForEachTaskTaskSparkJarTaskArgs> sparkJarTask) {
            $.sparkJarTask = sparkJarTask;
            return this;
        }

        public Builder sparkJarTask(JobTaskForEachTaskTaskSparkJarTaskArgs sparkJarTask) {
            return sparkJarTask(Output.of(sparkJarTask));
        }

        public Builder sparkPythonTask(@Nullable Output<JobTaskForEachTaskTaskSparkPythonTaskArgs> sparkPythonTask) {
            $.sparkPythonTask = sparkPythonTask;
            return this;
        }

        public Builder sparkPythonTask(JobTaskForEachTaskTaskSparkPythonTaskArgs sparkPythonTask) {
            return sparkPythonTask(Output.of(sparkPythonTask));
        }

        public Builder sparkSubmitTask(@Nullable Output<JobTaskForEachTaskTaskSparkSubmitTaskArgs> sparkSubmitTask) {
            $.sparkSubmitTask = sparkSubmitTask;
            return this;
        }

        public Builder sparkSubmitTask(JobTaskForEachTaskTaskSparkSubmitTaskArgs sparkSubmitTask) {
            return sparkSubmitTask(Output.of(sparkSubmitTask));
        }

        public Builder sqlTask(@Nullable Output<JobTaskForEachTaskTaskSqlTaskArgs> sqlTask) {
            $.sqlTask = sqlTask;
            return this;
        }

        public Builder sqlTask(JobTaskForEachTaskTaskSqlTaskArgs sqlTask) {
            return sqlTask(Output.of(sqlTask));
        }

        /**
         * @param taskKey string specifying an unique key for a given task.
         * * `*_task` - (Required) one of the specific task blocks described below:
         * 
         * @return builder
         * 
         */
        public Builder taskKey(Output<String> taskKey) {
            $.taskKey = taskKey;
            return this;
        }

        /**
         * @param taskKey string specifying an unique key for a given task.
         * * `*_task` - (Required) one of the specific task blocks described below:
         * 
         * @return builder
         * 
         */
        public Builder taskKey(String taskKey) {
            return taskKey(Output.of(taskKey));
        }

        /**
         * @param timeoutSeconds (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
         * 
         * @return builder
         * 
         */
        public Builder timeoutSeconds(@Nullable Output<Integer> timeoutSeconds) {
            $.timeoutSeconds = timeoutSeconds;
            return this;
        }

        /**
         * @param timeoutSeconds (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
         * 
         * @return builder
         * 
         */
        public Builder timeoutSeconds(Integer timeoutSeconds) {
            return timeoutSeconds(Output.of(timeoutSeconds));
        }

        /**
         * @param webhookNotifications (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
         * 
         * &gt; If no `jobClusterKey`, `existingClusterId`, or `newCluster` were specified in task definition, then task will executed using serverless compute.
         * 
         * @return builder
         * 
         */
        public Builder webhookNotifications(@Nullable Output<JobTaskForEachTaskTaskWebhookNotificationsArgs> webhookNotifications) {
            $.webhookNotifications = webhookNotifications;
            return this;
        }

        /**
         * @param webhookNotifications (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
         * 
         * &gt; If no `jobClusterKey`, `existingClusterId`, or `newCluster` were specified in task definition, then task will executed using serverless compute.
         * 
         * @return builder
         * 
         */
        public Builder webhookNotifications(JobTaskForEachTaskTaskWebhookNotificationsArgs webhookNotifications) {
            return webhookNotifications(Output.of(webhookNotifications));
        }

        public JobTaskForEachTaskTaskArgs build() {
            if ($.taskKey == null) {
                throw new MissingRequiredPropertyException("JobTaskForEachTaskTaskArgs", "taskKey");
            }
            return $;
        }
    }

}
