// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.databricks.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskCleanRoomsNotebookTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskConditionTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskDashboardTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskDbtCloudTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskDbtPlatformTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskDbtTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskDependsOn;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskEmailNotifications;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskGenAiComputeTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskHealth;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskLibrary;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskNewCluster;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskNotebookTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskNotificationSettings;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskPipelineTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskPowerBiTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskPythonWheelTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskRunJobTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskSparkJarTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskSparkPythonTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskSparkSubmitTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskSqlTask;
import com.pulumi.databricks.outputs.JobTaskForEachTaskTaskWebhookNotifications;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class JobTaskForEachTaskTask {
    private @Nullable JobTaskForEachTaskTaskCleanRoomsNotebookTask cleanRoomsNotebookTask;
    private @Nullable JobTaskForEachTaskTaskConditionTask conditionTask;
    private @Nullable JobTaskForEachTaskTaskDashboardTask dashboardTask;
    private @Nullable JobTaskForEachTaskTaskDbtCloudTask dbtCloudTask;
    private @Nullable JobTaskForEachTaskTaskDbtPlatformTask dbtPlatformTask;
    private @Nullable JobTaskForEachTaskTaskDbtTask dbtTask;
    /**
     * @return block specifying dependency(-ies) for a given task.
     * 
     */
    private @Nullable List<JobTaskForEachTaskTaskDependsOn> dependsOns;
    /**
     * @return description for this task.
     * 
     */
    private @Nullable String description;
    /**
     * @return A flag to disable auto optimization in serverless tasks.
     * 
     */
    private @Nullable Boolean disableAutoOptimization;
    /**
     * @return An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
     * 
     */
    private @Nullable JobTaskForEachTaskTaskEmailNotifications emailNotifications;
    /**
     * @return identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`sparkPythonTask`, `pythonWheelTask`, ...) running on serverless compute.
     * 
     */
    private @Nullable String environmentKey;
    /**
     * @return Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
     * 
     */
    private @Nullable String existingClusterId;
    private @Nullable JobTaskForEachTaskTaskGenAiComputeTask genAiComputeTask;
    /**
     * @return block described below that specifies health conditions for a given task.
     * 
     */
    private @Nullable JobTaskForEachTaskTaskHealth health;
    /**
     * @return Identifier of the Job cluster specified in the `jobCluster` block.
     * 
     */
    private @Nullable String jobClusterKey;
    /**
     * @return (Set) An optional list of libraries to be installed on the cluster that will execute the job.
     * 
     */
    private @Nullable List<JobTaskForEachTaskTaskLibrary> libraries;
    /**
     * @return (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
     * 
     */
    private @Nullable Integer maxRetries;
    /**
     * @return (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
     * 
     */
    private @Nullable Integer minRetryIntervalMillis;
    /**
     * @return Task will run on a dedicated cluster.  See databricks.Cluster documentation for specification. *Some parameters, such as `autoterminationMinutes`, `isPinned`, `workloadType` aren&#39;t supported!*
     * 
     */
    private @Nullable JobTaskForEachTaskTaskNewCluster newCluster;
    private @Nullable JobTaskForEachTaskTaskNotebookTask notebookTask;
    /**
     * @return An optional block controlling the notification settings on the job level documented below.
     * 
     */
    private @Nullable JobTaskForEachTaskTaskNotificationSettings notificationSettings;
    private @Nullable JobTaskForEachTaskTaskPipelineTask pipelineTask;
    private @Nullable JobTaskForEachTaskTaskPowerBiTask powerBiTask;
    private @Nullable JobTaskForEachTaskTaskPythonWheelTask pythonWheelTask;
    /**
     * @return (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
     * 
     */
    private @Nullable Boolean retryOnTimeout;
    /**
     * @return An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
     * 
     */
    private @Nullable String runIf;
    private @Nullable JobTaskForEachTaskTaskRunJobTask runJobTask;
    private @Nullable JobTaskForEachTaskTaskSparkJarTask sparkJarTask;
    private @Nullable JobTaskForEachTaskTaskSparkPythonTask sparkPythonTask;
    private @Nullable JobTaskForEachTaskTaskSparkSubmitTask sparkSubmitTask;
    private @Nullable JobTaskForEachTaskTaskSqlTask sqlTask;
    /**
     * @return string specifying an unique key for a given task.
     * * `*_task` - (Required) one of the specific task blocks described below:
     * 
     */
    private String taskKey;
    /**
     * @return (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
     * 
     */
    private @Nullable Integer timeoutSeconds;
    /**
     * @return (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
     * 
     * &gt; If no `jobClusterKey`, `existingClusterId`, or `newCluster` were specified in task definition, then task will executed using serverless compute.
     * 
     */
    private @Nullable JobTaskForEachTaskTaskWebhookNotifications webhookNotifications;

    private JobTaskForEachTaskTask() {}
    public Optional<JobTaskForEachTaskTaskCleanRoomsNotebookTask> cleanRoomsNotebookTask() {
        return Optional.ofNullable(this.cleanRoomsNotebookTask);
    }
    public Optional<JobTaskForEachTaskTaskConditionTask> conditionTask() {
        return Optional.ofNullable(this.conditionTask);
    }
    public Optional<JobTaskForEachTaskTaskDashboardTask> dashboardTask() {
        return Optional.ofNullable(this.dashboardTask);
    }
    public Optional<JobTaskForEachTaskTaskDbtCloudTask> dbtCloudTask() {
        return Optional.ofNullable(this.dbtCloudTask);
    }
    public Optional<JobTaskForEachTaskTaskDbtPlatformTask> dbtPlatformTask() {
        return Optional.ofNullable(this.dbtPlatformTask);
    }
    public Optional<JobTaskForEachTaskTaskDbtTask> dbtTask() {
        return Optional.ofNullable(this.dbtTask);
    }
    /**
     * @return block specifying dependency(-ies) for a given task.
     * 
     */
    public List<JobTaskForEachTaskTaskDependsOn> dependsOns() {
        return this.dependsOns == null ? List.of() : this.dependsOns;
    }
    /**
     * @return description for this task.
     * 
     */
    public Optional<String> description() {
        return Optional.ofNullable(this.description);
    }
    /**
     * @return A flag to disable auto optimization in serverless tasks.
     * 
     */
    public Optional<Boolean> disableAutoOptimization() {
        return Optional.ofNullable(this.disableAutoOptimization);
    }
    /**
     * @return An optional block to specify a set of email addresses notified when this task begins, completes or fails. The default behavior is to not send any emails. This block is documented below.
     * 
     */
    public Optional<JobTaskForEachTaskTaskEmailNotifications> emailNotifications() {
        return Optional.ofNullable(this.emailNotifications);
    }
    /**
     * @return identifier of an `environment` block that is used to specify libraries.  Required for some tasks (`sparkPythonTask`, `pythonWheelTask`, ...) running on serverless compute.
     * 
     */
    public Optional<String> environmentKey() {
        return Optional.ofNullable(this.environmentKey);
    }
    /**
     * @return Identifier of the interactive cluster to run job on.  *Note: running tasks on interactive clusters may lead to increased costs!*
     * 
     */
    public Optional<String> existingClusterId() {
        return Optional.ofNullable(this.existingClusterId);
    }
    public Optional<JobTaskForEachTaskTaskGenAiComputeTask> genAiComputeTask() {
        return Optional.ofNullable(this.genAiComputeTask);
    }
    /**
     * @return block described below that specifies health conditions for a given task.
     * 
     */
    public Optional<JobTaskForEachTaskTaskHealth> health() {
        return Optional.ofNullable(this.health);
    }
    /**
     * @return Identifier of the Job cluster specified in the `jobCluster` block.
     * 
     */
    public Optional<String> jobClusterKey() {
        return Optional.ofNullable(this.jobClusterKey);
    }
    /**
     * @return (Set) An optional list of libraries to be installed on the cluster that will execute the job.
     * 
     */
    public List<JobTaskForEachTaskTaskLibrary> libraries() {
        return this.libraries == null ? List.of() : this.libraries;
    }
    /**
     * @return (Integer) An optional maximum number of times to retry an unsuccessful run. A run is considered to be unsuccessful if it completes with a `FAILED` or `INTERNAL_ERROR` lifecycle state. The value -1 means to retry indefinitely and the value 0 means to never retry. The default behavior is to never retry. A run can have the following lifecycle state: `PENDING`, `RUNNING`, `TERMINATING`, `TERMINATED`, `SKIPPED` or `INTERNAL_ERROR`.
     * 
     */
    public Optional<Integer> maxRetries() {
        return Optional.ofNullable(this.maxRetries);
    }
    /**
     * @return (Integer) An optional minimal interval in milliseconds between the start of the failed run and the subsequent retry run. The default behavior is that unsuccessful runs are immediately retried.
     * 
     */
    public Optional<Integer> minRetryIntervalMillis() {
        return Optional.ofNullable(this.minRetryIntervalMillis);
    }
    /**
     * @return Task will run on a dedicated cluster.  See databricks.Cluster documentation for specification. *Some parameters, such as `autoterminationMinutes`, `isPinned`, `workloadType` aren&#39;t supported!*
     * 
     */
    public Optional<JobTaskForEachTaskTaskNewCluster> newCluster() {
        return Optional.ofNullable(this.newCluster);
    }
    public Optional<JobTaskForEachTaskTaskNotebookTask> notebookTask() {
        return Optional.ofNullable(this.notebookTask);
    }
    /**
     * @return An optional block controlling the notification settings on the job level documented below.
     * 
     */
    public Optional<JobTaskForEachTaskTaskNotificationSettings> notificationSettings() {
        return Optional.ofNullable(this.notificationSettings);
    }
    public Optional<JobTaskForEachTaskTaskPipelineTask> pipelineTask() {
        return Optional.ofNullable(this.pipelineTask);
    }
    public Optional<JobTaskForEachTaskTaskPowerBiTask> powerBiTask() {
        return Optional.ofNullable(this.powerBiTask);
    }
    public Optional<JobTaskForEachTaskTaskPythonWheelTask> pythonWheelTask() {
        return Optional.ofNullable(this.pythonWheelTask);
    }
    /**
     * @return (Bool) An optional policy to specify whether to retry a job when it times out. The default behavior is to not retry on timeout.
     * 
     */
    public Optional<Boolean> retryOnTimeout() {
        return Optional.ofNullable(this.retryOnTimeout);
    }
    /**
     * @return An optional value indicating the condition that determines whether the task should be run once its dependencies have been completed. One of `ALL_SUCCESS`, `AT_LEAST_ONE_SUCCESS`, `NONE_FAILED`, `ALL_DONE`, `AT_LEAST_ONE_FAILED` or `ALL_FAILED`. When omitted, defaults to `ALL_SUCCESS`.
     * 
     */
    public Optional<String> runIf() {
        return Optional.ofNullable(this.runIf);
    }
    public Optional<JobTaskForEachTaskTaskRunJobTask> runJobTask() {
        return Optional.ofNullable(this.runJobTask);
    }
    public Optional<JobTaskForEachTaskTaskSparkJarTask> sparkJarTask() {
        return Optional.ofNullable(this.sparkJarTask);
    }
    public Optional<JobTaskForEachTaskTaskSparkPythonTask> sparkPythonTask() {
        return Optional.ofNullable(this.sparkPythonTask);
    }
    public Optional<JobTaskForEachTaskTaskSparkSubmitTask> sparkSubmitTask() {
        return Optional.ofNullable(this.sparkSubmitTask);
    }
    public Optional<JobTaskForEachTaskTaskSqlTask> sqlTask() {
        return Optional.ofNullable(this.sqlTask);
    }
    /**
     * @return string specifying an unique key for a given task.
     * * `*_task` - (Required) one of the specific task blocks described below:
     * 
     */
    public String taskKey() {
        return this.taskKey;
    }
    /**
     * @return (Integer) An optional timeout applied to each run of this job. The default behavior is to have no timeout.
     * 
     */
    public Optional<Integer> timeoutSeconds() {
        return Optional.ofNullable(this.timeoutSeconds);
    }
    /**
     * @return (List) An optional set of system destinations (for example, webhook destinations or Slack) to be notified when runs of this task begins, completes or fails. The default behavior is to not send any notifications. This field is a block and is documented below.
     * 
     * &gt; If no `jobClusterKey`, `existingClusterId`, or `newCluster` were specified in task definition, then task will executed using serverless compute.
     * 
     */
    public Optional<JobTaskForEachTaskTaskWebhookNotifications> webhookNotifications() {
        return Optional.ofNullable(this.webhookNotifications);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(JobTaskForEachTaskTask defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable JobTaskForEachTaskTaskCleanRoomsNotebookTask cleanRoomsNotebookTask;
        private @Nullable JobTaskForEachTaskTaskConditionTask conditionTask;
        private @Nullable JobTaskForEachTaskTaskDashboardTask dashboardTask;
        private @Nullable JobTaskForEachTaskTaskDbtCloudTask dbtCloudTask;
        private @Nullable JobTaskForEachTaskTaskDbtPlatformTask dbtPlatformTask;
        private @Nullable JobTaskForEachTaskTaskDbtTask dbtTask;
        private @Nullable List<JobTaskForEachTaskTaskDependsOn> dependsOns;
        private @Nullable String description;
        private @Nullable Boolean disableAutoOptimization;
        private @Nullable JobTaskForEachTaskTaskEmailNotifications emailNotifications;
        private @Nullable String environmentKey;
        private @Nullable String existingClusterId;
        private @Nullable JobTaskForEachTaskTaskGenAiComputeTask genAiComputeTask;
        private @Nullable JobTaskForEachTaskTaskHealth health;
        private @Nullable String jobClusterKey;
        private @Nullable List<JobTaskForEachTaskTaskLibrary> libraries;
        private @Nullable Integer maxRetries;
        private @Nullable Integer minRetryIntervalMillis;
        private @Nullable JobTaskForEachTaskTaskNewCluster newCluster;
        private @Nullable JobTaskForEachTaskTaskNotebookTask notebookTask;
        private @Nullable JobTaskForEachTaskTaskNotificationSettings notificationSettings;
        private @Nullable JobTaskForEachTaskTaskPipelineTask pipelineTask;
        private @Nullable JobTaskForEachTaskTaskPowerBiTask powerBiTask;
        private @Nullable JobTaskForEachTaskTaskPythonWheelTask pythonWheelTask;
        private @Nullable Boolean retryOnTimeout;
        private @Nullable String runIf;
        private @Nullable JobTaskForEachTaskTaskRunJobTask runJobTask;
        private @Nullable JobTaskForEachTaskTaskSparkJarTask sparkJarTask;
        private @Nullable JobTaskForEachTaskTaskSparkPythonTask sparkPythonTask;
        private @Nullable JobTaskForEachTaskTaskSparkSubmitTask sparkSubmitTask;
        private @Nullable JobTaskForEachTaskTaskSqlTask sqlTask;
        private String taskKey;
        private @Nullable Integer timeoutSeconds;
        private @Nullable JobTaskForEachTaskTaskWebhookNotifications webhookNotifications;
        public Builder() {}
        public Builder(JobTaskForEachTaskTask defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.cleanRoomsNotebookTask = defaults.cleanRoomsNotebookTask;
    	      this.conditionTask = defaults.conditionTask;
    	      this.dashboardTask = defaults.dashboardTask;
    	      this.dbtCloudTask = defaults.dbtCloudTask;
    	      this.dbtPlatformTask = defaults.dbtPlatformTask;
    	      this.dbtTask = defaults.dbtTask;
    	      this.dependsOns = defaults.dependsOns;
    	      this.description = defaults.description;
    	      this.disableAutoOptimization = defaults.disableAutoOptimization;
    	      this.emailNotifications = defaults.emailNotifications;
    	      this.environmentKey = defaults.environmentKey;
    	      this.existingClusterId = defaults.existingClusterId;
    	      this.genAiComputeTask = defaults.genAiComputeTask;
    	      this.health = defaults.health;
    	      this.jobClusterKey = defaults.jobClusterKey;
    	      this.libraries = defaults.libraries;
    	      this.maxRetries = defaults.maxRetries;
    	      this.minRetryIntervalMillis = defaults.minRetryIntervalMillis;
    	      this.newCluster = defaults.newCluster;
    	      this.notebookTask = defaults.notebookTask;
    	      this.notificationSettings = defaults.notificationSettings;
    	      this.pipelineTask = defaults.pipelineTask;
    	      this.powerBiTask = defaults.powerBiTask;
    	      this.pythonWheelTask = defaults.pythonWheelTask;
    	      this.retryOnTimeout = defaults.retryOnTimeout;
    	      this.runIf = defaults.runIf;
    	      this.runJobTask = defaults.runJobTask;
    	      this.sparkJarTask = defaults.sparkJarTask;
    	      this.sparkPythonTask = defaults.sparkPythonTask;
    	      this.sparkSubmitTask = defaults.sparkSubmitTask;
    	      this.sqlTask = defaults.sqlTask;
    	      this.taskKey = defaults.taskKey;
    	      this.timeoutSeconds = defaults.timeoutSeconds;
    	      this.webhookNotifications = defaults.webhookNotifications;
        }

        @CustomType.Setter
        public Builder cleanRoomsNotebookTask(@Nullable JobTaskForEachTaskTaskCleanRoomsNotebookTask cleanRoomsNotebookTask) {

            this.cleanRoomsNotebookTask = cleanRoomsNotebookTask;
            return this;
        }
        @CustomType.Setter
        public Builder conditionTask(@Nullable JobTaskForEachTaskTaskConditionTask conditionTask) {

            this.conditionTask = conditionTask;
            return this;
        }
        @CustomType.Setter
        public Builder dashboardTask(@Nullable JobTaskForEachTaskTaskDashboardTask dashboardTask) {

            this.dashboardTask = dashboardTask;
            return this;
        }
        @CustomType.Setter
        public Builder dbtCloudTask(@Nullable JobTaskForEachTaskTaskDbtCloudTask dbtCloudTask) {

            this.dbtCloudTask = dbtCloudTask;
            return this;
        }
        @CustomType.Setter
        public Builder dbtPlatformTask(@Nullable JobTaskForEachTaskTaskDbtPlatformTask dbtPlatformTask) {

            this.dbtPlatformTask = dbtPlatformTask;
            return this;
        }
        @CustomType.Setter
        public Builder dbtTask(@Nullable JobTaskForEachTaskTaskDbtTask dbtTask) {

            this.dbtTask = dbtTask;
            return this;
        }
        @CustomType.Setter
        public Builder dependsOns(@Nullable List<JobTaskForEachTaskTaskDependsOn> dependsOns) {

            this.dependsOns = dependsOns;
            return this;
        }
        public Builder dependsOns(JobTaskForEachTaskTaskDependsOn... dependsOns) {
            return dependsOns(List.of(dependsOns));
        }
        @CustomType.Setter
        public Builder description(@Nullable String description) {

            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder disableAutoOptimization(@Nullable Boolean disableAutoOptimization) {

            this.disableAutoOptimization = disableAutoOptimization;
            return this;
        }
        @CustomType.Setter
        public Builder emailNotifications(@Nullable JobTaskForEachTaskTaskEmailNotifications emailNotifications) {

            this.emailNotifications = emailNotifications;
            return this;
        }
        @CustomType.Setter
        public Builder environmentKey(@Nullable String environmentKey) {

            this.environmentKey = environmentKey;
            return this;
        }
        @CustomType.Setter
        public Builder existingClusterId(@Nullable String existingClusterId) {

            this.existingClusterId = existingClusterId;
            return this;
        }
        @CustomType.Setter
        public Builder genAiComputeTask(@Nullable JobTaskForEachTaskTaskGenAiComputeTask genAiComputeTask) {

            this.genAiComputeTask = genAiComputeTask;
            return this;
        }
        @CustomType.Setter
        public Builder health(@Nullable JobTaskForEachTaskTaskHealth health) {

            this.health = health;
            return this;
        }
        @CustomType.Setter
        public Builder jobClusterKey(@Nullable String jobClusterKey) {

            this.jobClusterKey = jobClusterKey;
            return this;
        }
        @CustomType.Setter
        public Builder libraries(@Nullable List<JobTaskForEachTaskTaskLibrary> libraries) {

            this.libraries = libraries;
            return this;
        }
        public Builder libraries(JobTaskForEachTaskTaskLibrary... libraries) {
            return libraries(List.of(libraries));
        }
        @CustomType.Setter
        public Builder maxRetries(@Nullable Integer maxRetries) {

            this.maxRetries = maxRetries;
            return this;
        }
        @CustomType.Setter
        public Builder minRetryIntervalMillis(@Nullable Integer minRetryIntervalMillis) {

            this.minRetryIntervalMillis = minRetryIntervalMillis;
            return this;
        }
        @CustomType.Setter
        public Builder newCluster(@Nullable JobTaskForEachTaskTaskNewCluster newCluster) {

            this.newCluster = newCluster;
            return this;
        }
        @CustomType.Setter
        public Builder notebookTask(@Nullable JobTaskForEachTaskTaskNotebookTask notebookTask) {

            this.notebookTask = notebookTask;
            return this;
        }
        @CustomType.Setter
        public Builder notificationSettings(@Nullable JobTaskForEachTaskTaskNotificationSettings notificationSettings) {

            this.notificationSettings = notificationSettings;
            return this;
        }
        @CustomType.Setter
        public Builder pipelineTask(@Nullable JobTaskForEachTaskTaskPipelineTask pipelineTask) {

            this.pipelineTask = pipelineTask;
            return this;
        }
        @CustomType.Setter
        public Builder powerBiTask(@Nullable JobTaskForEachTaskTaskPowerBiTask powerBiTask) {

            this.powerBiTask = powerBiTask;
            return this;
        }
        @CustomType.Setter
        public Builder pythonWheelTask(@Nullable JobTaskForEachTaskTaskPythonWheelTask pythonWheelTask) {

            this.pythonWheelTask = pythonWheelTask;
            return this;
        }
        @CustomType.Setter
        public Builder retryOnTimeout(@Nullable Boolean retryOnTimeout) {

            this.retryOnTimeout = retryOnTimeout;
            return this;
        }
        @CustomType.Setter
        public Builder runIf(@Nullable String runIf) {

            this.runIf = runIf;
            return this;
        }
        @CustomType.Setter
        public Builder runJobTask(@Nullable JobTaskForEachTaskTaskRunJobTask runJobTask) {

            this.runJobTask = runJobTask;
            return this;
        }
        @CustomType.Setter
        public Builder sparkJarTask(@Nullable JobTaskForEachTaskTaskSparkJarTask sparkJarTask) {

            this.sparkJarTask = sparkJarTask;
            return this;
        }
        @CustomType.Setter
        public Builder sparkPythonTask(@Nullable JobTaskForEachTaskTaskSparkPythonTask sparkPythonTask) {

            this.sparkPythonTask = sparkPythonTask;
            return this;
        }
        @CustomType.Setter
        public Builder sparkSubmitTask(@Nullable JobTaskForEachTaskTaskSparkSubmitTask sparkSubmitTask) {

            this.sparkSubmitTask = sparkSubmitTask;
            return this;
        }
        @CustomType.Setter
        public Builder sqlTask(@Nullable JobTaskForEachTaskTaskSqlTask sqlTask) {

            this.sqlTask = sqlTask;
            return this;
        }
        @CustomType.Setter
        public Builder taskKey(String taskKey) {
            if (taskKey == null) {
              throw new MissingRequiredPropertyException("JobTaskForEachTaskTask", "taskKey");
            }
            this.taskKey = taskKey;
            return this;
        }
        @CustomType.Setter
        public Builder timeoutSeconds(@Nullable Integer timeoutSeconds) {

            this.timeoutSeconds = timeoutSeconds;
            return this;
        }
        @CustomType.Setter
        public Builder webhookNotifications(@Nullable JobTaskForEachTaskTaskWebhookNotifications webhookNotifications) {

            this.webhookNotifications = webhookNotifications;
            return this;
        }
        public JobTaskForEachTaskTask build() {
            final var _resultValue = new JobTaskForEachTaskTask();
            _resultValue.cleanRoomsNotebookTask = cleanRoomsNotebookTask;
            _resultValue.conditionTask = conditionTask;
            _resultValue.dashboardTask = dashboardTask;
            _resultValue.dbtCloudTask = dbtCloudTask;
            _resultValue.dbtPlatformTask = dbtPlatformTask;
            _resultValue.dbtTask = dbtTask;
            _resultValue.dependsOns = dependsOns;
            _resultValue.description = description;
            _resultValue.disableAutoOptimization = disableAutoOptimization;
            _resultValue.emailNotifications = emailNotifications;
            _resultValue.environmentKey = environmentKey;
            _resultValue.existingClusterId = existingClusterId;
            _resultValue.genAiComputeTask = genAiComputeTask;
            _resultValue.health = health;
            _resultValue.jobClusterKey = jobClusterKey;
            _resultValue.libraries = libraries;
            _resultValue.maxRetries = maxRetries;
            _resultValue.minRetryIntervalMillis = minRetryIntervalMillis;
            _resultValue.newCluster = newCluster;
            _resultValue.notebookTask = notebookTask;
            _resultValue.notificationSettings = notificationSettings;
            _resultValue.pipelineTask = pipelineTask;
            _resultValue.powerBiTask = powerBiTask;
            _resultValue.pythonWheelTask = pythonWheelTask;
            _resultValue.retryOnTimeout = retryOnTimeout;
            _resultValue.runIf = runIf;
            _resultValue.runJobTask = runJobTask;
            _resultValue.sparkJarTask = sparkJarTask;
            _resultValue.sparkPythonTask = sparkPythonTask;
            _resultValue.sparkSubmitTask = sparkSubmitTask;
            _resultValue.sqlTask = sqlTask;
            _resultValue.taskKey = taskKey;
            _resultValue.timeoutSeconds = timeoutSeconds;
            _resultValue.webhookNotifications = webhookNotifications;
            return _resultValue;
        }
    }
}
